[{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:1","title":"JavaScript Promiseの本","author":"azu","body":"1\nJavaScript Promiseの本\nazu\nTable of Contents\nはじめに\n  .......................................................................................................................   3\n書籍の目的\n  ...........................................................................................................  3\n本書を読むにあたって\n  ...........................................................................................   3\n表記法  ..................................................................................................................  4\n本書のソースコード/ライセンス\n  ..............................................................................  4\n意見や疑問点\n  ........................................................................................................  5\nChapter.1 - Promiseとは何か\n  .....................................................................................  5\nWhat Is Promise\n  ..................................................................................................  5\nPromise Overview\n  ..............................................................................................   7\nPromiseの書き方\n  ................................................................................................  11\nChapter.2 - Promiseの書き方\n  ...................................................................................  14\nPromise.resolve\n  ................................................................................................  15\nPromise.reject\n  ...................................................................................................  18\nコラム: Promiseは常に非同期?\n  ...........................................................................  18\nPromise#then\n  ....................................................................................................  21\nPromise#catch\n  ..................................................................................................  29\nコラム: thenは常に新しいpromiseオブジェクトを返す\n  .........................................  31\nPromiseと配列\n  ...................................................................................................  34\nPromise.all\n  ........................................................................................................  38\nPromise.race\n  .....................................................................................................  41\nthen or catch?\n  ...................................................................................................  43\nChapter.3 - Promiseのテスト\n  ....................................................................................  45\n基本的なテスト\n  ....................................................................................................  45\nMochaのPromiseサポート\n  ..................................................................................  49\n意図したテストを書くには\n  .....................................................................................  54\nChapter.4 - Advanced\n  ..............................................................................................  58\nPromiseのライブラリ\n  ...........................................................................................  58\nPromise.resolveとThenable\n  ..............................................................................  61\nthrowしないで、rejectしよう\n  ................................................................................  70\nDeferredとPromise\n  ............................................................................................  73\nPromise.raceとdelayによるXHRのキャンセル\n  ....................................................   79\nPromise.prototype.done とは何か?\n  ..................................................................  89","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":1},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:2","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n2\nPromiseとメソッドチェーン\n  ..................................................................................  95\nPromiseによる逐次処理\n  ...................................................................................   103\nPromises API Reference\n  ........................................................................................  111\nPromise#then\n  ..................................................................................................  111\nPromise#catch\n  ................................................................................................  111\nPromise.resolve\n  ..............................................................................................  112\nPromise.reject\n  .................................................................................................  113\nPromise.all\n  ......................................................................................................  113\nPromise.race\n  ...................................................................................................  114\n用語集  ......................................................................................................................  114\n参考サイト\n  ................................................................................................................  115\n著者について\n  ............................................................................................................  115\n著者へのメッセージ/おまけ\n  ...............................................................................  116\nThis book has been released in :\n• Chinese\n: JavaScript Promise迷你#（中文版）\n1\n• Korean\n: ##### eBook JavaScript Promise（###）\n2\n1\n http://liubin.github.io/promises-book/\n2\n http://www.hanbit.co.kr/ebook/look.html?isbn=9788968487293","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":2},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:3","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n3\nはじめに\n書籍の目的\nこの書籍はJavaScript標準仕様の\nECMAScript 6 Promises\nという仕様を中心にし、\nJavaScriptにおけるPromiseについて学ぶことを目的とした書籍です。\nこの書籍を読むことで学べることとして次の3つを目標としています\n• Promiseについて学び、パターンやテストを扱えるようになること\n• Promiseの向き不向きについて学び、何でもPromiseで解決するべきではないと知るこ\nと\n• ES6 Promisesを元に基本をよく学び、より発展した形を自分で形成できるようになるこ\nと\nこの書籍では、先程も述べたように\nES6 Promises\n、 つまりJavaScriptの標準仕様\n(ECMAScript)をベースとしたPromiseについて書かれています。\nそのため、FirefoxやChromeなどモダンなブラウザでは、ライブラリを使うこと無く利用でき\nる機能であり、 またES6 Promisesは元が\nPromises/A+\nというコミュニティベースの仕様で\nあるため、多くの実装ライブラリがあります。\nブラウザネイティブの機能、またはライブラリを使うことで今すぐ利用できるPromiseについ\nて基本的なAPIから学んでいきます。 その中でPromiseの得意/不得意を知り、Promiseを\n活用したJavaScriptを書けるようになることを目的としています。\n本書を読むにあたって\nこの書籍ではJavaScriptの基本的な機能についてすでに学習していることを前提にしてい\nます。\n• JavaScript: The Good Parts\n3\n• JavaScriptパターン\n4\n• JavaScript 第6版\n5\n• パーフェクトJavaScript\n6\n3\n http://www.oreilly.co.jp/books/9784873113913/\n4\n http://www.oreilly.co.jp/books/9784873114880/\n5\n http://www.oreilly.co.jp/books/9784873115733/\n6\n http://gihyo.jp/book/2011/978-4-7741-4813-7","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":3},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:4","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n4\n• Effective JavaScript\n7\nのいずれかの書籍を読んだことがあれば十分読み解くことができる内容だと思います。\nまたは、JavaScriptでウェブアプリケーションを書いたことがある、 Node.js でコマンドライ\nンアプリやサーバサイドを書いたことがあれば、 どこかで書いたことがあるような内容が出\nてくるかもしれません。\n一部セクションではNode.js環境での話となるため、Node.jsについて軽くでも知っておくと\nより理解がしやすいと思います。\n表記法\nこの書籍では短縮するために幾つかの表記を用いています。\n• Promiseに関する用語は\n用語集を参照する。\n◦ 大体、初回に出てきた際にはリンクを貼っています。\n• インスタンスメソッドを instance#method という表記で示す。\n◦ たとえば、\nPromise#then\n という表記は、Promiseのインスタンスオブジェクトの\nthen\n というメソッドを示しています。\n• オブジェクトメソッドを object.method という表記で示す。\n◦ これはJavaScriptの意味そのままで、\nPromise.all\n なら静的メソッドのことを示して\nいます。\nこの部分には文章についての補足が書かれています。\n本書のソースコード/ライセンス\nこの書籍に登場するサンプルのソースコード また その文章のソースコードは全てGitHubか\nら取得することができます。\nこの書籍は \nAsciiDoc\n8\n という形式で書かれています。\n• azu/promises-book\n9\n7\n http://www.shoeisha.co.jp/book/detail/9784798131115\n8\n http://asciidoctor.org/\n9\n https://github.com/azu/promises-book","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":4},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:5","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n5\nまたリポジトリには書籍中に出てくるサンプルコードのテストも含まれています。\nソースコードのライセンスはMITライセンスで、文章はCC-BY-NCで利用することができま\nす。\n意見や疑問点\n意見や疑問点がある場合はGitHubに直接Issueとして立てることができます。\n• Issues · azu/promises-book\n10\nまた、この書籍についての \nチャットページ\n11\n に書いていくのもいいでしょう。\nTwitterでのハッシュタグは\n#Promise本\n12\n なので、こちらを利用するのもいいでしょう。\nこの書籍は読める権利と同時に編集する権利があるため、 GitHubで \nPull Requests\n13\n も\n歓迎しています。\nChapter.1 - Promiseとは何か\nこの章では、JavaScriptにおけるPromiseについて簡単に紹介していきます。\nWhat Is Promise\nまずPromiseとはそもそもどのようなものでしょうか?\nPromiseは非同期処理を抽象化したオブジェクトとそれを操作する仕組みのことをいいま\nす。 詳しくはこれから学んでいくとして、PromiseはJavaScriptで発見された概念ではあり\nません。\n最初に発見されたのは \nE言語\n14\nにおけるもので、 並列/並行処理におけるプログラミング\n言語のデザインの一種です。\nこのデザインをJavaScriptに持ってきたものが、この書籍で学ぶJavaScript Promiseで\nす。\n10\n https://github.com/azu/promises-book/issues?state=open\n11\n https://gitter.im/azu/promises-book\n12\n https://twitter.com/search?q=%23Promise%E6%9C%AC\n13\n https://github.com/azu/promises-book/pulls\n14\n https://web.archive.org/web/20161029030824/http://erights.org/elib/distrib/pipeline.html","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":5},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:6","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n6\n一方、JavaScriptにおける非同期処理といえば、コールバックを利用する場合が多いと思\nいます。\nコールバックを使った非同期処理の一例\ngetAsync(\n\"fileA.txt\"\n, function(error, result){\n    if(error){// 取得失敗時の処理\n        throw error;\n    }\n    // 取得成功の処理\n});\nコールバック関数の引数には(エラーオブジェクト, 結果)が入る\nNode.js等JavaScriptでのコールバック関数の第一引数には \nError\n オブジェクトを渡す\nというルールを用いるケースがあります。\nこのようにコールバックでの非同期処理もルールが統一されていた場合、コールバック関\n数の書き方が明確になります。 しかし、これはあくまでコーディングルールであるため、異な\nる書き方をしても決して間違いではありません。\nPromiseでは、このような非同期に対するオブジェクトとルールを仕様化して、 統一的なイ\nンターフェースで書くようになっており、それ以外の書き方は出来ないようになっています。\nPromiseを使った非同期処理の一例\nvar promise = getAsyncPromise(\n\"fileA.txt\"\n); \npromise.then(\nfunction(result){\n    // 取得成功の処理\n}).catch(function(error){\n    // 取得失敗時の処理\n});\npromiseオブジェクトを返す\n非同期処理を抽象化したpromiseオブジェクトというものを用意し、 そのpromiseオブジェ\nクトに対して成功時の処理と失敗時の処理の関数を登録するようにして使います。\nコールバック関数と比べると何が違うのかを簡単に見ると、 非同期処理の書き方が\npromiseオブジェクトのインターフェースに沿った書き方に限定されます。\nつまり、promiseオブジェクトに用意されてるメソッド(ここでは \nthen\n や \ncatch\n)以外は使\nえないため、 コールバックのように引数に何を入れるかが自由に決められるわけではなく、\n一定のやり方に統一されます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":6},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:7","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n7\nこの、Promiseという統一されたインターフェースがあることで、 そのインターフェースにお\nけるさまざまな非同期処理のパターンを形成することができます。\nつまり、複雑な非同期処理等を上手くパターン化できるというのがPromiseの役割であり、\nPromiseを使う理由の一つであるといえるでしょう。\nそれでは、実際にJavaScriptでのPromiseについて学んでいきましょう。\nPromise Overview\nES6 Promises\nの仕様で定義されているAPIはそこまで多くはありません。\n大きく分けて以下の3種類になります。\nConstructor\nPromiseは \nXMLHttpRequest\n のように、コンストラクタ関数である \nPromise\n からインスタ\nンスとなる promiseオブジェクトを作成して利用します。\npromiseオブジェクトを作成するには、\nPromise\n コンストラクタを \nnew\n でインスタンス化\nします。\nvar promise = \nnew Promise(\nfunction(resolve, reject) {\n    // 非同期の処理\n    // 処理が終わったら、resolve または rejectを呼ぶ\n});\nInstance Method\nnewによって生成されたpromiseオブジェクトにはpromiseの値を \nresolve\n(成功) /\nreject(失敗) した時に呼ばれる コールバック関数を登録するために \npromise.then()\n と\nいうインスタンスメソッドがあります。\npromise.then(onFulfilled, onRejected)\nresolve(成功)した時\nonFulfilled\n が呼ばれる\nreject(失敗)した時\nonRejected\n が呼ばれる\nonFulfilled\n、\nonRejected\n どちらもオプショナルな引数となっています。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":7},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:8","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n8\npromise.then\n では成功時と失敗時の処理を同時に登録することができます。 また、エラー\n処理だけを書きたい場合には \npromise.then(undefined, onRejected)\n と同じ意味であ\nる \npromise.catch(onRejected)\n を使うことができます。\npromise.catch(onRejected)\nStatic Method\nPromise\n というグローバルオブジェクトには幾つかの静的なメソッドが存在します。\nPromise.all()\n や \nPromise.resolve()\n などが該当し、Promiseを扱う上での補助メソッ\nドが中心となっています。\nPromise workflow\n以下のようなサンプルコードを見てみましょう。\npromise-workflow.js\nfunction asyncFunction() {\n    \n    return new Promise(\nfunction (resolve, reject) {\n        setTimeout(\nfunction () {\n            resolve(\n'Async Hello world'\n);\n        }, \n16);\n    });\n}\nasyncFunction().then(\nfunction (value) {\n    console.log(value);    \n// => 'Async Hello world'\n}).catch(function (error) {\n    console.error(error);\n});\nPromiseコンストラクタを \nnew\n して、promiseオブジェクトを返します\n<1>のpromiseオブジェクトに対して \n.then\n で値が返ってきた時のコールバックを設\n定します\nasyncFunction\n という関数 は promiseオブジェクトを返していて、 そのpromiseオブジェ\nクトに対して \nthen\n でresolveした時のコールバックを、 \ncatch\n でエラーとなった場合の\nコールバックを設定しています。\nこのpromiseオブジェクトはsetTimeoutで16ms後にresolveされるので、 そのタイミング\nで \nthen\n のコールバックが呼ばれ \n'Async Hello world'\n と出力されます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":8},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:9","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n9\nこの場合 \ncatch\n のコールバックは呼ばれることはないですが、 \nsetTimeout\n が存在しな\nい環境などでは、例外が発生し \ncatch\n で登録したコールバック関数が呼ばれると思いま\nす。\nもちろん、\npromise.then(onFulfilled, onRejected)\n というように、 \ncatch\n を使わずに\nthen\n を使い、以下のように2つのコールバック関数を設定することでもほぼ同様の動作に\nなります。\nasyncFunction().then(\nfunction (value) {\n    console.log(value);\n}, function (error) {\n    console.error(error);\n});\nPromiseの状態\nPromiseの処理の流れが少しわかった所で、Promiseの状態について整理したいと思いま\nす。\nnew Promise\n でインスタンス化したpromiseオブジェクトには以下の3つの状態が存在し\nます。\nFulfilled\nresolve(成功)した時。このとき \nonFulfilled\n が呼ばれる\nRejected\nreject(失敗)した時。このとき \nonRejected\n が呼ばれる\nPending\nFulfilledまたはRejectedではない時。つまりpromiseオブジェクトが作成された初期状\n態等が該当する\nこれらの状態は\nES6 Promises\nの仕様で定められている名前です。 この状態をプログラム\nで直接触る方法は用意されていないため、書く際には余り気にしなくても問題ないですが、\nPromiseについて理解するのに役に立ちます。\nこの書籍では、\nPending\n、Fulfilled\n 、Rejected\n の状態を用いて解説していきます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":9},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:10","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n10\nFigure 1. promise states\nES6 Promisesの仕様\n では \n[[PromiseStatus]]\n という内部定義に\nよって状態が定められています。 \n[[PromiseStatus]]\n にアクセスする\nユーザーAPIは用意されていないため、基本的には知る方法はありませ\nん。\n3つの状態を見たところで、すでにこの章で全ての状態が出てきていることが分かります。\npromiseオブジェクトの状態は、一度\nPending\nからFulfilled\nやRejected\nになると、 その\npromiseオブジェクトの状態はそれ以降変化することはなくなります。\nつまり、PromiseはEvent等とは違い、\n.then\n で登録した関数が呼ばれるのは1回限りとい\nうことが明確になっています。\nまた、Fulfilled\nとRejected\nのどちらかの状態であることを\nSettled\n(不変の)と表現することが\nあります。\nSettled\nresolve(成功) または reject(失敗) した時。\nPending\nとSettled\nが対となる関係であると考えると、Promiseの状態の種類/遷移がシン\nプルであることが分かると思います。\nこのpromiseオブジェクトの状態が変化した時に、一度だけ呼ばれる関数を登録するのが\n.then\n といったメソッドとなるわけです。\nJavaScript Promises - Thinking Sync in an Async World //\nSpeaker Deck\n15\n というスライドではPromiseの状態遷移について分\nかりやすく書かれています。\n15\n https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":10},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:11","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n11\nPromiseの書き方\nPromiseの基本的な書き方について解説します。\npromiseオブジェクトの作成\npromiseオブジェクトを作る流れは以下のようになっています。\n1.\nnew Promise(fn)\n の返り値がpromiseオブジェクト\n2.\nfn\n には非同期等の何らかの処理を書く\n• 処理結果が正常なら、\nresolve(結果の値)\n を呼ぶ\n• 処理結果がエラーなら、\nreject(Errorオブジェクト)\n を呼ぶ\nこの流れに沿っているものを実際に書いてみましょう。\n非同期処理であるXMLHttpRequest(XHR)を使いデータを取得するものをPromiseで書\nいていきます。\nXHRのpromiseオブジェクトを作る\nまずは、XHRをPromiseを使って包んだような \ngetURL\n という関数を作ります。\nxhr-promise.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\n// 実行例\nvar URL = \"http://httpbin.org/get\"\n;","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":11},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:12","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n12\ngetURL(URL).then(\nfunction onFulfilled(value){\n    console.log(value);\n}).catch(function onRejected(error){\n    console.error(error);\n});\nこの \ngetURL\n では、 XHRでの取得結果のステータスコードが200の場合のみ \nresolve\n - つ\nまり取得に成功、 それ以外はエラーであるとして \nreject\n しています。\nresolve(req.responseText)\n ではレスポンスの内容を引数に入れています。 resolveの\n引数に入れる値には特に決まりはありませんが、コールバックと同様に次の処理へ渡したい\n値を入れるといいでしょう。 (この値は \nthen\n メソッドで受け取ることができます)\nNode.jsをやっている人は、コールバックを書く時に \ncallback(error, response)\n と第\n一引数にエラーオブジェクトを 入れることがよくあると思いますが、Promiseでは役割が\nresolve/rejectで分担されているので、 resolveにはresponseの値のみをいれるだけで問\n題ありません。\n次に、\nreject\n の方を見ていきましょう。\nXHRで \nonerror\n のイベントが呼ばれた場合はもちろんエラーなので \nreject\n を呼びま\nす。 ここで \nreject\n に渡している値に注目してみてください。\nエラーの場合は \nreject(new Error(req.statusText));\n というように、Errorオブジェクト\nを作成して渡していることが分かると思います。 \nreject\n に渡す値に制限はありませんが、\n一般的にErrorオブジェクト(またはErrorオブジェクトを継承したもの)を渡すことになってい\nます。\nreject\n に渡す値は、rejectする理由を書いたErrorオブジェクトとなっています。 今\n回は、ステータスコードが200以外であるならrejectするとしていたため、\nreject\n には\nstatusTextを入れています。 (この値は \nthen\n メソッドの第二引数 or \ncatch\n メソッドで受\nけ取ることができます)\npromiseオブジェクトに処理を書く\n先ほどの作成したpromiseオブジェクトを返す関数を実際に使ってみましょう\ngetURL(\"http://example.com/\"\n); // => promiseオブジェクトが返ってくる\nPromises Overview\n でも簡単に紹介したようにpromiseオブジェクトは幾つかインスタン\nスメソッドを持っており、 これを使いpromiseオブジェクトの状態に応じて一度だけ呼ばれ\nるコールバックとなる関数を登録します。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":12},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:13","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n13\npromiseオブジェクトに登録する処理は以下の2種類が主となります\n• promiseオブジェクトが \nresolve\n された時の処理(onFulfilled)\n• promiseオブジェクトが \nreject された時の処理(onRejected)\nFigure 2. promise value flow\nまずは、\ngetURL\n で通信が成功して値が取得できた場合の処理を書いてみましょう。\nこの場合の \n通信が成功した\n というのは、 resolveされたことにより \npromiseオブジェクトが\nFulFilledの状態になった\n 時ということですね。\nresolve\nされた時の処理は、 \n.then\n メソッドに呼びたい関数を渡すことで行えます。\nvar URL = \"http://httpbin.org/get\"\n;\ngetURL(URL).then(\nfunction onFulfilled(value){ \n    console.log(value);\n});\n分かりやすくするため関数に \nonFulfilled\n という名前を付けています\ngetURL関数\n 内で \nresolve(req.responseText);\n によってpromiseオブジェクトが解決\nされると、 値と共に \nonFulfilled\n 関数が呼ばれます。\nこのままでは通信エラーが起きた場合などに何も処理がされないため、 今度は、\ngetURL\nで何らかの問題があってエラーが起きた場合の処理を書いてみましょう。\nこの場合の \nエラーが起きた\n というのは、 rejectされたことより \npromiseオブジェクトが\nRejectedの状態になった\n 時ということですね。\nrejectされた時の処理は、\n.then\n の第二引数\n または \n.catch\n メソッドに呼びたい関数を渡\nすことで行えます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":13},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:14","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n14\n先ほどのソースにrejectされた場合の処理を追加してみましょう。\nvar URL = \"http://httpbin.org/status/500\"\n; \ngetURL(URL).then(\nfunction onFulfilled(value){\n    console.log(value);\n}).catch(function onRejected(error){ \n    console.error(error);\n});\nサーバはステータスコード500のレスポンスを返す\n分かりやすくするため関数 \nonRejected\n という名前を付けています\ngetURL\n の処理中に何らかの理由で例外が起きた場合、または明示的にrejectされた場合\nに、 その理由(Errorオブジェクト)と共に \n.catch\n の処理が呼ばれます。\n.catch\nは \npromise.then(undefined, onRejected)\n のエイリアスであるため、 同様の処\n理は以下のように書くこともできます。\ngetURL(URL).then(onFulfilled, onRejected);\nonFulfilled, onRejected それぞれは先ほどと同じ関数\n基本的には、\n.catch\nを使いresolveとrejectそれぞれを別々に処理した方がよいと考えら\nれますが、 両者の違いについては \nthenとcatchの違い\n で紹介します。\nまとめ\nこの章では以下のことについて簡単に紹介しました。\n•\nnew Promise\n を使ったpromiseオブジェクトの作成\n•\n.then\n や \n.catch\n を使ったpromiseオブジェクトの処理\nPromiseの基本的な書き方について学びました。 他の多くの処理はこれを発展させたり、用\n意された静的メソッドを利用したものになります。\nここでは、同様のことはコールバック関数を渡す形でもできるのに対してPromiseで書くメ\nリットについては触れていませんでした。 次の章では、Promiseのメリットであるエラーハン\nドリングの仕組みをコールバックベースの実装と比較しながら見ていきたいと思います。\nChapter.2 - Promiseの書き方\nこの章では、Promiseのメソッドの使い方、エラーハンドリングについて学びます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":14},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:15","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n15\nPromise.resolve\n一般に \nnew Promise()\n を使うことでpromiseオブジェクトを生成しますが、 それ以外にも\npromiseオブジェクトを生成する方法があります。\nここでは、\nPromise.resolve\n と \nPromise.reject\n について学びたいと思います。\nnew Promiseのショートカット\nPromise.resolve(value)\n という静的メソッドは、 \nnew Promise()\n のショートカットとなる\nメソッドです。\nたとえば、 \nPromise.resolve(42);\n というのは下記のコードのシンタックスシュガーです。\nnew Promise(\nfunction(resolve){\n    resolve(\n42);\n});\n結果的にすぐに \nresolve(42);\n と解決されて、次のthenの \nonFulfilled\n に設定された関\n数に \n42\n という値を渡します。\nPromise.resolve(value);\n で返ってくる値も同様にpromiseオブジェクトなので、 以下の\nように続けて \n.then\n を使った処理を書くことができます。\nPromise.resolve(\n42).then(function(value){\n    console.log(value);\n});\nPromise.resolve\nは \nnew Promise()\n のショートカットとして、 promiseオブジェクトの初期\n化時やテストコードを書く際にも活用できます。\nThenable\nもう一つ \nPromise.resolve\n の大きな特徴として、\nthenable\nなオブジェクトをpromiseオブ\nジェクトに変換するという機能があります。\nES6 Promises\nにはThenable\nという概念があり、簡単にいえばpromiseっぽいオブジェクト\nのことを言います。\n.length\n を持っているが配列ではないものをArray likeというのと同じで、 thenableの場\n合は \n.then\n というメソッドを持ってるオブジェクトを言います。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":15},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:16","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n16\nthenableなオブジェクトがもつ \nthen\n は、Promiseのもつ \nthen\n と同じような挙動を期\n待していて、 thenableなオブジェクトがもつ元々の \nthen\n を上手く利用できるようにし\npromiseオブジェクトに変換するという仕組みです。\nどのようなものがthenableなのかというと、分かりやすい例では \njQuery.ajax()\n16\nの返り値\nもthenableです。\njQuery.ajax()\n の返り値は \njqXHR Object\n17\n というもので、 このオブジェクトは \n.then\n と\nいうメソッドを持っているためです。\n$.ajax('http://httpbin.org/get'\n);// => `.then` をもつオブジェクト\nこのthenableなオブジェクトを \nPromise.resolve\n ではpromiseオブジェクトにすることが\nできます。\npromiseオブジェクトにすることができれば、\nthen\n や \ncatch\n といった、 \nES6 Promises\nが\nもつ機能をそのまま利用することができるようになります。\nthenableをpromiseオブジェクトにする\n// このサンプルコードはjQueryをロードしている場所でないと動きません\nvar promise = Promise.resolve($.ajax(\n'http://httpbin.org/get'\n));// => promiseオブジェクト\npromise.then(\nfunction(value){\n   console.log(value);\n});\njQueryとthenable\njQuery.ajax()\n18\nの返り値も \n.then\n というメソッドを持った \njqXHR\nObject\n19\nで、 このオブジェクトは \nDeferred Object\n20\n のメソッドやプロ\nパティ等を継承しています。\nしかし、jQuery 2.x以下では、このDeferred Objectは\nPromises/A\n+やES6 Promises\nに準拠したものではありません。 そのため、Deferred\nObjectをpromiseオブジェクトへ変換できたように見えて、一部欠損す\nる情報がでてしまうという問題があります。\n16\n https://api.jquery.com/jQuery.ajax/\n17\n http://api.jquery.com/jQuery.ajax/#jqXHR\n18\n https://api.jquery.com/jQuery.ajax/\n19\n http://api.jquery.com/jQuery.ajax/#jqXHR\n20\n http://api.jquery.com/category/deferred-object/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":16},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:17","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n17\nこの問題はjQueryの \nDeferred Object\n21\n の \nthen\n の挙動が違うため\nに発生します。\nそのため、\n.then\n というメソッドを持っていた場合でも、必ずES6\nPromisesとして使えるとは限らない事は知っておくべきでしょう。\n• JavaScript Promises: There and back again - HTML5 Rocks\n22\n• You're Missing the Point of Promises\n23\nなお、jQuery 3.0からは、 \nDeferred Object\n24\nや jqXHR\nObject\n25\nがPromises/A+\n準拠へと変更されています。 そのため、上記\nで紹介されている \n.then\n の挙動が異なる問題は解消されています。\n• jQuery 3.0 Final Released! | Official jQuery Blog\n26\nPromise.resolve\n は共通の挙動である \nthen\n だけを利用して、 さまざまなライブラリ間で\nのpromiseオブジェクトを相互に変換して使える仕組みを持っていることになります。\nこのthenableを変換する機能は、以前は \nPromise.cast\n という名前であったことからもそ\nの挙動が想像できるかもしれません。\nThenableについてはPromiseを使ったライブラリを書くとき等には知っておくべきですが、\n通常の利用だとそこまで使う機会がないものかもしれません。\nThenableとPromise.resolveの具体的な例を交えたものは 第4章\nのPromise.resolveとThenable\nにて詳しく解説しています。\nPromise.resolve\n を簡単にまとめると、「渡した値でFulfilledされるpromiseオブジェクト\nを返すメソッド」と考えるのがいいでしょう。\nまた、Promiseの多くの処理は内部的に \nPromise.resolve\n のアルゴリズムを使って値を\npromiseオブジェクトに変換しています。\n21\n http://api.jquery.com/category/deferred-object/\n22\n http://www.html5rocks.com/ja/tutorials/es6/promises/#toc-lib-compatibility\n23\n http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/\n24\n http://api.jquery.com/category/deferred-object/\n25\n http://api.jquery.com/jQuery.ajax/#jqXHR\n26\n https://blog.jquery.com/2016/06/09/jquery-3-0-final-released/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":17},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:18","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n18\nPromise.reject\nPromise.reject(error)\nは \nPromise.resolve(value)\n と同じ静的メソッドで \nnew\nPromise()\n のショートカットとなるメソッドです。\nたとえば、 \nPromise.reject(new Error(\"エラー\"))\n というのは下記のコードのシンタック\nスシュガーです。\nnew Promise(\nfunction(resolve,reject){\n    reject(\nnew Error(\"エラー\"));\n});\n返り値のpromiseオブジェクトに対して、thenの \nonRejected\n に設定された関数にエラー\nオブジェクトが渡ります。\nPromise.reject(\nnew Error(\"BOOM!\")).catch(function(error){\n    console.error(error);\n});\nPromise.resolve(value)\n との違いは resolveではなくrejectが呼ばれるという点で、 テ\nストコードやデバッグ、一貫性を保つために利用する機会などがあるかもしれません。\nコラム: Promiseは常に非同期?\nPromise.resolve(value)\n 等を使った場合、 promiseオブジェクトがすぐにresolveされ\nるので、\n.then\n に登録した関数も同期的に処理が行われるように錯覚してしまいます。\nしかし、実際には \n.then\n で登録した関数が呼ばれるのは、非同期となります。\nvar promise = \nnew Promise(\nfunction (resolve){\n    console.log(\n\"inner promise\"\n); // 1\n    resolve(\n42);\n});\npromise.then(\nfunction(value){\n    console.log(value); \n// 3\n});\nconsole.log(\n\"outer promise\"\n); // 2\n上記のコードを実行すると以下の順に呼ばれていることが分かります。\ninner promise // 1","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":18},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:19","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n19\nouter promise // 2\n42            // 3\nJavaScriptは上から実行されていくため、まず最初に \n<1>\n が実行されますね。 そして次\nに \nresolve(42);\n が実行され、この \npromise\n オブジェクトはこの時点で \n42\n という値に\nFulFilledされます。\n次に、\npromise.then\n で \n<3>\n のコールバック関数を登録しますが、ここがこのコラムの焦\n点です。\npromise.then\n を行う時点でpromiseオブジェクトの状態が決まっているため、 プログラ\nム的には同期的にコールバック関数に \n42\n を渡して呼び出すことはできますね。\nしかし、Promiseでは \npromise.then\n で登録する段階でpromiseの状態が決まっていて\nも、 そこで登録したコールバック関数は非同期で呼び出される仕様になっています。\nそのため、\n<2>\n が先に呼び出されて、最後に \n<3>\n のコールバック関数が呼ばれています。\nなぜ、同期的に呼び出せるのにわざわざ非同期的に呼び出しているでしょうか?\n同期と非同期の混在の問題\nこれはPromise以外でも適用できるため、もう少し一般的な問題として考えてみましょう。\nこの問題はコールバック関数を受け取る関数が、 状況によって同期処理になるのか非同期\n処理になるのかが変わってしまう問題と同じです。\n次のような、コールバック関数を受け取り処理する \nonReady(fn)\n を見てみましょう。\nmixed-onready.js\nfunction onReady(fn) {\n    var readyState = document.readyState;\n    if (readyState === \n'interactive'\n || readyState === \n'complete'\n) {\n        fn();\n    } else {\n        window.addEventListener(\n'DOMContentLoaded'\n, fn);\n    }\n}\nonReady(function () {\n    console.log(\n'DOM fully loaded and parsed'\n);\n});\nconsole.log(\n'==Starting=='\n);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":19},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:20","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n20\nmixed-onready.js\nではDOMが読み込み済みかどうかで、 コールバック関数が同期的か\n非同期的に呼び出されるのかが異なっています。\nonReadyを呼ぶ前にDOMの読み込みが完了している\n同期的にコールバック関数が呼ばれる\nonReadyを呼ぶ前にDOMの読み込みが完了していない\nDOMContentLoaded\n のイベントハンドラとしてコールバック関数を設定する\nそのため、このコードは配置する場所によって、 コンソールに出てくるメッセージの順番が変\nわってしまいます。\nこの問題の対処法として常に非同期で呼び出すように統一することです。\nasync-onready.js\nfunction onReady(fn) {\n    var readyState = document.readyState;\n    if (readyState === \n'interactive'\n || readyState === \n'complete'\n) {\n        setTimeout(fn, \n0);\n    } else {\n        window.addEventListener(\n'DOMContentLoaded'\n, fn);\n    }\n}\nonReady(function () {\n    console.log(\n'DOM fully loaded and parsed'\n);\n});\nconsole.log(\n'==Starting=='\n);\nこの問題については、 \nEffective JavaScript\n27\n の 項目67 非同期コールバックを同期的に\n呼び出してはいけない\n で紹介されています。\n• 非同期コールバックは（たとえデータが即座に利用できても）決して同期\n的に使ってはならない。\n• 非同期コールバックを同期的に呼び出すと、処理の期待されたシーケン\nスが乱され、 コードの実行順序に予期しない変動が生じるかもしれない。\n• 非同期コールバックを同期的に呼び出すと、スタックオーバーフローや\n例外処理の間違いが発生するかもしれない。\n• 非同期コールバックを次回に実行されるようスケジューリングするに\nは、\nsetTimeout\n のような非同期APIを使う。\n27\n http://effectivejs.com/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":20},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:21","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n21\n— David Herman \nEffective JavaScript\n先ほどの \npromise.then\n も同様のケースであり、この同期と非同期処理の混在の問題が\n起きないようにするため、 \nPromiseは常に非同期\n で処理されるということが仕様で定めら\nれているわけです。\n最後に、この \nonReady\n をPromiseを使って定義すると以下のようになります。\nonready-as-promise.js\nfunction onReadyPromise() {\n    return new Promise(\nfunction (resolve, reject) {\n        var readyState = document.readyState;\n        if (readyState === \n'interactive'\n || readyState === \n'complete'\n) {\n            resolve();\n        } \nelse {\n            window.addEventListener(\n'DOMContentLoaded'\n, resolve);\n        }\n    });\n}\nonReadyPromise().then(\nfunction () {\n    console.log(\n'DOM fully loaded and parsed'\n);\n});\nconsole.log(\n'==Starting=='\n);\nPromiseは常に非同期で実行されることが保証されているため、 \nsetTimeout\n のような明\n示的に非同期処理にするためのコードが不要となることが分かります。\nPromise#then\n先ほどの章でPromiseの基本となるインスタンスメソッドである \nthen\n と \ncatch\n の使い方\nを説明しました。\nその中で \n.then().catch()\n とメソッドチェーンで繋げて書いていたことからも分かるよう\nに、 Promiseではいくらでもメソッドチェーンを繋げて処理を書いていくことができます。\npromiseはメソッドチェーンで繋げて書ける\naPromise.then(\nfunction taskA(value){\n// task A\n}).then(function taskB(value){\n// task B\n}).catch(function onRejected(error){\n    console.error(error);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":21},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:22","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n22\n});\nthen\n で登録するコールバック関数をそれぞれtaskというものにした時に、 taskA → task\nB という流れをPromiseのメソッドチェーンを使って書くことができます。\nPromiseのメソッドチェーンだと長いので、今後は\npromise chain\nと呼びます。 この\npromise chainがPromiseが非同期処理の流れを書きやすい理由の一つといえるかもし\nれません。\nこのセクションでは、\nthen\n を使ったpromise chainの挙動と流れについて学んでいきま\nしょう。\npromise chain\n第一章の例だと、\npromise chain\nは then → catch というシンプルな例でしたが、この\npromise chainをもっとつなげた場合に、 それぞれのpromiseオブジェクトに登録された\nonFulfilledとonRejectedがどのように呼ばれるかを見ていきましょう。\npromise chain - すなわちメソッドチェーンが短いことはよいことです。\nこの例では説明のために長いメソッドチェーンを用います。\n次のようなpromise chainを見てみましょう。\npromise-then-catch-flow.js\nfunction taskA() {\n    console.log(\n\"Task A\");\n}\nfunction taskB() {\n    console.log(\n\"Task B\");\n}\nfunction onRejected(error) {\n    console.log(\n\"Catch Error: A or B\"\n, error);\n}\nfunction finalTask() {\n    console.log(\n\"Final Task\"\n);\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":22},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:23","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n23\n    .then(finalTask);\nこのようなpromise chainをつなげた場合、 それぞれの処理の流れは以下のように図で表\nせます。\nFigure 3. promise-then-catch-flow.jsの図\n上記のコード\nでは \nthen\n は第二引数(onRejected)を使っていないため、 以下のように読み\n替えても問題ありません。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":23},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:24","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n24\nthen\nonFulfilledの処理を登録\ncatch\nonRejectedの処理を登録\n図の方に注目してもらうと、 \nTask A と Task B それぞれから \nonRejected\n への線が出てい\nることが分かります。\nこれは、\nTask A または Task B の処理にて、次のような場合に \nonRejected\n が呼ばれるとい\nうことを示しています。\n• 例外が発生した時\n• Rejectedなpromiseオブジェクトがreturnされた時\n第一章でPromiseの処理は常に \ntry-catch\n されているようなものなので、 例外が起き\nた場合もキャッチして、\ncatch\n で登録された \nonRejected\n の処理を呼ぶことは学びました\nね。\nもう一つの \nRejectedなpromiseオブジェクトがreturnされた時\n については、 \nthrow\n を使\nわずにpromise chain中に \nonRejected\n を呼ぶ方法です。\nこれについては、ここでは必要ない内容なので詳しくは、 第4章の \nthrowしないで、rejectし\nよう にて解説しています。\nまた、onRejected\n と Final Task\n には \ncatch\n のpromise chainがこれより後ろにありませ\nん。 つまり、この処理中に例外が起きた場合はキャッチすることができないことに気をつけま\nしょう。\nもう少し具体的に、\nTask A → onRejected\n となる例を見てみます。\nTask Aで例外が発生したケース\nTask A の処理中に例外が発生した場合、 TaskA → onRejected → FinalTask という流れ\nで処理が行われます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":24},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:25","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n25\nFigure 4. Task Aで例外が発生した時の図\nコードにしてみると以下のようになります。\npromise-then-taska-throw.js\nfunction taskA() {\n    console.log(\n\"Task A\");\n    throw new Error(\"throw Error @ Task A\"\n);\n}","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":25},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:26","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n26\nfunction taskB() {\n    console.log(\n\"Task B\");// 呼ばれない\n}\nfunction onRejected(error) {\n    console.error(error);\n// => \"throw Error @ Task A\"\n}\nfunction finalTask() {\n    console.log(\n\"Final Task\"\n);\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n実行してみると、\nTask B が呼ばれていないことが分かるでしょう。\n例では説明のためにtaskAで \nthrow\n して例外を発生させています。\nしかし、実際に明示的にonRejectedを呼びたい場合は、Rejectedな\npromiseオブジェクトを返すべきでしょう。 それぞれの違いについては\nthrowしないで、rejectしよう\n で解説しています。\npromise chainでの値渡し\n先ほどの例ではそれぞれのTaskが独立していて、ただ呼ばれているだけでした。\nこのときに、Task AがTask Bへ値を渡したい時はどうすればよいでしょうか?\n答えはものすごく単純でTask Aの処理で \nreturn\n した値がTask Bが呼ばれるときに引数\nに設定されます。\n実際に例を見てみましょう。\npromise-then-passing-value.js\nfunction doubleUp(value) {\n    return value * \n2;\n}\nfunction increment(value) {\n    return value + \n1;\n}\nfunction output(value) {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":26},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:27","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n27\n    console.log(value);\n// => (1 + 1) * 2\n}\nvar promise = Promise.resolve(\n1);\npromise\n    .then(increment)\n    .then(doubleUp)\n    .then(output)\n    .catch(function(error){\n        // promise chain中にエラーが発生した場合に呼ばれる\n        console.error(error);\n    });\nスタートは \nPromise.resolve(1);\n で、この処理は以下のような流れでpromise chainが\n処理されていきます。\n1.\nPromise.resolve(1);\n から 1 が \nincrement\n に渡される\n2.\nincrement\n では渡された値に+1した値を \nreturn\n している\n3. この値(2)が次の \ndoubleUp\n に渡される\n4. 最後に \noutput\n が出力する","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":27},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:28","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n28\nFigure 5. promise-then-passing-value.jsの図\nこの \nreturn\n する値は数字や文字列だけではなく、 オブジェクトやpromiseオブジェクトも\nreturn\n することができます。\nreturnした値は \nPromise.resolve(returnされた値);\n のように処理されるため、 何を\nreturnしても最終的には新しいpromiseオブジェクトを返します。\nこれについて詳しくは \nthenは常に新しいpromiseオブジェクトを返す\nにて、 よくある間違いと共に紹介しています。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":28},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:29","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n29\nつまり、 \nPromise#then\n は単にコールバックとなる関数を登録するだけではなく、 受け取っ\nた値を変化させて別のpromiseオブジェクトを生成する という機能も持っていることを覚え\nておくといいでしょう。\nPromise#catch\n先ほどのPromise#then\nについてでも \nPromise#catch\n はすでに使っていましたね。\n改めて説明すると\nPromise#catch\nは \npromise.then(undefined, onRejected);\n のエイリ\nアスとなるメソッドです。 つまり、promiseオブジェクトがRejectedとなった時に呼ばれる関\n数を登録するためのメソッドです。\nPromise#then\nとPromise#catch\nの使い分けについては、 \nthen or\ncatch?で紹介しています。\nIE8以下での問題\nこのバッジは以下のコードが、 \npolyfill\n28\n を用いた状態でそれぞれのブラウザで正しく実行\nできているかを示したものです。\npolyfillとはその機能が実装されていないブラウザでも、その機能が使\nえるようにするライブラリのことです。 この例では \njakearchibald/es6-\npromise\n29\n を利用しています。\nPromise#catchの実行結果\nvar promise = Promise.reject(\nnew Error(\"message\"\n));\npromise.catch(function (error) {\n28\n https://github.com/jakearchibald/es6-promise\n29\n https://github.com/jakearchibald/es6-promise","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":29},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:30","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n30\n    console.error(error);\n});\nこのコードをそれぞれのブラウザで実行させると、IE8以下では実行する段階で \n識別子があ\nりません\n というSyntax Errorになってしまいます。\nこれはどういうことかというと、\ncatch\n という単語はECMAScriptにおける \n予約語\n30\n である\nことが関係します。\nECMAScript 3では予約語はプロパティの名前に使うことができませんでした。 IE8以下は\nECMAScript 3の実装であるため、\ncatch\n というプロパティを使う \npromise.catch()\n とい\nう書き方が出来ないので、 \n識別子がありません\nというエラーを起こしてしまう訳です。\n一方、現在のブラウザが実装済みであるECMAScript 5以降では、 予約語を\nIdentifierName\n31\n 、つまりプロパティ名に利用することが可能となっています。\nECMAScript 5でも予約語は \nIdentifier\n32\n 、つまり変数名、関数名に\nは利用することが出来ません。 \nfor\n という変数が定義できてしまう\nと \nfor\n 文との区別ができなくなってしまいます。 プロパティの場合は\nobject.for\n と \nfor\n 文の区別はできるので、少し考えてみると自然な\n動作ですね。\nこのECMAScript 3の予約語の問題を回避する書き方も存在します。\nドット表記法\n33\n はプロパティ名が有効な識別子(ECMAScript 3の場合は予約語が使えな\nい)でないといけませんが、 \nブラケット表記法\n34\n は有効な識別子ではなくても利用できま\nす。\nつまり、先ほどのコードは以下のように書き換えれば、IE8以下でも実行することができます。\n(もちろんpolyfillは必要です)\nPromise#catchの識別子エラーの回避\nvar promise = Promise.reject(\nnew Error(\"message\"\n));\npromise[\"catch\"](function (error) {\n    console.error(error);\n30\n http://mothereff.in/js-properties#catch\n31\n http://es5.github.io/#x7.6\n32\n http://es5.github.io/#x7.6\n33\n https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/\nProperty_Accessors#Dot_notation\n34\n https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/\nProperty_Accessors#Bracket_notation","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":30},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:31","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n31\n});\nもしくは単純に \ncatch\n を使わずに、\nthen\n を使うことでも回避できます。\nPromise#catchではなくPromise#thenを使う\nvar promise = Promise.reject(\nnew Error(\"message\"\n));\npromise.then(\nundefined\n, function (error) {\n    console.error(error);\n});\ncatch\n という識別子が問題となっているため、ライブラリによっては \ncaught\n 等の名前が\n違うだけのメソッドを用意しているケースがあります。\nまた多くの圧縮ツールは \npromise.catch\n を \npromise[\"catch\"]\n へと置換する処理が組\nみ込まれているため、知らない間に回避できていることも多いかも知れません。\nサポートブラウザにIE8以下を含める時は、この \ncatch\n の問題に気をつけるといいでしょう。\nコラム: thenは常に新しいpromiseオブジェクトを返す\naPromise.then(...).catch(...)\n は一見すると、全て最初の \naPromise\n オブジェクトに メ\nソッドチェーンで処理を書いてるように見えます。\nしかし、実際には \nthen\n で新しいpromiseオブジェクト、\ncatch\n でも別の新しいpromiseオ\nブジェクトを作成して返しています。\n本当に新しいpromiseオブジェクトを返しているのか確認してみましょう。\nvar aPromise = \nnew Promise(\nfunction (resolve) {\n    resolve(\n100);\n});\nvar thenPromise = aPromise.then(\nfunction (value) {\n    console.log(value);\n});\nvar catchPromise = thenPromise.\ncatch(function (error) {\n    console.error(error);\n});\nconsole.log(aPromise !== thenPromise); \n// => true\nconsole.log(thenPromise !== catchPromise);\n// => true\n===\n 厳密比較演算子によって比較するとそれぞれが別々のオブジェクトなので、 本当に\nthen\n や \ncatch\n は別のpromiseオブジェクトを返していることが分かりました。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":31},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:32","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n32\nこの仕組みはPromiseを拡張する時は意識しないと、いつのまにか触ってるpromiseオブ\nジェクトが 別のものであったということが起こりえると思います。\nまた、\nthen\n は新しいオブジェクトを作って返すということがわかっていれば、 次の \nthen\n の\n使い方では意味が異なることに気づくでしょう。\n// 1: それぞれの `then` は同時に呼び出される\nvar aPromise = \nnew Promise(\nfunction (resolve) {\n    resolve(\n100);\n});\naPromise.then(\nfunction (value) {\n    return value * \n2;\n});\naPromise.then(\nfunction (value) {\n    return value * \n2;\n});\naPromise.then(\nfunction (value) {\n    console.log(\n\"1: \" + value); \n// => 100\n})\n// vs\n// 2: `then` はpromise chain通り順番に呼び出される\nvar bPromise = \nnew Promise(\nfunction (resolve) {\n    resolve(\n100);\n});\nbPromise.then(\nfunction (value) {\n    return value * \n2;\n}).then(function (value) {\n    return value * \n2;\n}).then(function (value) {\n    console.log(\n\"2: \" + value); \n// => 100 * 2 * 2\n});","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":32},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:33","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n33\n1のpromiseをメソッドチェーン的に繋げない書き方はあまりすべきではありませんが、 この\nような書き方をした場合、それぞれの \nthen\n はほぼ同時に呼ばれ、また \nvalue\n に渡る値も\n全て同じ \n100\n となります。\n2はメソッドチェーン的につなげて書くことにより、resolve → then → then → then と書い\nた順番にキチンと実行され、 それぞれの \nvalue\n に渡る値は、一つ前のpromiseオブジェク\nトで \nreturn\n された値が渡ってくるようになります。\n1の書き方により発生するアンチパターンとしては以下のようなものが有名です。\n✘ \nthen\n の間違った使い方\nfunction badAsyncCall() {\n    var promise = Promise.resolve();\n    promise.then(\nfunction() {\n        // 何かの処理\n        return newVar;\n    });\n    return promise;\n}\nこのように書いてしまうと、\npromise.then\n の中で例外が発生するとその例外を取得する方\n法がなくなり、 また、何かの値を返していてもそれを受け取る方法が無くなってしまいます。\nこれは \npromise.then\n によって新たに作られたpromiseオブジェクトを返すようにすること\nで、 2のようにpromise chainをつなげるようにするべきなので、次のように修正することが\nできます。\nthen\n で作成したオブジェクトを返す\nfunction anAsyncCall() {\n    var promise = Promise.resolve();\n    return promise.then(\nfunction() {\n        // 何かの処理\n        return newVar;\n    });\n}\nこれらのアンチパターンについて、詳しくは \nPromise Anti-patterns\n35\n を参照して下さい。\nこの挙動はPromise全般に当てはまるため、後に説明する\nPromise.all\nやPromise.race\nも\n引数で受け取ったものとは別のpromiseオブジェクトを作って返しています。\n35\n http://taoofcode.net/promise-anti-patterns/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":33},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:34","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n34\nPromiseと配列\nここまでで、promiseオブジェクトが FulFilled または Rejected となった時の処理は\n.then\n と \n.catch\n で登録できることを学びました。\n一つのpromiseオブジェクトなら、そのpromiseオブジェクトに対して処理を書けばよいで\nすが、 複数のpromiseオブジェクトが全てFulFilledとなった時の処理を書く場合はどうす\nればよいでしょうか?\nたとえば、複数のXHR(非同期処理)が全て終わった後に、何かをしたいという事例を考えて\nみます。\n少しイメージしにくいので、 まずは、通常のコールバックスタイルを使って複数のXHRを行\nう以下のようなコードを見てみます。\nCORSについて\nブラウザにおけるXHRのリソース取得には、CORS(\nCross-Origin\nResource Sharing\n36\n)というセキュリティ上の制約が存在します。\nこのCORSの制約により、ブラウザでは同一ドメインではないリソースを\n許可なく取得することはできません。そのため、一般的には別サイトのリ\nソースは許可なくXHRでアクセスすることができません。\n次のサンプルでは \nhttp://azu.github.io/promises-book/json/\ncomment.json\n という \nazu.github.io\n ドメイン以下にあるリソースを\n取得する例が登場します。\nazu.github.io\n ドメイン以下のJSONには、別ドメインからの取得が許\n可する設定がされています。\nまた、 httpbin.org\n37\n というドメインがリソース取得の例として登場しま\nす。 こちらも、同一ドメインでなくてもリソースの取得が許可されていま\nす。\nコールバックで複数の非同期処理\nmultiple-xhr-callback.js\nfunction getURLCallback(URL, callback) {\n    var req = new XMLHttpRequest();\n36\n https://developer.mozilla.org/ja/docs/Web/HTTP/HTTP_access_control\n37\n http://httpbin.org/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":34},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:35","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n35\n    req.open(\n'GET', URL, true);\n    req.onload = \nfunction () {\n        if (req.status === \n200) {\n            callback(null, req.responseText);\n        } \nelse {\n            callback(\nnew Error(req.statusText), req.response);\n        }\n    };\n    req.onerror = \nfunction () {\n        callback(\nnew Error(req.statusText));\n    };\n    req.send();\n}\n// <1> JSONパースを安全に行う\nfunction jsonParse(callback, error, value) {\n    if (error) {\n        callback(error, value);\n    } else {\n        try {\n            \nvar result = JSON.parse(value);\n            callback(null, result);\n        } \ncatch (e) {\n            callback(e, value);\n        }\n    }\n}\n// <2> XHRを叩いてリクエスト\nvar request = {\n        comment: \nfunction getComment(callback) {\n            \nreturn getURLCallback(\n'http://azu.github.io/promises-book/json/comment.json'\n,\n jsonParse.bind(null, callback));\n        },\n        people: \nfunction getPeople(callback) {\n            \nreturn getURLCallback(\n'http://azu.github.io/promises-book/json/people.json'\n,\n jsonParse.bind(null, callback));\n        }\n    };\n// <3> 複数のXHRリクエストを行い、全部終わったらcallbackを呼ぶ\nfunction allRequest(requests, callback, results) {\n    if (requests.length === \n0) {\n        return callback(null, results);\n    }\n    var req = requests.shift();\n    req(function (error, value) {\n        if (error) {\n            callback(error, value);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":35},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:36","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n36\n        } \nelse {\n            results.push(value);\n            allRequest(requests, callback, results);\n        }\n    });\n}\nfunction main(callback) {\n    allRequest([request.comment, request.people], callback, []);\n}\n// 実行例\nmain(function(error, results){\n    if(error){\n        console.error(error);\n        return;\n    }\n    console.log(results);\n});\nこのコールバックスタイルでは幾つかの要素が出てきます。\n•\nJSON.parse\n をそのまま使うと例外となるケースがあるためラップした \njsonParse\n 関\n数を使う\n• 複数のXHRをそのまま書くとネストが深くなるため、\nallRequest\n というrequest関数を\n実行するものを利用する\n• コールバック関数には \ncallback(error,value)\n のように第一引数にエラー、第二引数\nにレスポンスを渡す。\njsonParse\n 関数を使うときに \nbind\n を使うことで、部分適用を使って無名関数を減らすよ\nうにしています。 (コールバックスタイルでも関数の処理などをちゃんと分離すれば、無名関\n数の使用も減らせると思います)\njsonParse.bind(null, callback);\n// は以下のように置き換えるのと殆ど同じ\nfunction bindJSONParse(error, value){\n    jsonParse(callback, error, value);\n}\nコールバックスタイルで書いたものを見ると以下のような点が気になります。\n• 明示的な例外のハンドリングが必要\n• ネストを深くしないために、requestを扱う関数が必要","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":36},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:37","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n37\n• コールバックがたくさんでてくる\n次は、\nPromise#then\n を使って同様のことをしてみたいと思います。\nPromise#thenのみで複数の非同期処理\n先に述べておきますが、\nPromise.all\n というこのような処理に適切なものがあるため、 ワ\nザと \n.then\n の部分をクドく書いています。\n.then\n を使った場合は、コールバックスタイルと完全に同等というわけではないですが以\n下のように書けると思います。\nmultiple-xhr.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":37},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:38","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n38\n    // [] は記録する初期値を部分適用している\n    var pushValue = recordValue.bind(null, []);\n    return request.comment().then(pushValue).then(request.people).then(pushValue);\n}\n// 実行例\nmain().then(\nfunction (value) {\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\nコールバックスタイル\nと比較してみると次のことがわかります。\n•\nJSON.parse\n をそのまま使っている\n•\nmain()\n はpromiseオブジェクトを返している\n• エラーハンドリングは返ってきたpromiseオブジェクトに対して書いている\n先ほども述べたように mainの \nthen\n の部分がクドく感じます。\nPromiseでは、このような複数の非同期処理をまとめて扱う \nPromise.all\n と\nPromise.race\n という静的メソッドが用意されています。\n次のセクションではそれらについて学んでいきましょう。\nPromise.all\nPromise.all\n は promiseオブジェクトの配列を受け取り、 その配列に入っているpromise\nオブジェクトが全てresolveされた時に、次の \n.then\n を呼び出します。\n先ほどの複数のXHRの結果をまとめて取得する処理は、 \nPromise.all\n を使うとシンプルに\n書くことができます。\n先ほどの例の \ngetURL\n はXHRによる通信を抽象化したpromiseオブジェクトを返していま\nす。 \nPromise.all\n に通信を抽象化したpromiseオブジェクトの配列を渡すことで、 全ての\n通信が完了(FulFilledまたはRejected)した時に、次の \n.then\n を呼び出すことができます。\npromise-all-xhr.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":38},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:39","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n39\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    return Promise.all([request.comment(), request.people()]);\n}\n// 実行例\nmain().then(\nfunction (value) {\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\n実行方法は \n前回のもの\n と同じですね。 \nPromise.all\n を使うことで以下のような違いがあ\nることがわかります。\n• mainの処理がスッキリしている\n• Promise.all は promiseオブジェクトの配列を扱っている\nPromise.all([request.comment(), request.people()]);\nというように処理を書いた場合は、\nrequest.comment()\n と \nrequest.people()\n は\n同時に実行されますが、 それぞれのpromiseの結果(resolve,rejectで渡される値)\nは、\nPromise.all\nに渡した配列の順番となります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":39},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:40","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n40\nつまり、この場合に次の \n.then\n に渡される結果の配列は [comment, people]の順番にな\nることが保証されています。\nmain().then(\nfunction (results) {\n    console.log(results); \n// [comment, people]の順番\n});\nPromise.all\n に渡したpromiseオブジェクトが同時に実行されてるのは、 次のようなタイ\nマーを使った例を見てみると分かりやすいです。\npromise-all-timer.js\n// `delay`ミリ秒後にresolveする\nfunction timerPromisefy(delay) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            resolve(delay);\n        }, delay);\n    });\n}\nvar startDate = \nDate.now();\n// 全てがresolveされたら終了\nPromise.all([\n    timerPromisefy(\n1),\n    timerPromisefy(\n32),\n    timerPromisefy(\n64),\n    timerPromisefy(\n128)\n]).then(function (values) {\n    console.log(\nDate.now() - startDate + \n'ms');\n    // 約128ms\n    console.log(values);    \n// [1,32,64,128]\n});\ntimerPromisefy\n は引数で指定したミリ秒後に、その指定した値でFulFilledとなる\npromiseオブジェクトを返してくれます。\nPromise.all\n に渡してるのは、それを複数作り配列にしたものですね。\nvar promises = [\n    timerPromisefy(\n1),\n    timerPromisefy(\n32),\n    timerPromisefy(\n64),\n    timerPromisefy(\n128)","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":40},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:41","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n41\n];\nこの場合は、1, 32, 64, 128 ミリ秒後にそれぞれ \nresolve\n されます。\nつまり、このpromiseオブジェクトの配列がすべてresolveされるには、最低でも128msか\nかることがわかります。 実際に\nPromise.all\n で処理してみると 約128msかかることがわか\nります。\nこのことから、\nPromise.all\n が一つづつ順番にやるわけではなく、 渡されたpromiseオブ\nジェクトの配列を並列に実行してるということがわかります。\n仮に逐次的に行われていた場合は、 1ms待機 → 32ms待機 → 64ms\n待機 → 128ms待機 となるので、 全て完了するまで225ms程度かかる\n計算になります。\n実際にPromiseを逐次的に処理したいケースについては第4章\nのPromiseによる逐次処理\nを参照して下さい。\nPromise.race\nPromise.all\n と同様に複数のpromiseオブジェクトを扱う\nPromise.race\nを見てみましょ\nう。\n使い方はPromise.allと同様で、promiseオブジェクトの配列を引数に渡します。\nPromise.all\n は、渡した全てのpromiseがFulFilled または Rejectedになるまで次の\n処理を待ちましたが、 \nPromise.race\n は、どれか一つでもpromiseがFulFilled または\nRejectedになったら次の処理を実行します。\nPromise.allのときと同じく、タイマーを使った \nPromise.race\n の例を見てみましょう\npromise-race-timer.js\n// `delay`ミリ秒後にresolveする\nfunction timerPromisefy(delay) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            resolve(delay);\n        }, delay);\n    });\n}\n// 一つでもresolve または reject した時点で終了\nPromise.race([","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":41},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:42","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n42\n    timerPromisefy(\n1),\n    timerPromisefy(\n32),\n    timerPromisefy(\n64),\n    timerPromisefy(\n128)\n]).then(function (value) {\n    console.log(value);    \n// => 1\n});\n上記のコードだと、1ms後、32ms後、64ms後、128ms後にそれぞれpromiseオブジェクト\nがFulFilledとなりますが、 一番最初に1msのものがFulFilledとなった時点で、\n.then\n が\n呼ばれます。 また、\nresolve(1)\n が呼ばれるため \nvalue\n に渡される値も1となります。\n最初にFulFilledとなったpromiseオブジェクト以外は、その後呼ばれているのかを見てみ\nましょう。\npromise-race-other.js\nvar winnerPromise = \nnew Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            console.log(\n'this is winner'\n);\n            resolve(\n'this is winner'\n);\n        }, \n4);\n    });\nvar loserPromise = \nnew Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            console.log(\n'this is loser'\n);\n            resolve(\n'this is loser'\n);\n        }, \n1000);\n    });\n// 一番最初のものがresolveされた時点で終了\nPromise.race([winnerPromise, loserPromise]).then(\nfunction (value) {\n    console.log(value);    \n// => 'this is winner'\n});\n先ほどのコードに \nconsole.log\n をそれぞれ追加しただけの内容となっています。\n実行してみると、winnter/loser どちらも \nsetTimeout\n の中身が実行されて \nconsole.log\nがそれぞれ出力されていることがわかります。\nつまり、\nPromise.race\nでは、 一番最初のpromiseオブジェクトがFulfilledとなっても、他の\npromiseがキャンセルされるわけでは無いということがわかります。\nES6 Promises\nの仕様には、キャンセルという概念はありません。 必\nず、resolve or rejectによる状態の解決が起こることが前提となってい","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":42},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:43","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n43\nます。 つまり、\n状態が固定されてしまうかもしれない処理には不向きで\nあるといえます。 ライブラリによってはキャンセルを行う仕組みが用意さ\nれている場合があります。\nthen or catch?\n前の章で \n.catch\n は \npromise.then(undefined, onRejected)\n であるということを紹介し\nました。\nこの書籍では基本的には、\n.catch\nを使い \n.then\n とは分けてエラーハンドリングを書くよう\nにしています。\nここでは、\n.then\n でまとめて指定した場合と、どのような違いがでるかについて学んでいき\nましょう。\nエラー処理ができないonRejected\n次のようなコードを見ていきます。\nthen-throw-error.js\nfunction throwError(value) {\n    // 例外を投げる\n    throw new Error(value);\n}\n// <1> onRejectedが呼ばれることはない\nfunction badMain(onRejected) {\n    return Promise.resolve(\n42).then(throwError, onRejected);\n}\n// <2> onRejectedが例外発生時に呼ばれる\nfunction goodMain(onRejected) {\n    return Promise.resolve(\n42).then(throwError).\ncatch(onRejected);\n}\n// 実行例\nbadMain(function(){\n    console.log(\n\"BAD\");\n});\ngoodMain(\nfunction(){\n    console.log(\n\"GOOD\");\n});\nこのコード例では、(必ずしも悪いわけではないですが)良くないパターンの \nbadMain\n と\nちゃんとエラーハンドリングが行える \ngoodMain\n があります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":43},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:44","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n44\nbadMain\n がなぜ良くないかというと、\n.then\n の第二引数にはエラー処理を書くことができ\nますが、 そのエラー処理は第一引数の \nonFulfilled\n で指定した関数内で起きたエラーを\nキャッチすることはできません。\nつまり、この場合、 \nthrowError\n でエラーがおきても、\nonRejected\n に指定した関数は呼ば\nれることなく、 どこでエラーが発生したのかわからなくなってしまいます。\nそれに対して、 \ngoodMain\n は \nthrowError\n → \nonRejected\n となるように書かれています。\nこの場合は \nthrowError\n でエラーが発生しても、次のchainである \n.catch\n が呼ばれるた\nめ、エラーハンドリングを行うことができます。\n.then\n のonRejectedが扱う処理は、その(またはそれ以前の)promiseオブジェクトに対し\nてであって、 \n.then\n に書かれたonFulfilledは対象ではないためこのような違いが生まれ\nます。\n.then\n や \n.catch\n はその場で\n新しいpromiseオブジェクトを作って返\nします。 Promiseではchainする度に異なるpromiseオブジェクトに対\nして処理を書くようになっています。\nFigure 6. Then Catch flow\nこの場合の \nthen\n は \nPromise.resolve(42)\n に対する処理となり、 \nonFulfilled\n で例外\nが発生しても、同じ \nthen\n で指定された \nonRejected\n はキャッチすることはありません。\nこの \nthen\n で発生した例外をキャッチできるのは、次のchainで書かれた \ncatch\n となりま\nす。\nもちろん \n.catch\n は \n.then\n のエイリアスなので、下記のように \n.then\n を使っても問題は\nありませんが、 \n.catch\n を使ったほうが意図が明確で分かりやすいでしょう。\nPromise.resolve(\n42).then(throwError).then(null, onRejected);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":44},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:45","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n45\nまとめ\nここでは次のようなことについて学びました。\n1.\npromise.then(onFulfilled, onRejected)\n において\n•\nonFulfilled\n で例外がおきても、この \nonRejected\n はキャッチできない\n2.\npromise.then(onFulfilled).catch(onRejected)\n とした場合\n•\nthen\n で発生した例外を \n.catch\n でキャッチできる\n3.\n.then\nと\n.catch\nに本質的な意味の違いはない\n• 使い分けると意図が明確になる\nbadMain\n のような書き方をすると、意図とは異なりエラーハンドリングができないケースが\n存在することは覚えておきましょう。\nChapter.3 - Promiseのテスト\nこの章ではPromiseのテストの書き方について学んで行きます。\n基本的なテスト\nES6 Promises\nのメソッド等についてひととおり学ぶことができたため、 実際にPromiseを\n使った処理を書いていくことはできると思います。\nそうした時に、次にどうすればいいのか悩むのがPromiseのテストの書き方です。\nここではまず、 \nMocha\n38\nを使った基本的なPromiseのテストの書き方について学んでいき\nましょう。\nまた、この章でのテストコードはNode.js環境で実行することを前提としているため、 各自\nNode.js環境を用意してください。\nこの書籍中に出てくるサンプルコードはそれぞれテストも書かれていま\nす。 テストコードは \nazu/promises-book\n39\n から参照できます。\nMochaとは\nMochaの公式サイト: \nhttp://mochajs.org/\n38\n http://mochajs.org/\n39\n https://github.com/azu/promises-book","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":45},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:46","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n46\nここでは、 Mocha自体については詳しく解説しませんが、 MochaはNode.js製のテストフ\nレームワークツールです。\nMochaはBDD,TDD,exportsのどれかのスタイルを選択でき、テストに使うアサーションメ\nソッドも任意のライブラリと組み合わせて利用します。 つまり、Mocha自体はテスト実行時\nの枠だけを提供しており、他は利用者が選択するというものになっています。\nMochaを選択した理由は、以下のとおりです。\n• 著名なテストフレームワークであること\n• Node.jsとブラウザ どちらのテストもサポートしている\n• \"Promiseのテスト\"をサポートしている\n最後の \"Promiseのテスト\"をサポートしている\n とはどういうことなのかについては後ほど解\n説します。\nこの章ではMochaを利用するため、npmを使いMochaをインストールしておく必要があり\nます。\n$ npm install -g mocha\nまた、アサーション自体はNode.jsに同梱されている \nassert\n モジュールを使用するので別\n途インストールは必要ありません。\nまずはコールバックスタイルの非同期処理をテストしてみましょう。\nコールバックスタイルのテスト\nコールバックスタイルの非同期処理をテストする場合、Mochaでは以下のように書くことが\nできます。\nbasic-test.js\nvar assert = require(\n'assert');\nit('should use `done` for test'\n, function (done) {\n    setTimeout(\nfunction () {\n        assert(true);\n        done();\n    }, 0);\n});","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":46},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:47","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n47\nこのテストを \nbasic-test.js\n というファイル名で作成し、 先ほどインストールしたMocha\nでコマンドラインからテストを実行することができます。\n$ mocha basic-test.js\nMochaは \nit\n の仮引数に \ndone\n のように指定してあげると、 \ndone()\n が呼ばれるまでテス\nトの終了を待つことで非同期のテストをサポートしています。\nMochaでの非同期テストは以下のような流れで実行されます。\nit(\"should use `done` for test\"\n, function (done) {\n    \n    setTimeout(\nfunction () {\n        assert(true);\n        done();\n    }, 0);\n});\nコールバックを使う非同期処理\ndone\n を呼ぶことでテストが終了する\nよく見かける形の書き方ですね。\ndone\n を使ったPromiseのテスト\n次に、同じく \ndone\n を使ったPromiseのテストを書いてみましょう。\nit(\"should use `done` for test?\"\n, function (done) {\n    var promise = Promise.resolve(\n42);\n    promise.then(\nfunction (value) {\n        assert(value === \n42);\n        done();\n    });\n});\nFulfilled\n となるpromiseオブジェクトを作成\ndone\n を呼ぶことでテストの終了を宣言\nPromise.resolve\n はpromiseオブジェクトを返しますが、 そのpromiseオブジェクトは\nFulFilledの状態になります。 その結果として \n.then\n で登録したコールバック関数が呼び\n出されます。\nコラム: Promiseは常に非同期?\n でも出てきたように、 promiseオブジェクトは常に非同期\nで処理されるため、テストも非同期に対応した書き方が必要となります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":47},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:48","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n48\nしかし、先ほどのテストコードでは \nassert\n が失敗した場合に問題が発生します。\n意図しない結果となるPromiseのテスト\nit(\"should use `done` for test?\"\n, function (done) {\n    var promise = Promise.resolve();\n    promise.then(\nfunction (value) {\n        assert(false);\n// => throw AssertionError\n        done();\n    });\n});\nこのテストは \nassert\n が失敗しているため、「テストは失敗する」と思うかもしれませんが、\n実際にはテストが終わることがなくタイムアウトします。\nFigure 7. テストが終わることがないためタイムアウトするまでそこで止まる\nassert\n が失敗した場合は通常はエラーをthrowし、 テストフレームワークがそれをキャッ\nチすることで、テストが失敗したと判断します。\nしかし、Promiseの場合は \n.then\n の中で行われた処理でエラーが発生しても、 Promise\nがそれをキャッチしてしまい、テストフレームワークまでエラーが届きません。\n意図しない結果となるPromiseのテスト\nを改善して、 \nassert\n が失敗した場合にちゃんとテ\nストが失敗となるようにしてみましょう。\n意図通りにテストが失敗する例\nit(\"should use `done` for test?\"\n, function (done) {\n    var promise = Promise.resolve();\n    promise.then(\nfunction (value) {\n        assert(false);\n    }).then(done, done);\n});\nちゃんとテストが失敗する例では、必ず \ndone\n が呼ばれるようにするため、 最後に\n.then(done, done);\n を追加しています。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":48},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:49","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n49\nassert\n がパスした場合は単純に \ndone()\n が呼ばれ、\nassert\n が失敗した場合は\ndone(error)\n が呼ばれます。\nこれでようやく\nコールバックスタイルのテスト\nと同等のPromiseのテストを書くことができま\nした。\nしかし、\nassert\n が失敗した時のために \n.then(done, done);\n というものを付ける必要が\nあります。 Promiseのテストを書くときにつけ忘れてしまうと終わらないテストができ上がっ\nてしまう場合があることに気をつけましょう。\n次に、最初にmochaを使う理由に上げた\"Promisesのテスト\"のサポートがどのような機能\nであるか学んでいきましょう。\nMochaのPromiseサポート\nMochaがサポートしてる\"Promiseのテスト\"とは何かについて学んでいきましょう。\n公式サイトの \nAsynchronous code\n40\nにもその概要が書かれています。\nAlternately, instead of using the done() callback, you can return a\npromise. This is useful if the APIs you are testing return promises\ninstead of taking callbacks:\nPromiseのテストの場合はコールバックとして \ndone()\n を呼ぶ代わりに、promiseオブジェ\nクトをreturnすることができると書いてあります。\nでは、実際にどのように書くかの例を見ていきたいと思います。\nmocha-promise-test.js\nvar assert = require(\n'assert');\ndescribe(\n'Promise Test'\n, function () {\n    it('should return a promise object'\n, function () {\n        var promise = Promise.resolve(\n42);\n        return promise.then(\nfunction (value) {\n            assert(value === \n42);\n        });\n    });\n});\n先ほどの \ndone\n を使った例\nをMochaのPromiseテストの形式に変更しました。\n40\n http://mochajs.org/#asynchronous-code","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":49},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:50","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n50\n変更点としては以下の2つとなっています。\n•\ndone\n そのものを取り除いた\n• promiseオブジェクトを返すようにした\nこの書き方をした場合、\nassert\n が失敗した場合はもちろんテストが失敗します。\nit(\"should be fail\"\n, function () {\n    return Promise.resolve().then(\nfunction () {\n        assert(false);\n// => テストが失敗する\n    });\n});\nこれにより \n.then(done, done);\n というような本質的にはテストとは関係ない記述を省くこ\nとができるようになりました。\nMochaがPromisesのテストをサポートしました | Web scratch\n41\n とい\nう記事でも MochaのPromiseサポートについて書かれています。\n意図しないテスト結果\nMochaがPromiseのテストをサポートしているため、この書き方でよいと思われるかもしれ\nません。 しかし、この書き方にも意図しない結果になる例外が存在します。\nたとえば、以下はある条件だとRejectedなpromiseオブジェクトを返す \nmayBeRejected()\nのテストコードです。\nエラーオブジェクトをテストしたい\nfunction mayBeRejected(){ \n    return Promise.reject(\nnew Error(\"woo\"));\n}\nit(\"is bad pattern\"\n, function () {\n    return mayBeRejected().\ncatch(function (error) {\n        assert(error.message === \n\"woo\");\n    });\n});\nこの関数が返すpromiseオブジェクトをテストしたい\nこのテストの目的とは以下のようになっています。\n41\n http://efcl.info/2014/0314/res3708/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":50},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:51","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n51\nmayBeRejected()\n が返すpromiseオブジェクトがFulFilledとなった場合\nテストを失敗させる\nmayBeRejected()\n が返すpromiseオブジェクトがRejectedとなった場合\nassert\n でErrorオブジェクトをチェックする\n上記のテストコードでは、Rejectedとなって \nonRejected\n に登録された関数が呼ばれるた\nめテストはパスしますね。\nこのテストで問題になるのは \nmayBeRejected()\n で返されたpromiseオブジェクトが\nFulFilledとなった場合\nに、必ずテストがパスしてしまうという問題が発生します。\nfunction mayBeRejected(){ \n    return Promise.resolve();\n}\nit(\"is bad pattern\"\n, function () {\n    return mayBeRejected().\ncatch(function (error) {\n        assert(error.message === \n\"woo\");\n    });\n});\n返されるpromiseオブジェクトはFulFilledとなる\nこの場合、\ncatch\n で登録した \nonRejected\n の関数はそもそも呼ばれないため、 \nassert\n が\nひとつも呼ばれることなくテストが必ずパスしてしまいます。\nこれを解消しようとして、\n.catch\n の前に \n.then\n を入れて、 \n.then\n が呼ばれたらテストを\n失敗にしたいと考えるかもしれません。\nfunction failTest() { \n    throw new Error(\"Expected promise to be rejected but it was fulfilled\"\n);\n}\nfunction mayBeRejected(){\n    return Promise.resolve();\n}\nit(\"should bad pattern\"\n, function () {\n    return mayBeRejected().then(failTest).\ncatch(function (error) {\n        assert(error.message === \n\"woo\");\n    });\n});\nthrowすることでテストを失敗にしたい\nしかし、この書き方だと\nthen or catch?\nで紹介したように、 \nfailTest\n で投げられたエラー\nが \ncatch\n されてしまいます。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":51},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:52","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n52\nFigure 8. Then Catch flow\nthen\n → \ncatch\n となり、\ncatch\n に渡ってくるErrorオブジェクトは \nAssertionError\n とな\nり、 意図したものとは違うものが渡ってきてしまいます。\nつまり、onRejectedになること\nだけを期待して書かれたテストは、onFulfilledの状態になっ\nてしまうと 常にテストがパスしてしまうという問題を持っていることが分かります。\n両状態を明示して意図しないテストを改善\n上記のエラーオブジェクトのテスト\nを書く場合、 どのようにすれば意図せず通ってしまうテス\nトを無くすことができるでしょうか?\n一番単純な方法としては、以下のようにそれぞれの状態の場合にどうなるのかをテストコー\nドに書く方法です。\nFulFilledとなった場合\n意図したとおりテストが失敗する\nRejectedとなった場合\nassert\n でテストを行える\nつまり、Fulfilled、Rejected 両方の状態について、テストがどうなってほしいかを明示する\n必要があるわけです。\nfunction mayBeRejected() {\n    return Promise.resolve();\n}\nit(\"catch -> then\"\n, function () {\n    // FulFilledとなった場合はテストは失敗する\n    return mayBeRejected().then(failTest, \nfunction (error) {\n        assert(error.message === \n\"woo\");\n    });","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":52},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:53","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n53\n});\nこのように書くことで、FulFilledとなった場合は失敗するテストコードを書くことができます。\nFigure 9. Promise onRejected test\nthen or catch?\nのときは、エラーの見逃しを避けるため、 \n.then(onFulfilled,\nonRejected)\n の第二引数ではなく、\nthen\n → \ncatch\n と分けることを推奨していました。\nしかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしま\nいます。 そのため \n.then(failTest, onRejected)\n と書くことで、どちらの状態になるのか\nを明示してテストを書くことができました。\nまとめ\nMochaのPromiseサポートについてと意図しない挙動となる場合について紹介しました。\n• 通常のコードは \nthen\n → \ncatch\n と分けた方がよい\n◦ エラーハンドリングのため。\nthen or catch?\nを参照\n• テストコードは \nthen\n にまとめた方がよい\n◦ アサーションエラーがテストフレームワークに届くようにするため。\n.then(onFulfilled, onRejected)\n を使うことで、 promiseオブジェクトが\nFulfilled、Rejectedどちらの状態になるかを明示してテストする必要があります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":53},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:54","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n54\nしかし、Rejectedのテストであることを明示するために、以下のように書くのはあまり直感的\nではないと思います。\npromise.then(failTest, \nfunction(error){\n    // assertでerrorをテストする\n});\n次は、Promiseのテストを手助けするヘルパー関数を定義して、 もう少し分かりやすいテス\nトを書くにはどうするべきかについて見ていきましょう。\n意図したテストを書くには\nここでいう意図したテストとは以下のような定義で進めます。\nあるpromiseオブジェクトをテスト対象として\n• Fulfilledされることを期待したテストを書いた時\n◦ Rejectedとなった場合は\nFail\n◦ assertionの結果が一致しなかった場合は\nFail\n• Rejectedされることを期待したテストを書いた時\n◦ Fulfilledとなった場合は\nFail\n◦ assertionの結果が一致しなかった場合は\nFail\n上記のケース(Fail)に該当しなければテストがパスするということですね。\nつまり、ひとつのテストケースにおいて以下のことを書く必要があります。\n• Fulfilled or Rejected どちらを期待するか\n• assertionで渡された値のチェック\n先ほどの \n.then\n を使ったコードはRejectedを期待したテストとなっていますね。\npromise.then(failTest, \nfunction(error){\n    // assertでerrorをテストする\n    assert(error \ninstanceof\n Error);\n});\nどちらの状態になるかを明示する\n意図したテストにするためには、\npromiseの状態\nが Fulfilled or Rejected どちらの状態に\nなって欲しいかを明示する必要があります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":54},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:55","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n55\nしかし、\n.then\n だと引数は省略可能なので、テストが落ちる条件を入れ忘れる可能性もあ\nります。\nそこで、promiseオブジェクトに期待する状態を明示できるヘルパー関数を定義してみま\nしょう。\nライブラリ化したものが \nazu/promise-test-helper\n42\n にありますが、 今\n回はその場で簡単に定義して進めます。\nまずは、先ほどの \n.then\n の例を元にonRejectedを期待してテストできる\nshouldRejected\n というヘルパー関数を作ってみたいと思います。\nshouldRejected-test.js\nvar assert = require(\n'assert');\nfunction shouldRejected(promise) {\n    return {\n        'catch': function (fn) {\n            \nreturn promise.then(\nfunction () {\n                \nthrow new Error('Expected promise to be rejected but it was fulfilled'\n);\n            }, \nfunction (reason) {\n                fn.call(promise, reason);\n            });\n        }\n    };\n}\nit('should be rejected'\n, function () {\n    var promise = Promise.reject(\nnew Error('human error'\n));\n    return shouldRejected(promise).\ncatch(function (error) {\n        assert(error.message === \n'human error'\n);\n    });\n});\nshouldRejected\n にpromiseオブジェクトを渡すと、\ncatch\n というメソッドをもつオブジェ\nクトを返します。\nこの \ncatch\n にはonRejectedで書くものと全く同じ使い方ができるので、 \ncatch\n の中に\nassertionによるテストを書けるようになっています。\nshouldRejected\n で囲む以外は、通常のpromiseの処理と似た感じになるので以下のよう\nになります。\n42\n https://github.com/azu/promise-test-helper","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":55},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:56","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n56\n1.\nshouldRejected\n にテスト対象のpromiseオブジェクトを渡す\n2. 返ってきたオブジェクトの \ncatch\n メソッドでonRejectedの処理を書く\n3. onRejectedにassertionによるテストを書く\nshouldRejected\n を使った場合、Fulfilledが呼ばれるとエラーをthrowしてテストが失敗\nするようになっています。\npromise.then(failTest, \nfunction(error){\n    assert(error.message === \n'human error'\n);\n});\n// == ほぼ同様の意味\nshouldRejected(promise).\ncatch(function (error) {\n    assert(error.message === \n'human error'\n);\n});\nshouldRejected\n のようなヘルパー関数を使うことで、テストコードが少し直感的になりまし\nたね。\nFigure 10. Promise onRejected test\n同様に、promiseオブジェクトがFulfilledになることを期待する \nshouldFulfilled\n も書い\nてみましょう。\nshouldFulfilled-test.js","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":56},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:57","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n57\nvar assert = require(\n'assert');\nfunction shouldFulfilled(promise) {\n    return {\n        'then': function (fn) {\n            \nreturn promise.then(\nfunction (value) {\n                fn.call(promise, value);\n            }, \nfunction (reason) {\n                \nthrow reason;\n            });\n        }\n    };\n}\nit('should be fulfilled'\n, function () {\n    var promise = Promise.resolve(\n'value');\n    return shouldFulfilled(promise).then(\nfunction (value) {\n        assert(value === \n'value');\n    });\n});\nshouldRejected-test.js\nと基本は同じで、返すオブジェクトの \ncatch\n が \nthen\n になって中\n身が逆転しただけですね。\nまとめ\nPromiseで意図したテストを書くためにはどうするか、またそれを補助するヘルパー関数に\nついて学びました。\n今回書いた \nshouldFulfilled\n と \nshouldRejected\n はライブラリとして\n利用できるようになっています。\nazu/promise-test-helper\n43\n からダウンロードすることが出来ます。\nまた、今回のヘルパー関数は\nMochaのPromiseサポート\nを前提とした書き方なので、 \ndone\nを使ったテスト\nでは利用しにくいと思います。\nテストフレームワークのPromiseサポートを使うか、\ndone\n のようにコールバックスタイルの\nテストを使うかは、 人それぞれのスタイルの問題であるためそこまではっきりした優劣はな\nいと思います。\nたとえば、 \nCoffeeScript\n44\nでテストを書いたりすると、 CoffeeScriptには暗黙のreturnがあ\nるので、\ndone\n を使ったほうが分かりやすいかもしれません。\n43\n https://github.com/azu/promise-test-helper\n44\n http://coffeescript.org/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":57},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:58","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n58\nPromiseのテストは普通に非同期関数のテスト以上に落とし穴があるため、 どのスタイル\nを取るかは自由ですが、一貫性を持った書き方をすることが大切だといえます。\nChapter.4 - Advanced\nこの章では、これまでに学んだことの応用や発展した内容について学んでいきます。\nPromiseのライブラリ\nこのセクションでは、ブラウザが実装しているPromiseではなく、サードパーティにより作ら\nれた Promise互換のライブラリについて紹介していきたいと思います。\nなぜライブラリが必要か?\nなぜライブラリが必要か?という疑問に関する多くの答えとしては、 その実行環境で「\nES6\nPromises\nが実装されていないから」というのがまず出てくるでしょう。\nPromiseのライブラリを探すときに、一つ目印になる言葉として\nPromises/A+互換\nがありま\nす。\nPromises/A+\nというのは\nES6 Promises\nの前身となったもので、 Promiseの \nthen\n について\n取り決めたコミュニティベースの仕様です。\nPromises/A+互換と書かれていた場合は \nthen\n についての動作は互換性があり、 多くの\n場合はそれに加えて \nPromise.all\n や \ncatch\n 等と同様の機能が実装されています。\nしかし、Promises/A+は \nPromise#then\n についてのみの仕様となっているため、 他の機能\nは実装されていても名前が異なる場合があります。\nまた、\nthen\n というメソッドに互換性があるということは、\nThenable\nであるということなので、\nPromise.resolve\nを使い、ES6のPromiseで定められたpromiseオブジェクトに変換するこ\nとができます。\nES6のPromiseで定められたpromiseオブジェクトというのは、 \ncatch\nというメソッドが使えたり、\nPromise.all\n で扱う際に問題が起こらない\nということです。\nPolyfillとライブラリ\nここでは、大きくわけて2種類のライブラリを紹介したいと思います。\n一つはPolyfillと呼ばれる種類のライブラリで、 もう一つは、\nPromises/A+互換\nに加えて、独\n自の拡張をもったライブラリです。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":58},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:59","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n59\nPromiseのライブラリは星の数ほどあるので、ここで紹介するのは極々\n一部です。\nPolyfill\nPolyfillライブラリは読み込むことで、IE10等まだPromiseが実装されていないブラウザ等\nでも、 Promiseと同等の機能を同じメソッド名で提供してくれるライブラリのことです。\nつまり、Polyfillを読みこめばこの書籍で紹介しているコードは、 Promiseがサポートされて\nない環境でも実行できるようになります。\njakearchibald/es6-promise\n45\nES6 Promisesと互換性を持ったPolyfillライブラリです。 \nRSVP.js\n46\n という Promises/\nA+互換ライブラリがベースとなっており、 これのサブセットとしてES6 PromisesのAPI\nだけが実装されているライブラリです。\ngetify/native-promise-only\n47\nES6 Promisesのpolyfillとなることを目的としたライブラリです。 ES6 Promisesの仕様\nに厳密に沿うように作られており、仕様にない機能は入れないようになっています。 実\n行環境にネイティブのPromiseがある場合はそちらを優先します。 この書籍ではこの\nPolyfillを読み込み、サンプルコードを動かしています\nyahoo/ypromise\n48\nYUI\n49\n の一部としても利用されているES6 Promisesと互換性を持ったPolyfillライブラ\nリです。\nPromise拡張ライブラリ\nPromiseを仕様どおりに実装したものに加えて独自のメソッド等を提供してくれるライブラ\nリです。\nPromise拡張ライブラリは本当に沢山ありますが、以下の2つの著名なライブラリを紹介し\nます。\n45\n https://github.com/jakearchibald/es6-promise\n46\n https://github.com/tildeio/rsvp.js\n47\n https://github.com/getify/native-promise-only/\n48\n https://github.com/yahoo/ypromise\n49\n http://yuilibrary.com/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":59},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:60","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n60\nkriskowal/q\n50\nQ\n と呼ばれるPromisesやDeferredsを実装したライブラリです。 2009年から開発され\nており、Node.js向けのファイルIOのAPIを提供する \nQ-IO\n51\n 等、 多くの状況で使える機\n能が用意されているライブラリです。\npetkaantonov/bluebird\n52\nPromise互換に加えて、キャンセルできるPromiseや進行度を取得できるPromise、エ\nラーハンドリングの拡張検出等、 多くの拡張を持っており、またパフォーマンスにも気を\n配った実装がされているライブラリです。\nQ と Bluebird どちらのライブラリもブラウザでも動作する他、APIリファレンスが充実してい\nるのも特徴的です。\n• API Reference · kriskowal/q Wiki\n53\nQのドキュメントにはjQueryがもつDeferredの仕組みとどのように違うのか、移行する場合\nの対応メソッドについても \nComing from jQuery\n54\n にまとめられています。\n• bluebird/API.md at master · petkaantonov/bluebird\n55\nBluebirdではPromiseを使った豊富な実装例に加えて、エラーが起きた時の対処法や\nPromiseのアンチパターン\n56\n について書かれています。\nどちらのドキュメントも優れているため、このライブラリを使ってない場合でも読んでおくと\n参考になることが多いと思います。\nまとめ\nこのセクションではPromiseのライブラリとしてPolyfillと拡張ライブラリを紹介しました。\nPromiseのライブラリは多種多様であるため、どれを使用するかは好みの問題といえるで\nしょう。\nしかし、PromiseはPromises/A+ または ES6 Promisesという共通のインターフェースを\n持っているため、 そのライブラリで書かれているコードや独自の拡張などは、他のライブラリ\nを利用している時でも参考になるケースは多いでしょう。\n50\n https://github.com/kriskowal/q\n51\n https://github.com/kriskowal/q-io\n52\n https://github.com/petkaantonov/bluebird\n53\n https://github.com/kriskowal/q/wiki/API-Reference\n54\n https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n55\n https://github.com/petkaantonov/bluebird/blob/master/API.md\n56\n https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":60},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:61","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n61\nそのようなPromiseの共通の概念を学び、応用できるようになるのがこの書籍の目的の一\nつです。\nPromise.resolveとThenable\n第二章のPromise.resolve\nにて、\nPromise.resolve\n の大きな特徴の一つとしてthenable\nなオブジェクトを変換する機能について紹介しました。\nこのセクションでは、thenableなオブジェクトからpromiseオブジェクトに変換してどのよう\nに利用するかについて学びたいと思います。\nWeb Notificationsをthenableにする\nWeb Notifications\n57\nという デスクトップ通知を行うAPIを例に考えてみます。\nWeb Notifications APIについて詳しくは以下を参照して下さい。\n• Web Notifications の使用 - WebAPI | MDN\n58\n• Can I use Web Notifications\n59\nWeb Notifications APIについて簡単に解説すると、以下のように \nnew Notification\n を\nすることで通知メッセージが表示できます。\nnew Notification(\n\"Hi!\");\nしかし、通知を行うためには、\nnew Notification\n をする前にユーザーに許可を取る必要\nがあります。\n57\n https://developer.mozilla.org/ja/docs/Web/API/notification\n58\n https://developer.mozilla.org/ja/docs/WebAPI/Using_Web_Notifications\n59\n http://caniuse.com/notifications","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":61},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:62","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n62\nFigure 11. Notificationの許可ダイアログ\nこの許可ダイアログで選択した結果は、\nNotification.permission\n に入りますが、 値は許\n可(\"granted\")か不許可(\"denied\")の2種類です。\nNotificationのダイアログの選択肢は、 Firefoxだと許可、不許可に加\nえて 永続 か セッション限り\n の組み合わせがありますが、値自体は同じ\nです。\n許可ダイアログは \nNotification.requestPermission()\n を実行すると表示され、 ユー\nザーが選択した結果がコールバック関数の \nstatus\n に渡されます。\nコールバック関数を受け付けることから分かるように、この許可、不許可は非同期的に行わ\nれます。\nNotification.requestPermission(\nfunction (status) {\n    // statusに\"granted\" or \"denied\"が入る\n    console.log(status);\n});\n通知を行うまでの流れをまとめると以下のようになります。\n• ユーザーに通知の許可を受け付ける非同期処理がある\n• 許可がある場合は \nnew Notification\n で通知を表示できる\n◦ すでに許可済みのケース\n◦ その場で許可を貰うケース\n• 許可がない場合は何もしない","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":62},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:63","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n63\nいくつかのパターンが出ますが、最終的には許可か不許可になるので、以下の2パターンに\nまとめることができます。\n許可時(\"granted\")\nnew Notification\n で通知を作成\n不許可時(\"denied\")\n何もしない\nこの2パターンはどこかで見たことがありますね。 そう、PromiseのFulfilled または\nRejected となった時の動作で書くことが出来そうな気がします。\nresolve(成功)した時 == 許可時(\"granted\")\nonFulfilled\n が呼ばれる\nreject(失敗)した時 == 不許可時(\"denied\")\nonRejected\n が呼ばれる\nPromiseで書けそうな目処が見えた所で、まずはコールバックスタイルで書いてみましょ\nう。\nWeb Notification ラッパー\nまずは先ほどのWeb Notification APIのラッパー関数をコールバックスタイルで書くと次\nのように書くことができます。\nnotification-callback.js\nfunction notifyMessage(message, options, callback) {\n    if (typeof Notification === \n'undefined'\n) {\n        callback(\nnew Error('doesn\\'t support Notification API'\n));\n        return;\n    }\n    if (Notification.permission === \n'granted'\n) {\n        var notification = \nnew Notification(message, options);\n        callback(null, notification);\n    } else {\n        Notification.requestPermission(\nfunction (status) {\n            \nif (Notification.permission !== status) {\n                Notification.permission = status;\n            }\n            \nif (status === \n'granted'\n) {\n                \nvar notification = \nnew Notification(message, options);\n                callback(null, notification);\n            } \nelse {\n                callback(\nnew Error('user denied'\n));","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":63},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:64","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n64\n            }\n        });\n    }\n}\n// 実行例\n// 第二引数は `Notification` に渡すオプションオブジェクト\nnotifyMessage(\n\"Hi!\", {}, function (error, notification) {\n    if(error){\n        console.error(error);\n        return;\n    }\n    console.log(notification);\n// 通知のオブジェクト\n});\nコールバックスタイルでは、許可がない場合は \nerror\n に値が入り、 許可がある場合は通\n知が行われて \nnotification\n に値が入ってくるという感じにしました。\nコールバック関数はエラーとnotificationオブジェクトを受け取る\nfunction callback(error, notification){\n}\n次に、このコールバックスタイルの関数をPromiseとして使える関数を書いてみたいと思い\nます。\nNotifications API\n60\nの最新仕様では、 コールバック関数を渡さなかっ\nた場合にpromiseオブジェクトを返すようになっています。 そのため、こ\nこから先の話は最新の仕様ではもっとシンプルに書ける可能性がありま\nす。\nしかし、古いNotification APIの仕様では、コールバック関数のみしか\n扱う方法がありませんでした。 ここではコールバック関数のみしか扱え\nるNotification APIを前提にしています。\nWeb Notification as Promise\n先ほどのコールバックスタイルの \nnotifyMessage\n とは別に、 promiseオブジェクトを返す\nnotifyMessageAsPromise\n を定義してみます。\nnotification-as-promise.js\nfunction notifyMessage(message, options, callback) {\n60\n https://notifications.spec.whatwg.org/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":64},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:65","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n65\n    if (typeof Notification === \n'undefined'\n) {\n        callback(\nnew Error('doesn\\'t support Notification API'\n));\n        return;\n    }\n    if (Notification.permission === \n'granted'\n) {\n        var notification = \nnew Notification(message, options);\n        callback(null, notification);\n    } else {\n        Notification.requestPermission(\nfunction (status) {\n            \nif (Notification.permission !== status) {\n                Notification.permission = status;\n            }\n            \nif (status === \n'granted'\n) {\n                \nvar notification = \nnew Notification(message, options);\n                callback(null, notification);\n            } \nelse {\n                callback(\nnew Error('user denied'\n));\n            }\n        });\n    }\n}\nfunction notifyMessageAsPromise(message, options) {\n    return new Promise(\nfunction (resolve, reject) {\n        notifyMessage(message, options, \nfunction (error, notification) {\n            \nif (error) {\n                reject(error);\n            } \nelse {\n                resolve(notification);\n            }\n        });\n    });\n}\n// 実行例\nnotifyMessageAsPromise(\n\"Hi!\").then(function (notification) {\n    console.log(notification);\n// 通知のオブジェクト\n}).catch(function(error){\n    console.error(error);\n});\n上記の実行例では、許可がある場合 \n\"Hi!\"\n という通知が表示されます。\n許可されている場合は \n.then\n が呼ばれ、 不許可となった場合は \n.catch\n が呼ばれます。\nブラウザはWeb Notifications APIの状態をサイトごとに許可状態を記\n憶できるため、 実際には以下の4つのパターンが存在します。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":65},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:66","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n66\n既に許可されている\n.then\n が呼ばれる\n許可ダイアログがでて許可された\n.then\n が呼ばれる\n既に不許可となっている\n.catch\n が呼ばれる\n許可ダイアログが出て不許可となった\n.catch\n が呼ばれる\nつまり、Web Notifications APIをそのまま扱うと、4つのパターンについ\nて書かないといけませんが、 それを2パターンにできるラッパーを書くと\n扱いやすくなります。\n上記のnotification-as-promise.js\nは、とても便利そうですが実際に使うときには \nPromise\nをサポートしてない環境では使えない\nという問題があります。\nnotification-as-promise.js\nのようなPromiseスタイルで使えるライブラリを作る場合、 ラ\nイブラリ作成者には以下の選択肢があると思います。\nPromiseが使える環境を前提とする\n• 利用者に \nPromise\n があることを保証してもらう\n• Promiseをサポートしてない環境では動かないことにする\nライブラリ自体に \nPromise\n の実装を入れてしまう\n• ライブラリ自体にPromiseの実装を取り込む\n• 例) localForage\n61\nコールバックでも \nPromise\n でも使えるようにする\n• 利用者がどちらを使うかを選択できるようにする\n• Thenableを返せるようにする\nnotification-as-promise.js\nは \nPromise\n があることを前提としたような書き方です。\n本題に戻り\nThenable\nはここでいう\nコールバックでも \nPromise\n でも使えるようにする\nという\nことを 実現するのに役立つ概念です。\n61\n https://github.com/mozilla/localForage","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":66},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:67","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n67\nWeb Notifications As Thenable\nthenable\nというのは \n.then\n というメソッドを持ってるオブジェクトのことを言いましたね。\n次はnotification-callback.js\nに \nthenable\n を返すメソッドを追加してみましょう。\nnotification-thenable.js\nfunction notifyMessage(message, options, callback) {\n    if (typeof Notification === \n'undefined'\n) {\n        callback(\nnew Error('doesn\\'t support Notification API'\n));\n        return;\n    }\n    if (Notification.permission === \n'granted'\n) {\n        var notification = \nnew Notification(message, options);\n        callback(null, notification);\n    } else {\n        Notification.requestPermission(\nfunction (status) {\n            \nif (Notification.permission !== status) {\n                Notification.permission = status;\n            }\n            \nif (status === \n'granted'\n) {\n                \nvar notification = \nnew Notification(message, options);\n                callback(null, notification);\n            } \nelse {\n                callback(\nnew Error('user denied'\n));\n            }\n        });\n    }\n}\n// `thenable` を返す\nfunction notifyMessageAsThenable(message, options) {\n    return {\n        'then': function (resolve, reject) {\n            notifyMessage(message, options, \nfunction (error, notification) {\n                \nif (error) {\n                    reject(error);\n                } \nelse {\n                    resolve(notification);\n                }\n            });\n        }\n    };\n}\n// 実行例\nPromise.resolve(notifyMessageAsThenable(\n\"message\"\n)).then(function (notification) {\n    console.log(notification);\n// 通知のオブジェクト","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":67},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:68","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n68\n}).catch(function(error){\n    console.error(error);\n});\nnotification-thenable.js\n には \nnotifyMessageAsThenable\n というそのままのメソッドを追\n加してみました。 返すオブジェクトには \nthen\n というメソッドがあります。\nthen\n メソッドの仮引数には \nnew Promise(function (resolve, reject){})\n と同じよう\nに、 解決した時に呼ぶ \nresolve\n と、棄却した時に呼ぶ \nreject\n が渡ります。\nthen\n メソッドがやっている中身は\nnotification-as-promise.js\nの\nnotifyMessageAsPromise\n と同じですね。\nこの \nthenable\n を \nPromise.resolve(thenable)\n を使いpromiseオブジェクトにしてから、\nPromiseとして利用していることが分かりますね。\nPromise.resolve(notifyMessageAsThenable(\n\"message\"\n)).then(function (notification) {\n    console.log(notification);\n// 通知のオブジェクト\n}).catch(function(error){\n    console.error(error);\n});\nThenableを使った\nnotification-thenable.js\nとPromiseに依存した\nnotification-as-\npromise.js\nは、 非常に似た使い方ができることがわかります。\nnotification-thenable.js\nにはnotification-as-promise.js\nと比べた時に、次のような違い\nがあります。\n• ライブラリ側に \nPromise\n 実装そのものはでてこない\n◦ 利用者が \nPromise.resolve(thenable)\n を使い \nPromise\n の実装を与える\n• Promiseとして使う時に \nPromise.resolve(thenable)\n と一枚挟む必要がある\nThenable\nオブジェクトを利用することで、 既存のコールバックスタイルとPromiseスタイ\nルの中間的な実装をすることができました。\nまとめ\nこのセクションではThenableとは何かやThenableを \nPromise.resolve(thenable)\n を\n使って、 promiseオブジェクトとして利用する方法について学びました。\nCallback\n—Thenable\n—Promise","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":68},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:69","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n69\nThenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、 ライ\nブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。\nThenable自体は \nPromise\n という機能に依存してはいませんが、Promise以外からの利用\n方法は特にないため、 間接的にはPromiseに依存しています。\nまた、使うためには利用者が \nPromise.resolve(thenable)\n について理解している必要が\nあるため、 ライブラリの公開APIとしては難しい部分があります。 Thenable自体は公開API\nより、内部的に使われてるケースが多いでしょう。\n非同期処理を行うライブラリを書く際には、まずはコールバックスタイ\nルの関数を書いて公開APIとすることをオススメします。\nNode.jsのCore moduleがこの方法をとっているように、ライブラリが提\n供するのは基本となるコールバックスタイル関数としたほうが、 利用者\nがPromiseやGenerator等の好きな方法で実装ができるためです。\n最初からPromiseで利用することを目的としたライブラリや、その機能\nがPromiseに依存している場合は、 promiseオブジェクトを返す関数を\n公開APIとしても問題ないと思います。\nThenableの使われているところ\nでは、どのような場面でThenableは使われてるのでしょうか?\n恐らく、一番多く使われている所は\nPromiseのライブラリ\n間での相互変換でしょう。\nたとえば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、 \nES6\nPromises\nのpromiseオブジェクトが持っていないメソッドを持っています。 Q promiseオ\nブジェクトには \npromise.finally(callback)\n や \npromise.nodeify(callback)\n などのメ\nソッドが用意されてます。\nES6 PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われ\nるのが、 まさにこのThenableです。\nthenableを使ってQ promiseオブジェクトにする\nvar Q = require(\n\"Q\");\n// このpromiseオブジェクトはES6のもの\nvar promise = \nnew Promise(\nfunction(resolve){\n    resolve(\n1);\n});\n// Q promiseオブジェクトに変換する\nQ(promise).then(\nfunction(value){","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":69},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:70","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n70\n    console.log(value);\n}).finally(function(){ \n    console.log(\n\"finally\"\n);\n});\nQ promiseオブジェクトとなったため \nfinally\n が利用できる\n最初に作成したpromiseオブジェクトは \nthen\n というメソッドを持っているので、もちろん\nThenableです。 \nQ(thenable)\n とすることでThenableなオブジェクトをQ promiseオブ\nジェクトへと変換することができます。\nこれは、\nPromise.resolve(thenable)\n と同じ仕組みといえるので、もちろん逆も可能で\nす。\nこのように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っ\nていますが、 Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブ\nPromiseも含めて)で相互にpromiseオブジェクトを変換することができます。\nこのようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にす\nる機会はないかもしれません。 しかしこのThenableはPromiseでも大事な概念であるた\nめ知っておくとよいでしょう。\nthrowしないで、rejectしよう\nPromiseコンストラクタや、\nthen\n で実行される関数は基本的に、 \ntry...catch\n で囲まれて\nるような状態なので、その中で \nthrow\n してもプログラムは終了しません。\nPromiseの中で \nthrow\n による例外が発生した場合は自動的に \ntry...catch\n され、その\npromiseオブジェクトはRejectedとなります。\nvar promise = \nnew Promise(\nfunction(resolve, reject){\n    throw new Error(\"message\"\n);\n});\npromise.catch(function(error){\n    console.error(error);\n// => \"message\"\n});\nこのように書いても動作的には問題ありませんが、\npromiseオブジェクトの状態\nをRejected\nにしたい場合は \nreject\n という与えられた関数を呼び出すのが一般的です。\n先ほどのコードは以下のように書くことができます。\nvar promise = \nnew Promise(\nfunction(resolve, reject){\n    reject(\nnew Error(\"message\"\n));","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":70},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:71","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n71\n});\npromise.catch(function(error){\n    console.error(error);\n// => \"message\"\n})\nthrow\n が \nreject\n に変わったと考えれば、\nreject\n にはErrorオブジェクトを渡すべきであ\nるということが分かりやすいかもしれません。\nなぜrejectした方がいいのか\nそもそも、promiseオブジェクトの状態をRejectedにしたい場合に、 なぜ \nthrow\n ではなく\nreject\n した方がいいのでしょうか?\nひとつは \nthrow\n が意図したものか、それとも本当に\n例外なのか区別が難しくなってしまう\nことにあります。\nたとえば、Chrome等の開発者ツールには例外が発生した時に、 デバッガーが自動で\nbreakする機能が用意されています。\nFigure 12. Pause On Caught Exceptions\nこの機能を有効にしていた場合、以下のように \nthrow\n するとbreakしてしまいます。\nvar promise = \nnew Promise(\nfunction(resolve, reject){\n    throw new Error(\"message\"\n);\n});\n本来デバッグとは関係ない場所でbreakしてしまうため、 Promiseの中で \nthrow\n している\n箇所があると、この機能が殆ど使い物にならなくなってしまうでしょう。\nthenでもrejectする\nPromiseコンストラクタの中では \nreject\n という関数そのものがあるので、 \nthrow\n を使わ\nないでpromiseオブジェクトをRejectedにするのは簡単でした。\nでは、次のような \nthen\n の中でrejectしたい場合はどうすればいいでしょうか?\nvar promise = Promise.resolve();\npromise.then(\nfunction (value) {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":71},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:72","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n72\n    setTimeout(\nfunction () {\n        // 一定時間経って終わらなかったらrejectしたい - 2\n    }, 1000);\n    // 時間がかかる処理 - 1\n    somethingHardWork();\n}).catch(function (error) {\n    // タイムアウトエラー - 3\n});\nいわゆるタイムアウト処理ですが、\nthen\n の中で \nreject\n を呼びたいと思った場合に、 コー\nルバック関数に渡ってくるのは一つ前のpromiseオブジェクトの返した値だけなので困って\nしまいます。\nPromiseを使ったタイムアウト処理の実装については \nPromise.raceと\ndelayによるXHRのキャンセル\n にて詳しく解説しています。\nここで少し \nthen\n の挙動について思い出してみましょう。\nthen\n に登録するコールバック関数では値を \nreturn\n することができます。 このときreturn\nした値が、次の \nthen\n や \ncatch\n のコールバックに渡されます。\nまた、returnするものはプリミティブな値に限らずオブジェクト、そしてpromiseオブジェクト\nも返すことができます。\nこのとき、returnしたものがpromiseオブジェクトである場合、そのpromiseオブジェクトの\n状態によって、 次の \nthen\n に登録されたonFulfilledとonRejectedのうち、どちらが呼ばれ\nるかを決めることができます。\nvar promise = Promise.resolve();\npromise.then(\nfunction () {\n    var retPromise = \nnew Promise(\nfunction (resolve, reject) {\n        // resolve or reject で onFulfilled or onRejected どちらを呼ぶか決まる\n    });\n    return retPromise;\n}).then(onFulfilled, onRejected);\n次に呼び出されるthenのコールバックはpromiseオブジェクトの状態によって決定さ\nれる\nつまり、この \nretPromise\n がRejectedになった場合は、\nonRejected\n が呼び出されるので、\nthrow\n を使わなくても \nthen\n の中でrejectすることができます。\nvar onRejected = console.error.bind(console);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":72},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:73","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n73\nvar promise = Promise.resolve();\npromise.then(\nfunction () {\n    var retPromise = \nnew Promise(\nfunction (resolve, reject) {\n       reject(\nnew Error(\"this promise is rejected\"\n));\n    });\n    return retPromise;\n}).catch(onRejected);\nこれは、\nthe section called “Promise.reject”\n を使うことでもっと簡潔に書くことができま\nす。\nvar onRejected = console.error.bind(console);\nvar promise = Promise.resolve();\npromise.then(\nfunction () {\n    return Promise.reject(\nnew Error(\"this promise is rejected\"\n));\n}).catch(onRejected);\nまとめ\nこのセクションでは、以下のことについて学びました。\n•\nthrow\n ではなくて \nreject\n した方が安全\n•\nthen\n の中でも \nreject\n する方法\n中々使いどころが多くはないかもしれませんが、安易に \nthrow\n してしまうよりはいいことが\n多いので、 覚えておくといいでしょう。\nこれを利用した具体的な例としては、 \nPromise.raceとdelayによるXHRのキャンセル\n で解\n説しています。\nDeferredとPromise\nこのセクションではDeferredとPromiseの関係について簡潔に学んでいきます。\nDeferredとは何か\nDeferredという単語はPromiseと同じコンテキストで聞いたことがあるかもしれません。 有\n名な所だと \njQuery.Deferred\n62\n や JSDeferred\n63\n 等があげられるでしょう。\n62\n http://api.jquery.com/category/deferred-object/\n63\n http://cho45.stfuawsc.com/jsdeferred/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":73},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:74","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n74\nDeferredはPromiseと違い、共通の仕様があるわけではなく、各ライブラリがそのような目\n的の実装をそう呼んでいます。\n今回は jQuery.Deferred\n64\n のようなDeferredの実装を中心にして話を進めます。\nDeferredとPromiseの関係\nDeferredとPromiseの関係を簡単に書くと以下のようになります。\n• Deferred は Promiseを持っている\n• Deferred は Promiseの状態を操作する特権的なメソッドを持っている\n64\n http://api.jquery.com/category/deferred-object/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":74},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:75","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n75\nFigure 13. DeferredとPromise\nこの図を見ると分かりますが、DeferredとPromiseは比べるような関係ではなく、 Deferred\nがPromiseを内蔵しているような関係になっていることが分かります。\njQuery.Deferredの構造を簡略化したものです。もちろんPromiseを持\nたないDeferredの実装もあります。\n図だけだと分かりにくいので、実際にPromiseを使ってDeferredを実装してみましょう。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":75},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:76","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n76\nDeferred top on Promise\nPromiseの上にDeferredを実装した例です。\ndeferred.js\nfunction Deferred() {\n    this.promise = \nnew Promise(\nfunction (resolve, reject) {\n        this._resolve = resolve;\n        this._reject = reject;\n    }.bind(\nthis));\n}\nDeferred.\nprototype\n.resolve = \nfunction (value) {\n    this._resolve(value);\n};\nDeferred.\nprototype\n.reject = \nfunction (reason) {\n    this._reject(reason);\n};\n以前Promiseを使って実装した\ngetURL\nをこのDeferredで実装しなおしてみます。\nxhr-deferred.js\nfunction Deferred() {\n    this.promise = \nnew Promise(\nfunction (resolve, reject) {\n        this._resolve = resolve;\n        this._reject = reject;\n    }.bind(\nthis));\n}\nDeferred.\nprototype\n.resolve = \nfunction (value) {\n    this._resolve(value);\n};\nDeferred.\nprototype\n.reject = \nfunction (reason) {\n    this._reject(reason);\n};\nfunction getURL(URL) {\n    var deferred = \nnew Deferred();\n    var req = new XMLHttpRequest();\n    req.open(\n'GET', URL, true);\n    req.onload = \nfunction () {\n        if (req.status === \n200) {\n            deferred.resolve(req.responseText);\n        } \nelse {\n            deferred.reject(\nnew Error(req.statusText));\n        }","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":76},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:77","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n77\n    };\n    req.onerror = \nfunction () {\n        deferred.reject(\nnew Error(req.statusText));\n    };\n    req.send();\n    return deferred.promise;\n}\n// 実行例\nvar URL = \"http://httpbin.org/get\"\n;\ngetURL(URL).then(\nfunction onFulfilled(value){\n    console.log(value);\n}).catch(console.error.bind(console));\nPromiseの状態を操作する特権的なメソッドというのは、 promiseオブジェクトの状態を\nresolve、rejectすることができるメソッドで、 通常のPromiseだとコンストラクタで渡した関\n数の中でしか操作することができません。\n通常のPromiseで実装したものと見比べていきたいと思います。\nxhr-promise.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\n// 実行例\nvar URL = \"http://httpbin.org/get\"\n;\ngetURL(URL).then(\nfunction onFulfilled(value){\n    console.log(value);\n}).catch(console.error.bind(console));\n2つの \ngetURL\n を見比べて見ると以下のような違いがあることが分かります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":77},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:78","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n78\n• Deferred の場合は全体がPromiseで囲まれていない\n◦ 関数で囲んでないため、1段ネストが減っている\n◦ Promiseコンストラクタの中で処理が行われていないため、自動的に例外をキャッ\nチしない\n逆に以下の部分は同じことをやっています。\n• 全体的な処理の流れ\n◦\nresolve\n、\nreject\n を呼ぶタイミング\n• 関数はpromiseオブジェクトを返す\nこのDeferredはPromiseを持っているため、大きな流れは同じですが、 Deferredには特権\n的なメソッドを持っていることや自分で流れを制御する裁量が大きいことが分かります。\nたとえば、Promiseの場合はコンストラクタの中に処理を書くことが通例なので、\nresolve\n、\nreject\n を呼ぶタイミングが大体みて分かります。\nnew Promise(\nfunction (resolve, reject){\n    // この中に解決する処理を書く\n});\n一方Deferredの場合は、関数的なまとまりはないのでdeferredオブジェクトを作ったところ\nから、 任意のタイミングで \nresolve\n、\nreject\n を呼ぶ感じになります。\nvar deferred = \nnew Deferred();\n// どこかのタイミングでdeferred.resolve or deferred.rejectを呼ぶ\nこのように小さな\nDeferred\nの実装ですが\nPromise\nとの違いが出ていることが分かります。\nこれは、Promiseが値を抽象化したオブジェクトなのに対して、 Deferredはまだ処理が終\nわってないという状態や操作を抽象化したオブジェクトである違いがでているのかもしれま\nせん。\n言い換えると、 Promiseはこの値は将来的に正常な値(FulFilled)か異常な値(Rejected)\nが入るというものを予約したオブジェクトなのに対して、 Deferredはまだ処理が終わってな\nいということを表すオブジェクトで、 処理が終わった時の結果を取得する機構(Promise)に\n加えて処理を進める機構をもったものといえるかもしれません。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":78},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:79","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n79\nより詳しくDeferredについて知りたい人は以下を参照するといいでしょう。\n• Promise & Deferred objects in JavaScript Pt.1: Theory and Semantics.\n65\n• Twisted 入門 — Twisted Intro\n66\n• Promise anti patterns · petkaantonov/bluebird Wiki\n67\n• Coming from jQuery · kriskowal/q Wiki\n68\nDeferredはPythonの \nTwisted\n69\n というフレームワークが最初に\n定義した概念です。 JavaScriptへは \nMochiKit.Async\n70\n 、 dojo/\nDeferred\n71\n 等のライブラリがその概念を持ってきたと言われています。\nPromise.raceとdelayによるXHRのキャンセル\nこのセクションでは\n2章で紹介した\nPromise.race\nのユースケースとして、 Promise.raceを\n使ったタイムアウトの実装を学んでいきます。\nもちろんXHRは \ntimeout\n72\n プロパティを持っているので、 これを利用すると簡単にできま\nすが、複数のXHRを束ねたタイムアウトや他の機能でも応用が効くため、 分かりやすい非\n同期処理であるXHRにおけるタイムアウトによるキャンセルを例にしています。\nPromiseで一定時間待つ\nまずはタイムアウトをPromiseでどう実現するかを見ていきたいと思います。\nタイムアウトというのは一定時間経ったら何かするという処理なので、\nsetTimeout\n を使え\nばいいことが分かりますね。\nまずは単純に \nsetTimeout\n をPromiseでラップした関数を作ってみましょう。\ndelayPromise.js\n65\n http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-\nsemantics\n66\n http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html\n67\n https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern\n68\n https://github.com/kriskowal/q/wiki/Coming-from-jQuery\n69\n https://twistedmatrix.com/trac/\n70\n http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html\n71\n http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html\n72\n https://developer.mozilla.org/ja/docs/XMLHttpRequest/\nSynchronous_and_Asynchronous_Requests","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":79},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:80","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n80\nfunction delayPromise(ms) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\ndelayPromise(ms)\n は引数で指定したミリ秒後にonFulfilledを呼ぶpromiseオブジェクト\nを返すので、 通常の \nsetTimeout\n を直接使ったものと比較すると以下のように書けるだけ\nの違いです。\nsetTimeout(\nfunction () {\n    alert(\n\"100ms 経ったよ!\"\n);\n}, 100);\n// == ほぼ同様の動作\ndelayPromise(\n100).then(function () {\n    alert(\n\"100ms 経ったよ!\"\n);\n});\nここでは\npromiseオブジェクト\nであるということが重要になってくるので覚えておいて下さ\nい。\nPromise.raceでタイムアウト\nPromise.race\n について簡単に振り返ると、 以下のようにどれか一つでもpromiseオブ\nジェクトが解決状態になったら次の処理を実行する静的メソッドでした。\nvar winnerPromise = \nnew Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            console.log(\n'this is winner'\n);\n            resolve(\n'this is winner'\n);\n        }, \n4);\n    });\nvar loserPromise = \nnew Promise(\nfunction (resolve) {\n        setTimeout(\nfunction () {\n            console.log(\n'this is loser'\n);\n            resolve(\n'this is loser'\n);\n        }, \n1000);\n    });\n// 一番最初のものがresolveされた時点で終了\nPromise.race([winnerPromise, loserPromise]).then(\nfunction (value) {\n    console.log(value);    \n// => 'this is winner'\n});","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":80},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:81","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n81\n先ほどの\ndelayPromise\nと別のpromiseオブジェクトを、 \nPromise.race\n によって競争させ\nることで簡単にタイムアウトが実装できます。\nsimple-timeout-promise.js\nfunction delayPromise(ms) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\nfunction timeoutPromise(promise, ms) {\n    var timeout = delayPromise(ms).then(\nfunction () {\n            \nthrow new Error('Operation timed out after '\n + ms + ' ms');\n        });\n    return Promise.race([promise, timeout]);\n}\ntimeoutPromise(比較対象のpromise, ms)\n はタイムアウト処理を入れたい promiseオ\nブジェクトとタイムアウトの時間を受け取り、\nPromise.race\n により競争させたpromiseオ\nブジェクトを返します。\ntimeoutPromise\n を使うことで以下のようにタイムアウト処理を書くことができるようになり\nます。\nfunction delayPromise(ms) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\nfunction timeoutPromise(promise, ms) {\n    var timeout = delayPromise(ms).then(\nfunction () {\n            \nthrow new Error('Operation timed out after '\n + ms + ' ms');\n        });\n    return Promise.race([promise, timeout]);\n}\n// 実行例\nvar taskPromise = \nnew Promise(\nfunction(resolve){\n    // 何らかの処理\n    var delay = \nMath.random() * \n2000;\n    setTimeout(\nfunction(){\n        resolve(delay + \n\"ms\");\n    }, delay);\n});\ntimeoutPromise(taskPromise, \n1000).then(function(value){","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":81},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:82","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n82\n    console.log(\n\"taskPromiseが時間内に終わった : \"\n + value);\n}).catch(function(error){\n    console.log(\n\"タイムアウトになってしまった\"\n, error);\n});\nタイムアウトになった場合はエラーが呼ばれるようにできましたが、 このままでは\n通常のエ\nラーとタイムアウトのエラー\nの区別がつかなくなってしまいます。\nこの \nError\n オブジェクトの区別をしやすくするため、 \nError\n オブジェクトのサブクラスとし\nて \nTimeoutError\n を定義したいと思います。\nカスタムErrorオブジェクト\nError\n オブジェクトはECMAScriptのビルトインオブジェクトです。\nECMAScript5では完璧に \nError\n を継承したものを作ることは不可能ですが(スタックト\nレース周り等)、 今回は通常のErrorとは区別を付けたいという目的なので、それを満たせる\nTimeoutError\n オブジェクトを作成します。\nECMAScript 6では \nclass\n 構文を使うことで内部的にも正確に継承を\n行うことが出来ます。\nclass MyError \nextends Error{\n    // Errorを継承したオブジェクト\n}\nerror instanceof TimeoutError\n というように利用できる \nTimeoutError\n を定義すると\n以下のようになります。\nTimeoutError.js\nfunction copyOwnFrom(target, source) {\n    Object.getOwnPropertyNames(source).forEach(\nfunction (propName) {\n        Object.defineProperty(target, propName, \nObject.getOwnPropertyDescriptor(source,\n propName));\n    });\n    return target;\n}\nfunction TimeoutError() {\n    var superInstance = \nError.apply(null, arguments);\n    copyOwnFrom(\nthis, superInstance);\n}\nTimeoutError.\nprototype\n = Object.create(Error.prototype\n);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":82},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:83","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n83\nTimeoutError.\nprototype\n.constructor = TimeoutError;\nTimeoutError\n というコンストラクタ関数を定義して、このコンストラクタにErrorを\nprototype継承させています。\n使い方は通常の \nError\n オブジェクトと同じで以下のように \nthrow\n するなどして利用できま\nす。\nvar promise = \nnew Promise(\nfunction(){\n    throw new TimeoutError(\n\"timeout\"\n);\n});\npromise.catch(function(error){\n    console.log(error \ninstanceof\n TimeoutError);\n// true\n});\nこの \nTimeoutError\n を使えば、タイムアウトによるErrorオブジェクトなのか、他の原因の\nErrorオブジェクトなのかが容易に判定できるようになります。\n今回紹介したビルトインオブジェクトを継承したオブジェクトの作成方\n法については \nChapter 28. Subclassing Built-ins\n73\n で詳しく紹介され\nています。 また、 \nError - JavaScript | MDN\n74\n にもErrorオブジェクトに\nついて書かれています。\nタイムアウトによるXHRのキャンセル\nここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかも\nしれません。\nXHRのキャンセル自体は \nXMLHttpRequest\n オブジェクトの \nabort()\n メソッドを呼ぶだけ\nなので難しくないですね。\nabort()\n メソッドを外から呼べるようにするために、今までのセクションにもでてき\nた\ngetURL\nを少し拡張して、 XHRを包んだpromiseオブジェクトと共にそのXHRを中止する\nメソッドをもつオブジェクトを返すようにしています。\ndelay-race-cancel.js\nfunction cancelableXHR(URL) {\n    var req = new XMLHttpRequest();\n73\n http://speakingjs.com/es5/ch28.html\n74\n https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":83},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:84","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n84\n    var promise = \nnew Promise(\nfunction (resolve, reject) {\n            req.open(\n'GET', URL, true);\n            req.onload = \nfunction () {\n                \nif (req.status === \n200) {\n                    resolve(req.responseText);\n                } \nelse {\n                    reject(\nnew Error(req.statusText));\n                }\n            };\n            req.onerror = \nfunction () {\n                reject(\nnew Error(req.statusText));\n            };\n            req.onabort = \nfunction () {\n                reject(\nnew Error('abort this request'\n));\n            };\n            req.send();\n        });\n    var abort = \nfunction () {\n        // 既にrequestが止まってなければabortする\n        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/\nUsing_XMLHttpRequest\n        if (req.readyState !== XMLHttpRequest.UNSENT) {\n            req.abort();\n        }\n    };\n    return {\n        promise: promise,\n        abort: abort\n    };\n}\nこれで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけで\nす。 大まかな流れとしては以下のようになります。\n1.\ncancelableXHR\n を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得\nする\n2.\ntimeoutPromise\n を使いXHRのpromiseとタイムアウト用のpromiseを\nPromise.race\n で競争させる\n• XHRが時間内に取得できた場合\na. 通常のpromiseと同様に \nthen\n で中身を取得する\n• タイムアウトとなった場合は\na.\nthrow new TimeoutError\n されるので \ncatch\n する","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":84},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:85","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n85\nb. catchしたエラーオブジェクトが \nTimeoutError\n のものだったら \nabort\n を呼び\n出してXHRをキャンセルする\nこれらの要素を全てまとめると次のように書けます。\ndelay-race-cancel-play.js\nfunction copyOwnFrom(target, source) {\n    Object.getOwnPropertyNames(source).forEach(\nfunction (propName) {\n        Object.defineProperty(target, propName, \nObject.getOwnPropertyDescriptor(source,\n propName));\n    });\n    return target;\n}\nfunction TimeoutError() {\n    var superInstance = \nError.apply(null, arguments);\n    copyOwnFrom(\nthis, superInstance);\n}\nTimeoutError.\nprototype\n = Object.create(Error.prototype\n);\nTimeoutError.\nprototype\n.constructor = TimeoutError;\nfunction delayPromise(ms) {\n    return new Promise(\nfunction (resolve) {\n        setTimeout(resolve, ms);\n    });\n}\nfunction timeoutPromise(promise, ms) {\n    var timeout = delayPromise(ms).then(\nfunction () {\n            \nreturn Promise.reject(\nnew TimeoutError(\n'Operation timed out after '\n + ms + '\n ms'));\n        });\n    return Promise.race([promise, timeout]);\n}\nfunction cancelableXHR(URL) {\n    var req = new XMLHttpRequest();\n    var promise = \nnew Promise(\nfunction (resolve, reject) {\n            req.open(\n'GET', URL, true);\n            req.onload = \nfunction () {\n                \nif (req.status === \n200) {\n                    resolve(req.responseText);\n                } \nelse {\n                    reject(\nnew Error(req.statusText));\n                }\n            };\n            req.onerror = \nfunction () {\n                reject(\nnew Error(req.statusText));\n            };","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":85},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:86","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n86\n            req.onabort = \nfunction () {\n                reject(\nnew Error('abort this request'\n));\n            };\n            req.send();\n        });\n    var abort = \nfunction () {\n        // 既にrequestが止まってなければabortする\n        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/\nUsing_XMLHttpRequest\n        if (req.readyState !== XMLHttpRequest.UNSENT) {\n            req.abort();\n        }\n    };\n    return {\n        promise: promise,\n        abort: abort\n    };\n}\nvar object = cancelableXHR(\n'http://httpbin.org/get'\n);\n// main\ntimeoutPromise(object.promise, \n1000).then(function (contents) {\n    console.log(\n'Contents'\n, contents);\n}).catch(function (error) {\n    if (error instanceof\n TimeoutError) {\n        object.abort();\n        console.error(error);\n        return;\n    }\n    console.log(\n'XHR Error :'\n, error);\n});\nこれで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現で\nきました。\n通常の開発の場合は繰り返し使えるように、それぞれファイルに分割し\nて定義しておくといいですね。\npromiseと操作メソッド\n先ほどの\ncancelableXHR\nはpromiseオブジェクトと操作のメソッドが 一緒になったオブ\nジェクトを返すようにしていたため少し分かりにくかったかもしれません。\n一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、\ncancelableXHR\n の中で生成した \nreq\n は外から参照できないので、特定のメソッド(先ほど\nのケースは \nabort\n)からは触れるようにする必要があります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":86},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:87","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n87\n返すpromiseオブジェクト自体を拡張して \nabort\n できるようにするという手段もあると思い\nますが、 promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用の\nメソッドをつけていくと複雑になってしまうかもしれません。\n一つの関数で全てやろうとしてるのがそもそも良くないので、 以下のように関数に分離して\nいくというのが妥当な気がします。\n• XHRを行うpromiseオブジェクトを返す\n• promiseオブジェクトを渡したら該当するXHRを止める\nこれらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、 一つの関数が\nやることも小さくて済むので見通しも良くなると思います。\nモジュールの作り方は色々作法(AMD,CommonJS,ES6 module etc..)があるので ここで\nは、先ほどの \ncancelableXHR\n をNode.jsのモジュールとして作りなおしてみます。\ncancelableXHR.js\n\"use strict\"\n;\nvar requestMap = {};\nfunction createXHRPromise(URL) {\n    var req = new XMLHttpRequest();\n    var promise = \nnew Promise(\nfunction (resolve, reject) {\n        req.open(\n'GET', URL, true);\n        req.onreadystatechange = \nfunction () {\n            \nif (req.readyState === XMLHttpRequest.DONE) {\n                \ndelete requestMap[URL];\n            }\n        };\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.onabort = \nfunction () {\n            reject(\nnew Error('abort this req'\n));\n        };\n        req.send();\n    });\n    requestMap[URL] = {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":87},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:88","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n88\n        promise: promise,\n        request: req\n    };\n    return promise;\n}\nfunction abortPromise(promise) {\n    if (typeof promise === \n\"undefined\"\n) {\n        return;\n    }\n    var request;\n    Object.keys(requestMap).some(\nfunction (URL) {\n        if (requestMap[URL].promise === promise) {\n            request = requestMap[URL].request;\n            \nreturn true;\n        }\n    });\n    if (request != null && request.readyState !== XMLHttpRequest.UNSENT) {\n        request.abort();\n    }\n}\nmodule.exports.createXHRPromise = createXHRPromise;\nmodule.exports.abortPromise = abortPromise;\n使い方もシンプルに \ncreateXHRPromise\n でXHRのpromiseオブジェクトを作成して、 その\nXHRを \nabort\n したい場合は \nabortPromise(promise)\n にpromiseオブジェクトを渡すとい\nう感じで利用できるようになります。\nvar cancelableXHR = require(\n\"./cancelableXHR\"\n);\nvar xhrPromise = cancelableXHR.createXHRPromise(\n'http://httpbin.org/get'\n);\nxhrPromise.\ncatch(function (error) {\n    // abort されたエラーが呼ばれる\n});\ncancelableXHR.abortPromise(xhrPromise);\nXHRをラップしたpromiseオブジェクトを作成\n1で作成したpromiseオブジェクトのリクエストをキャンセル\nまとめ\nここでは以下のことについて学びました。\n• 一定時間後に解決されるdelayPromise","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":88},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:89","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n89\n• delayPromiseとPromise.raceを使ったタイムアウトの実装\n• XHRのpromiseのリクエストのキャンセル\n• モジュール化によるpromiseオブジェクトと操作の分離\nPromiseは処理のフローを制御する力に優れているため、 それを最大限活かすためには\n一つの関数でやり過ぎないで処理を小さく分けること等、 今までのJavaScriptで言われて\nいるようなことをより意識していいのかもしれません。\nPromise.prototype.done とは何か?\n既存のPromise実装ライブラリを利用したことがある人は、 \nthen\n の代わりに使う \ndone\n と\nいうメソッドを見たことがあるかもしれません。\nそれらのライブラリでは \nPromise.prototype.done\n というような実装が存在し、 使い方は\nthen\n と同じですが、promiseオブジェクトを返さないようになっています。\nPromise.prototype.done\n は、ES6 Promises\nやPromises/A+\nの仕様には 存在していない\n記述ですが、多くのライブラリが実装しています。\nこのセクションでは、\nPromise.prototype.done\n とは何か? またなぜこのようなメソッドが\n多くのライブラリで実装されているかについて学んでいきましょう。\ndoneを使ったコード例\n実際にdoneを使ったコードを見てみると \ndone\n の挙動が分かりやすいと思います。\npromise-done-example.js\nif (typeof Promise.\nprototype\n.done === \n'undefined'\n) {\n    Promise.\nprototype\n.done = function (onFulfilled, onRejected) {\n        this.then(onFulfilled, onRejected).\ncatch(function (error) {\n            setTimeout(\nfunction () {\n                \nthrow error;\n            }, \n0);\n        });\n    };\n}\nvar promise = Promise.resolve();\npromise.done(\nfunction () {\n    JSON.parse(\n'this is not json'\n);    // => SyntaxError: JSON.parse\n});\n// => ブラウザの開発ツールのコンソールを開いてみましょう","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":89},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:90","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n90\n最初に述べたように、\nPromise.prototype.done\n は仕様としては存在しないため、 利用す\nる際は実装されているライブラリを使うか自分で実装する必要があります。\n実装については後で解説しますが、まずは \nthen\n を使った場合と \ndone\n を使ったものを比\n較してみます。\nthenを使った場合\nvar promise = Promise.resolve();\npromise.then(\nfunction () {\n    JSON.parse(\n\"this is not json\"\n);\n}).catch(function (error) {\n    console.error(error);\n// => \"SyntaxError: JSON.parse\"\n});\n比べて見ると以下のような違いがあることが分かります。\n•\ndone\n はpromiseオブジェクトを返さない\n◦ つまり、doneの後に \ncatch\n 等のメソッドチェーンはできない\n•\ndone\n の中で発生したエラーはそのまま外に例外として投げられる\n◦ つまり、Promiseによるエラーハンドリングが行われない\ndone\n はpromiseオブジェクトを返していないので、 Promise chainの最後におくメソッドと\nいうのは分かると思います。\nまた、Promiseには強力なエラーハンドリング機能があると紹介していましたが、 \ndone\n の\n中ではそのエラーハンドリングをワザと突き抜けて例外を出すようになっています。\nなぜこのようなPromiseの機能とは相反するメソッドが、多くのライブラリで実装されている\nかについては 次のようなPromiseの失敗例を見ていくと分かるかもしれません。\n沈黙したエラー\nPromiseには強力なエラーハンドリング機能がありますが、 (デバッグツールが上手く働か\nない場合に) この機能がヒューマンエラーをより複雑なものにしてしまう一面があります。\nこれは、\nthen or catch?\nでも同様の内容が出てきたことを覚えているかもしれません。\n次のような、promiseオブジェクトを返す関数を考えてみましょう。\njson-promise.js\nfunction JSONPromise(value) {\n    return new Promise(\nfunction (resolve) {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":90},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:91","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n91\n        resolve(JSON.parse(value));\n    });\n}\n渡された値を \nJSON.parse\n してpromiseオブジェクトを返す関数ですね。\n以下のように使うことができ、\nJSON.parse\n はパースに失敗すると例外を投げるので、 それ\nを \ncatch\n することができます。\nfunction JSONPromise(value) {\n    return new Promise(\nfunction (resolve) {\n        resolve(JSON.parse(value));\n    });\n}\n// 実行例\nvar string = \n\"jsonではない文字列\"\n;\nJSONPromise(string).then(\nfunction (object) {\n    console.log(object);\n}).catch(function(error){\n    // => JSON.parseで例外が発生した時\n    console.error(error);\n});\nちゃんと \ncatch\n していれば何も問題がないのですが、その処理を忘れてしまうというミス\nを した時にどこでエラーが発生してるのかわからなくなるというヒューマンエラーを助長さ\nせる面があります。\ncatchによるエラーハンドリングを忘れてしまった場合\nvar string = \n\"jsonではない文字列\"\n;\nJSONPromise(string).then(\nfunction (object) {\n    console.log(object);\n}); \n例外が投げられても何も処理されない\nJSON.parse\n のような分かりやすい例の場合はまだよいですが、 メソッドをtypoしたことに\nよるSyntax Errorなどはより深刻な問題となりやすいです。\ntypoによるエラー\nvar string = \n\"{}\";\nJSONPromise(string).then(\nfunction (object) {\n    conosle.log(object);\n});","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":91},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:92","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n92\nconosle というtypoがある\nこの場合は、\nconsole\n を \nconosle\n とtypoしているため、以下のようなエラーが発生するは\nずです。\nReferenceError: conosle is not defined\nしかし、Promiseではtry-catchされるため、エラーが握りつぶされてしまうという現象が起\nきてしまいます。 毎回、正しく \ncatch\n の処理を書くことができる場合は何も問題ありません\nが、 Promiseの実装によってはこのようなミスが検知しにくくなるケースがあることを知って\nおくべきでしょう。\nこのようなエラーの握りつぶしは\nunhandled rejection\nと言われることがあります。\n\"Rejectedされた時の処理がない\"というそのままの意味ですね。\nこのunhandled rejectionが検知しにくい問題はPromiseの実装に依\n存します。 例えば、 \nypromise\n75\n はunhandled rejectionがある場合\nは、その事をコンソールに表示します。\nPromise rejected but no error handlers were\nregistered to it\nまた、 Bluebird\n76\n の場合も、 明らかに人間のミスにみえる\nReferenceErrorの場合などはそのままコンソールにエラーを表示してく\nれます。\n\"Possibly unhandled ReferenceError. conosle is\nnot defined\nネイティブのPromiseの場合も同様にこの問題への対処としてGC-\nbased unhandled rejection trackingというものが 搭載されつつあり\nます。\nこれはpromiseオブジェクトがガーベッジコレクションによって回収さ\nれるときに、 それがunhandled rejectionであるなら、エラー表示をす\nるという仕組みがベースとなっているようです。\nFirefox\n77\n や Chrome\n78\n のネイティブPromiseでは一部実装されてい\nます。\n75\n https://github.com/yahoo/ypromise\n76\n https://github.com/petkaantonov/bluebird\n77\n https://twitter.com/domenic/status/461154989856264192\n78\n https://code.google.com/p/v8/issues/detail?id=3093","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":92},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:93","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n93\ndoneの実装\nPromiseにおける \ndone\n は先程のエラーの握りつぶしを避けるにはどうするかという方法\n論として、 そもそもエラーハンドリングをしなければいい という豪快な解決方法を提供する\nメソッドです。\ndone\n はPromiseの上に実装することができるので、 \nPromise.prototype.done\n という\nPromiseのprototype拡張として実装してみましょう。\npromise-prototype-done.js\n\"use strict\"\n;\nif (typeof Promise.\nprototype\n.done === \n\"undefined\"\n) {\n    Promise.\nprototype\n.done = function (onFulfilled, onRejected) {\n        this.then(onFulfilled, onRejected).\ncatch(function (error) {\n            setTimeout(\nfunction () {\n                \nthrow error;\n            }, \n0);\n        });\n    };\n}\nどのようにPromiseの外へ例外を投げているかというと、 setTimeoutの中でthrowをする\nことで、外へそのまま例外を投げられることを利用しています。\nsetTimeoutのコールバック内での例外\ntry{\n    setTimeout(\nfunction callback() {\n        throw new Error(\"error\");\n    }, 0);\n}catch(error){\n    console.error(error);\n}\nこの例外はキャッチされない\nなぜ非同期の \ncallback\n 内での例外をキャッチ出来ないのかは以下\nが参考になります。\n• JavaScriptと非同期のエラー処理 - Yahoo! JAPAN Tech Blog\n79\n79\n http://techblog.yahoo.co.jp/programming/javascript_error/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":93},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:94","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n94\nPromise.prototype.done\n をよく見てみると、何も \nreturn\n していないことも分かると思\nいます。 つまり、\ndone\n は「ここでPromise chainは終了して、例外が起きた場合はそのまま\npromiseの外へ投げ直す」という処理になっています。\n実装や環境がしっかり対応していれば、\nunhandled rejection\nの検知はできるため、必\nずしも \ndone\n が必要というわけではなく、 また今回の\nPromise.prototype.done\nのよう\nに、\ndone\n は既存のPromiseの上に実装することができるため、 \nES6 Promises\nの仕様その\nものには入らなかったといえるかもしれません。\n今回の \nPromise.prototype.done\n の実装は \npromisejs.org\n80\n を参考\nにしています。\nまとめ\nこのセクションでは、 \nQ\n81\n や Bluebird\n82\n や prfun\n83\n 等 多くのPromiseライブラリで実装\nされている \ndone\n の基礎的な実装と、\nthen\n とはどのような違いがあるかについて学びまし\nた。\ndone\n には2つの側面があることがわかりました。\n•\ndone\n の中で起きたエラーは外へ例外として投げ直す\n• Promise chain を終了するという宣言\nthen or catch?\n と同様にPromiseにより沈黙してしまったエラーについては、 デバッグツー\nルやライブラリの改善等で殆どのケースでは問題ではなくなるかもしれません。\nまた、\ndone\n は値を返さないことでそれ以上Promise chainを繋げることができなくなるた\nめ、 そのような統一感を持たせるという用途で \ndone\n を使うこともできます。\nES6 Promises\n では根本に用意されてる機能はあまり多くありません。 そのため、自ら拡張\nしたり、拡張したライブラリ等を利用するケースが多いと思います。\nそのときでも何でもやり過ぎると、せっかく非同期処理をPromiseでまとめても複雑化してし\nまう場合があるため、 統一感を持たせるというのは抽象的なオブジェクトであるPromiseに\nおいては大事な部分といえるかもしれません。\n80\n https://www.promisejs.org/\n81\n https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-\nonprogress\n82\n https://github.com/petkaantonov/bluebird\n83\n https://github.com/cscott/prfun#promisedone—undefined","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":94},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:95","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n95\nPromises: The Extension Problem (part 4) | getiblog\n84\n では、\nPromiseの拡張を書く手法について書かれています。\n•\nPromise.prototype\n を拡張する方法\n• Wrapper/Delegate を使った抽象レイヤーを作る方法\nまた、Delegateを利用した方法については、 \nChapter 28. Subclassing\nBuilt-ins\n85\n にて 詳しく解説されています。\nPromiseとメソッドチェーン\nPromiseは \nthen\n や \ncatch\n 等のメソッドを繋げて書いていきます。 これはDOMやjQuery\n等でよくみられるメソッドチェーンとよく似ています。\n一般的なメソッドチェーンは \nthis\n を返すことで、メソッドを繋げて書けるようになっていま\nす。\nメソッドチェーンの作り方については \nメソッドチェーンの作り方 - あと\n味\n86\n などを参照するといいでしょう。\n一方、Promiseは\n毎回新しいpromiseオブジェクトを返す\nようになっていますが、 一般的な\nメソッドチェーンと見た目は全く同じです。\nこのセクションでは、一般的なメソッドチェーンで書かれたものを インターフェースはその\nままで内部的にはPromiseで処理されるようにする方法について学んでいきたいと思いま\nす。\nfsのメソッドチェーン\n以下のような \nNode.jsのfs\n87\nモジュールを例にしてみたいと思います。\nまた、今回の例は見た目のわかりやすさを重視しているため、 現実的にはあまり有用なケー\nスとはいえないかもしれません。\nfs-method-chain.js\n\"use strict\"\n;\nvar fs = require(\n\"fs\");\n84\n http://blog.getify.com/promises-part-4/\n85\n http://speakingjs.com/es5/ch28.html\n86\n http://taiju.hatenablog.com/entry/20100307/1267962826\n87\n http://nodejs.org/api/fs.html","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":95},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:96","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n96\nfunction File() {\n    this.lastValue = null;\n}\n// Static method for File.prototype.read\nFile.read = \nfunction FileRead(filePath) {\n    var file = new File();\n    return file.read(filePath);\n};\nFile.prototype\n.read = function (filePath) {\n    this.lastValue = fs.readFileSync(filePath, \n\"utf-8\");\n    return this;\n};\nFile.prototype\n.transform = \nfunction (fn) {\n    this.lastValue = fn.call(\nthis, this.lastValue);\n    return this;\n};\nFile.prototype\n.write = \nfunction (filePath) {\n    this.lastValue = fs.writeFileSync(filePath, \nthis.lastValue);\n    return this;\n};\nmodule.exports = File;\nこのモジュールは以下のようにread → transform → writeという流れを メソッドチェーン\nで表現することができます。\nvar File = require(\n\"./fs-method-chain\"\n);\nvar inputFilePath = \n\"input.txt\"\n,\n    outputFilePath = \n\"output.txt\"\n;\nFile.read(inputFilePath)\n    .transform(\nfunction (content) {\n        return \">>\" + content;\n    })\n    .write(outputFilePath);\ntransform\n は引数で受け取った値を変更する関数を渡して処理するメソッドです。 この場\n合は、readで読み込んだ内容の先頭に \n>>\n という文字列を追加しているだけです。\nPromiseによるfsのメソッドチェーン\n次に先ほどの\nメソッドチェーン\nをインターフェースはそのまま維持して 内部的にPromiseを\n使った処理にしてみたいと思います。\nfs-promise-chain.js\n\"use strict\"\n;","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":96},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:97","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n97\nvar fs = require(\n\"fs\");\nfunction File() {\n    this.promise = Promise.resolve();\n}\n// Static method for File.prototype.read\nFile.read = \nfunction (filePath) {\n    var file = new File();\n    return file.read(filePath);\n};\nFile.prototype\n.then = function (onFulfilled, onRejected) {\n    this.promise = \nthis.promise.then(onFulfilled, onRejected);\n    return this;\n};\nFile.prototype\n[\"catch\"] = function (onRejected) {\n    this.promise = \nthis.promise.\ncatch(onRejected);\n    return this;\n};\nFile.prototype\n.read = function (filePath) {\n    return this.then(function () {\n        return fs.readFileSync(filePath, \n\"utf-8\");\n    });\n};\nFile.prototype\n.transform = \nfunction (fn) {\n    return this.then(fn);\n};\nFile.prototype\n.write = \nfunction (filePath) {\n    return this.then(function (data) {\n        return fs.writeFileSync(filePath, data)\n    });\n};\nmodule.exports = File;\n内部に持ってるpromiseオブジェクトに対するエイリアスとして \nthen\n と \ncatch\n を持たせ\nていますが、それ以外のインターフェースは全く同じ使い方となっています。\nそのため、先ほどのコードで \nrequire\n するモジュールを変更しただけで動作します。\nvar File = require(\n\"./fs-promise-chain\"\n);\nvar inputFilePath = \n\"input.txt\"\n,\n    outputFilePath = \n\"output.txt\"\n;\nFile.read(inputFilePath)\n    .transform(\nfunction (content) {\n        return \">>\" + content;\n    })","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":97},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:98","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n98\n    .write(outputFilePath);\nFile.prototype.then\n というメソッドは、 \nthis.promise.then\n が返す新しいpromiseオ\nブジェクトを \nthis.promise\n に対して代入しています。\nこれはどういうことなのかというと、以下のように擬似的に展開してみると分かりやすいで\nしょう。\nvar File = require(\n\"./fs-promise-chain\"\n);\nFile.read(inputFilePath)\n    .transform(\nfunction (content) {\n        return \">>\" + content;\n    })\n    .write(outputFilePath);\n// => 擬似的に以下のような流れに展開できる\npromise.then(\nfunction read(){\n        return fs.readFileSync(filePath, \n\"utf-8\");\n    }).then(\nfunction transform(content) {\n         \nreturn \">>\" + content;\n    }).then(\nfunction write(){\n        return fs.writeFileSync(filePath, data);\n    });\npromise = promise.then(...)\n という書き方は一見すると、上書きしているようにみえるた\nめ、 それまでのpromiseのchainが途切れてしまうと思うかもしれません。\nイメージとしては \npromise = addPromiseChain(promise, fn);\n のような感じになってい\nて、 既存のpromiseオブジェクトに対して新たな処理を\n追加したpromiseオブジェクトを\n作って返すため、 自分で逐次的に処理する機構を実装しなくても問題ないわけです。\n両者の違い\n同期と非同期\nfs-method-chain.js\nとPromise版\nの違いを見ていくと、 そもそも両者には同期的、非同期\n的という大きな違いがあります。\nfs-method-chain.js\n のようなメソッドチェーンでもキュー等の処理を実装すれば、 非同期\n的なほぼ同様のメソッドチェーンを実装できますが、複雑になるため今回は単純な同期的\nなメソッドチェーンにしました。\nPromise版は\nコラム: Promiseは常に非同期?\nで紹介したように 常に非同期処理となるた\nめ、promiseを使ったメソッドチェーンも非同期となっています。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":98},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:99","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n99\nエラーハンドリング\nfs-method-chain.js\nにはエラーハンドリングの処理は入っていないですが、 同期処理であ\nるため全体を \ntry-catch\n で囲むことで行えます。\nPromise版\n では内部で利用するpromiseオブジェクトの \nthen\n と \ncatch\n へのエイリアス\nを用意してあるため、通常のpromiseと同じように \ncatch\n によってエラーハンドリングが行\nえます。\nfs-promise-chainでのエラーハンドリング\nvar File = require(\n\"./fs-promise-chain\"\n);\nFile.read(inputFilePath)\n    .transform(\nfunction (content) {\n        return \">>\" + content;\n    })\n    .write(outputFilePath)\n    .catch(function(error){\n        console.error(error);\n    });\nfs-method-chain.js\nに非同期処理を加えたものを自力で実装する場合、 エラーハンドリン\nグが大きな問題となるため、非同期処理にしたい時は Promiseを使うと比較的簡単に実装\nできるといえるかもしれません。\nPromise以外での非同期処理\nこのメソッドチェーンと非同期処理を見てNode.jsに慣れている方は \nStream\n88\n が思い浮\nかぶと思います。\nStream\n89\n を使うと、 \nthis.lastValue\n のような値を保持する必要がなくなることや大きな\nファイルの扱いが改善されます。 また、Promiseを使った例に比べるとより高速に処理でき\nる可能性が高いと思います。\nstreamによるread→transform→write\nreadableStream.pipe(transformStream).pipe(writableStream);\nそのため、非同期処理には常にPromiseが最適という訳ではなく、 目的と状況にあった実\n装をしていくことを考えていくべきでしょう。\n88\n http://nodejs.org/api/stream.html\n89\n http://nodejs.org/api/stream.html","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":99},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:100","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n100\nNode.jsのStreamはEventをベースにしている技術\nNode.jsのStreamについて詳しくは以下を参照して下さい。\n• Node.js の Stream API で「データの流れ」を扱う方法 - Block Rockin’ Codes\n90\n• Stream2の基本\n91\n• Node-v0.12の新機能について\n92\nPromiseラッパー\n話を戻して\nfs-method-chain.js\nとPromise版\nの両者を比べると、 内部的にもかなり似てい\nて、同期版のものがそのまま非同期版でも使えるような気がします。\nJavaScriptでは動的にメソッドを定義することもできるため、 自動的にPromise版を生成\nできないかということを考えると思います。 (もちろん静的に定義する方が扱いやすいです\nが)\nそのような仕組みは\nES6 Promises\nにはありませんが、 著名なサードパーティのPromise実\n装である \nbluebird\n93\n などには \nPromisification\n94\n という機能が用意されています。\nこれを利用すると以下のように、その場でpromise版のメソッドを追加して利用できるよう\nになります。\nvar fs = Promise.promisifyAll(require(\n\"fs\"));\nfs.readFileAsync(\n\"myfile.js\"\n, \"utf8\").then(function(contents){\n    console.log(contents);\n}).catch(function(e){\n    console.error(e.stack);\n});\nArrayのPromiseラッパー\n先ほどの \nPromisification\n95\n が何をやっているのか少しイメージしにくいので、 次のような\nネイティブ \nArray\n のPromise版となるメソッドを動的に定義する例を考えてみましょう。\n90\n http://jxck.hatenablog.com/entry/20111204/1322966453\n91\n http://www.slideshare.net/shigeki_ohtsu/stream2-kihon\n92\n http://www.slideshare.net/shigeki_ohtsu/node-v012tng12\n93\n https://github.com/petkaantonov/bluebird/\n94\n https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification\n95\n https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":100},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:101","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n101\nJavaScriptにはネイティブにもDOMやString等メソッドチェーンが行える機能が多くあ\nります。 \nArray\n もその一つで、\nmap\n や \nfilter\n 等のメソッドは配列を返すため、メソッド\nチェーンが利用しやすい機能です\narray-promise-chain.js\n\"use strict\"\n;\nfunction ArrayAsPromise(array) {\n    this.array = array;\n    this.promise = Promise.resolve();\n}\nArrayAsPromise.\nprototype\n.then = function (onFulfilled, onRejected) {\n    this.promise = \nthis.promise.then(onFulfilled, onRejected);\n    return this;\n};\nArrayAsPromise.\nprototype\n[\"catch\"] = function (onRejected) {\n    this.promise = \nthis.promise.\ncatch(onRejected);\n    return this;\n};\nObject.getOwnPropertyNames(\nArray.prototype\n).forEach(\nfunction (methodName) {\n    // Don't overwrite\n    if (typeof ArrayAsPromise[methodName] !== \n\"undefined\"\n) {\n        return;\n    }\n    var arrayMethod = \nArray.prototype\n[methodName];\n    if (typeof  arrayMethod !== \n\"function\"\n) {\n        return;\n    }\n    ArrayAsPromise.\nprototype\n[methodName] = \nfunction () {\n        var that = this;\n        var args = arguments;\n        this.promise = \nthis.promise.then(\nfunction () {\n            that.array = \nArray.prototype\n[methodName].apply(that.array, args);\n            \nreturn that.array;\n        });\n        return this;\n    };\n});\nmodule.exports = ArrayAsPromise;\nmodule.exports.array = \nfunction newArrayAsPromise(array) {\n    return new ArrayAsPromise(array);\n};","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":101},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:102","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n102\nネイティブのArrayと \nArrayAsPromise\n を使った場合の違いは \n上記のコード\nのテストを見\nてみるのが分かりやすいでしょう。\narray-promise-chain-test.js\n\"use strict\"\n;\nvar assert = require(\n\"power-assert\"\n);\nvar ArrayAsPromise = require(\n\"../src/promise-chain/array-promise-chain\"\n);\ndescribe(\n\"array-promise-chain\"\n, function () {\n    function isEven(value) {\n        return value % \n2 === 0;\n    }\n    function double(value) {\n        return value * \n2;\n    }\n    beforeEach(\nfunction () {\n        this.array = [\n1, 2, 3, 4, 5];\n    });\n    describe(\n\"Native array\"\n, function () {\n        it(\n\"can method chain\"\n, function () {\n            \nvar result = \nthis.array.filter(isEven).map(\ndouble);\n            assert.deepEqual(result, [\n4, 8]);\n        });\n    });\n    describe(\n\"ArrayAsPromise\"\n, function () {\n        it(\n\"can promise chain\"\n, function (done) {\n            \nvar array = \nnew ArrayAsPromise(\nthis.array);\n            array.filter(isEven).map(\ndouble).then(function (value) {\n                assert.deepEqual(value, [\n4, 8]);\n            }).then(done, done);\n        });\n    });\n});\nArrayAsPromise\n でもArrayのメソッドを利用できているのが分かります。 先ほどと同じよう\nに、ネイティブのArrayは同期処理で、\nArrayAsPromise\n は非同期処理という違いがありま\nす。\nArrayAsPromise\n の実装を見て気づくと思いますが、\nArray.prototype\n のメソッドを全て\n実装しています。 しかし、\narray.indexOf\n など \nArray.prototype\n には配列を返さないも\nのもあるため、全てをメソッドチェーンにするのは不自然なケースがあると思います。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":102},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:103","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n103\nここで大事なのが、同じ値を受けるインターフェースを持っているAPIはこのような手段で\nPromise版のAPIを自動的に作成できるという点です。 このようなAPIの規則性を意識して\nみるとまた違った使い方が見つかるかもしれません。\n先ほどの \nPromisification\n96\n は Node.jsのCoreモジュールの非同\n期処理には \nfunction(error,result){}\n というように第一引数に\nerror\n が来るというルールを利用して、 自動的にPromiseでラップし\nたメソッドを生成しています\nまとめ\nこのセクションでは以下のことについて学びました。\n• Promise版のメソッドチェーンの実装\n• Promiseが常に非同期の最善の手段ではない\n• Promisification\n• 統一的なインターフェースの再利用\nES6 Promises\nはCoreとなる機能しか用意されていません。 そのため、自分でPromiseを\n使った既存の機能のラッパー的な実装をすることがあるかもしれません。\nしかし、何度もコールバックを呼ぶEventのような処理がPromiseには不向きなように、\nPromiseが常に最適な非同期処理という訳ではありません。\nその機能にPromiseを使うのが最適なのかを考えることはこの書籍の目的でもあるため、\n何でもPromiseにするというわけではなく、その目的にPromiseが合うのかどうかを考えて\nみるのもいいと思います。\nPromiseによる逐次処理\n第2章の\nPromise.all\nでは、 複数のpromiseオブジェクトをまとめて処理する方法について\n学びました。\nしかし、\nPromise.all\n は全ての処理を並行に行うため、 Aの処理 が終わったら Bの処理 と\nいうような逐次的な処理を扱うことができません。\nまた、同じ2章の\nPromiseと配列\nでは、 効率的ではないですが、\nthenを連ねた書き方\nでその\nような逐次処理を行っていました。\n96\n https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":103},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:104","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n104\nこのセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思いま\nす。\nループと逐次処理\nthenを連ねた書き方\nでは以下のような書き方でしたね。\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    // [] は記録する初期値を部分適用している\n    var pushValue = recordValue.bind(null, []);\n    return request.comment().then(pushValue).then(request.people).then(pushValue);\n}\n// 実行例\nmain().then(\nfunction (value) {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":104},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:105","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n105\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\nこの書き方だと、\nrequest\n の数が増える分 \nthen\n を書かないといけなくなってしまいます。\nそこで、処理を配列にまとめて、forループで処理していければ、数が増えた場合も問題無い\nですね。 まずはforループを使って先ほどと同じ処理を書いてみたいと思います。\npromise-foreach-xhr.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    // [] は記録する初期値を部分適用してる\n    var pushValue = recordValue.bind(null, []);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":105},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:106","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n106\n    // promiseオブジェクトを返す関数の配列\n    var tasks = [request.comment, request.people];\n    var promise = Promise.resolve();\n    // スタート地点\n    for (var i = 0; i < tasks.length; i++) {\n        var task = tasks[i];\n        promise = promise.then(task).then(pushValue);\n    }\n    return promise;\n}\n// 実行例\nmain().then(\nfunction (value) {\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\nforループで書く場合、\nコラム: thenは常に新しいpromiseオブジェクトを返す\nやPromiseと\nメソッドチェーン\nで学んだように、 \nPromise#then\n は新しいpromiseオブジェクトを返して\nいます。\nそのため、\npromise = promise.then(task).then(pushValue);\n というのは \npromise\n と\nいう変数に上書きするというよりは、 そのpromiseオブジェクトに処理を追加していくような\n処理になっています。\nしかし、この書き方だと一時変数として \npromise\n が必要で、処理の内容的にもあまりスッキ\nリしません。\nこのループの書き方は \nArray.prototype.reduce\n を使うともっとスマートに書くことができ\nます。\nPromise chainとreduce\nArray.prototype.reduce\n を使って書き直すと以下のようになります。\npromise-reduce-xhr.js\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":106},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:107","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n107\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    var pushValue = recordValue.bind(null, []);\n    var tasks = [request.comment, request.people];\n    return tasks.reduce(\nfunction (promise, task) {\n        return promise.then(task).then(pushValue);\n    }, Promise.resolve());\n}\n// 実行例\nmain().then(\nfunction (value) {\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\nmain\n 以外の処理はforループのものと同様です。\nArray.prototype.reduce\n は第二引数に初期値を入れることができます。 つまりこ\nの場合、最初の \npromise\n には \nPromise.resolve()\n が入り、 そのときの \ntask\n は\nrequest.comment\n となります。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":107},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:108","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n108\nreduceの中で \nreturn\n したものが、次のループで \npromise\n に入ります。 つまり、\nthen\nを使って作成した新たなpromiseオブジェクトを返すことで、 forループの場合と同じよう\nにPromise chain\nを繋げることができます。\nArray.prototype.reduce\n については詳しくは以下を参照して下さい。\n• Array.prototype.reduce() - JavaScript | MDN\n97\n• Array.prototype.reduce Dance\n98\nforループと異なる点は、一時変数としての \npromise\n が不要になることに伴い、 \npromise =\npromise.then(task).then(pushValue);\n という不格好な書き方がなくなる点が大きな違\nいだと思います。\nArray.prototype.reduce\n とPromiseの逐次処理は相性がよいので覚えておくといいの\nですが、 初めて見た時にどのような動作をするのかがまだ分かりにくいという問題がありま\nす。\nそこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う \nsequenceTasks\n と\nいうものを作ってみます。\n以下のように書くことができれば、\ntasks\n が順番に処理されていくことが関数名から見て分\nかるようになります。\nvar tasks = [request.comment, request.people];\nsequenceTasks(tasks);\n逐次処理を行う関数を定義する\n基本的には、\nreduceを使ったやり方\nを関数として切り離せばいいだけですね。\npromise-sequence.js\nfunction sequenceTasks(tasks) {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    var pushValue = recordValue.bind(null, []);\n97\n https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/\nReduce\n98\n http://azu.github.io/slide/JSGohan/reduce.html","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":108},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:109","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n109\n    return tasks.reduce(\nfunction (promise, task) {\n        return promise.then(task).then(pushValue);\n    }, Promise.resolve());\n}\n一つ注意点として、\nPromise.all\n 等と違い、引数に受け取るのは関数の配列です。\nなぜ、渡すのがpromiseオブジェクトの配列ではないのかというと、 promiseオブジェクト\nを作った段階ですでにXHRが実行されている状態なので、 それを逐次処理しても意図とは\n異なる動作になるためです。\nそのため \nsequenceTasks\n では関数(promiseオブジェクトを返す)の配列を引数に受け取\nります。\n最後に、\nsequenceTasks\n を使って最初の例を書き換えると以下のようになります。\npromise-sequence-xhr.js\nfunction sequenceTasks(tasks) {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    var pushValue = recordValue.bind(null, []);\n    return tasks.reduce(\nfunction (promise, task) {\n        return promise.then(task).then(pushValue);\n    }, Promise.resolve());\n}\nfunction getURL(URL) {\n    return new Promise(\nfunction (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.open(\n'GET', URL, true);\n        req.onload = \nfunction () {\n            \nif (req.status === \n200) {\n                resolve(req.responseText);\n            } \nelse {\n                reject(\nnew Error(req.statusText));\n            }\n        };\n        req.onerror = \nfunction () {\n            reject(\nnew Error(req.statusText));\n        };\n        req.send();\n    });\n}\nvar request = {","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":109},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:110","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n110\n        comment: \nfunction getComment() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\ncomment.json'\n).then(JSON.parse);\n        },\n        people: \nfunction getPeople() {\n            \nreturn getURL('http://azu.github.io/promises-book/json/\npeople.json'\n).then(JSON.parse);\n        }\n    };\nfunction main() {\n    return sequenceTasks([request.comment, request.people]);\n}\n// 実行例\nmain().then(\nfunction (value) {\n    console.log(value);\n}).catch(function(error){\n    console.error(error);\n});\nmain()\n の中がかなりスッキリしたことが分かります。\nこのようにPromiseでは、逐次処理ということをするのに色々な書き方ができると思います。\n• thenをその場に並べた書き方\n• forループを使った書き方\n• reduceを使った書き方\n• 逐次処理する関数を分けた書き方\nしかし、これはJavaScriptで配列を扱うのにforループや \nforEach\n 等、色々やり方があるの\nと本質的には違いはありません。 そのため、Promiseを扱う場合も処理をまとめられるところ\nは小さく関数に分けて、実装していくのがいいといえるでしょう。\nまとめ\nこのセクションでは、\nPromise.all\nとは違い、 一つづつ順番に処理したい場合に、Promise\nでどのように実装していくかについて学びました。\n手続き的な書き方から、逐次処理を行う関数を定義するところまで見ていき、 Promiseで\nあっても関数に処理を分けるという基本的なことは変わらないことを示しました。\nPromiseで書くとPromise chainを繋げすぎて縦に長い処理を書いてしまうことがありま\nす。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":110},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:111","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n111\nそんな時は基本に振り返り、処理を関数に分けることで全体の見通しを良くすることは大切\nです。\nまた、Promiseのコンストラクタ関数や \nthen\n 等は高階関数なので、 処理を関数に分けて\nおくと組み合わせが行い易いという副次的な効果もあるため、意識してみるといいかもしれ\nません。\n高階関数とは引数に関数オブジェクトを受け取る関数のこと\nPromises API Reference\nPromise#then\npromise.then(onFulfilled, onRejected);\nthenコード例\nvar promise = \nnew Promise(\nfunction(resolve, reject){\n    resolve(\n\"thenに渡す値\"\n);\n});\npromise.then(\nfunction (value) {\n    console.log(value);\n}, function (error) {\n    console.error(error);\n});\npromiseオブジェクトに対してonFulfilledとonRejectedのハンドラを定義し、 新たな\npromiseオブジェクトを作成して返す。\nこのハンドラはpromiseがresolve または rejectされた時にそれぞれ呼ばれる。\n• 定義されたハンドラ内で返した値は、新たなpromiseオブジェクトのonFulfilledに対し\nて渡される。\n• 定義されたハンドラ内で例外が発生した場合は、新たなpromiseオブジェクトの\nonRejectedに対して渡される。\nPromise#catch\npromise.catch(onRejected);","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":111},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:112","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n112\ncatchのコード例\nvar promise = \nnew Promise(\nfunction(resolve, reject){\n    resolve(\n\"thenに渡す値\"\n);\n});\npromise.then(\nfunction (value) {\n    console.log(value);\n}).catch(function (error) {\n    console.error(error);\n});\npromise.then(undefined, onRejected)\n と同等の意味をもつシンタックスシュガー。\nPromise.resolve\nPromise.resolve(promise);\nPromise.resolve(thenable);\nPromise.resolve(object);\nPromise.resolveのコード例\nvar taskName = \n\"task 1\"\nasyncTask(taskName).then(\nfunction (value) {\n    console.log(value);\n}).catch(function (error) {\n    console.error(error);\n});\nfunction asyncTask(name){\n    return Promise.resolve(name).then(\nfunction(value){\n        return \"Done! \"+ value;\n    });\n}\n受け取った値に応じたpromiseオブジェクトを返す。\nどの場合でもpromiseオブジェクトを返すが、大きく分けて以下の3種類となる。\npromiseオブジェクトを受け取った場合\n受け取ったpromiseオブジェクトをそのまま返す\nthenableなオブジェクトを受け取った場合\nthen\n をもつオブジェクトを新たなpromiseオブジェクトにして返す\nその他の値(オブジェクトやnull等も含む)を受け取った場合\nその値でresolveされる新たなpromiseオブジェクトを作り返す","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":112},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:113","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n113\nPromise.reject\nPromise.reject(object)\nPromise.rejectのコード例\nvar failureStub = sinon.stub(xhr, \n\"request\"\n).returns(Promise.reject(\nnew Error(\"bad!\")));\n受け取った値でrejectされた新たなpromiseオブジェクトを返す。\nPromise.rejectに渡す値は \nError\n オブジェクトとすべきである。\nまた、Promise.resolveとは異なり、promiseオブジェクトを渡した場合も常に新たな\npromiseオブジェクトを作成する。\nvar r = Promise.reject(\nnew Error(\"error\"));\nconsole.log(r === Promise.reject(r));\n// false\nPromise.all\nPromise.all(promiseArray);\nPromise.allのコード例\nvar p1 = Promise.resolve(\n1),\n    p2 = Promise.resolve(\n2),\n    p3 = Promise.resolve(\n3);\nPromise.all([p1, p2, p3]).then(\nfunction (results) {\n    console.log(results);  \n// [1, 2, 3]\n});\n新たなpromiseオブジェクトを作成して返す。\n渡されたpromiseオブジェクトの配列が全てresolveされた時に、 新たなpromiseオブ\nジェクトはその値でresolveされる。\nどれかの値がrejectされた場合は、その時点で新たなpromiseオブジェクトはrejectされ\nる。\n渡された配列の値はそれぞれ \nPromise.resolve\n にラップされるため、 promiseオブジェ\nクト以外が混在している場合も扱える。","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":113},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:114","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n114\nPromise.race\nPromise.race(promiseArray);\nPromise.raceのコード例\nvar p1 = Promise.resolve(\n1),\n    p2 = Promise.resolve(\n2),\n    p3 = Promise.resolve(\n3);\nPromise.race([p1, p2, p3]).then(\nfunction (value) {\n    console.log(value);  \n// 1\n});\n新たなpromiseオブジェクトを作成して返す。\n渡されたpromiseオブジェクトの配列のうち、 一番最初にresolve または rejectされた\npromiseにより、 新たなpromiseオブジェクトはその値でresolve または rejectされる。\n用語集\nPromises\nプロミスという仕様そのもの\npromiseオブジェクト\nプロミスオブジェクト、\nPromise\n のインスタンスオブジェクトのこと\nES6 Promises\nECMAScript 6th Edition(ECMAScript 2015)\n99\n を明示的に示す場合にprefixとして\nES6 をつける\nPromises/A+\nPromises/A+\n100\nのこと。 ES6 Promisesの前身となったコミュニティベースの仕様であ\nり、ES6 Promisesとは多くの部分が共通している。\nThenable\nPromiseライクなオブジェクトのこと。 \n.then\n というメソッドをもつオブジェクト。\npromise chain\npromiseオブジェクトを \nthen\n や \ncatch\n のメソッドチェーンでつなげたもの。 この用語\nは書籍中のものであり、\nES6 Promises\nで定められた用語ではありません。\n99\n http://www.ecma-international.org/ecma-262/6.0/index.html\n100\n http://promises-aplus.github.io/promises-spec/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":114},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:115","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n115\n参考サイト\nw3ctag/promises-guide\n101\n （日本語訳）\n102\nPromisesのガイド - 概念的な説明はここから得たものが多い\ndomenic/promises-unwrapping\n103\nES6 Promisesの仕様の元となったリポジトリ - issueを検索して得た経緯や情報も多い\nECMAScript 2015 Language Specification – ECMA-262 6th Edition\n104\nES6 Promisesの仕様書 - 仕様書として参照する場合はこちらを優先した\nJavaScript Promises: There and back again - HTML5 Rocks\n105\nPromisesについての記事 - 完成度がとても高くサンプルコードやリファレンス等を参考\nにした\nNode.jsにPromiseが再びやって来た！ - ぼちぼち日記\n106\nNode.jsとPromiseの記事 - \nthenable\nについて参考にした\nExploring ES6: Upgrade to the next version of JavaScript\n107\nECMAScript 6全般について詳しく書かれている書籍\n著者について\nazu\n108\n (Twitter : @\nazu_re\n109\n )\nブラウザ、JavaScriptの最新技術を常に追いかけている。\n目的を手段にしてしまうことを得意としている(この書籍もその結果できた)。\nWeb Scratch\n110\n や JSer.info\n111\n といったサイトを運営している。\n101\n https://github.com/w3ctag/promises-guide\n102\n http://www.hcn.zaq.ne.jp/___/WEB/promises-guide-ja.html\n103\n https://github.com/domenic/promises-unwrapping\n104\n http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects\n105\n http://www.html5rocks.com/ja/tutorials/es6/promises/\n106\n http://d.hatena.ne.jp/jovi0608/20140319/1395199285\n107\n http://exploringjs.com/\n108\n https://github.com/azu/\n109\n https://twitter.com/azu_re\n110\n http://efcl.info/\n111\n http://jser.info/","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":115},{"id":"./test/fixtures/pdf/javascript-promise-book.pdf:116","title":"JavaScript Promiseの本","author":"azu","body":"JavaScript Promiseの本\n116\n著者へのメッセージ/おまけ\n以下の おまけ.pdf\n112\n では、 この書籍を書き始めた理由や、どのように書いていったか、テ\nストなどについて書かれています。\n•\nGum r oad\n¥0\nJavaScript Promiseの本のおまけ\n113\nGumroadから無料 または 好きな値段でダウンロードすることができます。\nダウンロードする際に作者へのメッセージも書けるので、 メッセージを残すついでにダウン\nロードして行ってください。\n問題の指摘などがありましたら、GitHubやGitterに書いてくださると解決できます。\n• Issues · azu/promises-book\n114\n• azu/promises-book - Gitter\n115\n112\n https://gumroad.com/l/javascript-promise\n113\n https://gumroad.com/l/javascript-promise\n114\n https://github.com/azu/promises-book/issues?state=open\n115\n https://gitter.im/azu/promises-book","filePath":"./test/fixtures/pdf/javascript-promise-book.pdf","pageNumber":116},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:1","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"A\nLICE\n’\nS\nA\nDVENTURES\nIN\nW\nONDERLAND\nby Lewis Carroll\nwith fourty-two illustrations by John Tenniel\nThis book is in public domain.\nNo rigths reserved. Free for copy and distribution.\nThis PDF book is designed and published by PDF\nREE\nB\nOOKS\n.\nORG","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":1},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:2","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Contents\nPoem. All in the golden afternoon\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3\nI\nDown the Rabbit-Hole\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   4\nII    The Pool of Tears\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9\nIII   A Caucus-Race and a Long Tale\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nIV   The Rabbit Sends in a Little Bill\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19\nV    Advice from a Caterpillar\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nVI   Pig and Pepper\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  32\nVII  A Mad Tea-Party\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  39\nVIII  The Queen’s Croquet-Ground\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nIX   The Mock Turtle’s Story\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nX    The Lobster Quadrille\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\nXI   Who Stole the Tarts?\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\nXII  Alice’s Evidence\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n1","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":2},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:3","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":3},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:4","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Poem\nAll in the golden afternoon\nFull leisurely we glide;\nFor both our oars, with little skill,\nBy little arms are plied,\nWhile little hands make vain pretence\nOur wanderings to guide.\nAh, cruel Three! In such an hour,\nBeneath such dreamy weather,\nTo beg a tale of breath too weak\nTo stir the tiniest feather!\nYet what can one poor voice avail\nAgainst three tongues together?\nImperious Prima flashes forth\nHer edict ‘to begin it’ –\nIn gentler tone Secunda hopes\n‘There will be nonsense in it!’ –\nWhile Tertia interrupts the tale\nNot more than once a minute.\nAnon, to sudden silence won,\nIn fancy they pursue\nThe dream-child moving through a land\nOf wonders wild and new,\nIn friendly chat with bird or beast –\nAnd half believe it true.\nAnd ever, as the story drained\nThe wells of fancy dry,\nAnd faintly strove that weary one\nTo put the subject by,\n“The rest next time –” “It is next time!”\nThe happy voices cry.\nThus grew the tale of Wonderland:\nThus slowly, one by one,\nIts quaint events were hammered out –\nAnd now the tale is done,\nAnd home we steer, a merry crew,\nBeneath the setting sun.\nAlice! a childish story take,\nAnd with gentle hand\nLay it were Childhood’s dreams are twined\nIn Memory’s mystic band,\nLike pilgrim’s wither’d wreath of flowers\nPluck’d in a far-off land.\n3","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":4},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:5","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter I\nDown the Rabbit-Hole\nAlice was beginning to get very tired of sitting by her sister on the bank and\nof having nothing to do; once or twice she had peeped into the book her sister\nwas reading, but it had no pictures or conversations in it, ‘and what is the use of\na book,’ thought Alice, ‘without pictures or conversation?’\nSo she was considering in her own mind\n(as well as she could, for the hot day made\nher feel very sleepy and stupid), whether the\npleasure of making a daisy-chain would be\nworth the trouble of getting up and picking\nthe daisies, when suddenly a White Rabbit\nwith pink eyes ran close by her.\nThere was nothing so\nvery\nremarkable\nin that; nor did Alice think it so\nvery\nmuch\nout of the way to hear the Rabbit say to it-\nself, ‘Oh dear! Oh dear! I shall be late!’\n(when she thought it over afterwards, it oc-\ncurred to her that she ought to have won-\ndered at this, but at the time it all seemed\nquite natural); but when the Rabbit actu-\nally\ntook a watch out of its waistcoat-pocket\nand looked at it and then hurried on, Alice\nstarted to her feet, for it flashed across her\nmind that she had never before seen a rabbit\nwith either a waistcoat-pocket or a watch to take out of it, and burning with cu-\nriosity, she ran across the field after it, and fortunately was just in time to see it\npop down a large rabbit-hole under the hedge.\nIn another moment down went Alice after it, never once considering how in\nthe world she was to get out again.\n4","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":5},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:6","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER I.  DOWN THE RABBIT-HOLE\n5\nThe rabbit-hole went straight on like a tunnel for some way, and then dipped\nsuddenly down, so suddenly that Alice had not a moment to think about stopping\nherself before she found herself falling down a very deep well.\nEither the well was very deep, or she fell very slowly, for she had plenty of\ntime as she went down to look about her and to wonder what was going to happen\nnext. First, she tried to look down and make out what she was coming to, but it was\ntoo dark to see anything; then she looked at the sides of the well, and noticed that\nthey were filled with cupboards and book-shelves; here and there she saw maps\nand pictures hung upon pegs. She took down a jar from one of the shelves as she\npassed; it was labelled ‘O\nRANGE\nM\nARMALADE\n’, but to her great disappointment\nit was empty: she did not like to drop the jar for fear of killing somebody, so\nmanaged to put it into one of the cupboards as she fell past it.\n‘Well!’ thought Alice to herself, ‘after such a fall as this, I shall think nothing\nof tumbling down stairs! How brave they’ll all think me at home! Why, I wouldn’t\nsay anything about it, even if I fell off the top of the house!’ (Which was very\nlikely true.)\nDown, down, down. Would the fall\nnever\ncome to an end! ‘I wonder how\nmany miles I’ve fallen by this time?’ she said aloud. ‘I must be getting somewhere\nnear the centre of the earth. Let me see: that would be four thousand miles down,\nI think – ’ (for, you see, Alice had learnt several things of this sort in her lessons in\nthe schoolroom, and though this was not a\nvery\ngood opportunity for showing off\nher knowledge, as there was no one to listen to her, still it was good practice to say\nit over) ‘ – yes, that’s about the right distance – but then I wonder what Latitude or\nLongitude I’ve got to?’ (Alice had no idea what Latitude was or Longitude either,\nbut thought they were nice grand words to say.)\nPresently she began again. ‘I wonder if I shall fall right\nthrough\nthe earth!\nHow funny it’ll seem to come out among the people that walk with their heads\ndownward! The Antipathies, I think – ’ (she was rather glad there\nwas\nno one\nlistening, this time, as it didn’t sound at all the right word) ‘ – but I shall have to\nask them what the name of the country is, you know. Please, Ma’am, is this New\nZealand or Australia?’ (and she tried to curtsey as she spoke – fancy\ncurtseying\nas you’re falling through the air! Do you think you could manage it?) ‘And what\nan ignorant little girl she’ll think me for asking! No, it’ll never do to ask; perhaps\nI shall see it written up somewhere.’\nDown, down, down. There was nothing else to do, so Alice soon began talking\nagain. ‘Dinah’ll miss me very much to-night, I should think!’ (Dinah was the\ncat.) ‘I hope they’ll remember her saucer of milk at tea-time. Dinah my dear!\nI wish you were down here with me! There are no mice in the air, I’m afraid, but\nyou might catch a bat and that’s very like a mouse, you know. But do cats eat\nbats, I wonder?’ And here Alice began to get rather sleepy and went on saying\nto herself, in a dreamy sort of way, ‘Do cats eat bats? Do cats eat bats?’ and","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":6},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:7","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER I.  DOWN THE RABBIT-HOLE\n6\nsometimes, ‘Do bats eat cats?’ for, you see, as she couldn’t answer either question,\nit didn’t much matter which way she put it. She felt that she was dozing off and\nhad just begun to dream that she was walking hand in hand with Dinah and saying\nto her very earnestly, ‘Now, Dinah, tell me the truth: did you ever eat a bat?’ when\nsuddenly, thump! thump! down she came upon a heap of sticks and dry leaves\nand the fall was over.\nAlice was not a bit hurt and she jumped up on to her feet in a moment; she\nlooked up, but it was all dark overhead; before her was another long passage, and\nthe White Rabbit was still in sight, hurrying down it. There was not a moment\nto be lost; away went Alice like the wind and was just in time to hear it say, as it\nturned a corner, ‘Oh my ears and whiskers, how late it’s getting!’ She was close\nbehind it when she turned the corner, but the Rabbit was no longer to be seen; she\nfound herself in a long, low hall, which was lit up by a row of lamps hanging from\nthe roof.\nThere were doors all round the hall, but they were all locked; and when Alice\nhad been all the way down one side and up the other, trying every door, she walked\nsadly down the middle, wondering how she\nwas ever to get out again.\nSuddenly she came upon a little three-\nlegged table, all made of solid glass; there\nwas nothing on it except a tiny golden key\nand Alice’s first thought was that it might\nbelong to one of the doors of the hall, but,\nalas! either the locks were too large or the\nkey was too small, but at any rate it would\nnot open any of them. However, on the sec-\nond time round, she came upon a low cur-\ntain she had not noticed before and behind\nit was a little door about fifteen inches high;\nshe tried the little golden key in the lock and to her great delight it fitted!\nAlice opened the door and found that it led into a small passage, not much\nlarger than a rat-hole; she knelt down and looked along the passage into the loveli-\nest garden you ever saw. How she longed to get out of that dark hall, and wan-\nder about among those beds of bright flowers and those cool fountains, but she\ncould not even get her head through the doorway; ‘and even if my head would go\nthrough,’ thought poor Alice, ‘it would be of very little use without my shoulders.\nOh, how I wish I could shut up like a telescope! I think I could, if I only know\nhow to begin.’ For, you see, so many out-of-the-way things had happened lately,\nthat Alice had begun to think that very few things indeed were really impossible.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":7},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:8","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER I.  DOWN THE RABBIT-HOLE\n7\nThere seemed to be no use in wait-\ning by the little door, so she went back\nto the table, half hoping she might find\nanother key on it or at any rate a book\nof rules for shutting people up like tele-\nscopes; this time she found a little bot-\ntle on it, (‘which certainly was not here\nbefore,’ said Alice,) and round the neck\nof the bottle was a paper label, with the\nwords ‘D\nRINK\nM\nE\n’ beautifully printed\non it in large letters.\nIt was all very well to say ‘Drink me,’\nbut the wise little Alice was not going to\ndo\nthat\nin a hurry. ‘No, I’ll look first,’ she\nsaid, ‘and see whether it’s marked “poi-\nson” or not’; for she had read several nice\nlittle histories about children who had\ngot burnt, and eaten up by wild beasts\nand other unpleasant things, all because\nthey\nwould\nnot remember the simple rules their friends had taught them: such as,\nthat a red-hot poker will burn you if you hold it too long; and that if you cut your\nfinger\nvery\ndeeply with a knife, it usually bleeds; and she had never forgotten that,\nif you drink much from a bottle marked ‘poison,’ it is almost certain to disagree\nwith you, sooner or later.\nHowever, this bottle was\nnot\nmarked ‘poison,’ so Alice ventured to taste it and\nfinding it very nice, (it had, in fact, a sort of mixed flavour of cherry-tart, custard,\npine-apple, roast turkey, toffee and hot buttered toast) she very soon finished it off.\n*    *    *    *    *    *    *    *    *    *\n‘What a curious feeling!’ said Alice, ‘I must be shutting up like a telescope.’\nAnd so it was indeed: she was now only ten inches high and her face bright-\nened up at the thought that she was now the right size for going through the little\ndoor into that lovely garden. First, however, she waited for a few minutes to see\nif she was going to shrink any further; she felt a little nervous about this; ‘for\nit might end, you know,’ said Alice to herself, ‘in my going out altogether, like\na candle. I wonder what I should be like then?’ And she tried to fancy what the\nflame of a candle is like after the candle is blown out, for she could not remember\never having seen such a thing.\nAfter a while, finding that nothing more happened, she decided on going into\nthe garden at once; but, alas for poor Alice! when she got to the door, she found\nshe had forgotten the little golden key, and when she went back to the table for it,","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":8},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:9","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER I.  DOWN THE RABBIT-HOLE\n8\nshe found she could not possibly reach it; she could see it quite plainly through\nthe glass, and she tried her best to climb up one of the legs of the table, but it was\ntoo slippery; and when she had tired herself out with trying, the poor little thing\nsat down and cried.\n‘Come, there’s no use in crying like that!’ said Alice to herself, rather sharply,\n‘I advise you to leave off this minute!’ She generally gave herself very good\nadvice, (though she very seldom followed it), and sometimes she scolded herself\nso severely as to bring tears into her eyes; and once she remembered trying to\nbox her own ears for having cheated herself in a game of croquet she was playing\nagainst herself, for this curious child was very fond of pretending to be two people.\n‘But it’s no use now,’ thought poor Alice, ‘to pretend to be two people! Why,\nthere’s hardly enough of me left to make\none\nrespectable person!’\nSoon her eye fell on a little glass box that was lying under the table; she\nopened it, and found in it a very small cake, on which the words ‘E\nAT\nM\nE\n’ were\nbeautifully marked in currants. ‘Well, I’ll eat it,’ said Alice, ‘and if it makes me\ngrow larger, I can reach the key; and if it makes me grow smaller, I can creep under\nthe door; so either way I’ll get into the garden, and I don’t care which happens!’\nShe ate a little bit and said anxiously to herself, ‘Which way? Which way?’,\nholding her hand on the top of her head to feel which way it was growing, and\nshe was quite surprised to find that she remained the same size; to be sure, this\ngenerally happens when one eats cake, but Alice had got so much into the way of\nexpecting nothing but out-of-the-way things to happen, that it seemed quite dull\nand stupid for life to go on in the common way.\nSo she set to work, and very soon finished off the cake.\n*    *    *    *    *    *    *    *    *    *","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":9},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:10","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter II\nThe Pool of Tears\n‘Curiouser and curiouser!’  cried Alice (she was so\nmuch surprised, that for the moment she quite forgot\nhow to speak good English); ‘now I’m opening out like\nthe largest telescope that ever was! Good-bye, feet!’\n(for when she looked down at her feet, they seemed to\nbe almost out of sight, they were getting so far off). ‘Oh,\nmy poor little feet, I wonder who will put on your shoes\nand stockings for you now, dears? I’m sure\nI\nshan’t\nbe able! I shall be a great deal too far off to trouble\nmyself about you: you must manage the best way you\ncan; – but I must be kind to them,’ thought Alice, ‘or\nperhaps they won’t walk the way I want to go! Let me\nsee: I’ll give them a new pair of boots every Christmas.’\nAnd she went on planning to herself how she would\nmanage it. ‘They must go by the carrier,’ she thought,\n‘and how funny it’ll seem, sending presents to one’s\nown feet! And how odd the directions will look!\nA\nLICE\n’\nS\nR\nIGHT\nF\nOOT\n, E\nSQ\n.\nH\nEARTHRUG\n,\nN\nEAR THE\nF\nENDER\n,\n(\nWITH\nA\nLICE\n’\nS\nL\nOVE\n).\nOh dear, what nonsense I’m talking!’\nJust then her head struck against the roof of the hall;\nin fact she was now more than nine feet high and she at\nonce took up the little golden key and hurried off to the\ngarden door.\n9","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":10},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:11","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER II.  THE POOL OF TEARS\n10\nPoor Alice! It was as much as she could do, lying down on one side, to look\nthrough into the garden with one eye; but to get through was more hopeless than\never; she sat down and began to cry again.\n‘You ought to be ashamed of yourself,’ said Alice, ‘a great girl like you,’ (she\nmight well say this), ‘to go on crying in this way! Stop this moment, I tell you!’\nBut she went on all the same, shedding gallons of tears, until there was a large\npool all round her, about four inches deep and reaching half down the hall.\nAfter a time she heard a little pat-\ntering of feet in the distance and she\nhastily dried her eyes to see what\nwas coming. It was the White Rab-\nbit returning, splendidly dressed, with\na pair of white kid gloves in one hand\nand a large fan in the other; he came\ntrotting along in a great hurry, mutter-\ning to himself as he came, ‘Oh! the\nDuchess, the Duchess!  Oh!  won’t\nshe be savage if I’ve kept her wait-\ning!’ Alice felt so desperate that she\nwas ready to ask help of any one; so,\nwhen the Rabbit came near her, she\nbegan, in a low, timid voice, ‘If you\nplease, sir – ’ The Rabbit started vi-\nolently, dropped the white kid gloves and the fan, and skurried away into the\ndarkness as hard as he could go.\nAlice took up the fan and gloves, and, as the hall was very hot, she kept fanning\nherself all the time she went on talking, ‘Dear, dear! How queer everything is to-\nday! And yesterday things went on just as usual. I wonder if I’ve been changed\nin the night? Let me think: was I the same when I got up this morning? I almost\nthink I can remember feeling a little different. But if I’m not the same, the next\nquestion is, Who in the world am I? Ah,\nthat’s\nthe great puzzle!’ And she began\nthinking over all the children she knew that were of the same age as herself, to see\nif she could have been changed for any of them.\n‘I’m sure I’m not Ada,’ she said, ‘for her hair goes in such long ringlets, and\nmine doesn’t go in ringlets at all; and I’m sure I can’t be Mabel, for I know all\nsorts of things, and she, oh! she knows such a very little! Besides,\nshe’s\nshe, and\nI’m I, and – oh dear, how puzzling it all is! I’ll try if I know all the things I used\nto know. Let me see: four times five is twelve, and four times six is thirteen, and\nfour times seven is – oh dear! I shall never get to twenty at that rate! However, the\nMultiplication Table doesn’t signify; let’s try Geography. London is the capital\nof Paris, and Paris is the capital of Rome, and Rome – no,\nthat’s\nall wrong, I’m","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":11},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:12","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER II.  THE POOL OF TEARS\n11\ncertain! I must have been changed for Mabel! I’ll try and say “How doth the\nlittle – ” ’ and she crossed her hands on her lap as if she were saying lessons and\nbegan to repeat it, but her voice sounded hoarse and strange, and the words did\nnot come the same as they used to do:\n‘How doth the little crocodile\nImprove his shining tail,\nAnd pour the waters of the Nile\nOn every golden scale!\nHow cheerfully he seems to grin,\nHow neatly spread his claws,\nAnd welcome little fishes in\nWith gently smiling jaws!’\n‘I’m sure those are not the right words,’ said poor Alice, and her eyes filled\nwith tears again as she went on, ‘I must be Mabel after all, and I shall have to go\nand live in that poky little house and have next to no toys to play with, and oh! ever\nso many lessons to learn! No, I’ve made up my mind about it; if I’m Mabel, I’ll\nstay down here! It’ll be no use their putting their heads down and saying “Come\nup again, dear!” I shall only look up and say, “Who am I then? Tell me that first,\nand then, if I like being that person, I’ll come up: if not, I’ll stay down here till I’m\nsomebody else” – but, oh dear!’ cried Alice, with a sudden burst of tears, ‘I do\nwish they\nwould\nput their heads down! I am so\nvery\ntired of being all alone here!’\nAs she said this she looked down at her hands, and was surprised to see that\nshe had put on one of the Rabbit’s little white kid gloves while she was talking.\n‘How\ncan\nI have done that?’ she thought, ‘I must be growing small again.’ She\ngot up and went to the table to measure herself by it, and found that, as nearly\nas she could guess, she was now about two feet high and was going on shrinking\nrapidly; she soon found out that the cause of this was the fan she was holding, and\nshe dropped it hastily, just in time to avoid shrinking away altogether.\n‘That\nwas\na narrow escape!’ said Alice, a good deal frightened at the sudden\nchange, but very glad to find herself still in existence, ‘and now for the garden!’\nand she ran with all speed back to the little door; but, alas! the little door was\nshut again, and the little golden key was lying on the glass table as before, ‘and\nthings are worse than ever,’ thought the poor child, ‘for I never was so small as\nthis before, never! And I declare it’s too bad, that it is!’\nAs she said these words her foot slipped and in another moment, splash! she\nwas up to her chin in salt water. Her first idea was that she had somehow fallen into\nthe sea, ‘and in that case I can go back by railway,’ she said to herself. (Alice had\nbeen to the seaside once in her life, and had come to the general conclusion, that\nwherever you go to on the English coast you find a number of bathing machines","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":12},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:13","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER II.  THE POOL OF TEARS\n12\nin the sea, some children digging in\nthe sand with wooden spades, then\na row of lodging houses and behind\nthem a railway station.) However, she\nsoon made out that she was in the pool\nof tears which she had wept when she\nwas nine feet high.\n‘I wish I hadn’t cried so much!’\nsaid Alice, as she swam about, trying\nto find her way out, ‘I shall be pun-\nished for it now, I suppose, by being\ndrowned in my own tears! That\nwill\nbe a queer thing, to be sure! However,\neverything is queer to-day.’\nJust then she heard something splashing about in the pool a little way off, and\nshe swam nearer to make out what it was; at first she thought it must be a walrus\nor hippopotamus, but then she remembered how small she was now, and she soon\nmade out that it was only a mouse that had slipped in like herself.\n‘Would it be of any use, now,’ thought Alice, ‘to speak to this mouse? Every-\nthing is so out-of-the-way down here, that I should think very likely it can talk; at\nany rate, there’s no harm in try-\ning.’  So she began, ‘O Mouse,\ndo you know the way out of this\npool?  I am very tired of swim-\nming about here, O Mouse!’ (Al-\nice thought this must be the right\nway of speaking to a mouse; she\nhad never done such a thing be-\nfore, but she remembered having\nseen in her brother’s Latin Gram-\nmar, ‘A mouse – of a mouse – to a mouse – a mouse – O mouse!’) The Mouse\nlooked at her rather inquisitively, and seemed to her to wink with one of its little\neyes, but it said nothing.\n‘Perhaps it doesn’t understand English,’ thought Alice, ‘I daresay it’s a French\nmouse, come over with William the Conqueror.’ (For, with all her knowledge of\nhistory, Alice had no very clear notion how long ago anything had happened.) So\nshe began again: ‘O\n`\nu est ma chatte?’ which was the first sentence in her French\nlesson-book. The Mouse gave a sudden leap out of the water, and seemed to quiver\nall over with fright. ‘Oh, I beg your pardon!’ cried Alice hastily, afraid that she\nhad hurt the poor animal’s feelings. ‘I quite forgot you didn’t like cats.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":13},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:14","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER II.  THE POOL OF TEARS\n13\n‘Not like cats!’ cried the Mouse, in a shrill, passionate voice, ‘Would\nyou\nlike\ncats if you were me?’\n‘Well, perhaps not,’ said Alice in a soothing tone, ‘don’t be angry about it.\nAnd yet I wish I could show you our cat Dinah: I think you’d take a fancy to cats\nif you could only see her. She is such a dear quiet thing,’ Alice went on, half to\nherself, as she swam lazily about in the pool, ‘and she sits purring so nicely by the\nfire, licking her paws and washing her face – and she is such a nice soft thing to\nnurse – and she’s such a capital one for catching mice – oh, I beg your pardon!’\ncried Alice again, for this time the Mouse was bristling all over and she felt certain\nit must be really offended, ‘We won’t talk about her any more if you’d rather not.’\n‘We indeed!’ cried the Mouse, who was trembling down to the end of his tail,\n‘As if I would talk on such a subject! Our family always\nhated\ncats: nasty, low,\nvulgar things! Don’t let me hear the name again!’\n‘I won’t indeed!’ said Alice, in a great hurry to change the subject of con-\nversation, ‘Are you – are you fond – of – of dogs?’ The Mouse did not answer,\nso Alice went on eagerly, ‘There is such a nice little dog near our house I should\nlike to show you! A little bright-eyed terrier, you know, with oh, such long curly\nbrown hair! And it’ll fetch things when you throw them and it’ll sit up and beg for\nits dinner, and all sorts of things – I can’t remember half of them – and it belongs\nto a farmer, you know, and he says it’s so useful, it’s worth a hundred pounds! He\nsays it kills all the rats and – oh dear!’ cried Alice in a sorrowful tone, ‘I’m afraid\nI’ve offended it again!’ For the Mouse was swimming away from her as hard as it\ncould go, and making quite a commotion in the pool as it went.\nSo she called softly after it, ‘Mouse dear! Do come back again, and we won’t\ntalk about cats or dogs either, if you don’t like them!’ When the Mouse heard this,\nit turned round and swam slowly back to her; its face was quite pale (with passion,\nAlice thought) and it said in a low trembling voice, ‘Let us get to the shore, and\nthen I’ll tell you my history, and you’ll understand why it is I hate cats and dogs.’\nIt was high time to go, for the pool was getting quite crowded with the birds\nand animals that had fallen into it: there were a Duck and a Dodo, a Lory and an\nEaglet, and several other curious creatures. Alice led the way, and the whole party\nswam to the shore.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":14},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:15","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter III\nA Caucus-Race and a Long Tale\nThey were indeed a queer-looking party that assembled on the bank – the birds\nwith draggled feathers, the animals with their fur clinging close to them, and all\ndripping wet, cross, and uncomfortable.\nThe first question of course was, how to get dry again; they had a consultation\nabout this and after a few minutes it seemed quite natural to Alice to find herself\ntalking familiarly with them, as if she\nhad known them all her life. Indeed,\nshe had quite a long argument with\nthe Lory, who at last turned sulky, and\nwould only say, ‘I am older than you\nand must know better’; and this Al-\nice would not allow without knowing\nhow old it was and, as the Lory posi-\ntively refused to tell its age, there was\nno more to be said.\nAt last the Mouse, who seemed to\nbe a person of authority among them,\ncalled out, ‘Sit down, all of you, and\nlisten to me!\nI’ll\nsoon make you dry\nenough!’ They all sat down at once,\nin a large ring, with the Mouse in the\nmiddle. Alice kept her eyes anxiously fixed on it, for she felt sure she would catch\na bad cold if she did not get dry very soon.\n‘Ahem!’ said the Mouse with an important air, ‘are you all ready? This is the\ndriest thing I know. Silence all round, if you please! “William the Conqueror,\nwhose cause was favoured by the pope, was soon submitted to by the English,\nwho wanted leaders, and had been of late much accustomed to usurpation and\nconquest. Edwin and Morcar, the earls of Mercia and Northumbria – ” ’\n14","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":15},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:16","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER III.  A CAUCUS-RACE AND A LONG TALE\n15\n‘Ugh!’ said the Lory, with a shiver.\n‘I beg your pardon!’ said the Mouse, frowning, but very politely, ‘Did you\nspeak?’\n‘Not I!’ said the Lory hastily.\n‘I thought you did,’ said the Mouse, ‘ – I proceed. “Edwin and Morcar, the\nearls of Mercia and Northumbria, declared for him; and even Stigand, the patriotic\narchbishop of Canterbury, found it advisable – ” ’\n‘Found\nwhat\n?’ said the Duck.\n‘Found\nit\n,’ the Mouse replied rather crossly, ‘of course you know what “it”\nmeans.’\n‘I know what “it” means well enough when I find a thing,’ said the Duck, ‘it’s\ngenerally a frog or a worm. The question is, what did the archbishop find?’\nThe Mouse did not notice this question, but hurriedly went on, ‘ “ – found it\nadvisable to go with Edgar Atheling to meet William and offer him the crown.\nWilliam’s conduct at first was moderate. But the insolence of his Normans – ”\nHow are you getting on now, my dear?’ it continued, turning to Alice as it spoke.\n‘As wet as ever,’ said Alice in a melancholy tone, ‘it doesn’t seem to dry me\nat all.’\n‘In that case,’ said the Dodo solemnly, rising to its feet, ‘I move that the meet-\ning adjourn, for the immediate adoption of more energetic remedies – ’\n‘Speak English!’ said the Eaglet, ‘I don’t know the meaning of half those long\nwords, and, what’s more, I don’t believe you do either!’ And the Eaglet bent down\nits head to hide a smile; some of the other birds tittered audibly.\n‘What I was going to say,’ said the Dodo in an offended tone, ‘was, that the\nbest thing to get us dry would be a Caucus-race.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":16},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:17","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER III.  A CAUCUS-RACE AND A LONG TALE\n16\n‘What\nis\na Caucus-race?’ said Alice; not that she wanted much to know, but\nthe Dodo had paused as if it thought that\nsomebody\nought to speak, and no one\nelse seemed inclined to say anything.\n‘Why,’ said the Dodo, ‘the best way to explain it is to do it.’ (And, as you\nmight like to try the thing yourself, some winter day, I will tell you how the Dodo\nmanaged it.)\nFirst it marked out a race-course, in a sort of circle (‘the exact shape doesn’t\nmatter,’ it said), and then all the party were placed along the course, here and\nthere. There was no ‘One, two, three, and away,’ but they began running when\nthey liked, and left off when they liked, so that it was not easy to know when the\nrace was over. However, when they had been running half an hour or so, and were\nquite dry again, the Dodo suddenly called out ‘The race is over!’ and they all\ncrowded round it, panting, and asking, ‘But who has won?’\nThis question the Dodo could not answer without a great deal of thought, and\nit sat for a long time with one finger pressed upon its forehead (the position in\nwhich you usually see Shakespeare, in the pictures of him), while the rest waited\nin silence. At last the Dodo said, ‘\neverybody\nhas won, and all must have prizes.’\n‘But who is to give the prizes?’ quite a chorus of voices asked.\n‘Why,\nshe\n, of course,’ said the Dodo, pointing to Alice with one finger; and\nthe whole party at once crowded round her, calling out in a confused way, ‘Prizes!\nPrizes!’\nAlice had no idea what to do, and in despair she put her hand in her pocket,\nand pulled out a box of comfits, (luckily the salt water had not got into it), and\nhanded them round as prizes. There was exactly one a-piece all round.\n‘But she must have a prize herself, you know,’ said the Mouse.\n‘Of course,’ the Dodo replied very gravely, ‘What else have you got in your\npocket?’ he went on, turning to Alice.\n‘Only a thimble,’ said Alice sadly.\n‘Hand it over here,’ said the Dodo.\nThen they all crowded round her once more, while the Dodo solemnly pre-\nsented the thimble, saying, ‘We beg your acceptance of this elegant thimble’; and,\nwhen it had finished this short speech, they all cheered.\nAlice thought the whole thing very absurd, but they all looked so grave that\nshe did not dare to laugh; and, as she could not think of anything to say, she simply\nbowed, and took the thimble, looking as solemn as she could.\nThe next thing was to eat the comfits; this caused some noise and confusion,\nas the large birds complained that they could not taste theirs and the small ones\nchoked and had to be patted on the back. However, it was over at last and they sat\ndown again in a ring and begged the Mouse to tell them something more.\n‘You promised to tell me your history, you know,’ said Alice, ‘and why it is you\nhate – C and D,’ she added in a whisper, half afraid that it would be offended again.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":17},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:18","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER III.  A CAUCUS-RACE AND A LONG TALE\n17\n‘Mine is a long and a sad tale!’ said the Mouse, turning to Alice and sighing.\n‘It\nis\na long tail, certainly,’ said Alice, looking down with wonder at the\nMouse’s tail; ‘but why do you call it sad?’ And she kept on puzzling about it while\nthe Mouse was speaking, so that her idea of the tale was something like this:\n‘Fury said to\na mouse, That he\nmet in the\nhouse,\n“Let us\nboth go to\nlaw: I will\nprosecute\nyou\n.  – Come,\nI’ll take no\ndenial; We\nmust have\na trial: For\nreally this\nmorning I’ve\nnothing\nto do.”\nSaid the\nmouse to the\ncur, “Such a trial,\ndear Sir,\nWith\nno jury\nor judge,\nwould be\nwasting\nour\nbreath.”\n“I’ll be\njudge, I’ll\nbe jury,”\nSaid\ncunning\nold Fury:\n“I’ll\ntry the\nwhole\ncause,\nand\ncondemn\nyou\nto\ndeath.” ’\n‘You are not attending!’ said the Mouse to Alice severely, ‘What are you\nthinking of?’\n‘I beg your pardon,’ said Alice very humbly, ‘you had got to the fifth bend,\nI think?’\n‘I had\nnot\n!’ cried the Mouse, sharply and very angrily.\n‘A knot!’ said Alice, always ready to make herself useful, and looking anx-\niously about her, ‘Oh, do let me help to undo it!’\n‘I shall do nothing of the sort,’ said the Mouse, getting up and walking away,\n‘You insult me by talking such nonsense!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":18},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:19","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER III.  A CAUCUS-RACE AND A LONG TALE\n18\n‘I didn’t mean it!’ pleaded poor Alice. ‘But you’re so easily offended, you\nknow!’\nThe Mouse only growled in reply.\n‘Please come back and finish your story!’ Alice called after it, and the others\nall joined in chorus, ‘Yes, please do!’ but the Mouse only shook its head impa-\ntiently, and walked a little quicker.\n‘What a pity it wouldn’t stay!’ sighed the Lory as soon as it was quite out of\nsight; and an old Crab took the opportunity of saying to her daughter, ‘Ah, my\ndear! Let this be a lesson to you never to lose\nyour\ntemper!’ – ‘Hold your tongue,\nMa!’ said the young Crab, a little snappishly, ‘You’re enough to try the patience\nof an oyster!’\n‘I wish I had our Dinah here, I know I do!’ said Alice aloud, addressing\nnobody in particular, ‘She’d soon fetch it back!’\n‘And who is Dinah, if I might venture to ask the question?’ said the Lory.\nAlice replied eagerly, for she was always ready to talk about her pet, ‘Dinah’s\nour cat. And she’s such a capital one for catching mice you can’t think! And oh,\nI wish you could see her after the birds! Why, she’ll eat a little bird as soon as\nlook at it!’\nThis speech caused a remarkable sensation among the party. Some of the\nbirds hurried off at once; one old Magpie began wrapping itself up very carefully,\nremarking, ‘I really must be getting home; the night-air doesn’t suit my throat!’\nand a Canary called out in a trembling voice to its children, ‘Come away, my\ndears! It’s high time you were all in bed!’ On various pretexts they all moved off,\nand Alice was soon left alone.\n‘I wish I hadn’t mentioned Dinah!’ she said to herself in a melancholy tone,\n‘Nobody seems to like her, down here, and I’m sure she’s the best cat in the world!\nOh, my dear Dinah! I wonder if I shall ever see you any more!’ And here poor\nAlice began to cry again, for she felt very lonely and low-spirited. In a little\nwhile, however, she again heard a little pattering of footsteps in the distance and\nshe looked up eagerly, half hoping that the Mouse had changed his mind, and was\ncoming back to finish his story.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":19},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:20","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter IV\nThe Rabbit Sends in a Little Bill\nIt was the White Rabbit, trotting slowly back again, and looking anxiously about\nas it went, as if it had lost something; and she heard it muttering to itself, ‘The\nDuchess! The Duchess! Oh my dear paws! Oh my fur and whiskers! She’ll\nget me executed, as sure as ferrets are ferrets! Where\ncan\nI have dropped them,\nI wonder?’ Alice guessed in a moment that it was looking for the fan and the pair\nof white kid gloves, and she very good-naturedly began hunting about for them,\nbut they were nowhere to be seen – everything seemed to have changed since her\nswim in the pool, and the great hall, with the glass table and the little door, had\nvanished completely.\nVery soon the Rabbit noticed Alice, as she went hunting about, and called out\nto her in an angry tone, ‘Why, Mary Ann, what\nare\nyou doing out here? Run\nhome this moment, and fetch me a pair of gloves and a fan! Quick, now!’ And\nAlice was so much frightened that she ran off at once in the direction it pointed\nto, without trying to explain the mistake it had made.\n‘He took me for his housemaid,’ she said to herself as she ran. ‘How surprised\nhe’ll be when he finds out who I am! But I’d better take him his fan and gloves –\nthat is, if I can find them.’ As she said this, she came upon a neat little house, on\nthe door of which was a bright brass plate with the name ‘W. R\nABBIT\n’ engraved\nupon it. She went in without knocking and hurried upstairs, in great fear lest she\nshould meet the real Mary Ann, and be turned out of the house before she had\nfound the fan and gloves.\n‘How queer it seems,’ Alice said to herself, ‘to be going messages for a rabbit!\nI suppose Dinah’ll be sending me on messages next!’ And she began fancying the\nsort of thing that would happen: ‘ “Miss Alice! Come here directly, and get ready\nfor your walk!” – “Coming in a minute, nurse! But I’ve got to see that the mouse\ndoesn’t get out.” Only I don’t think,’ Alice went on, ‘that they’d let Dinah stop in\nthe house if it began ordering people about like that!’\n19","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":20},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:21","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IV.  THE RABBIT SENDS IN A LITTLE BILL\n20\nBy this time she had found her way into a tidy little room with a table in the\nwindow, and on it (as she had hoped) a fan and two or three pairs of tiny white kid\ngloves; she took up the fan and a pair of the gloves, and was just going to leave\nthe room, when her eye fell upon a little bottle that stood near the looking-glass.\nThere was no label this time with the words ‘D\nRINK\nM\nE\n,’ but nevertheless she\nuncorked it and put it to her lips. ‘I know\nsomething\ninteresting is sure to happen,’\nshe said to herself, ‘whenever I eat or drink anything; so I’ll just see what this\nbottle does. I do hope it’ll make me grow large again, for really I’m quite tired of\nbeing such a tiny little thing!’\nIt did so indeed, and much sooner than she had expected; before she had drunk\nhalf the bottle, she found her head pressing against the ceiling and had to stoop\nto save her neck from being broken. She hastily put down the bottle, saying to\nherself ‘That’s quite enough – I hope I shan’t grow any more – As it is, I can’t get\nout at the door – I do wish I hadn’t drunk quite so much!’\nAlas! it was too late to wish that! She went on growing and growing and very\nsoon had to kneel down on the floor; in another minute there was not even room\nfor this and she tried the effect of\nlying down with one elbow against\nthe door, and the other arm curled\nround her head. Still she went on\ngrowing, and, as a last resource,\nshe put one arm out of the win-\ndow, and one foot up the chimney,\nand said to herself ‘Now I can do\nno more, whatever happens. What\nwill\nbecome of me?’\nLuckily for Alice, the little\nmagic bottle had now had its full effect, and she grew no larger; still it was very\nuncomfortable, and, as there seemed to be no sort of chance of her ever getting\nout of the room again, no wonder she felt unhappy.\n‘It was much pleasanter at home,’ thought poor Alice, ‘when one wasn’t al-\nways growing larger and smaller, and being ordered about by mice and rabbits.\nI almost wish I hadn’t gone down that rabbit-hole – and yet – and yet – it’s rather\ncurious, you know, this sort of life! I do wonder what\ncan\nhave happened to me!\nWhen I used to read fairy-tales, I fancied that kind of thing never happened, and\nnow here I am in the middle of one! There ought to be a book written about me,\nthat there ought! And when I grow up, I’ll write one – but I’m grown up now,’ she\nadded in a sorrowful tone, ‘at least there’s no room to grow up any more\nhere\n.’\n‘But then,’ thought Alice, ‘shall I\nnever\nget any older than I am now? That’ll\nbe a comfort, one way – never to be an old woman – but then – always to have\nlessons to learn! Oh, I shouldn’t like\nthat\n!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":21},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:22","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IV.  THE RABBIT SENDS IN A LITTLE BILL\n21\n‘Oh, you foolish Alice!’ she answered herself, ‘How can you learn lessons in\nhere? Why, there’s hardly room for\nyou\n, and no room at all for any lesson-books!’\nAnd so she went on, taking first one side and then the other, and making quite\na conversation of it altogether; but after a few minutes she heard a voice outside\nand stopped to listen.\n‘Mary Ann! Mary Ann!’ said the voice, ‘Fetch me my gloves this moment!’\nThen came a little pattering of feet on the stairs. Alice knew it was the Rabbit\ncoming to look for her, and she trembled till she shook the house, quite forgetting\nthat she was now about a thousand times as large as the Rabbit and had no reason\nto be afraid of it.\nPresently the Rabbit came up to the door and tried to open it; but, as the door\nopened inwards and Alice’s elbow was pressed hard against it, that attempt proved\na failure. Alice heard it say to itself, ‘Then I’ll go round and get in at the window.’\n‘\nThat\nyou won’t’ thought Alice\nand, after waiting till she fancied she\nheard the Rabbit just under the win-\ndow, she suddenly spread out her\nhand, and made a snatch in the air.\nShe did not get hold of anything, but\nshe heard a little shriek and a fall and\na crash of broken glass, from which\nshe concluded that it was just possible\nit had fallen into a cucumber-frame or\nsomething of the sort.\nNext came an angry voice – the\nRabbit’s – ‘Pat! Pat! Where are you?’\nAnd then a voice she had never heard\nbefore, ‘Sure then I’m here! Digging\nfor apples, yer honour!’\n‘Digging for apples, indeed!’ said\nthe Rabbit angrily, ‘Here! Come and\nhelp me out of\nthis\n!’ (Sounds of more\nbroken glass.)\n‘Now tell me, Pat, what’s that in the window?’\n‘Sure, it’s an arm, yer honour!’ (He pronounced it ‘arrum.’)\n‘An arm, you goose! Who ever saw one that size? Why, it fills the whole\nwindow!’\n‘Sure, it does, yer honour; but it’s an arm for all that.’\n‘Well, it’s got no business there, at any rate; go and take it away!’\nThere was a long silence after this and Alice could only hear whispers now and\nthen; such as, ‘Sure, I don’t like it, yer honour, at all, at all!’ – ‘Do as I tell you,","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":22},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:23","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IV.  THE RABBIT SENDS IN A LITTLE BILL\n22\nyou coward!’ and at last she spread out her hand again and made another snatch\nin the air. This time there were\ntwo\nlittle shrieks and more sounds of broken glass.\n‘What a number of cucumber-frames there must be!’ thought Alice, ‘I wonder\nwhat they’ll do next! As for pulling me out of the window, I only wish they\ncould\n! I’m sure I don’t want to stay in here any longer!’\nShe waited for some time without hearing anything more; at last came a rum-\nbling of little cartwheels and the sound of a good many voices all talking together;\nshe made out the words: ‘Where’s the other ladder? – Why, I hadn’t to bring but\none; Bill’s got the other – Bill! fetch it here, lad! – Here, put ’em up at this corner –\nNo, tie ’em together first – they don’t reach half high enough yet – Oh! they’ll do\nwell enough; don’t be particular – Here, Bill! catch hold of this rope – Will the\nroof bear? – Mind that loose slate – Oh, it’s coming down! Heads below!’ (a loud\ncrash) ‘Now, who did that? – It was Bill, I fancy – Who’s to go down the chim-\nney? – Nay, I shan’t!\nyou\ndo it! – That I won’t, then! – Bill’s to go down – Here,\nBill! the master says you’re to go down the chimney!’\n‘Oh! So Bill’s got to come down the chimney, has\nhe?’ said Alice to herself, ‘Shy, they seem to put every-\nthing upon Bill! I wouldn’t be in Bill’s place for a good\ndeal: this fireplace is narrow, to be sure; but I\nthink\nI can\nkick a little!’\nShe drew her foot as far down the chimney as she\ncould and waited till she heard a little animal (she\ncouldn’t guess of what sort it was) scratching and\nscrambling about in the chimney close above her; then,\nsaying to herself, ‘This is Bill,’ she gave one sharp kick\nand waited to see what would happen next.\nThe first thing she heard was a general chorus of\n‘There goes Bill!’  then the Rabbit’s voice along –\n‘Catch him, you by the hedge!’; then silence, and then\nanother confusion of voices – ‘Hold up his head – Bran-\ndy now – Don’t choke him – How was it, old fellow?\nWhat happened to you? Tell us all about it!’\nLast came a little feeble, squeaking voice, (‘That’s\nBill,’ thought Alice,) ‘Well, I hardly know – No more,\nthank ye; I’m better now – but I’m a deal too flustered\nto tell you – all I know is, something comes at me like\na Jack-in-the-box, and up I goes like a sky-rocket!’\n‘So you did, old fellow!’ said the others.\n‘We must burn the house down!’ said the Rabbit’s voice; and Alice called out\nas loud as she could, ‘If you do I’ll set Dinah at you!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":23},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:24","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IV.  THE RABBIT SENDS IN A LITTLE BILL\n23\nThere was a dead silence instantly and Alice thought to herself, ‘I wonder\nwhat they\nwill\ndo next! If they had any sense, they’d take the roof off.’ After\na minute or two they began moving about again, and Alice heard the Rabbit say,\n‘A barrowful will do, to begin with.’\n‘A barrowful of\nwhat\n?’ thought Alice; but she had not long to doubt, for the\nnext moment a shower of little pebbles came rattling in at the window and some\nof them hit her in the face. ‘I’ll put a stop to this,’ she said to herself and shouted\nout, ‘You’d better not do that again!’ which produced another dead silence.\nAlice noticed with some surprise that the pebbles were all turning into little\ncakes as they lay on the floor, and a bright idea came into her head. ‘If I eat one\nof these cakes,’ she thought, ‘it’s sure to make\nsome\nchange in my size; and as it\ncan’t possibly make me larger, it must make me smaller, I suppose.’\nSo she swallowed one of the cakes and was delighted to find that she began\nshrinking directly. As soon as she was small enough to get through the door, she\nran out of the house, and found quite a crowd of little animals and birds waiting\noutside. The poor little Lizard, Bill, was in the middle, being held up by two\nguinea-pigs, who were giving it something out of a bottle. They all made a rush\nat Alice the moment she appeared; but she ran off as hard as she could, and soon\nfound herself safe in a thick wood.\n‘The first thing I’ve got to do,’ said Alice to herself, as she wandered about in\nthe wood, ‘is to grow to my right size again; and the second thing is to find my\nway into that lovely garden. I think that will be the best plan.’\nIt sounded an excellent plan, no doubt, and very neatly and simply arranged;\nthe only difficulty was, that she had not the smallest idea how to set about it; and\nwhile she was peering about anx-\niously among the trees, a little sharp\nbark just over her head made her look\nup in a great hurry.\nAn enormous puppy was looking\ndown at her with large round eyes,\nand feebly stretching out one paw, try-\ning to touch her. ‘Poor little thing!’\nsaid Alice in a coaxing tone and she\ntried hard to whistle to it; but she was\nterribly frightened all the time at the\nthought that it might be hungry, in\nwhich case it would be very likely to\neat her up in spite of all her coaxing.\nHardly knowing what she did she\npicked up a little bit of stick and held\nit out to the puppy; whereupon the","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":24},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:25","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IV.  THE RABBIT SENDS IN A LITTLE BILL\n24\npuppy jumped into the air off all its feet at once with a yelp of delight, and rushed\nat the stick and made believe to worry it; then Alice dodged behind a great thistle,\nto keep herself from being run over; and the moment she appeared on the other\nside, the puppy made another rush at the stick, and tumbled head over heels in\nits hurry to get hold of it; then Alice, thinking it was very like having a game\nof play with a cart-horse, and expecting every moment to be trampled under its\nfeet, ran round the thistle again; then the puppy began a series of short charges at\nthe stick, running a very little way forwards each time and a long way back and\nbarking hoarsely all the while, till at last it sat down a good way off, panting, with\nits tongue hanging out of its mouth and its great eyes half shut.\nThis seemed to Alice a good opportunity for making her escape; so she set off\nat once and ran till she was quite tired and out of breath and till the puppy’s bark\nsounded quite faint in the distance.\n‘And yet what a dear little puppy it was!’ said Alice, as she leant against\na buttercup to rest herself, and fanned herself with one of the leaves, ‘I should\nhave liked teaching it tricks very much, if – if I’d only been the right size to do it!\nOh dear! I’d nearly forgotten that I’ve got to grow up again! Let me see – how\nis\nit to be managed? I suppose I ought to eat or drink something or other; but the\ngreat question is, what?’\nThe great question certainly was, what? Alice looked all round her at the\nflowers and the blades of grass, but she did not see anything that looked like the\nright thing to eat or drink under the circumstances. There was a large mushroom\ngrowing near her, about the same height as herself; and when she had looked\nunder it, and on both sides of it, and behind it, it occurred to her that she might as\nwell look and see what was on the top of it.\nShe stretched herself up on tiptoe, and peeped over the edge of the mushroom,\nand her eyes immediately met those of a large caterpillar, that was sitting on the\ntop with its arms folded, quietly smoking a long hookah, and taking not the small-\nest notice of her or of anything else.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":25},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:26","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter V\nAdvice from a Caterpillar\nThe Caterpillar and Alice looked at each other for some time in silence; at last\nthe Caterpillar took the hookah out of its mouth and addressed her in a languid,\nsleepy voice.\n‘Who are\nyou\n?’ said the Caterpillar.\nThis  was  not  an  encouraging\nopening for a conversation.  Alice\nreplied, rather shyly, ‘I – I hardly\nknow, sir, just at present – at least\nI know who I\nwas\nwhen I got up this\nmorning, but I think I must have been\nchanged several times since then.’\n‘What do you mean by that?’ said\nthe Caterpillar sternly, ‘Explain your-\nself!’\n‘I can’t explain\nmyself\n, I’m afraid,\nsir’ said Alice, ‘because I’m not my-\nself, you see.’\n‘I don’t see,’ said the Caterpillar.\n‘I’m afraid I can’t put it more\nclearly,’ Alice replied very politely,\n‘for I can’t understand it myself to be-\ngin with; and being so many different sizes in a day is very confusing.’\n‘It isn’t,’ said the Caterpillar.\n‘Well, perhaps you haven’t found it so yet,’ said Alice, ‘but when you have\nto turn into a chrysalis – you will some day, you know – and then after that into\na butterfly, I should think you’ll feel it a little queer, won’t you?’\n‘Not a bit,’ said the Caterpillar.\n‘Well, perhaps your feelings may be different,’ said Alice, ‘all I know is, it\n25","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":26},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:27","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n26\nwould feel very queer to\nme\n.’\n‘You!’ said the Caterpillar contemptuously, ‘Who are\nyou\n?’\nWhich brought them back again to the beginning of the conversation. Alice\nfelt a little irritated at the Caterpillar’s making such\nvery\nshort remarks and she\ndrew herself up and said, very gravely, ‘I think, you ought to tell me who\nyou\nare,\nfirst.’\n‘Why?’ said the Caterpillar.\nHere was another puzzling question; and as Alice could not think of any good\nreason, and as the Caterpillar seemed to be in a\nvery\nunpleasant state of mind, she\nturned away.\n‘Come back!’ the Caterpillar called after her, ‘I’ve something important to\nsay!’\nThis sounded promising, certainly; Alice turned and came back again.\n‘Keep your temper,’ said the Caterpillar.\n‘Is that all?’ said Alice, swallowing down her anger as well as she could.\n‘No,’ said the Caterpillar.\nAlice thought she might as well wait, as she had nothing else to do, and per-\nhaps after all it might tell her something worth hearing. For some minutes it puffed\naway without speaking, but at last it unfolded its arms, took the hookah out of its\nmouth again and said, ‘So you think you’re changed, do you?’\n‘I’m afraid I am, sir,’ said Alice, ‘I can’t remember things as I used – and\nI don’t keep the same size for ten minutes together!’\n‘Can’t remember\nwhat\nthings?’ said the Caterpillar.\n‘Well, I’ve tried to say “H\nOW\nD\nOTH\nT\nHE\nL\nITTLE\nB\nUSY\nB\nEE\n,” but it all came\ndifferent!’ Alice replied in a very melancholy voice.\n‘Repeat “Y\nOU\nA\nRE\nO\nLD\n, F\nATHER\nW\nILLIAM\n,” ’ said the Caterpillar.\nAlice folded her hands, and began:\n‘You are old, Father William,’ the young man said,\n‘And your hair has become very white;\nAnd yet you incessantly stand on your head –\nDo you think, at your age, it is right?’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":27},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:28","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n27\n‘In my youth,’ Father William replied to his son,\n‘I feared it might injure the brain;\nBut, now that I’m perfectly sure I have none,\nWhy, I do it again and again.’\n‘You are old,’ said the youth, ‘as I mentioned before,\nAnd have grown most uncommonly fat;\nYet you turned a back-somersault in at the door –\nPray, what is the reason of that?’\n‘In my youth,’ said the sage, as he shook his grey locks,\n‘I kept all my limbs very supple\nBy the use of this ointment – one shilling the box –\nAllow me to sell you a couple?’\n‘You are old,’ said the youth, ‘and your jaws are too weak\nFor anything tougher than suet;\nYet you finished the goose, with the bones and the beak –\nPray how did you manage to do it?’\n‘In my youth,’ said his father, ‘I took to the law,\nAnd argued each case with my wife;\nAnd the muscular strength, which it gave to my jaw,\nHas lasted the rest of my life.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":28},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:29","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n28\n‘You are old,’ said the youth, ‘one would hardly suppose\nThat your eye was as steady as ever;\nYet you balanced an eel on the end of your nose –\nWhat made you so awfully clever?’\n‘I have answered three questions, and that is enough,’\nSaid his father; ‘don’t give yourself airs!\nDo you think I can listen all day to such stuff?\nBe off, or I’ll kick you down stairs!’\n‘That is not said right,’ said the Caterpillar.\n‘Not\nquite\nright, I’m afraid,’ said Alice, timidly, ‘some of the words have got\naltered.’\n‘It is wrong from beginning to end,’ said the Caterpillar decidedly, and there\nwas silence for some minutes.\nThe Caterpillar was the first to speak.\n‘What size do you want to be?’ it asked.\n‘Oh, I’m not particular as to size,’ Alice hastily replied, ‘only one doesn’t like\nchanging so often, you know.’\n‘I\ndon’t\nknow,’ said the Caterpillar.\nAlice said nothing: she had never been so much contradicted in her life before\nand she felt that she was losing her temper.\n‘Are you content now?’ said the Caterpillar.\n‘Well, I should like to be a\nlittle\nlarger, sir, if you wouldn’t mind,’ said Alice,\n‘three inches is such a wretched height to be.’\n‘It is a very good height indeed!’ said the Caterpillar angrily, rearing itself\nupright as it spoke (it was exactly three inches high).\n‘But I’m not used to it!’ pleaded poor Alice in a piteous tone. And she thought\nof herself, ‘I wish the creatures wouldn’t be so easily offended!’\n‘You’ll get used to it in time,’ said the Caterpillar; and it put the hookah into\nits mouth and began smoking again.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":29},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:30","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n29\nThis time Alice waited patiently until it chose to speak again. In a minute or\ntwo the Caterpillar took the hookah out of its mouth and yawned once or twice\nand shook itself. Then it got down off the mushroom, and crawled away in the\ngrass, merely remarking as it went, ‘One side will make you grow taller and the\nother side will make you grow shorter.’\n‘One side of\nwhat\n? The other side of\nwhat\n?’ thought Alice to herself.\n‘Of the mushroom,’ said the Caterpillar, just as if she had asked it aloud; and\nin another moment it was out of sight.\nAlice remained looking thoughtfully at the mushroom for a minute, trying to\nmake out which were the two sides of it; and as it was perfectly round, she found\nthis a very difficult question. However, at last she stretched her arms round it as\nfar as they would go and broke off a bit of the edge with each hand.\n‘And now which is which?’ she said to herself and nibbled a little of the right-\nhand bit to try the effect; the next moment she felt a violent blow underneath her\nchin: it had struck her foot!\nShe was a good deal frightened by this very sudden change, but she felt that\nthere was no time to be lost, as she was shrinking rapidly; so she set to work at\nonce to eat some of the other bit. Her chin was pressed so closely against her foot,\nthat there was hardly room to open her mouth; but she did it at last and managed\nto swallow a morsel of the lefthand bit.\n*    *    *    *    *    *    *    *    *    *\n‘Come, my head’s free at last!’ said Alice in a tone of delight, which changed\ninto alarm in another moment, when she found that her shoulders were nowhere\nto be found: all she could see, when she looked down, was an immense length\nof neck, which seemed to rise like a stalk out of a sea of green leaves that lay far\nbelow her.\n‘What\ncan\nall that green stuff be?’ said Alice, ‘and where\nhave\nmy shoulders\ngot to? And oh, my poor hands, how is it I can’t see you?’ She was moving them\nabout as she spoke, but no result seemed to follow, except a little shaking among\nthe distant green leaves.\nAs there seemed to be no chance of getting her hands up to her head, she\ntried to get her head down to them, and was delighted to find that her neck\nwould bend about easily in any direction like a serpent. She had just succeeded\nin curving it down into a graceful zigzag and was going to dive in among the\nleaves, which she found to be nothing but the tops of the trees under which\nshe had been wandering, when a sharp hiss made her draw back in a hurry:\na large pigeon had flown into her face, and was beating her violently with its\nwings.\n‘Serpent!’ screamed the Pigeon.\n‘I’m\nnot\na serpent!’ said Alice indignantly, ‘let me alone!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":30},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:31","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n30\n‘Serpent, I say again!’ repeated the Pigeon, but in a more subdued tone, and\nadded with a kind of sob, ‘I’ve tried every way, and nothing seems to suit them!’\n‘I haven’t the least idea what you’re talking about,’ said Alice.\n‘I’ve tried the roots of trees, and I’ve tried banks, and I’ve tried hedges,’ the\nPigeon went on, without attending to her, ‘but those serpents! There’s no pleasing\nthem!’\nAlice was more and more puzzled, but she thought there was no use in saying\nanything more till the Pigeon had finished.\n‘As if it wasn’t trouble enough hatching the eggs,’ said the Pigeon, ‘but I must\nbe on the look-out for serpents night and day! Why, I haven’t had a wink of sleep\nthese three weeks!’\n‘I’m very sorry you’ve been annoyed,’ said Alice, who was beginning to see\nits meaning.\n‘And just as I’d taken the highest tree in the wood,’ continued the Pigeon,\nraising its voice to a shriek, ‘and just as I was thinking I should be free of them at\nlast, they must needs come wriggling down from the sky! Ugh, Serpent!’\n‘But I’m\nnot\na serpent, I tell you!’ said Alice, ‘I’m a – I’m a – ’\n‘Well!\nWhat\nare you?’ said the Pigeon, ‘I can see you’re trying to invent\nsomething!’\n‘I – I’m a little girl,’ said Alice, rather doubtfully, as she remembered the\nnumber of changes she had gone through that day.\n‘A likely story indeed!’ said the Pigeon in a tone of the deepest contempt,\n‘I’ve seen a good many little girls in my time, but never\none\nwith such a neck as\nthat! No, no! You’re a serpent; and there’s no use denying it. I suppose you’ll be\ntelling me next that you never tasted an egg!’\n‘I\nhave\ntasted eggs, certainly,’ said Alice, who was a very truthful child, ‘but\nlittle girls eat eggs quite as much as serpents do, you know.’\n‘I don’t believe it,’ said the Pigeon, ‘but if they do, why then they’re a kind of\nserpent, that’s all I can say.’\nThis was such a new idea to Alice, that she was quite silent for a minute or\ntwo, which gave the Pigeon the opportunity of adding, ‘You’re looking for eggs,\nI know\nthat\nwell enough; and what does it matter to me whether you’re a little girl\nor a serpent?’\n‘It matters a good deal to\nme\n,’ said Alice hastily, ‘but I’m not looking for eggs,\nas it happens; and if I was, I shouldn’t want\nyours\n: I don’t like them raw.’\n‘Well, be off, then!’ said the Pigeon in a sulky tone, as it settled down again\ninto its nest. Alice crouched down among the trees as well as she could, for her\nneck kept getting entangled among the branches, and every now and then she had\nto stop and untwist it. After a while she remembered that she still held the pieces\nof mushroom in her hands and she set to work very carefully, nibbling first at one","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":31},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:32","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER V.  ADVICE FROM A CATERPILLAR\n31\nand then at the other, and growing sometimes taller and sometimes shorter until\nshe had succeeded in bringing herself down to her usual height.\nIt was so long since she had been anything near the right size that it felt quite\nstrange at first; but she got used to it in a few minutes and began talking to herself,\nas usual, ‘Come, there’s half my plan done now! How puzzling all these changes\nare! I’m never sure what I’m going to be, from one minute to another! However,\nI’ve got back to my right size; the next thing is, to get into that beautiful garden –\nhow\nis\nthat to be done, I wonder?’ As she said this, she came suddenly upon an\nopen place with a little house in it about four feet high. ‘Whoever lives there,’\nthought Alice, ‘it’ll never do to come upon them\nthis\nsize; why, I should frighten\nthem out of their wits!’ So she began nibbling at the righthand bit again and\ndid not venture to go near the house till she had brought herself down to nine\ninches high.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":32},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:33","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter VI\nPig and Pepper\nFor a minute or two she stood looking at the house, and wondering what to do\nnext, when suddenly a footman in livery came running out of the wood – (she\nconsidered him to be a footman because he was in livery; otherwise, judging by\nhis face only, she would have called\nhim a fish) – and rapped loudly at\nthe door with his knuckles.  It was\nopened by another footman in livery,\nwith a round face and large eyes like\na frog; and both footmen, Alice no-\nticed, had powdered hair that curled\nall over their heads. She felt very curi-\nous to know what it was all about and\ncrept a little way out of the wood to\nlisten.\nThe Fish-Footman began by pro-\nducing from under his arm a great let-\nter, nearly as large as himself, and this\nhe handed over to the other, saying, in\na solemn tone, ‘For the Duchess. An\ninvitation from the Queen to play cro-\nquet.’ The Frog-Footman repeated, in the same solemn tone, only changing the\norder of the words a little, ‘From the Queen. An invitation for the Duchess to play\ncroquet.’\nThen they both bowed low, and their curls got entangled together.\nAlice laughed so much at this, that she had to run back into the wood for fear of\ntheir hearing her; and when she next peeped out the Fish-Footman was gone, and\nthe other was sitting on the ground near the door, staring stupidly up into the sky.\nAlice went timidly up to the door and knocked.\n32","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":33},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:34","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n33\n‘There’s no sort of use in knocking,’ said the Footman, ‘and that for two rea-\nsons. First, because I’m on the same side of the door as you are; secondly, because\nthey’re making such a noise inside, no one could possibly hear you.’ And cer-\ntainly there was a most extraordinary noise going on within – a constant howling\nand sneezing, and every now and then a great crash, as if a dish or kettle had been\nbroken to pieces.\n‘Please, then,’ said Alice, ‘how am I to get in?’\n‘There might be some sense in your knocking,’ the Footman went on without\nattending to her, ‘if we had the door between us. For instance, if you were\ninside\n,\nyou might knock, and I could let you out, you know.’ He was looking up into the\nsky all the time he was speaking, and this Alice thought decidedly uncivil. ‘But\nperhaps he can’t help it,’ she said to herself, ‘his eyes are so\nvery\nnearly at the top\nof his head. But at any rate he might answer questions. – How am I to get in?’ she\nrepeated, aloud.\n‘I shall sit here,’ the Footman remarked, ‘till tomorrow – ’\nAt this moment the door of the house opened and a large plate came skimming\nout, straight at the Footman’s head; it just grazed his nose and broke to pieces\nagainst one of the trees behind him.\n‘ – or next day, maybe,’ the Footman continued in the same tone, exactly as if\nnothing had happened.\n‘How am I to get in?’ asked Alice again, in a louder tone.\n‘\nAre\nyou to get in at all?’ said the Footman, ‘That’s the first question, you\nknow.’\nIt was, no doubt; only Alice did not like to be told so. ‘It’s really dreadful,’\nshe muttered to herself, ‘the way all the creatures argue. It’s enough to drive one\ncrazy!’\nThe Footman seemed to think this a good opportunity for repeating his remark,\nwith variations. ‘I shall sit here,’ he said, ‘on and off, for days and days.’\n‘But what am I to do?’ said Alice.\n‘Anything you like,’ said the Footman and began whistling.\n‘Oh, there’s no use in talking to him,’ said Alice desperately, ‘he’s perfectly\nidiotic!’ And she opened the door and went in.\nThe door led right into a large kitchen, which was full of smoke from one end\nto the other; the Duchess was sitting on a three-legged stool in the middle, nursing\na baby; the cook was leaning over the fire, stirring a large cauldron which seemed\nto be full of soup.\n‘There’s certainly too much pepper in that soup!’ Alice said to herself, as well\nas she could for sneezing.\nThere was certainly too much of it in the air. Even the Duchess sneezed oc-\ncasionally; and as for the baby, it was sneezing and howling alternately without","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":34},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:35","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n34\na moment’s pause. The only things in the kitchen that did not sneeze, were the\ncook, and a large cat which was sitting on the hearth and grinning from ear to ear.\n‘Please would you tell me,’ said\nAlice, a little timidly, for she was not\nquite sure whether it was good man-\nners for her to speak first, ‘why your\ncat grins like that?’\n‘It’s a Cheshire cat,’  said the\nDuchess, ‘and that’s why. Pig!’\nShe said the last word with such\nsudden  violence  that  Alice  quite\njumped; but she saw in another mo-\nment that it was addressed to the baby,\nand not to her, so she took courage,\nand went on again:\n‘I didn’t know that Cheshire cats always grinned; in fact, I didn’t know that\ncats\ncould\ngrin.’\n‘They all can,’ said the Duchess, ‘and most of ’em do.’\n‘I don’t know of any that do,’ Alice said very politely, feeling quite pleased to\nhave got into a conversation.\n‘You don’t know much,’ said the Duchess, ‘and that’s a fact.’\nAlice did not at all like the tone of this remark and thought it would be as\nwell to introduce some other subject of conversation. While she was trying to fix\non one, the cook took the cauldron of soup off the fire, and at once set to work\nthrowing everything within her reach at the Duchess and the baby – the fire-irons\ncame first; then followed a shower of saucepans, plates and dishes. The Duchess\ntook no notice of them even when they hit her; and the baby was howling so much\nalready, that it was quite impossible to say whether the blows hurt it or not.\n‘Oh,\nplease\nmind what you’re doing!’ cried Alice, jumping up and down in an\nagony of terror, ‘Oh, there goes his\nprecious\nnose,’ as an unusually large saucepan\nflew close by it and very nearly carried it off.\n‘If everybody minded their own business,’ the Duchess said in a hoarse growl,\n‘the world would go round a deal faster than it does.’\n‘Which would\nnot\nbe an advantage,’ said Alice, who felt very glad to get an\nopportunity of showing off a little of her knowledge, ‘Just think of what work it\nwould make with the day and night! You see the earth takes twenty-four hours to\nturn round on its axis – ’\n‘Talking of axes,’ said the Duchess, ‘chop off her head!’\nAlice glanced rather anxiously at the cook, to see if she meant to take the hint;\nbut the cook was busily stirring the soup, and seemed not to be listening, so she\nwent on again, ‘Twenty-four hours, I\nthink\n; or is it twelve? I – ’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":35},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:36","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n35\n‘Oh, don’t bother\nme\n,’ said the Duchess, ‘I never could abide figures!’ And\nwith that she began nursing her child again, singing a sort of lullaby to it as she\ndid so, and giving it a violent shake at the end of every line:\n‘Speak roughly to your little boy,\nAnd beat him when he sneezes;\nHe only does it to annoy,\nBecause he knows it teases.’\nChorus\n(in which the cook and the baby joined)\n‘Wow! wow! wow!’\nWhile the Duchess sang the second verse of the song, she kept tossing the\nbaby violently up and down and the poor little thing howled so, that Alice could\nhardly hear the words:\n‘I speak severely to my boy,\nI beat him when he sneezes;\nFor he can thoroughly enjoy\nThe pepper when he pleases!’\nChorus\n‘Wow! wow! wow!’\n‘Here! you may nurse it a bit, if you like!’ the Duchess said to Alice, flinging\nthe baby at her as she spoke, ‘I must go and get ready to play croquet with the\nQueen,’ and she hurried out of the room. The cook threw a frying-pan after her as\nshe went out, but it just missed her.\nAlice caught the baby with some difficulty, as it was a queer-shaped little\ncreature, and held out its arms and legs in all directions, ‘just like a star-fish,’\nthought Alice. The poor little thing was snorting like a steam-engine when she\ncaught it and kept doubling itself up and straightening itself out again, so that\naltogether, for the first minute or two, it was as much as she could do to hold it.\nAs soon as she had made out the proper way of nursing it, (which was to twist\nit up into a sort of knot and then keep tight hold of its right ear and left foot, so\nas to prevent its undoing itself) she carried it out into the open air. ‘\nIf\nI don’t take\nthis child away with me,’ thought Alice, ‘they’re sure to kill it in a day or two;\nwouldn’t it be murder to leave it behind?’ She said the last words out loud and the\nlittle thing grunted in reply (it had left off sneezing by this time). ‘Don’t grunt,’\nsaid Alice, ‘that’s not at all a proper way of expressing yourself.’\nThe baby grunted again and Alice looked very anxiously into its face to see\nwhat was the matter with it. There could be no doubt that it had a\nvery\nturn-up\nnose, much more like a snout than a real nose; also its eyes were getting extremely","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":36},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:37","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n36\nsmall for a baby; altogether Alice did not like the look of the thing at all. ‘But\nperhaps it was only sobbing,’ she thought and looked into its eyes again to see if\nthere were any tears.\nNo, there were no tears. ‘If you’re going to turn into a pig, my dear,’ said\nAlice, seriously, ‘I’ll have nothing more to do with you. Mind now!’ The poor\nlittle thing sobbed again (or grunted, it was impossible to say which), and they\nwent on for some while in silence.\nAlice was just beginning to think to herself, ‘Now, what am I to do with this\ncreature when I get it home?’ when it grunted again, so violently, that she looked\ndown into its face in some alarm. This time there could be\nno\nmistake about it: it\nwas neither more nor less than a pig,\nand she felt that it would be quite ab-\nsurd for her to carry it further.\nSo she set the little creature down,\nand felt quite relieved to see it trot\naway quietly into the wood.  ‘If it\nhad grown up,’ she said to herself, ‘it\nwould have made a dreadfully ugly\nchild; but it makes rather a hand-\nsome pig, I think.’  And she began\nthinking over other children she knew,\nwho might do very well as pigs, and\nwas just saying to herself, ‘if one\nonly knew the right way to change\nthem – ’ when she was a little startled\nby seeing the Cheshire Cat sitting on\na bough of a tree a few yards off.\nThe Cat only grinned when it saw\nAlice.  It looked good-natured, she\nthought; still it had\nvery\nlong claws\nand a great many teeth, so she felt that\nit ought to be treated with respect.\n‘Cheshire Puss,’ she began, rather timidly, as she did not at all know whether\nit would like the name; however, it only grinned a little wider. ‘Come, it’s pleased\nso far,’ thought Alice, and she went on, ‘would you tell me, please, which way\nI ought to go from here?’\n‘That depends a good deal on where you want to get to,’ said the Cat.\n‘I don’t much care where – ’ said Alice.\n‘Then it doesn’t matter which way you go,’ said the Cat.\n‘ – so long as I get\nsomewhere\n,’ Alice added as an explanation.\n‘Oh, you’re sure to do that,’ said the Cat, ‘if you only walk long enough.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":37},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:38","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n37\nAlice felt that this could not be\ndenied, so she tried another question,\n‘What sort of people live about here?’\n‘In\nthat\ndirection,’ the Cat said,\nwaving its right paw round, ‘lives\na Hatter; and in\nthat\ndirection,’ wav-\ning the other paw, ‘lives a March\nHare.  Visit either you like: they’re\nboth mad.’\n‘But I don’t want to go among mad people,’ Alice re-\nmarked.\n‘Oh, you can’t help that,’ said the Cat, ‘we’re all mad\nhere. I’m mad. You’re mad.’\n‘How do you know I’m mad?’ said Alice.\n‘You must be,’ said the Cat, ‘or you wouldn’t have come\nhere.’\nAlice didn’t think that proved it at all; however, she went\non, ‘And how do you know that you’re mad?’\n‘To begin with,’ said the Cat, ‘a dog’s not mad. You\ngrant that?’\n‘I suppose so,’ said Alice.\n‘Well, then,’ the Cat went on, ‘you see, a dog growls when it’s angry, and wags\nits tail when it’s pleased. Now I growl when I’m pleased, and wag my tail when\nI’m angry. Therefore I’m mad.’\n‘I call it purring, not growling,’ said Alice.\n‘Call it what you like,’ said the Cat, ‘Do you play croquet with the Queen\nto-day?’\n‘I should like it very much,’ said Alice, ‘but I haven’t been invited yet.’\n‘You’ll see me there,’ said the Cat and vanished.\nAlice was not much surprised at this, she was getting so used to queer things\nhappening. While she was looking at the place where it had been, it suddenly\nappeared again.\n‘By-the-bye, what became of the baby?’ said the Cat, ‘I’d nearly forgotten to\nask.’\n‘It turned into a pig,’ Alice quietly said, just as if it had come back in a natural\nway.\n‘I thought it would,’ said the Cat and vanished again.\nAlice waited a little, half expecting to see it again, but it did not appear, and\nafter a minute or two she walked on in the direction in which the March Hare was\nsaid to live. ‘I’ve seen hatters before,’ she said to herself, ‘the March Hare will be\nmuch the most interesting, and perhaps as this is May it won’t be raving mad – at","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":38},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:39","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VI.  PIG AND PEPPER\n38\nleast not so mad as it was in March.’ As she said this, she looked up, and there\nwas the Cat again, sitting on a branch of a tree.\n‘Did you say pig or fig?’ said the Cat.\n‘I said pig,’ replied Alice, ‘and I wish you wouldn’t keep appearing and van-\nishing so suddenly: you make one quite giddy.’\n‘All right,’ said the Cat; and this\ntime it vanished quite slowly, begin-\nning with the end of the tail, and\nending with the grin which remained\nsome time after the rest of it had gone.\n‘Well! I’ve often seen a cat with-\nout a grin,’ thought Alice, ‘but a grin\nwithout a cat! It’s the most curious\nthing I ever saw in my life!’\nShe had not gone much farther before she came in sight of the house of the\nMarch Hare: she thought it must be the right house, because the chimneys were\nshaped like ears and the roof was thatched with fur. It was so large a house, that\nshe did not like to go nearer till she had nibbled some more of the lefthand bit\nof mushroom and raised herself to about two feet high; even then she walked up\ntowards it rather timidly, saying to herself ‘Suppose it should be raving mad after\nall! I almost wish I’d gone to see the Hatter instead!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":39},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:40","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter VII\nA Mad Tea-Party\nThere was a table set out under a tree\nin front of the house, and the March\nHare and the Hatter were having tea\nat it; a Dormouse was sitting between\nthem, fast asleep, and the other two\nwere using it as a cushion, resting\ntheir elbows on it, and talking over\nits head. ‘Very uncomfortable for the\nDormouse,’ thought Alice, ‘only, as\nit’s asleep, I suppose it doesn’t mind.’\nThe table was a large one, but the\nthree were all crowded together at one\ncorner of it; ‘No room!  No room!’\nthey cried out when they saw Alice coming. ‘There’s\nplenty\nof room!’ said Alice\nindignantly, and she sat down in a large arm-chair at one end of the table.\n‘Have some wine,’ the March Hare said in an encouraging tone.\nAlice looked all round the table, but there was nothing on it but tea. ‘I don’t\nsee any wine,’ she remarked.\n‘There isn’t any,’ said the March Hare.\n‘Then it wasn’t very civil of you to offer it,’ said Alice angrily.\n‘It wasn’t very civil of you to sit down without being invited,’ said the March\nHare.\n‘I didn’t know it was\nyour\ntable,’ said Alice, ‘it’s laid for a great many more\nthan three.’\n‘Your hair wants cutting,’ said the Hatter. He had been looking at Alice for\nsome time with great curiosity, and this was his first speech.\n‘You should learn not to make personal remarks,’ Alice said with some sever-\nity, ‘it’s very rude.’\n39","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":40},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:41","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n40\nThe Hatter opened his eyes very wide on hearing this; but all he\nsaid\nwas,\n‘Why is a raven like a writing-desk?’\n‘Come, we shall have some fun now!’ thought Alice. ‘I’m glad they’ve begun\nasking riddles. – I believe I can guess that,’ she added aloud.\n‘Do you mean that you think you can find out the answer to it?’ said the March\nHare.\n‘Exactly so,’ said Alice.\n‘Then you should say what you mean,’ the March Hare went on.\n‘I do,’ Alice hastily replied, ‘at least – at least I mean what I say – that’s the\nsame thing, you know.’\n‘Not the same thing a bit!’ said the Hatter, ‘You might just as well say that\n“I see what I eat” is the same thing as “I eat what I see”!’\n‘You might just as well say,’ added the March Hare, ‘that “I like what I get” is\nthe same thing as “I get what I like”!’\n‘You might just as well say,’ added the Dormouse, who seemed to be talking\nin his sleep, ‘that “I breathe when I sleep” is the same thing as “I sleep when\nI breathe”!’\n‘It\nis\nthe same thing with you,’ said the Hatter, and here the conversation\ndropped and the party sat silent for a minute, while Alice thought over all she\ncould remember about ravens and writing-desks, which wasn’t much.\nThe Hatter was the first to break the silence. ‘What day of the month is it?’ he\nsaid, turning to Alice; he had taken his watch out of his pocket and was looking at\nit uneasily, shaking it every now and then and holding it to his ear.\nAlice considered a little, and then said ‘The fourth.’\n‘Two days wrong!’ sighed the Hatter. ‘I told you butter wouldn’t suit the\nworks!’ he added looking angrily at the March Hare.\n‘It was the\nbest\nbutter,’ the March Hare meekly replied.\n‘Yes, but some crumbs must have got in as well,’ the Hatter grumbled, ‘you\nshouldn’t have put it in with the bread-knife.’\nThe March Hare took the watch and looked at it gloomily; then he dipped it\ninto his cup of tea, and looked at it again; but he could think of nothing better to\nsay than his first remark, ‘It was the\nbest\nbutter, you know.’\nAlice had been looking over his shoulder with some curiosity. ‘What a funny\nwatch!’ she remarked, ‘It tells the day of the month, and doesn’t tell what o’clock\nit is!’\n‘Why should it?’ muttered the Hatter, ‘Does\nyour\nwatch tell you what year\nit is?’\n‘Of course not,’ Alice replied very readily, ‘but that’s because it stays the same\nyear for such a long time together.’\n‘Which is just the case with\nmine\n,’ said the Hatter.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":41},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:42","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n41\nAlice felt dreadfully puzzled. The Hatter’s remark seemed to have no sort of\nmeaning in it and yet it was certainly English. ‘I don’t quite understand you,’ she\nsaid, as politely as she could.\n‘The Dormouse is asleep again,’ said the Hatter, and he poured a little hot tea\nupon its nose.\nThe Dormouse shook its head impatiently, and said, without opening its eyes,\n‘Of course, of course; just what I was going to remark myself.’\n‘Have you guessed the riddle yet?’ the Hatter said, turning to Alice again.\n‘No, I give it up,’ Alice replied, ‘what’s the answer?’\n‘I haven’t the slightest idea,’ said the Hatter.\n‘Nor I,’ said the March Hare.\nAlice sighed wearily. ‘I think you might do something better with the time,’\nshe said, ‘than waste it in asking riddles that have no answers.’\n‘If you knew Time as well as I do,’ said the Hatter, ‘you wouldn’t talk about\nwasting\nit\n. It’s\nhim\n.’\n‘I don’t know what you mean,’ said Alice.\n‘Of course you don’t!’  the Hatter said, tossing his head contemptuously,\n‘I dare say you never even spoke to Time!’\n‘Perhaps not,’ Alice cautiously replied, ‘but I know I have to beat time when\nI learn music.’\n‘Ah!  that accounts for it,’ said\nthe Hatter, ‘He won’t stand beating.\nNow, if you only kept on good terms\nwith him, he’d do almost anything\nyou liked with the clock. For instance,\nsuppose it were nine o’clock in the\nmorning, just time to begin lessons;\nyou’d only have to whisper a hint to\nTime, and round goes the clock in\na twinkling! Half-past one, time for\ndinner!’\n(‘I only wish it was,’ the March\nHare said to itself in a whisper.)\n‘That would be grand, certainly,’\nsaid Alice thoughtfully, ‘but then –\nI shouldn’t be hungry for it, you\nknow.’\n‘Not at first, perhaps,’ said the\nHatter, ‘but you could keep it to half-past one as long as you liked.’\n‘Is that the way\nyou\nmanage?’ Alice asked.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":42},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:43","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n42\nThe Hatter shook his head mournfully. ‘Not I!’ he replied, ‘We quarrelled last\nMarch – just before\nhe\nwent mad, you know – ’ (pointing with his tea spoon at\nthe March Hare,) ‘ – it was at the great concert given by the Queen of Hearts, and\nI had to sing\n“Twinkle, twinkle, little bat!\nHow I wonder what you’re at!”\nYou know the song, perhaps?’\n‘I’ve heard something like it,’ said Alice.\n‘It goes on, you know,’ the Hatter continued, ‘in this way:\n“Up above the world you fly,\nLike a tea-tray in the sky.\nTwinkle, twinkle – ” ’\nHere the Dormouse shook itself and began singing in its sleep ‘Twinkle, twin-\nkle, twinkle, twinkle – ’ and went on so long that they had to pinch it to make it\nstop.\n‘Well, I’d hardly finished the first verse,’ said the Hatter, ‘when the Queen\njumped up and bawled out, “He’s murdering the time! Off with his head!” ’\n‘How dreadfully savage!’ exclaimed Alice.\n‘And ever since that,’ the Hatter went on in a mournful tone, ‘he won’t do\na thing I ask! It’s always six o’clock now.’ A bright idea came into Alice’s head.\n‘Is that the reason so many tea-things are put out here?’ she asked.\n‘Yes, that’s it,’ said the Hatter with a sigh, ‘it’s always tea-time and we’ve no\ntime to wash the things between whiles.’\n‘Then you keep moving round, I suppose?’ said Alice.\n‘Exactly so,’ said the Hatter, ‘as the things get used up.’\n‘But what happens when you come to the beginning again?’ Alice ventured\nto ask.\n‘Suppose we change the subject,’ the March Hare interrupted, yawning, ‘I’m\ngetting tired of this. I vote the young lady tells us a story.’\n‘I’m afraid I don’t know one,’ said Alice, rather alarmed at the proposal.\n‘Then the Dormouse shall!’ they both cried, ‘Wake up, Dormouse!’ And they\npinched it on both sides at once.\nThe Dormouse slowly opened his eyes. ‘I wasn’t asleep,’ he said in a hoarse,\nfeeble voice, ‘I heard every word you fellows were saying.’\n‘Tell us a story!’ said the March Hare.\n‘Yes, please do!’ pleaded Alice.\n‘And be quick about it,’ added the Hatter, ‘or you’ll be asleep again before\nit’s done.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":43},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:44","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n43\n‘Once upon a time there were three little sisters,’ the Dormouse began in\na great hurry, ‘and their names were Elsie, Lacie and Tillie; and they lived at\nthe bottom of a well – ’\n‘What did they live on?’ said Alice, who always took a great interest in ques-\ntions of eating and drinking.\n‘They lived on treacle,’ said the Dormouse, after thinking a minute or two.\n‘They couldn’t have done that, you know,’ Alice gently remarked, ‘they’d have\nbeen ill.’\n‘So they were,’ said the Dormouse, ‘\nvery\nill.’\nAlice tried to fancy to herself what such an extraordinary ways of living would\nbe like, but it puzzled her too much, so she went on, ‘But why did they live at the\nbottom of a well?’\n‘Take some more tea,’ the March Hare said to Alice, very earnestly.\n‘I’ve had nothing yet,’ Alice replied in an offended tone, ‘so I can’t take more.’\n‘You mean you can’t take\nless\n,’ said the Hatter, ‘it’s very easy to take\nmore\nthan nothing.’\n‘Nobody asked\nyour\nopinion,’ said Alice.\n‘Who’s making personal remarks now?’ the Hatter asked triumphantly.\nAlice did not quite know what to say to this; so she helped herself to some tea\nand bread-and-butter, and then turned to the Dormouse, and repeated her question,\n‘Why did they live at the bottom of a well?’\nThe Dormouse again took a minute or two to think about it and then said, ‘It\nwas a treacle-well.’\n‘There’s no such thing!’ Alice was beginning very angrily, but the Hatter and\nthe March Hare went ‘Sh! sh!’ and the Dormouse sulkily remarked, ‘If you can’t\nbe civil, you’d better finish the story for yourself.’\n‘No, please go on!’ Alice said very humbly, ‘I won’t interrupt again. I dare\nsay there may be\none\n.’\n‘One, indeed!’ said the Dormouse indignantly. However, he consented to go\non, ‘And so these three little sisters – they were learning to draw, you know – ’\n‘What did they draw?’ said Alice, quite forgetting her promise.\n‘Treacle,’ said the Dormouse without considering at all this time.\n‘I want a clean cup,’ interrupted the Hatter, ‘let’s all move one place on.’\nHe moved on as he spoke, and the Dormouse followed him; the March Hare\nmoved into the Dormouse’s place and Alice rather unwillingly took the place of\nthe March Hare. The Hatter was the only one who got any advantage from the\nchange; and Alice was a good deal worse off than before as the March Hare had\njust upset the milk-jug into his plate.\nAlice did not wish to offend the Dormouse again, so she began very cautiously,\n‘But I don’t understand. Where did they draw the treacle from?’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":44},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:45","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n44\n‘You can draw water out of a water-well,’ said the Hatter, ‘so I should think\nyou could draw treacle out of a treacle-well – eh, stupid?’\n‘But they were\nin\nthe well,’ Alice said to the Dormouse, not choosing to notice\nthis last remark.\n‘Of course they were’, said the Dormouse, ‘ – well in.’\nThis answer so confused poor Alice, that she let the Dormouse go on for some\ntime without interrupting it.\n‘They were learning to draw,’ the Dormouse went on, yawning and rubbing\nits eyes, for it was getting very sleepy, ‘and they drew all manner of things –\neverything that begins with an M – ’\n‘Why with an M?’ said Alice.\n‘Why not?’ said the March Hare.\nAlice was silent.\nThe Dormouse had closed its eyes by this time and was going off into a doze;\nbut, on being pinched by the Hatter, it woke up again with a little shriek, and went\non, ‘ – that begins with an M, such as mouse-traps, and the moon, and memory,\nand muchness – you know you say things are “much of a muchness” – did you\never see such a thing as a drawing of a muchness?’\n‘Really, now you ask me,’ said\nAlice, very much confused, ‘I don’t\nthink – ’\n‘Then you shouldn’t talk,’ said the\nHatter.\nThis piece of rudeness was more\nthan Alice could bear; she got up\nin great disgust, and walked off; the\nDormouse fell asleep instantly and\nneither of the others took the least no-\ntice of her going, though she looked\nback once or twice, half hoping that\nthey would call after her; the last time\nshe saw them, they were trying to put\nthe Dormouse into the teapot.\n‘At any rate I’ll never go\nthere\nagain!’ said Alice as she picked her way through\nthe wood, ‘It’s the stupidest tea-party I ever was at in all my life!’\nJust as she said this, she noticed that one of the trees had a door leading right\ninto it. ‘That’s very curious!’ she thought, ‘But everything’s curious today. I think\nI may as well go in at once.’ And in she went.\nOnce more she found herself in the long hall, and close to the little glass table.\n‘Now, I’ll manage better this time,’ she said to herself and began by taking the\nlittle golden key, and unlocking the door that led into the garden. Then she went","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":45},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:46","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VII.  A MAD TEA-PARTY\n45\nto work nibbling at the mushroom (she had kept a piece of it in her pocket) till\nshe was about a foot high; then she walked down the little passage; and\nthen\n– she\nfound herself at last in the beautiful garden, among the bright flower-beds and the\ncool fountains.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":46},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:47","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter VIII\nThe Queen’s Croquet-Ground\nA large rose-tree stood near the en-\ntrance of the garden; the roses grow-\ning on it were white, but there were\nthree gardeners at it, busily painting\nthem red. Alice thought this a very\ncurious thing, and she went nearer\nto watch them, and just as she came\nup to them she heard one of them\nsay, ‘Look out now, Five! Don’t go\nsplashing paint over me like that!’\n‘I couldn’t help it,’ said Five, in\na sulky tone, ‘Seven jogged my el-\nbow.’\nOn which Seven looked up and\nsaid, ‘That’s right, Five! Always lay\nthe blame on others!’\n‘\nYou’d\nbetter not talk!’ said Five,\n‘I heard the Queen say only yesterday\nyou deserved to be beheaded!’\n‘What for?’ said the one who had\nspoken first.\n‘That’s none of\nyour\nbusiness, Two!’ said Seven.\n‘Yes, it\nis\nhis business!’ said Five, ‘and I’ll tell him – it was for bringing the\ncook tulip-roots instead of onions.’\nSeven flung down his brush, and had just begun, ‘Well, of all the unjust\nthings – ’ when his eye chanced to fall upon Alice, as she stood watching them\nand he checked himself suddenly; the others looked round also, and all of them\nbowed low.\n46","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":47},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:48","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n47\n‘Would you tell me,’ said Alice, a little timidly, ‘why you are painting those\nroses?’\nFive and Seven said nothing, but looked at Two. Two began in a low voice,\n‘Why the fact is, you see, Miss, this here ought to have been a\nred\nrose-tree, and\nwe put a white one in by mistake; and if the Queen was to find it out, we should all\nhave our heads cut off, you know. So you see, Miss, we’re doing our best, afore\nshe comes, to – ’ At this moment Five, who had been anxiously looking across\nthe garden, called out ‘The Queen! The Queen!’ and the three gardeners instantly\nthrew themselves flat upon their faces. There was a sound of many footsteps and\nAlice looked round eager to see the Queen.\nFirst came ten soldiers carrying clubs; these were all shaped like the three\ngardeners, oblong and flat, with their hands and feet at the corners; next the ten\ncourtiers; these were ornamented all over with diamonds and walked two and two,\nas the soldiers did. After these came the royal children; there were ten of them\nand the little dears came jumping merrily along hand in hand in couples; they\nwere all ornamented with hearts. Next came the guests, mostly Kings and Queens,\nand among them Alice recognised the White Rabbit; it was talking in a hurried\nnervous manner, smiling at everything that was said, and went by without noticing\nher. Then followed the Knave of Hearts, carrying the King’s crown on a crimson\nvelvet cushion; and, last of all this grand procession, came\nthe King and Queen of\nHearts\n.\nAlice was rather doubtful whether she ought not to lie down on her face like\nthe three gardeners, but she could not remember ever having heard of such a rule\nat processions; ‘and besides, what would be the use of a procession,’ thought she,\n‘if people had all to lie down upon their faces, so that they couldn’t see it?’ So she\nstood still where she was, and waited.\nWhen the procession came opposite to Alice, they all stopped and looked at\nher, and the Queen said severely ‘Who is this?’ she said it to the Knave of Hearts,\nwho only bowed and smiled in reply.\n‘Idiot!’ said the Queen, tossing her head impatiently; and, turning to Alice,\nshe went on, ‘What’s your name, child?’\n‘My name is Alice, so please your Majesty,’ said Alice very politely; but she\nadded, to herself, ‘Why, they’re only a pack of cards, after all. I needn’t be afraid\nof them!’\n‘And who are\nthese\n?’ said the Queen, pointing to the three gardeners who\nwere lying round the rose-tree; for, you see, as they were lying on their faces\nand the pattern on their backs was the same as the rest of the pack, she could not\ntell whether they were gardeners, or soldiers, or courtiers, or three of her own\nchildren.\n‘How should I know?’ said Alice, surprised at her own courage, ‘It’s no busi-\nness of\nmine\n.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":48},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:49","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n48\nThe Queen turned crimson with\nfury, and, after glaring at her for a mo-\nment like a wild beast, screamed ‘Off\nwith her head! Off – ’\n‘Nonsense!’   said Alice,  very\nloudly and decidedly, and the Queen\nwas silent.\nThe King laid his hand upon her\narm and timidly said ‘Consider, my\ndear: she is only a child!’\nThe Queen turned angrily away\nfrom him and said to the Knave ‘Turn\nthem over!’\nThe Knave did so, very carefully,\nwith one foot.\n‘Get up!’   said the Queen, in\na shrill, loud voice, and the three gar-\ndeners instantly jumped up and began\nbowing to the King, the Queen, the royal children and everybody else.\n‘Leave off that!’ screamed the Queen, ‘You make me giddy.’ And then, turn-\ning to the rose-tree, she went on, ‘What\nhave\nyou been doing here?’\n‘May it please your Majesty,’ said Two, in a very humble tone, going down on\none knee as he spoke, ‘we were trying – ’\n‘I see!’ said the Queen, who had meanwhile been examining the roses, ‘Off\nwith their heads!’ and the procession moved on, three of the soldiers remaining\nbehind to execute the unfortunate gardeners, who ran to Alice for protection.\n‘You shan’t be beheaded!’ said Alice, and she put them into a large flower-pot\nthat stood near. The three soldiers wandered about for a minute or two, looking\nfor them, and then quietly marched off after the others.\n‘Are their heads off?’ shouted the Queen.\n‘Their heads are gone, if it please your Majesty!’ the soldiers shouted in reply.\n‘That’s right!’ shouted the Queen, ‘Can you play croquet?’\nThe soldiers were silent, and looked at Alice, as the question was evidently\nmeant for her.\n‘Yes!’ shouted Alice.\n‘Come on, then!’ roared the Queen, and Alice joined the procession wonder-\ning very much what would happen next.\n‘It’s – it’s a very fine day!’ said a timid voice at her side. She was walking\nby the White Rabbit, who was peeping anxiously into her face.\n‘Very,’ said Alice, ‘ – where’s the Duchess?’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":49},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:50","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n49\n‘Hush! Hush!’ said the Rabbit in a low, hurried tone. He looked anxiously\nover his shoulder as he spoke, and then raised himself upon tiptoe, put his mouth\nclose to her ear and whispered ‘She’s under sentence of execution.’\n‘What for?’ said Alice.\n‘Did you say “What a pity!”?’ the Rabbit asked.\n‘No, I didn’t,’ said Alice, ‘I don’t think it’s at all a pity. I said “What for?” ’\n‘She boxed the Queen’s ears – ’ the Rabbit began. Alice gave a little scream\nof laughter. ‘Oh, hush!’ the Rabbit whispered in a frightened tone, ‘The Queen\nwill hear you! You see, she came rather late, and the Queen said – ’\n‘Get to your places!’ shouted the Queen in a voice of thunder, and people\nbegan running about in all directions, tumbling up against each other; however,\nthey got settled down in a minute or two and the game began. Alice thought\nshe had never seen such a curious croquet-ground in her life; it was all ridges\nand furrows; the balls were live hedge-\nhogs, the mallets live flamingoes, and the\nsoldiers had to double themselves up and\nto stand on their hands and feet, to make\nthe arches.\nThe chief difficulty Alice found at\nfirst was in managing her flamingo; she\nsucceeded in getting its body tucked\naway, comfortably enough, under her\narm, with its legs hanging down, but\ngenerally, just as she had got its neck\nnicely straightened out, and was going\nto give the hedgehog a blow with its\nhead, it\nwould\ntwist itself round and look\nup in her face, with such a puzzled ex-\npression that she could not help burst-\ning out laughing; and when she had got\nits head down and was going to begin\nagain, it was very provoking to find that\nthe hedgehog had unrolled itself and was\nin the act of crawling away; besides all this, there was generally a ridge or furrow\nin the way wherever she wanted to send the hedgehog to, and, as the doubled-up\nsoldiers were always getting up and walking off to other parts of the ground, Alice\nsoon came to the conclusion that it was a very difficult game indeed.\nThe players all played at once without waiting for turns, quarrelling all the\nwhile and fighting for the hedgehogs; and in a very short time the Queen was in\na furious passion and went stamping about and shouting ‘Off with his head!’ or\n‘Off with her head!’ about once in a minute.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":50},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:51","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n50\nAlice began to feel very uneasy; to be sure, she had not as yet had any dispute\nwith the Queen, but she knew that it might happen any minute, ‘And then,’ thought\nshe, ‘what would become of me? They’re dreadfully fond of beheading people\nhere; the great wonder is, that there’s any one left alive!’\nShe was looking about for some way of escape and wondering whether she\ncould get away without being seen, when she noticed a curious appearance in the\nair; it puzzled her very much at first, but, after watching it a minute or two, she\nmade it out to be a grin and she said to herself ‘It’s the Cheshire Cat; now I shall\nhave somebody to talk to.’\n‘How are you getting on?’ said the Cat, as soon as there was mouth enough\nfor it to speak with.\nAlice waited till the eyes appeared, and then nodded. ‘It’s no use speaking\nto it,’ she thought, ‘till its ears have come, or at least one of them.’ In another\nminute the whole head appeared, and then Alice put down her flamingo, and be-\ngan an account of the game, feeling very glad she had someone to listen to her.\nThe Cat seemed to think that there was enough of it now in sight, and no more of\nit appeared.\n‘I don’t think they play at all fairly,’ Alice began, in rather a complaining\ntone, ‘and they all quarrel so dreadfully one can’t hear oneself speak – and they\ndon’t seem to have any rules in particular; at least, if there are, nobody attends\nto them – and you’ve no idea how confusing it is all the things being alive; for\ninstance, there’s the arch I’ve got to go through next walking about at the other\nend of the ground – and I should have croqueted the Queen’s hedgehog just now,\nonly it ran away when it saw mine coming!’\n‘How do you like the Queen?’ said the Cat in a low voice.\n‘Not at all,’ said Alice, ‘she’s so extremely – ’ Just then she noticed that the\nQueen was close behind her, listening; so she went on, ‘ – likely to win, that it’s\nhardly worth while finishing the game.’\nThe Queen smiled and passed on.\n‘Who\nare\nyou talking to?’ said the King, going up to Alice and looking at the\nCat’s head with great curiosity.\n‘It’s a friend of mine – a Cheshire Cat,’ said Alice, ‘allow me to introduce it.’\n‘I don’t like the look of it at all,’ said the King, ‘however, it may kiss my hand\nif it likes.’\n‘I’d rather not,’ the Cat remarked.\n‘Don’t be impertinent,’ said the King, ‘and don’t look at me like that!’ He got\nbehind Alice as he spoke.\n‘A cat may look at a king,’ said Alice, ‘I’ve read that in some book, but I don’t\nremember where.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":51},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:52","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n51\n‘Well, it must be removed,’ said the King very decidedly and he called the\nQueen, who was passing at the moment, ‘My dear! I wish you would have this cat\nremoved!’\nThe Queen had only one way of settling all difficulties, great or small. ‘Off\nwith his head!’ she said without even looking round.\n‘I’ll fetch the executioner myself,’ said the King eagerly and he hurried off.\nAlice thought she might as well go back and see how the game was going on,\nas she heard the Queen’s voice in the distance, screaming with passion. She had\nalready heard her sentence three of the players to be executed for having missed\ntheir turns and she did not like the look of things at all, as the game was in such\nconfusion that she never knew whether it was her turn or not. So she went in\nsearch of her hedgehog.\nThe hedgehog was engaged in a fight with another hedgehog, which seemed to\nAlice an excellent opportunity for croqueting one of them with the other; the only\ndifficulty was, that her flamingo was gone across to the other side of the garden,\nwhere Alice could see it trying in a helpless sort of way to fly up into a tree.\nBy the time she had caught the flamingo and brought it back, the fight was\nover, and both the hedgehogs were out of sight; ‘But it doesn’t matter much,’\nthought Alice, ‘as all the arches are gone from this side of the ground.’ So she\ntucked it away under her arm, that\nit might not escape again, and went\nback for a little more conversation\nwith her friend.\nWhen she got back to the Cheshire\nCat, she was surprised to find quite\na large crowd collected round it; there\nwas a dispute going on between the\nexecutioner, the King and the Queen,\nwho were all talking at once, while all\nthe rest were quite silent, and looked\nvery uncomfortable.\nThe moment Alice appeared, she\nwas appealed to by all three to settle\nthe question, and they repeated their\narguments to her, though, as they all\nspoke at once, she found it very hard\nindeed to make out exactly what they\nsaid.\nThe executioner’s argument was, that you couldn’t cut off a head unless there\nwas a body to cut it off from; that he had never had to do such a thing before and\nhe wasn’t going to begin at\nhis\ntime of life.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":52},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:53","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER VIII.  THE QUEEN’S CROQUET-GROUND\n52\nThe King’s argument was, that anything that had a head could be beheaded\nand that you weren’t to talk nonsense.\nThe Queen’s argument was, that if something wasn’t done about it in less than\nno time she’d have everybody executed, all round. (It was this last remark that\nhad made the whole party look so grave and anxious.)\nAlice could think of nothing else to say but ‘It belongs to the Duchess; you’d\nbetter ask\nher\nabout it.’\n‘She’s in prison,’ the Queen said to the executioner, ‘fetch her here.’ And the\nexecutioner went off like an arrow.\nThe Cat’s head began fading away the moment he was gone, and, by the time\nhe had come back with the Duchess, it had entirely disappeared; so the King and\nthe executioner ran wildly up and down looking for it, while the rest of the party\nwent back to the game.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":53},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:54","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter IX\nThe Mock Turtle’s Story\n‘You can’t think how glad I am to see\nyou again, you dear old thing!’ said\nthe Duchess, as she tucked her arm\naffectionately into Alice’s and they\nwalked off together.\nAlice was very glad to find her in\nsuch a pleasant temper and thought to\nherself that perhaps it was only the\npepper that had made her so savage\nwhen they met in the kitchen.\n‘When\nI’m\na Duchess,’ she said to\nherself, (not in a very hopeful tone\nthough), ‘I won’t have any pepper\nin my kitchen\nat  all\n.   Soup does\nvery well without – Maybe it’s al-\nways pepper that makes people hot-\ntempered,’ she went on, very much\npleased at having found out a new\nkind of rule, ‘and vinegar that makes\nthem sour  –  and camomile that\nmakes them bitter – and – and barley-sugar and such things that make children\nsweet-tempered. I only wish people knew that: then they wouldn’t be so stingy\nabout it, you know – ’\nShe had quite forgotten the Duchess by this time and was a little startled when\nshe heard her voice close to her ear. ‘You’re thinking about something, my dear,\nand that makes you forget to talk. I can’t tell you just now what the moral of that\nis, but I shall remember it in a bit.’\n‘Perhaps it hasn’t one,’ Alice ventured to remark.\n53","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":54},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:55","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IX.  THE MOCK TURTLE’S STORY\n54\n‘Tut, tut, child!’ said the Duchess, ‘Everything’s got a moral, if only you can\nfind it.’ And she squeezed herself up closer to Alice’s side as she spoke.\nAlice did not much like keeping so close to her: first, because the Duchess was\nvery\nugly; and secondly, because she was exactly the right height to rest her chin\nupon Alice’s shoulder, and it was an uncomfortably sharp chin. However, she did\nnot like to be rude, so she bore it as well as she could.\n‘The game’s going on rather better now,’ she said, by way of keeping up the\nconversation a little.\n‘ ’Tis so,’ said the Duchess, ‘and the moral of that is – “Oh, ’tis love, ’tis love,\nthat makes the world go round!” ’\n‘Somebody said,’ Alice whispered, ‘that it’s done by everybody minding their\nown business!’\n‘Ah, well! It means much the same thing,’ said the Duchess, digging her sharp\nlittle chin into Alice’s shoulder as she added, ‘and the moral of\nthat\nis – “Take\ncare of the sense and the sounds will take care of themselves.” ’\n‘How fond she is of finding morals in things!’ Alice thought to herself.\n‘I dare say you’re wondering why I don’t put my arm round your waist,’ the\nDuchess said after a pause, ‘the reason is, that I’m doubtful about the temper of\nyour flamingo. Shall I try the experiment?’\n‘\nHe\nmight bite,’ Alice cautiously replied, not feeling at all anxious to have the\nexperiment tried.\n‘Very true,’ said the Duchess, ‘flamingoes and mustard both bite. And the\nmoral of that is – “Birds of a feather flock together.” ’\n‘Only mustard isn’t a bird,’ Alice remarked.\n‘Right, as usual,’ said the Duchess, ‘what a clear way you have of putting\nthings!’\n‘It’s a mineral, I\nthink\n,’ said Alice.\n‘Of course it is,’ said the Duchess, who seemed ready to agree to everything\nthat Alice said, ‘there’s a large mustard-mine near here. And the moral of that\nis – “The more there is of mine, the less there is of yours.” ’\n‘Oh, I know!’ exclaimed Alice, who had not attended to this last remark, ‘it’s\na vegetable. It doesn’t look like one, but it is.’\n‘I quite agree with you,’ said the Duchess, ‘and the moral of that is – “Be what\nyou would seem to be” – or if you’d like it put more simply – “Never imagine\nyourself not to be otherwise than what it might appear to others that what you\nwere or might have been was not otherwise than what you had been would have\nappeared to them to be otherwise.” ’\n‘I think I should understand that better,’ Alice said very politely, ‘if I had it\nwritten down; but I can’t quite follow it as you say it.’\n‘That’s nothing to what I could say if I chose,’ the Duchess replied in a pleased\ntone.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":55},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:56","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IX.  THE MOCK TURTLE’S STORY\n55\n‘Pray don’t trouble yourself to say it any longer than that,’ said Alice.\n‘Oh, don’t talk about trouble!’ said the Duchess, ‘I make you a present of\neverything I’ve said as yet.’\n‘A cheap sort of present!’ thought Alice, ‘I’m glad they don’t give birthday\npresents like that!’ But she did not venture to say it out loud.\n‘Thinking again?’ the Duchess asked with another dig of her sharp little chin.\n‘I’ve a right to think,’ said Alice sharply, for she was beginning to feel a little\nworried.\n‘Just about as much right,’ said the Duchess, ‘as pigs have to fly; and the m – ’\nBut here, to Alice’s great surprise, the Duchess’s voice died away, even in the\nmiddle of her favourite word ‘moral,’ and the arm that was linked into hers began\nto tremble. Alice looked up, and there stood the Queen in front of them, with her\narms folded, frowning like a thunderstorm.\n‘A fine day, your Majesty!’ the Duchess began in a low, weak voice.\n‘Now, I give you fair warning,’ shouted the Queen, stamping on the ground as\nshe spoke, ‘either you or your head must be off, and that in about half no time!\nTake your choice!’\nThe Duchess took her choice and was gone in a moment.\n‘Let’s go on with the game,’ the Queen said to Alice; and Alice was too much\nfrightened to say a word, but slowly followed her back to the croquet-ground.\nThe other guests had taken advantage of the Queen’s absence, and were resting\nin the shade; however, the moment they saw her, they hurried back to the game,\nthe Queen merely remarking that a moment’s delay would cost them their lives.\nAll the time they were playing the Queen never left off quarrelling with the\nother players and shouting ‘Off with his head!’ or ‘Off with her head!’ Those\nwhom she sentenced were taken into custody by the soldiers, who of course had\nto leave off being arches to do this, so that by the end of half an hour or so there\nwere no arches left and all the players, except the King, the Queen, and Alice,\nwere in custody and under sentence of execution.\nThen the Queen left off, quite out of breath, and said to Alice, ‘Have you seen\nthe Mock Turtle yet?’\n‘No,’ said Alice, ‘I don’t even know what a Mock Turtle is.’\n‘It’s the thing Mock Turtle Soup is made from,’ said the Queen.\n‘I never saw one or heard of one,’ said Alice.\n‘Come on, then,’ said the Queen, ‘and he shall tell you his history,’\nAs they walked off together, Alice heard the King say in a low voice to the\ncompany generally, ‘You are all pardoned.’ ‘Come,\nthat’s\na good thing!’ she said\nto herself, for she had felt quite unhappy at the number of executions the Queen\nhad ordered.\nThey very soon came upon a Gryphon, lying fast asleep in the sun. (\nif\nyou\ndon’t know what a Gryphon is, look at the picture.)  ‘Up, lazy thing!’  said","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":56},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:57","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IX.  THE MOCK TURTLE’S STORY\n56\nthe Queen, ‘and take this young lady\nto see the Mock Turtle and to hear his\nhistory. I must go back and see after\nsome executions I have ordered’; and\nshe walked off, leaving Alice alone\nwith the Gryphon. Alice did not quite\nlike the look of the creature, but on the\nwhole she thought it would be quite as\nsafe to stay with it as to go after that\nsavage Queen; so she waited.\nThe Gryphon sat up and rubbed its eyes; then it watched the Queen till she\nwas out of sight; then it chuckled. ‘What fun!’ said the Gryphon, half to itself,\nhalf to Alice.\n‘What\nis\nthe fun?’ said Alice.\n‘Why,\nshe\n,’ said the Gryphon, ‘It’s all her fancy, that; they never executes\nnobody, you know. Come on!’\n‘Everybody says “come on!” here,’ thought Alice, as she went slowly after it,\n‘I never was so ordered about in all my life, never!’\nThey had not gone far before they saw the Mock Turtle in the distance, sitting\nsad and lonely on a little ledge of rock, and, as they came nearer, Alice could\nhear him sighing as if his heart\nwould break. She pitied him deeply.\n‘What is his sorrow?’ she asked the\nGryphon, and the Gryphon answered,\nvery nearly in the same words as be-\nfore, ‘It’s all his fancy, that; he hasn’t\ngot no sorrow, you know. Come on!’\nSo they went up to the Mock Tur-\ntle, who looked at them with large\neyes full of tears, but said nothing.\n‘This here young lady,’ said the\nGryphon, ‘she wants for to know your\nhistory, she do.’\n‘I’ll tell it her,’ said the Mock Tur-\ntle in a deep, hollow tone, ‘sit down,\nboth of you, and don’t speak a word\ntill I’ve finished.’\nSo they sat down, and nobody spoke for some minutes. Alice thought to her-\nself, ‘I don’t see how he can\neven\nfinish, if he doesn’t begin.’ But she waited\npatiently.\n‘Once,’ said the Mock Turtle at last, with a deep sigh, ‘I was a real Turtle.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":57},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:58","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IX.  THE MOCK TURTLE’S STORY\n57\nThese words were followed by a very long silence, broken only by an occa-\nsional exclamation of ‘Hjckrrh!’ from the Gryphon and the constant heavy sob-\nbing of the Mock Turtle. Alice was very nearly getting up and saying, ‘Thank\nyou, sir, for your interesting story,’ but she could not help thinking there\nmust\nbe\nmore to come, so she sat still and said nothing.\n‘When we were little,’ the Mock Turtle went on at last, more calmly, though\nstill sobbing a little now and then, ‘we went to school in the sea. The master was\nan old Turtle – we used to call him Tortoise – ’\n‘Why did you call him Tortoise, if he wasn’t one?’ Alice asked.\n‘We called him Tortoise because he taught us,’ said the Mock Turtle angrily,\n‘really you are very dull!’\n‘You ought to be ashamed of yourself for asking such a simple question,’\nadded the Gryphon; and then they both sat silent and looked at poor Alice, who\nfelt ready to sink into the earth. At last the Gryphon said to the Mock Turtle,\n‘Drive on, old fellow! Don’t be all day about it!’ and he went on in these words:\n‘Yes, we went to school in the sea, though you mayn’t believe it – ’\n‘I never said I didn’t!’ interrupted Alice.\n‘You did,’ said the Mock Turtle.\n‘Hold your tongue!’ added the Gryphon, before Alice could speak again. The\nMock Turtle went on.\n‘We had the best of educations – in fact, we went to school every day – ’\n‘\nI’ve\nbeen to a day-school, too,’ said Alice, ‘you needn’t be so proud as all\nthat.’\n‘With extras?’ asked the Mock Turtle a little anxiously.\n‘Yes,’ said Alice, ‘we learned French and music.’\n‘And washing?’ said the Mock Turtle.\n‘Certainly not!’ said Alice indignantly.\n‘Ah! then yours wasn’t a really good school,’ said the Mock Turtle in a tone\nof great relief, ‘Now at\nours\nthey had at the end of the bill, “French, music,\nand\nwashing\n– extra.” ’\n‘You couldn’t have wanted it much,’ said Alice, ‘living at the bottom of the\nsea.’\n‘I couldn’t afford to learn it.’ said the Mock Turtle with a sigh, ‘I only took\nthe regular course.’\n‘What was that?’ inquired Alice.\n‘Reeling and Writhing, of course, to begin with,’ the Mock Turtle replied, ‘and\nthen the different branches of Arithmetic – Ambition, Distraction, Uglification,\nand Derision.’\n‘I never heard of “Uglification,” ’ Alice ventured to say, ‘What is it?’\nThe Gryphon lifted up both its paws in surprise. ‘What! Never heard of ugli-\nfying!’ it exclaimed, ‘You know what to beautify is, I suppose?’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":58},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:59","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER IX.  THE MOCK TURTLE’S STORY\n58\n‘Yes,’ said Alice doubtfully, ‘it means – to – make – anything – prettier.’\n‘Well, then,’ the Gryphon went on, ‘if you don’t know what to uglify is, you\nare\na simpleton.’\nAlice did not feel encouraged to ask any more questions about it, so she turned\nto the Mock Turtle and said, ‘What else had you to learn?’\n‘Well, there was Mystery,’ the Mock Turtle replied, counting off the subjects\non his flappers, ‘ – Mystery, ancient and modern, with Seaography; then Drawl-\ning – the Drawling-master was an old conger-eel, that used to come once a week;\nhe\ntaught us Drawling, Stretching, and Fainting in Coils.’\n‘What was\nthat\nlike?’ said Alice.\n‘Well, I can’t show it you myself,’ the Mock Turtle said, ‘I’m too stiff. And\nthe Gryphon never learnt it.’\n‘Hadn’t time,’ said the Gryphon, ‘I went to the Classics master, though. He\nwas an old crab,\nhe\nwas.’\n‘I never went to him,’ the Mock Turtle said with a sigh, ‘he taught Laughing\nand Grief, they used to say.’\n‘So he did, so he did,’ said the Gryphon, sighing in his turn; and both creatures\nhid their faces in their paws.\n‘And how many hours a day did you do lessons?’ said Alice in a hurry to\nchange the subject.\n‘Ten hours the first day,’ said the Mock Turtle, ‘nine the next, and so on.’\n‘What a curious plan!’ exclaimed Alice.\n‘That’s the reason they’re called lessons,’ the Gryphon remarked, ‘because\nthey lessen from day to day.’\nThis was quite a new idea to Alice and she thought it over a little before she\nmade her next remark, ‘Then the eleventh day must have been a holiday?’\n‘Of course it was,’ said the Mock Turtle.\n‘And how did you manage on the twelfth?’ Alice went on eagerly.\n‘That’s enough about lessons,’ the Gryphon interrupted in a very decided tone,\n‘tell her something about the games now.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":59},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:60","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter X\nThe Lobster Quadrille\nThe Mock Turtle sighed deeply, and drew the back of one flapper across his eyes.\nHe looked at Alice and tried to speak, but for a minute or two sobs choked his\nvoice. ‘Same as if he had a bone in his throat,’ said the Gryphon; and it set to work\nshaking him and punching him in the back. At last the Mock Turtle recovered his\nvoice, and, with tears running down his cheeks, he went on again:\n‘You may not have lived much under the sea – ’ (‘I haven’t,’ said Alice) – ‘and\nperhaps you were never even introduced to a lobster – ’ (Alice began to say ‘I once\ntasted – ’ but checked herself hastily, and said ‘No, never’) ‘ – so you can have no\nidea what a delightful thing a Lobster Quadrille is!’\n‘No, indeed,’ said Alice, ‘What sort of a dance is it?’\n‘Why,’ said the Gryphon, ‘you first form into a line along the sea-shore – ’\n‘Two lines!’ cried the Mock Turtle, ‘Seals, turtles, salmon, and so on; then,\nwhen you’ve cleared all the jelly-fish out of the way – ’\n‘\nThat\ngenerally takes some time,’ interrupted the Gryphon.\n‘ – you advance twice – ’\n‘Each with a lobster as a partner!’ cried the Gryphon.\n‘Of course,’ the Mock Turtle said, ‘advance twice, set to partners – ’\n‘ – change lobsters, and retire in same order,’ continued the Gryphon.\n‘Then, you know,’ the Mock Turtle went on, ‘you throw the – ’\n‘The lobsters!’ shouted the Gryphon, with a bound into the air.\n‘ – as far out to sea as you can – ’\n‘Swim after them!’ screamed the Gryphon.\n‘Turn a somersault in the sea!’ cried the Mock Turtle, capering wildly about.\n‘Change lobsters again!’ yelled the Gryphon at the top of its voice.\n‘Back to land again and that’s all the first figure,’ said the Mock Turtle, sud-\ndenly dropping his voice; and the two creatures, who had been jumping about like\nmad things all this time, sat down again very sadly and quietly and looked at Alice.\n‘It must be a very pretty dance,’ said Alice timidly.\n59","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":60},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:61","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER X.  THE LOBSTER QUADRILLE\n60\n‘Would you like to see a little of it?’ said the Mock Turtle.\n‘Very much indeed,’ said Alice.\n‘Come, let’s try the first figure!’ said the Mock Turtle to the Gryphon, ‘We\ncan do without lobsters, you know. Which shall sing?’\n‘Oh,\nyou\nsing,’ said the Gryphon, ‘I’ve forgotten the words.’\nSo they began solemnly dancing round and round Alice, every now and then\ntreading on her toes when they passed too close and waving their forepaws to\nmark the time, while the Mock Turtle sang this, very slowly and sadly:\n‘ “Will you walk a little faster?” said a whiting to a snail.\n“There’s a porpoise close behind us and he’s treading on my tail.\nSee how eagerly the lobsters and the turtles all advance!\nThey are waiting on the shingle – will you come and join the dance?\nWill you, won’t you, will you, won’t you, will you join the dance?\nWill you, won’t you, will you, won’t you, won’t you join the dance?\n“You can really have no notion how delightful it will be\nWhen they take us up and throw us, with the lobsters, out to sea!”\nBut the snail replied “Too far, too far!” and gave a look askance –\nSaid he thanked the whiting kindly, but he would not join the dance.\nWould not, could not, would not, could not, would not join the dance.\nWould not, could not, would not, could not, could not join the dance.\n‘ “What matters it how far we go?” his scaly friend replied.\n“There is another shore, you know, upon the other side.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":61},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:62","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER X.  THE LOBSTER QUADRILLE\n61\nThe further off from England the nearer is to France –\nThen turn not pale, beloved snail, but come and join the dance.\nWill you, won’t you, will you, won’t you, will you join the dance?\nWill you, won’t you, will you, won’t you, won’t you join the dance?” ’\n‘Thank you, it’s a very interesting dance to watch,’ said Alice, feeling very\nglad that it was over at last, ‘and I do so like that curious song about the whiting!’\n‘Oh, as to the whiting,’ said the Mock Turtle, ‘they – you’ve seen them, of\ncourse?’\n‘Yes,’ said Alice, ‘I’ve often seen them at dinn – ’ she checked herself hastily.\n‘I don’t know where Dinn may be,’ said the Mock Turtle, ‘but if you’ve seen\nthem so often, of course you know what they’re like.’\n‘I believe so,’ Alice replied thoughtfully, ‘They have their tails in their mouths –\nand they’re all over crumbs.’\n‘You’re wrong about the crumbs,’ said the Mock Turtle, ‘crumbs would all\nwash off in the sea. But they\nhave\ntheir tails in their mouths; and the reason is – ’\nhere the Mock Turtle yawned and shut his eyes. ‘Tell her about the reason and all\nthat,’ he said to the Gryphon.\n‘The reason is,’ said the Gryphon, ‘that they\nwould\ngo with the lobsters to the\ndance. So they got thrown out to sea. So they had to fall a long way. So they got\ntheir tails fast in their mouths. So they couldn’t get them out again. That’s all.’\n‘Thank you,’ said Alice, ‘it’s very interesting. I never knew so much about\na whiting before.’\n‘I can tell you more than that, if you like,’ said the Gryphon, ‘Do you know\nwhy it’s called a whiting?’\n‘I never thought about it,’ said Alice, ‘Why?’\n‘\nIt does the boots and shoes\n.’ the Gryphon replied very solemnly.\nAlice was thoroughly puzzled. ‘Does the boots and shoes!’ she repeated in\na wondering tone.\n‘Why, what are\nyour\nshoes done with?’ said the Gryphon, ‘I mean, what\nmakes them so shiny?’\nAlice looked down at them and considered a little before she gave her answer.\n‘They’re done with blacking, I believe.’\n‘Boots and shoes under the sea,’ the Gryphon went on in a deep voice, ‘are\ndone with a whiting. Now you know.’\n‘And what are they made of?’ Alice asked in a tone of great curiosity.\n‘Soles and eels, of course,’ the Gryphon replied rather impatiently, ‘any shrimp\ncould have told you that.’\n‘If I’d been the whiting,’ said Alice, whose thoughts were still running on\nthe song, ‘I’d have said to the porpoise, “Keep back, please: we don’t want\nyou\nwith us!” ’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":62},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:63","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER X.  THE LOBSTER QUADRILLE\n62\n‘They were obliged to have him with them,’ the Mock Turtle said, ‘no wise\nfish would go anywhere without a porpoise.’\n‘Wouldn’t it really?’ said Alice in a tone of great surprise.\n‘Of course not,’ said the Mock Turtle, ‘why, if a fish came to\nme\nand told me\nhe was going a journey, I should say “With what porpoise?” ’\n‘Don’t you mean “purpose”?’ said Alice.\n‘I mean what I say,’ the Mock Turtle replied in an offended tone. And the\nGryphon added ‘Come, let’s hear some of\nyour\nadventures.’\n‘I could tell you my adventures – beginning from this morning,’ said Alice\na little timidly, ‘but it’s no use going back to yesterday, because I was a different\nperson then.’\n‘Explain all that,’ said the Mock Turtle.\n‘No, no! The adventures first,’ said the Gryphon in an impatient tone, ‘expla-\nnations take such a dreadful time.’\nSo Alice began telling them her adventures from the time when she first saw\nthe White Rabbit. She was a little nervous about it just at first, the two creatures\ngot so close to her, one on each side, and opened their eyes and mouths so\nvery\nwide, but she gained courage as she went on. Her listeners were perfectly quiet\ntill she got to the part about her repeating ‘Y\nOU\nA\nRE\nO\nLD\n, F\nATHER\nW\nILLIAM\n,’\nto the Caterpillar and the words all coming different, and then the Mock Turtle\ndrew a long breath, and said ‘That’s very curious.’\n‘It’s all about as curious as it can be,’ said the Gryphon.\n‘It all came different!’ the Mock Turtle repeated thoughtfully, ‘I should like\nto hear her try and repeat something now. Tell her to begin.’ He looked at the\nGryphon as if he thought it had some kind of authority over Alice.\n‘Stand up and repeat “ ’T\nIS\nT\nHE\nV\nOICE\nO\nF\nT\nHE\nS\nLUGGARD\n,” ’ said the\nGryphon.\n‘How the creatures order one about, and make one repeat lessons!’ thought\nAlice, ‘I might as well be at school at once.’ However, she got up, and began to\nrepeat it, but her head was so full of the Lobster Quadrille, that she hardly knew\nwhat she was saying and the words came very queer indeed:\n‘ ’Tis the voice of the Lobster; I heard him declare,\n“You have baked me too brown, I must sugar my hair.”\nAs a duck with its eyelids, so he with his nose\nTrims his belt and his buttons, and turns out his toes.’\nWhen the sands are all dry, he is gay as a lark,\nAnd will talk in contemptuous tones of the Shark,\nBut, when the tide rises and sharks are around,\nHis voice has a timid and tremulous sound.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":63},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:64","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER X.  THE LOBSTER QUADRILLE\n63\n‘That’s different from what I used to say when\nI was a child,’ said the Gryphon.\n‘Well, I never heard it before,’ said the Mock\nTurtle, ‘but it sounds uncommon nonsense.’\nAlice said nothing; she had sat down with her\nface in her hands, wondering if anything would\never\nhappen in a natural way again.\n‘I should like to have it explained,’ said the\nMock Turtle.\n‘She can’t explain it,’  said the Gryphon\nhastily, ‘Go on with the next verse.’\n‘But about his toes?’  the Mock Turtle per-\nsisted, ‘How\ncould\nhe turn them out with his nose,\nyou know?’\n‘It’s the first position in dancing.’ Alice said;\nbut was dreadfully puzzled by the whole thing,\nand longed to change the subject.\n‘Go on with the next verse,’ the Gryphon repeated impatiently, ‘it begins\n“I P\nASSED\nB\nY\nH\nIS\nG\nARDEN\n.” ’\nAlice did not dare to disobey, though she felt sure it would all come wrong,\nand she went on in a trembling voice:\n‘I passed by his garden and marked, with one eye,\nHow the Owl and the Panther were sharing a pie – ’\nThe Panther took pie-crust, and gravy, and meat,\nWhile the Owl had the dish as its share of the treat.\nWhen the pie was all finished, the Owl, as a boon,\nWas kindly permitted to pocket the spoon;\nWhile the Panther received knife and fork with a growl,\nAnd concluded the banquet –\n‘What\nis\nthe use of repeating all that stuff,’ the Mock Turtle interrupted, ‘if you\ndon’t explain it as you go on? It’s by far the most confusing thing I ever heard!’\n‘Yes, I think you’d better leave off,’ said the Gryphon; and Alice was only too\nglad to do so.\n‘Shall we try another figure of the Lobster Quadrille?’ the Gryphon went on,\n‘Or would you like the Mock Turtle to sing you a song?’\n‘Oh, a song, please, if the Mock Turtle would be so kind,’ Alice replied, so\neagerly that the Gryphon said, in a rather offended tone, ‘Hm! No accounting for\ntastes! Sing her “T\nURTLE\nS\nOUP\n,” will you, old fellow?’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":64},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:65","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER X.  THE LOBSTER QUADRILLE\n64\nThe Mock Turtle sighed deeply and began, in a voice sometimes choked with\nsobs, to sing this:\n‘Beautiful Soup, so rich and green,\nWaiting in a hot tureen!\nWho for such dainties would not stoop?\nSoup of the evening, beautiful Soup!\nSoup of the evening, beautiful Soup!\nBeau – ootiful Soo – oop!\nBeau – ootiful Soo – oop!\nSoo – oop of the e – e – evening,\nBeautiful, beautiful Soup!\n‘Beautiful Soup! Who cares for fish,\nGame, or any other dish?\nWho would not give all else for two\nPennyworth only of beautiful Soup?\nPennyworth only of beautiful Soup?\nBeau – ootiful Soo – oop!\nBeau – ootiful Soo – oop!\nSoo – oop of the e – e – evening,\nBeautiful, beauti –\nful Soup\n!’\n‘Chorus again!’ cried the Gryphon, and the Mock Turtle had just begun to\nrepeat it, when a cry of ‘The trial’s beginning!’ was heard in the distance.\n‘Come on!’ cried the Gryphon, and, taking Alice by the hand, it hurried off,\nwithout waiting for the end of the song.\n‘What trial is it?’ Alice panted as she ran; but the Gryphon only answered\n‘Come on!’ and ran the faster, while more and more faintly came, carried on the\nbreeze that followed them, the melancholy words:\n‘Soo – oop of the e – e – evening,\nBeautiful, beautiful Soup!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":65},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:66","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter XI\nWho Stole the Tarts?\nThe King and Queen of Hearts were seated\non their throne when they arrived, with\na great crowd assembled about them – all\nsorts of little birds and beasts, as well as the\nwhole pack of cards; the Knave was stand-\ning before them, in chains, with a soldier on\neach side to guard him; and near the King\nwas the White Rabbit with a trumpet in one\nhand and a scroll of parchment in the other.\nIn the very middle of the court was a ta-\nble, with a large dish of tarts upon it; they\nlooked so good, that it made Alice quite\nhungry to look at them – ‘I wish they’d get\nthe trial done,’ she thought, ‘and hand round\nthe refreshments!’ But there seemed to be\nno chance of this, so she began looking at\neverything about her to pass away the time.\nAlice had never been in a court of justice\nbefore, but she had read about them in books and she was quite pleased to find\nthat she knew the name of nearly everything there. ‘That’s the judge,’ she said to\nherself, ‘because of his great wig.’\nThe judge, by the way, was the King; and as he wore his crown over the wig,\n(look at the frontispiece if you want to see how he did it,) he did not look at all\ncomfortable, and it was certainly not becoming.\n‘And that’s the jury-box,’ thought Alice, ‘and those twelve creatures,’ (she was\nobliged to say ‘creatures,’ you see, because some of them were animals and some\nwere birds,) ‘I suppose they are the jurors.’ She said this last word two or three\ntimes over to herself, being rather proud of it: for she thought, and rightly too, that\n65","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":66},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:67","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XI.  WHO STOLE THE TARTS?\n66\nvery few little girls of her age knew the meaning of it at all. However, ‘jury-men’\nwould have done just as well.\nThe twelve jurors were all writing very busily on slates. ‘What are they do-\ning?’ Alice whispered to the Gryphon. ‘They can’t have anything to put down\nyet, before the trial’s begun.’\n‘They’re putting down their names,’ the Gryphon whispered in reply, ‘for fear\nthey should forget them before the end of the trial.’\n‘Stupid things!’ Alice began in a loud, indignant voice, but she stopped hastily,\nfor the White Rabbit cried out, ‘Silence in the court!’ and the King put on his\nspectacles and looked anxiously round to make out who was talking.\nAlice could see, as well as if she were looking over their shoulders, that all the\njurors were writing down ‘stupid things!’ on their slates, and she could even make\nout that one of them didn’t know how to spell ‘stupid,’ and that he had to ask his\nneighbour to tell him. ‘A nice muddle their slates’ll be in before the trial’s over!’\nthought Alice.\nOne of the jurors had a pencil that squeaked. This of course, Alice could not\nstand, and she went round the court and got behind him, and very soon found an\nopportunity of taking it away. She did it so quickly that the poor little juror (it was\nBill, the Lizard) could not make out at all what had become of it; so, after hunting\nall about for it, he was obliged to write with one finger for the rest of the day; and\nthis was of very little use, as it left no mark on the slate.\n‘Herald, read the accusation!’ said the King.\nOn this the White Rabbit blew three blasts on the trumpet, and then unrolled\nthe parchment scroll and read as follows:\n‘The Queen of Hearts, she made some tarts,\nAll on a summer day;\nThe Knave of Hearts, he stole those tarts,\nAnd took them quite away!’\n‘Consider your verdict,’ the King said to the jury.\n‘Not yet, not yet!’ the Rabbit hastily interrupted, ‘There’s a great deal to come\nbefore that!’\n‘Call the first witness,’ said the King; and the White Rabbit blew three blasts\non the trumpet, and called out, ‘First witness!’\nThe first witness was the Hatter. He came in with a teacup in one hand and\na piece of bread-and-butter in the other. ‘I beg pardon, your Majesty,’ he began,\n‘for bringing these in; but I hadn’t quite finished my tea when I was sent for.’\n‘You ought to have finished,’ said the King, ‘When did you begin?’\nThe Hatter looked at the March Hare, who had followed him into the court,\narm-in-arm with the Dormouse. ‘Fourteenth of March, I think it was,’ he said.\n‘Fifteenth,’ said the March Hare.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":67},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:68","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XI.  WHO STOLE THE TARTS?\n67\n‘Sixteenth,’ added the Dormouse.\n‘Write that down,’ the King said\nto the jury, and the jury eagerly wrote\ndown all three dates on their slates\nand then added them up and reduced\nthe answer to shillings and pence.\n‘Take off your hat,’ the King said\nto the Hatter.\n‘It isn’t mine,’ said the Hatter.\n‘Stolen!’   the King exclaimed,\nturning to the jury, who instantly\nmade a memorandum of the fact.\n‘I keep them to sell,’ the Hatter\nadded as an explanation; ‘I’ve none of\nmy own. I’m a hatter.’\nHere the Queen put on her spec-\ntacles and began staring at the Hatter,\nwho turned pale and fidgeted.\n‘Give your evidence,’ said the\nKing, ‘and don’t be nervous, or I’ll\nhave you executed on the spot.’\nThis did not seem to encourage the witness at all: he kept shifting from one\nfoot to the other, looking uneasily at the Queen, and in his confusion he bit a large\npiece out of his teacup instead of the bread-and-butter.\nJust at this moment Alice felt a very curious sensation, which puzzled her\na good deal until she made out what it was: she was beginning to grow larger\nagain, and she thought at first she would get up and leave the court; but on second\nthoughts she decided to remain where she was as long as there was room for her.\n‘I wish you wouldn’t squeeze so.’ said the Dormouse, who was sitting next to\nher, ‘I can hardly breathe.’\n‘I can’t help it,’ said Alice very meekly, ‘I’m growing.’\n‘You’ve no right to grow here,’ said the Dormouse.\n‘Don’t talk nonsense,’ said Alice more boldly, ‘you know you’re growing too.’\n‘Yes, but I grow at a reasonable pace,’ said the Dormouse, ‘not in that ridicu-\nlous fashion.’ And he got up very sulkily and crossed over to the other side of the\ncourt.\nAll this time the Queen had never left off staring at the Hatter, and, just as the\nDormouse crossed the court, she said to one of the officers of the court, ‘Bring me\nthe list of the singers in the last concert!’ on which the wretched Hatter trembled\nso, that he shook both his shoes off.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":68},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:69","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XI.  WHO STOLE THE TARTS?\n68\n‘Give your evidence,’ the King repeated angrily, ‘or I’ll have you executed,\nwhether you’re nervous or not.’\n‘I’m a poor man, your Majesty,’ the Hatter began, in a trembling voice, ‘ – and\nI hadn’t begun my tea – not above a week or so – and what with the bread-and-\nbutter getting so thin – and the twinkling of the tea – ’\n‘The twinkling of the what?’ said the King.\n‘It began with the tea,’ the Hatter replied.\n‘Of course twinkling begins with a T!’ said the King sharply. ‘Do you take me\nfor a dunce? Go on!’\n‘I’m a poor man,’ the Hatter went on, ‘and most things twinkled after that –\nonly the March Hare said – ’\n‘I didn’t!’ the March Hare interrupted in a great hurry.\n‘You did!’ said the Hatter.\n‘I deny it!’ said the March Hare.\n‘He denies it,’ said the King, ‘leave out that part.’\n‘Well, at any rate, the Dormouse said – ’ the Hatter went on, looking anxiously\nround to see if he would deny it too; but the Dormouse denied nothing, being fast\nasleep.\n‘After that,’ continued the Hatter, ‘I cut some more bread-and-butter – ’\n‘But what did the Dormouse say?’ one of the jury asked.\n‘That I can’t remember,’ said the Hatter.\n‘You\nmust\nremember,’ remarked the King, ‘or I’ll have you executed.’\nThe miserable Hatter dropped his teacup and bread-and-butter, and went down\non one knee. ‘I’m a poor man, your Majesty,’ he began.\n‘You’re a very poor speaker,’ said the King.\nHere one of the guinea-pigs cheered, and was immediately suppressed by the\nofficers of the court. (As that is rather a hard word, I will just explain to you how\nit was done. They had a large canvas bag, which tied up at the mouth with strings;\ninto this they slipped the guinea-pig, head first, and then sat upon it.)\n‘I’m glad I’ve seen that done,’ thought Alice, ‘I’ve so often read in the news-\npapers, at the end of trials, “There was some attempts at applause, which was\nimmediately suppressed by the officers of the court,” and I never understood what\nit meant till now.’\n‘If that’s all you know about it, you may stand down,’ continued the King.\n‘I can’t go no lower,’ said the Hatter, ‘I’m on the floor, as it is.’\n‘Then you may\nsit\ndown,’ the King replied.\nHere the other guinea-pig cheered and was suppressed.\n‘Come, that finished the guinea-pigs!’ thought Alice, ‘Now we shall get on\nbetter.’\n‘I’d rather finish my tea,’ said the Hatter, with an anxious look at the Queen,\nwho was reading the list of singers.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":69},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:70","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XI.  WHO STOLE THE TARTS?\n69\n‘You may go,’ said the King,\nand the Hatter hurriedly left the\ncourt without even waiting to put his\nshoes on.\n‘ – and just take his head off out-\nside,’ the Queen added to one of the\nofficers; but the Hatter was out of\nsight before the officer could get to\nthe door.\n‘Call the next witness!’ said the\nKing.\nThe next witness was the Duchess’s cook. She carried the pepper-box in her\nhand and Alice guessed who it was, even before she got into the court, by the way\nthe people near the door began sneezing all at once.\n‘Give your evidence,’ said the King.\n‘Shan’t,’ said the cook.\nThe King looked anxiously at the White Rabbit, who said in a low voice, ‘Your\nMajesty must cross-examine\nthis\nwitness.’\n‘Well, if I must, I must,’ the King said, with a melancholy air, and, after folding\nhis arms and frowning at the cook till his eyes were nearly out of sight, he said in\na deep voice, ‘What are tarts made of?’\n‘Pepper, mostly,’ said the cook.\n‘Treacle,’ said a sleepy voice behind her.\n‘Collar that Dormouse,’ the Queen shrieked out, ‘Behead that Dormouse! Turn\nthat Dormouse out of court! Suppress him! Pinch him! Off with his whiskers!’\nFor some minutes the whole court was in confusion, getting the Dormouse\nturned out, and, by the time they had settled down again, the cook had disappeared.\n‘Never mind!’ said the King, with an air of great relief. ‘Call the next witness.’\nAnd he added in an undertone to the Queen, ‘Really, my dear,\nyou\nmust cross-\nexamine the next witness. It quite makes my forehead ache!’\nAlice watched the White Rabbit as he fumbled over the list, feeling very cu-\nrious to see what the next witness would be like, ‘ – for they haven’t got much\nevidence\nyes\n,’ she said to herself. Imagine her surprise, when the White Rabbit\nread out, at the top of his shrill little voice, the name ‘Alice!’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":70},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:71","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"Chapter XII\nAlice’s Evidence\n‘Here!’ cried Alice, quite forgetting\nin the flurry of the moment how large\nshe had grown in the last few minutes,\nand she jumped up in such a hurry that\nshe tipped over the jury-box with the\nedge of her skirt, upsetting all the ju-\nrymen on to the heads of the crowd\nbelow, and there they lay sprawling\nabout, reminding her very much of\na globe of goldfish she had acciden-\ntally upset the week before.\n‘Oh, I\nbeg\nyour pardon!’ she ex-\nclaimed in a tone of great dismay\nand began picking them up again as\nquickly as she could, for the accident\nof the goldfish kept running in her\nhead and she had a vague sort of idea\nthat they must be collected at once\nand put back into the jury-box or they would die.\n‘The trial cannot proceed,’ said the King in a very grave voice, ‘until all the\njurymen are back in their proper places –\nall\n,’ he repeated with great emphasis,\nlooking hard at Alice as he said do.\nAlice looked at the jury-box and saw that, in her haste, she had put the Lizard\nin head downwards and the poor little thing was waving its tail about in a melan-\ncholy way, being quite unable to move. She soon got it out again and put it right;\n‘not that it signifies much,’ she said to herself, ‘I should think it would be\nquite\nas\nmuch use in the trial one way up as the other.’\n70","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":71},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:72","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XII.  ALICE’S EVIDENCE\n71\nAs soon as the jury had a little recovered from the\nshock of being upset and their slates and pencils had\nbeen found and handed back to them, they set to work\nvery diligently to write out a history of the accident, all\nexcept the Lizard, who seemed too much overcome to\ndo anything but sit with its mouth open, gazing up into\nthe roof of the court.\n‘What do you know about this business?’ the King\nsaid to Alice.\n‘Nothing,’ said Alice.\n‘Nothing\nwhatever\n?’ persisted the King.\n‘Nothing whatever,’ said Alice.\n‘That’s very important,’ the King\nsaid, turning to the jury. They were\njust beginning to write this down\non their slates when the White Rab-\nbit interrupted, ‘\nUn\nimportant, your\nMajesty means, of course,’ he said in\na very respectful tone, but frowning and making faces at him as he spoke.\n‘\nUn\nimportant, of course, I meant,’ the King hastily said, and went on to him-\nself in an undertone, ‘important – unimportant – unimportant – important – ’ as\nif he were trying which word sounded best.\nSome of the jury wrote it down ‘important,’ and some ‘unimportant.’ Alice\ncould see this, as she was near enough to look over their slates; ‘but it doesn’t\nmatter a bit,’ she thought to herself.\nAt this moment the King, who had been for some time busily writing in his\nnote-book, cackled out ‘Silence!’ and read out from his book, ‘Rule Forty-two.\nAll persons more than a mile high to leave the court\n.’\nEverybody looked at Alice.\n‘\nI’m\nnot a mile high,’ said Alice.\n‘You are,’ said the King.\n‘Nearly two miles high,’ added the Queen.\n‘Well, I shan’t go, at any rate,’ said Alice, ‘besides, that’s not a regular rule:\nyou invented it just now.’\n‘It’s the oldest rule in the book,’ said the King.\n‘Then it ought to be Number One,’ said Alice.\nThe King turned pale, and shut his note-book hastily. ‘Consider your verdict,’\nhe said to the jury, in a low, trembling voice.\n‘There’s more evidence to come yet, please your Majesty,’ said the White\nRabbit, jumping up in a great hurry, ‘this paper has just been picked up.’","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":72},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:73","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XII.  ALICE’S EVIDENCE\n72\n‘What’s in it?’ said the Queen.\n‘I haven’t opened it yet,’ said the White Rabbit, ‘but it seems to be a letter,\nwritten by the prisoner to – to somebody.’\n‘It must have been that,’ said the King, ‘unless it was written to nobody, which\nisn’t usual, you know.’\n‘Who is it directed to?’ said one of the jurymen.\n‘It isn’t directed at all,’ said the White Rabbit, ‘in fact, there’s nothing written\non the\noutside\n.’ He unfolded the paper as he spoke, and added ‘It isn’t a letter,\nafter all: it’s a set of verses.’\n‘Are they in the prisoner’s handwriting?’ asked another of the jurymen.\n‘No, they’re not,’ said the White Rabbit, ‘and that’s the queerest thing about\nit.’ (The jury all looked puzzled.)\n‘He must have imitated somebody else’s hand,’ said the King. (The jury all\nbrightened up again.)\n‘Please your Majesty,’ said the Knave, ‘I didn’t write it and they can’t prove\nI did: there’s no name signed at the end.’\n‘If you didn’t sign it,’ said the King, ‘that only makes the matter worse. You\nmust\nhave meant some mischief or else you’d have signed your name like an\nhonest man.’\nThere was a general clapping of hands at this: it was the first really clever\nthing the King had said that day.\n‘That\nproves\nhis guilt,’ said the Queen.\n‘It proves nothing of the sort!’ said Alice, ‘Why, you don’t even know what\nthey’re about!’\n‘Read them,’ said the King.\nThe White Rabbit put on his spectacles. ‘Where shall I begin, please your\nMajesty?’ he asked.\n‘Begin at the beginning,’ the King said gravely, ‘and go on till you come to the\nend; then stop.’\nThese were the verses the White Rabbit read:\n‘They told me you had been to her,\nAnd mentioned me to him;\nShe gave me a good character,\nBut said I could not swim.\nHe sent them word I had not gone\n(We know it to be true);\nIf she should push the matter on,\nWhat would become of you?\nI gave her one, they gave him two,\nYou gave us three or more;","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":73},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:74","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XII.  ALICE’S EVIDENCE\n73\nThey all returned from him to you,\nThough they were mine before.\nIf I or she should chance to be\nInvolved in this affair,\nHe trusts to you to set them free,\nExactly as we were.\nMy notion was that you had been\n(Before she had this fit)\nAn obstacle that came between\nHim and ourselves and it.\nDon’t let him know she liked them best,\nFor this must ever be\nA secret kept from all the rest,\nBetween yourself and me.’\n‘That’s the most important piece of evidence we’ve heard yet,’ said the King,\nrubbing his hands, ‘so now let the jury – ’\n‘If any one of them can explain it,’ said Alice, (she had grown so large in the\nlast few minutes that she wasn’t a bit afraid of interrupting him,) ‘I’ll give him\nsixpence.\nI\ndon’t believe there’s an atom of meaning in it.’\nThe jury all wrote down on their slates, ‘\nShe\ndoesn’t believe there’s an atom\nof meaning in it,’ but none of them attempted to explain the paper.\n‘If there’s no meaning in it,’ said the King, ‘that saves a world of trouble, you\nknow, as we needn’t try to find any. And yet I don’t know,’ he went on, spreading\nout the verses on his knee and looking at them with one eye; ‘I seem to see some\nmeaning in them, after all. – “\nSaid I could not swim\n” – you can’t swim, can you?’\nhe added, turning to the Knave.\nThe Knave shook his head sadly. ‘Do I look like it?’ he said. (Which he\ncertainly did\nnot\n, being made entirely of cardboard.)\n‘All right, so far,’ said the King, and he went on muttering over the verses to\nhimself, ‘ “\nWe know it to be true\n” – that’s the jury, of course – “\nI gave her one,\nthey gave him two\n” – why, that must be what he did with the tarts, you know – ’\n‘But, it goes on “\nThey all returned from him to you\n,” ’ said Alice.\n‘Why, there they are!’ said the King triumphantly, pointing to the tarts on\nthe table. ‘Nothing can be clearer than\nthat\n. Then again – “\nBefore she had this\nfit\n” – you never had fits, my dear, I think?’ he said to the Queen.\n‘Never!’ said the Queen furiously, throwing an inkstand at the Lizard as she\nspoke. (The unfortunate little Bill had left off writing on his slate with one finger,\nas he found it made no mark; but he now hastily began again, using the ink, that\nwas trickling down his face as long as it lasted.)","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":74},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:75","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XII.  ALICE’S EVIDENCE\n74\n‘Then the words don’t\nfit\nyou,’ said the King looking round the court with\na smile. There was a dead silence.\n‘It’s a pun!’ the King added in an offended tone and everybody laughed, ‘Let\nthe jury consider their verdict,’ the King said, for about the twentieth time that\nday.\n‘No, no!’ said the Queen, ‘Sentence first – verdict afterwards.’\n‘Stuff and nonsense!’ said Alice loudly, ‘The idea of having the sentence first!’\n‘Hold your tongue!’ said the Queen turning purple.\n‘I won’t!’ said Alice.\n‘Off with her head!’  the Queen\nshouted at the top of her voice. No-\nbody moved.\n‘Who cares for you?’ said Alice\n(she had grown to her full size by this\ntime). ‘You’re nothing but a pack of\ncards!’\nAt this the whole pack rose up into\nthe air and came flying down upon\nher; she gave a little scream, half of\nfright and half of anger, and tried to\nbeat them off, and found herself lying\non the bank with her head in the lap\nof her sister, who was gently brush-\ning away some dead leaves that had\nfluttered down from the trees upon her\nface.\n‘Wake up, Alice dear!’ said her\nsister, ‘Why, what a long sleep you’ve had!’\n‘Oh, I’ve had such a curious dream!’ said Alice and she told her sister, as well\nas she could remember them, all these strange adventures of hers that you have\njust been reading about; and when she had finished, her sister kissed her and said,\n‘It\nwas\na curious dream, dear, certainly; but now run in to your tea; it’s getting\nlate.’ So Alice got up and ran off thinking while she ran, as well she might, what\na wonderful dream it had been.\nBut her sister sat still just as she left her, leaning her head on her hand, watch-\ning the setting sun, and thinking of little Alice and all her wonderful adventures\ntill she too began dreaming after a fashion and this was her dream:\nFirst, she dreamed of little Alice herself and once again the tiny hands were\nclasped upon her knee and the bright eager eyes were looking up into hers – she\ncould hear the very tones of her voice and see that queer little toss of her head to\nkeep back the wandering hair that\nwould\nalways get into her eyes – and still as she","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":75},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:76","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"CHAPTER XII.  ALICE’S EVIDENCE\n75\nlistened, or seemed to listen, the whole place around her became alive the strange\ncreatures of her little sister’s dream.\nThe long grass rustled at her feet as the White Rabbit hurried by – the fright-\nened Mouse splashed his way through the neighbouring pool – she could hear the\nrattle of the teacups as the March Hare and his friends shared their never-ending\nmeal and the shrill voice of the Queen ordering off her unfortunate guests to exe-\ncution – once more the pig-baby was sneezing on the Duchess’s knee while plates\nand dishes crashed around it – once more the shriek of the Gryphon, the squeaking\nof the Lizard’s slate-pencil and the choking of the suppressed guinea-pigs, filled\nthe air, mixed up with the distant sobs of the miserable Mock Turtle.\nSo she sat on, with closed eyes, and half believed herself in Wonderland,\nthough she knew she had but to open them again and all would change to dull\nreality – the grass would be only rustling in the wind, and the pool rippling to the\nwaving of the reeds – the rattling teacups would change to tinkling sheep-bells\nand the Queen’s shrill cries to the voice of the shepherd boy – and the sneeze of\nthe baby, the shriek of the Gryphon, and all the other queer noises, would change\n(she knew) to the confused clamour of the busy farm-yard – while the lowing of\nthe cattle in the distance would take the place of the Mock Turtle’s heavy sobs.\nLastly, she pictured to herself how this same little sister of hers would, in the\nafter-time, be herself a grown woman; and how she would keep, through all her\nriper years, the simple and loving heart of her childhood; and how she would\ngather about her other little children and make\ntheir\neyes bright and eager with\nmany a strange tale, perhaps even with the dream of Wonderland of long ago; and\nhow she would feel with all their simple sorrows and find a pleasure in all their\nsimple joys remembering her own child-life and the happy summer days.","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":76},{"id":"./test/fixtures/pdf/alice-in-wonderland-book.pdf:77","title":"Alice's Adventures in Wonderland","author":"Lewis Carroll","body":"T\nHE\nE\nND","filePath":"./test/fixtures/pdf/alice-in-wonderland-book.pdf","pageNumber":77},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:1","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"T\nHROUGH THE\nL\nOOKING\n-G\nLASS\nAND\nW\nHAT\nA\nLICE\nF\nOUND\nT\nHERE\nby Lewis Carroll\nwith fifty illustrations by John Tenniel\nThis book is in public domain.\nNo rigths reserved. Free for copy and distribution.\nThe book is designed and published by PDF\nREE\nB\nOOKS\n.\nORG","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":1},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:2","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":2},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:3","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Contents\nI\nLooking-Glass House\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   2\nII    The Garden of Live Flowers\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11\nIII   Looking-Glass Insects\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nIV   Tweedledum and Tweedledee\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25\nV    Wool and Water\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  35\nVI   Humpty Dumpty\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nVII  The Lion and the Unicorn\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  52\nVIII  It’s My Own Invention\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  59\nIX   Queen Alice\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\nX    Shaking\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\nXI   Waking\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  82\nXII  Which Dreamed It?\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  83\n1","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":3},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:4","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter I\nLooking-Glass House\nOne thing was certain, that the\nwhite\nkitten had had nothing to do with it – it\nwas the black kitten’s fault entirely. For the white kitten had been having its face\nwashed by the old cat for the last quarter of an hour (and bearing it pretty well,\nconsidering); so you see that it\ncouldn’t\nhave had any hand in the mischief.\nThe way Dinah washed her children’s faces was this: first she held the poor\nthing down by its ear with one paw, and then with the other paw she rubbed its\nface all over, the wrong way, beginning at the nose: and just now, as I said, she\nwas hard at work on the white kitten, which was lying quite still and trying to\npurr – no doubt feeling that it was all meant for its good.\nBut the black kitten had been finished with earlier in the afternoon, and so,\nwhile Alice was sitting curled up in a corner of the great arm-chair, half talking\nto herself and half asleep, the kit-\nten had been having a grand game of\nromps with the ball of worsted Alice\nhad been trying to wind up, and had\nbeen rolling it up and down till it had\nall come undone again; and there it\nwas, spread over the hearth-rug, all\nknots and tangles, with the kitten run-\nning after its own tail in the middle.\n‘Oh,  you wicked little thing!’\ncried Alice, catching up the kitten,\nand giving it a little kiss to make it un-\nderstand that it was in disgrace. ‘Re-\nally, Dinah ought to have taught you\nbetter manners!  You\nought\n, Dinah,\nyou know you ought!’  she added,\nlooking reproachfully at the old cat,\n2","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":4},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:5","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n3\nand speaking in as cross a voice as she could manage – and then she scrambled\nback into the arm-chair, taking the kitten and the worsted with her, and began\nwinding up the ball again. But she didn’t get on very fast, as she was talking all\nthe time, sometimes to the kitten, and sometimes to herself. Kitty sat very de-\nmurely on her knee, pretending to watch the progress of the winding, and now\nand then putting out one paw and gently touching the ball, as if it would be glad\nto help, if it might.\n‘Do you know what to-morrow is,\nKitty?’   Alice began,  ‘You’d have\nguessed if you’d been up in the window\nwith me – only Dinah was making you\ntidy, so you couldn’t. I was watching the\nboys getting in sticks for the bonfire –\nand it wants plenty of sticks, Kitty! Only\nit got so cold, and it snowed so, they had\nto leave off. Never mind, Kitty, we’ll go and see the bonfire to-morrow.’ Here\nAlice wound two or three turns of the worsted round the kitten’s neck, just to see\nhow it would look: this led to a scramble, in which the ball rolled down upon the\nfloor, and yards and yards of it got unwound again.\n‘Do you know, I was so angry, Kitty,’ Alice went on as soon as they were\ncomfortably settled again, ‘when I saw all the mischief you had been doing, I was\nvery nearly opening the window, and putting you out into the snow! And you’d\nhave deserved it, you little mischievous darling! What have you got to say for\nyourself? Now don’t interrupt me!’ she went on, holding up one finger. ‘I’m\ngoing to tell you all your faults. Number one: you squeaked twice while Dinah\nwas washing your face this morning. Now you can’t deny it, Kitty: I heard you!\nWhat’s that you say?’ (pretending that the kitten was speaking.) ‘Her paw went\ninto your eye? Well, that’s\nyour\nfault, for keeping your eyes open – if you’d shut\nthem tight up, it wouldn’t have happened. Now don’t make any more excuses, but\nlisten! Number two: you pulled Snowdrop away by the tail just as I had put down\nthe saucer of milk before her! What, you were thirsty, were you? How do you\nknow she wasn’t thirsty too? Now for number three: you unwound every bit of\nthe worsted while I wasn’t looking!\n‘That’s three faults, Kitty, and you’ve not been punished for any of them yet.\nYou know I’m saving up all your punishments for Wednesday week – Suppose\nthey had saved up all\nmy\npunishments!’ she went on, talking more to herself than\nthe kitten. ‘What\nwould\nthey do at the end of a year? I should be sent to prison,\nI suppose, when the day came. Or – let me see – suppose each punishment was to\nbe going without a dinner: then, when the miserable day came, I should have to\ngo without fifty dinners at once! Well, I shouldn’t mind\nthat\nmuch! I’d far rather\ngo without them than eat them!’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":5},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:6","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n4\n‘Do you hear the snow against the window-panes, Kitty? How nice and soft\nit sounds! Just as if some one was kissing the window all over outside. I wonder\nif the snow\nloves\nthe trees and fields, that it kisses them so gently? And then\nit covers them up snug, you know, with a white quilt; and perhaps it says, “Go\nto sleep, darlings, till the summer comes again.” And when they wake up in the\nsummer, Kitty, they dress themselves all in green, and dance about – whenever\nthe wind blows – oh, that’s very pretty!’ cried Alice, dropping the ball of worsted\nto clap her hands. ‘And I do so\nwish\nit was true! I’m sure the woods look sleepy\nin the autumn, when the leaves are getting brown.\n‘Kitty, can you play chess? Now, don’t smile, my dear, I’m asking it seriously.\nBecause, when we were playing just now, you watched just as if you understood\nit: and when I said “Check!” you purred! Well, it\nwas\na nice check, Kitty, and\nreally I might have won, if it hadn’t been for that nasty Knight, that came wiggling\ndown among my pieces. Kitty, dear, let’s pretend – ’ And here I wish I could tell\nyou half the things Alice used to say, beginning with her favourite phrase ‘Let’s\npretend.’ She had had quite a long argument with her sister only the day before –\nall because Alice had begun with ‘Let’s pretend we’re kings and queens;’ and her\nsister, who liked being very exact, had argued that they couldn’t, because there\nwere only two of them, and Alice had been reduced at last to say, ‘Well,\nyou\ncan\nbe one of them then, and\nI’ll\nbe all the rest.’ And once she had really frightened\nher old nurse by shouting suddenly in her ear, ‘Nurse! Do let’s pretend that I’m\na hungry hyaena, and you’re a bone.’\nBut this is taking us away from Alice’s speech to the kitten. ‘Let’s pretend that\nyou’re the Red Queen, Kitty! Do you know, I think if you sat up and folded your\narms, you’d look exactly like her. Now do try, there’s a dear!’ And Alice got the\nRed Queen off the table, and set it up before the kitten as a model for it to imi-\ntate: however, the thing didn’t succeed, principally, Alice said, because the kitten\nwouldn’t fold its arms properly. So, to punish it, she held it up to the Looking-\nglass, that it might see how sulky it was – ‘and if you’re not good directly,’ she\nadded, ‘I’ll put you through into Looking-glass House. How would you like\nthat\n?’\n‘Now, if you’ll only attend, Kitty, and not talk so much, I’ll tell you all my\nideas about Looking-glass House. First, there’s the room you can see through the\nglass – that’s just the same as our drawing room, only the things go the other way.\nI can see all of it when I get upon a chair – all but the bit behind the fireplace. Oh!\nI do so wish I could see\nthat\nbit! I want so much to know whether they’ve a fire in\nthe winter: you never\ncan\ntell, you know, unless our fire smokes, and then smoke\ncomes up in that room too – but that may be only pretence, just to make it look\nas if they had a fire. Well then, the books are something like our books, only the\nwords go the wrong way; I know that, because I’ve held up one of our books to\nthe glass, and then they hold up one in the other room.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":6},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:7","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n5\n‘How would you like to live in Looking-glass House, Kitty? I wonder if they’d\ngive you milk in there? Perhaps Looking-glass milk isn’t good to drink – But oh,\nKitty! now we come to the passage. You can just see a little\npeep\nof the passage\nin Looking-glass House, if you leave the door of our drawing-room wide open:\nand it’s very like our passage as far as you can see, only you know it may be quite\ndifferent on beyond. Oh, Kitty! How nice it would be if we could only get through\ninto Looking-glass House! I’m sure it’s got, oh! such beautiful things in it! Let’s\npretend there’s a way of getting through into it, somehow, Kitty. Let’s pretend the\nglass has got all soft like gauze, so that we can get through. Why, it’s turning into\na sort of mist now, I declare! It’ll be easy enough to get through – ’ She was up\non the chimney-piece while she said this, though she hardly knew how she had\ngot there. And certainly the glass\nwas\nbeginning to melt away, just like a bright\nsilvery mist.\nIn another moment Alice was through the glass, and had jumped lightly down\ninto the Looking-glass room. The very first thing she did was to look whether\nthere was a fire in the fireplace, and she was quite pleased to find that there was\na real one, blazing away as brightly as the one she had left behind. ‘So I shall be\nas warm here as I was in the old room,’ thought Alice, ‘warmer, in fact, because\nthere’ll be no one here to scold me away from the fire. Oh, what fun it’ll be, when\nthey see me through the glass in here, and can’t get at me!’\nThen she began looking about, and noticed that what could be seen from the\nold room was quite common and uninteresting, but that all the rest was as dif-\nferent as possible. For instance, the pictures on the wall next the fire seemed to","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":7},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:8","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n6\nbe all alive, and the very clock on the chimney-piece (you know you can only\nsee the back of it in the Looking-glass) had got the face of a little old man and\ngrinned at her.\n‘They don’t keep this room so tidy\nas the other,’ Alice thought to herself,\nas she noticed several of the chessmen\ndown in the hearth among the cinders:\nbut in another moment, with a little\n‘Oh!’ of surprise, she was down on\nher hands and knees watching them.\nThe chessmen were walking about,\ntwo and two!\n‘Here are the Red King and the\nRed Queen,’ Alice said (in a whisper,\nfor fear of frightening them), ‘and there are the White King and the White Queen\nsitting on the edge of the shovel – and here are two castles walking arm in arm –\nI don’t think they can hear me,’ she went on, as she put her head closer down, ‘and\nI’m nearly sure they can’t see me. I feel somehow as if I were invisible – ’\nHere something began squeaking on the table behind Alice, and made her turn\nher head just in time to see one of the White Pawns roll over and begin kicking:\nshe watched it with great curiosity to see what would happen next.\n‘It is the voice of my child!’ the White Queen cried out as she rushed past the\nKing, so violently that she knocked him over among the cinders. ‘My precious\nLily! My imperial kitten!’ and she began scrambling wildly up the side of the\nfender.\n‘Imperial fiddlestick!’ said the King, rubbing his nose, which had been hurt by\nthe fall. He had a right to be a\nlittle\nannoyed with the Queen, for he was covered\nwith ashes from head to foot.\nAlice was very anxious to be of use, and, as the poor little Lily was nearly\nscreaming herself into a fit, she hastily picked up the Queen and set her on the\ntable by the side of her noisy little daughter.\nThe Queen gasped, and sat down: the rapid journey through the air had quite\ntaken away her breath and for a minute or two she could do nothing but hug the\nlittle Lily in silence. As soon as she had recovered her breath a little, she called out\nto the White King, who was sitting sulkily among the ashes, ‘Mind the volcano!’\n‘What volcano?’ said the King, looking up anxiously into the fire, as if he\nthought that was the most likely place to find one.\n‘Blew – me – up,’ panted the Queen, who was still a little out of breath. ‘Mind\nyou come up – the regular way – don’t get blown up!’\nAlice watched the White King as he slowly struggled up from bar to bar, till at\nlast she said, ‘Why, you’ll be hours and hours getting to the table, at that rate. I’d","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":8},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:9","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n7\nfar better help you, hadn’t I?’ But the King took no notice of the question: it was\nquite clear that he could neither hear her nor see her.\nSo Alice picked him up very gen-\ntly, and lifted him across more slowly\nthan she had lifted the Queen, that she\nmightn’t take his breath away: but,\nbefore she put him on the table, she\nthought she might as well dust him\na little, he was so covered with ashes.\nShe said afterwards that she had\nnever seen in all her life such a face as\nthe King made, when he found him-\nself held in the air by an invisible\nhand, and being dusted: he was far\ntoo much astonished to cry out, but\nhis eyes and his mouth went on getting larger and larger, and rounder and rounder,\ntill her hand shook so with laughing that she nearly let him drop upon the floor.\n‘Oh!\nPlease\ndon’t make such faces, my dear!’ she cried out, quite forgetting\nthat the King couldn’t hear her. ‘You make me laugh so that I can hardly hold\nyou! And don’t keep your mouth so wide open! All the ashes will get into it –\nthere, now I think you’re tidy enough!’ she added, as she smoothed his hair, and\nset him upon the table near the Queen.\nThe King immediately fell flat on his back, and lay perfectly still: and Alice\nwas a little alarmed at what she had done, and went round the room to see if she\ncould find any water to throw over him. However, she could find nothing but\na bottle of ink, and when she got back with it she found he had recovered, and he\nand the Queen were talking together in a frightened whisper – so low, that Alice\ncould hardly hear what they said.\nThe King was saying, ‘I assure, you my dear, I turned cold to the very ends of\nmy whiskers!’\nTo which the Queen replied, ‘You haven’t got any whiskers.’\n‘The horror of that moment,’ the King went on, ‘I shall never,\nnever\nforget!’\n‘You will, though,’ the Queen said, ‘if you don’t make a memorandum of it.’\nAlice looked on with great interest as the King took an enormous memoran-\ndum-book out of his pocket, and began writing. A sudden thought struck her, and\nshe took hold of the end of the pencil, which came some way over his shoulder,\nand began writing for him.\nThe poor King looked puzzled and unhappy, and struggled with the pencil for\nsome time without saying anything; but Alice was too strong for him, and at last","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":9},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:10","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n8\nhe panted out, ‘My dear! I really\nmust\nget\na thinner pencil.  I can’t manage this one\na bit; it writes all manner of things that\nI don’t intend – ’\n‘What manner of things?’   said the\nQueen, looking over the book (in which Al-\nice had put ‘T\nHE WHITE KNIGHT IS SLID\n-\nING DOWN THE POKER\n.  H\nE BALANCES\nVERY BADLY\n’) ‘That’s not a memorandum\nof\nyour\nfeelings!’\nThere was a book lying near Alice on\nthe table, and while she sat watching the\nWhite King (for she was still a little anx-\nious about him, and had the ink all ready to\nthrow over him, in case he fainted again),\nshe turned over the leaves, to find some part that she could read, ‘ – for it’s all in\nsome language I don’t know,’ she said to herself.\nIt was like this:\nJ\nABBERWOCKY\n’Twas brilling, and the slithy toves\nDid gyre and gimble in the wabe;\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.\nShe puzzled over this for some time, but at last a bright thought struck her.\n‘Why, it’s a Looking-glass book, of course! And if I hold it up to a glass, the\nwords will all go the right way again.’\nThis was the poem that Alice read:\nJ\nABBERWOCKY\n’Twas brilling, and the slithy toves\nDid gyre and gimble in the wabe;\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.\n‘Beware the Jabberwock, my son!\nThe jaws that bite, the claws that catch!\nBeware the Jubjub bird, and shun\nThe frumious Bandersnatch!’\nHe took his vorpal sword in hand:\nLong time the manxome foe he sought –","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":10},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:11","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n9\nSo rested he by the Tumtum tree,\nAnd stood awhile in thought.\nAnd as in uffish thought he stood,\nThe Jabberwock, with eyes of flame,\nCame whiffling through the tulgey wood,\nAnd burbled as it came!\nOne, two! One, two! And through and through\nThe vorpal blade went snicker-snack!\nHe left it dead, and with its head\nHe went galumphing back.\n‘And hast thou slain the Jabberwock?\nCome to my arms, my beamish boy!\nO frabjous day! Callooh! Callay!’\nHe chortled in his joy.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":11},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:12","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER I.  LOOKING-GLASS HOUSE\n10\n’Twas brilling, and the slithy toves\nDid gyre and gimble in the wabe;\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.\n‘It seems very pretty,’ she said when she had finished it, ‘but it’s\nrather\nhard to\nunderstand!’ (You see she didn’t like to confess, ever to herself, that she couldn’t\nmake it out at all.) ‘Somehow it seems to fill my head with ideas – only I don’t\nexactly know what they are! However,\nsomebody\nkilled\nsomething\n: that’s clear, at\nany rate – ’\n‘But oh!’ thought Alice, suddenly jumping up, ‘if I don’t make haste I shall\nhave to go back through the Looking-glass, before I’ve seen what the rest of the\nhouse is like! Let’s have a look at the garden first!’ She was out of the room\nin a moment, and ran down stairs – or, at least, it wasn’t exactly running, but\na new invention of hers for getting down stairs quickly and easily, as Alice said\nto herself. She just kept the tips of her fingers on the hand-rail, and floated gently\ndown without even touching the stairs with her feet; then she floated on through\nthe hall, and would have gone straight out at the door in the same way, if she hadn’t\ncaught hold of the door-post. She was getting a little giddy with so much floating\nin the air, and was rather glad to find herself walking again in the natural way.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":12},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:13","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter II\nThe Garden of Live Flowers\n‘I should see the garden far better,’ said Alice to herself, ‘if I could get to the top\nof that hill: and here’s a path that leads straight to it – at least, no, it doesn’t do\nthat – ’ (after going a few yards along the path, and turning several sharp corners),\n‘but I suppose it will at last. But how curiously it twists! It’s more like a corkscrew\nthan a path! Well,\nthis\nturn goes to the hill, I suppose – no, it doesn’t! This goes\nstraight back to the house! Well then, I’ll try it the other way.’\nAnd so she did: wandering up and down, and trying turn after turn, but always\ncoming back to the house, do what she would. Indeed, once, when she turned\na corner rather more quickly than usual, she ran against it before she could stop\nherself.\n‘It’s no use talking about it,’ Alice said, looking up at the house and pretending\nit was arguing with her. ‘I’m\nnot\ngoing in again yet. I know I should have to get\nthrough the Looking-glass again – back into the old room – and there’d be an end\nof all my adventures!’\nSo, resolutely turning her back upon the house, she set out once more down\nthe path, determined to keep straight on till she got to the hill. For a few minutes\nall went on well, and she was just saying, ‘I really\nshall\ndo it this time – ’ when\nthe path gave a sudden twist and shook itself (as she described it afterwards), and\nthe next moment she found herself actually walking in at the door.\n‘Oh, it’s too bad!’ she cried. ‘I never saw such a house for getting in the way!\nNever!’\nHowever, there was the hill full in sight, so there was nothing to be done but\nstart again. This time she came upon a large flower-bed, with a border of daisies,\nand a willow-tree growing in the middle.\n‘O Tiger-lily,’ said Alice, addressing herself to one that was waving gracefully\nabout in the wind, ‘I\nwish\nyou could talk!’\n‘We\ncan\ntalk,’ said the Tiger-lily, ‘when there’s anybody worth talking to.’\nAlice was so astonished that she could not speak for a minute: it quite seemed\n11","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":13},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:14","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n12\nto take her breath away.  At length,\nas the Tiger-lily only went on wav-\ning about, she spoke again, in a timid\nvoice – almost in a whisper: ‘And can\nall\nthe flowers talk?’\n‘As well as\nyou\ncan,’ said the\nTiger-lily. ‘And a great deal louder.’\n‘It isn’t manners for us to be-\ngin, you know,’ said the Rose, ‘and\nI really was wondering when you’d\nspeak! Said I to myself, “Her face has\ngot\nsome\nsense in it, though it’s not\na clever one!” Still, you’re the right\ncolour, and that goes a long way.’\n‘I don’t care about the colour,’\nthe Tiger-lily remarked. ‘If only her\npetals curled up a little more, she’d be all right.’\nAlice didn’t like being criticised, so she began asking questions. ‘Aren’t you\nsometimes frightened at being planted out here, with nobody to take care of you?’\n‘There’s the tree in the middle,’ said the Rose, ‘what else is it good for?’\n‘But what could it do, if any danger came?’ Alice asked.\n‘It says “Bough-wough!” ’ cried a Daisy, ‘that’s why its branches are called\nboughs!’\n‘Didn’t you know\nthat\n?’ cried another Daisy, and here they all began shouting\ntogether, till the air seemed quite full of little shrill voices. ‘Silence, every one\nof you!’ cried the Tiger- lily, waving itself passionately from side to side, and\ntrembling with excitement. ‘They know I can’t get at them!’ it panted, bending\nits quivering head towards Alice, ‘or they wouldn’t dare to do it!’\n‘Never mind!’ Alice said in a soothing tone, and stooping down to the daisies,\nwho were just beginning again, she whispered, ‘If you don’t hold your tongues,\nI’ll pick you!’\nThere was silence in a moment, and several of the pink daisies turned white.\n‘That’s right!’ said the Tiger-lily. ‘The daisies are worst of all. When one\nspeaks, they all begin together, and it’s enough to make one wither to hear the\nway they go on!’\n‘How is it you can all talk so nicely?’ Alice said, hoping to get it into a better\ntemper by a compliment. ‘I’ve been in many gardens before, but none of the\nflowers could talk.’\n‘Put your hand down, and feel the ground,’ said the Tiger-lily. ‘Then you’ll\nknow why.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":14},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:15","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n13\nAlice did so. ‘It’s very hard,’ she said, ‘but I don’t see what that has to do\nwith it.’\n‘In most gardens,’ the Tiger-lily said, ‘they make the beds too soft – so that\nthe flowers are always asleep.’\nThis sounded a very good reason, and Alice was quite pleased to know it.\n‘I never thought of that before!’ she said.\n‘It’s\nmy\nopinion that you never think\nat all\n,’ the Rose said in a rather severe\ntone.\n‘I never saw anybody that looked stupider,’ a Violet said, so suddenly, that\nAlice quite jumped; for it hadn’t spoken before.\n‘Hold\nyour\ntongue!’ cried the Tiger-lily. ‘As if\nyou\never saw anybody! You\nkeep your head under the leaves, and snore away there, till you know no more\nwhat’s going on in the world, than if you were a bud!’\n‘Are there any more people in the garden besides me?’ Alice said, not choos-\ning to notice the Rose’s last remark.\n‘There’s one other flower in the garden that can move about like you,’ said the\nRose. ‘I wonder how you do it – ’ (‘You’re always wondering,’ said the Tiger-lily),\n‘but she’s more bushy than you are.’\n‘Is she like me?’  Alice asked eagerly, for the thought crossed her mind,\n‘There’s another little girl in the garden, somewhere!’\n‘Well, she has the same awkward shape as you,’ the Rose said, ‘but she’s\nredder – and her petals are shorter, I think.’\n‘Her petals are done up close, almost like a dahlia,’ the Tiger-lily interrupted,\n‘not tumbled about anyhow, like yours.’\n‘But that’s not\nyour\nfault,’ the Rose added kindly, ‘you’re beginning to fade,\nyou know – and then one can’t help one’s petals getting a little untidy.’\nAlice didn’t like this idea at all: so, to change the subject, she asked ‘Does she\never come out here?’\n‘I daresay you’ll see her soon,’ said the Rose. ‘She’s one of the thorny kind.’\n‘Where does she wear the thorns?’ Alice asked with some curiosity.\n‘Why all round her head, of course,’ the Rose replied. ‘I was wondering\nyou\nhadn’t got some too. I thought it was the regular rule.’\n‘She’s coming!’  cried the Larkspur.  ‘I hear her footstep, thump, thump,\nthump, along the gravel-walk!’\nAlice looked round eagerly, and found that it was the Red Queen. ‘She’s\ngrown a good deal!’ was her first remark. She had indeed: when Alice first found\nher in the ashes, she had been only three inches high – and here she was, half\na head taller than Alice herself!\n‘It’s the fresh air that does it,’ said the Rose, ‘wonderfully fine air it is, out\nhere.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":15},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:16","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n14\n‘I think I’ll go and meet her,’ said Alice, for, though the flowers were interest-\ning enough, she felt that it would be far grander to have a talk with a real Queen.\n‘You can’t possibly do that,’ said the Rose, ‘\nI\nshould advise you to walk the\nother way.’\nThis sounded nonsense to Alice, so she said nothing, but set off at once to-\nwards the Red Queen. To her surprise, she lost sight of her in a moment, and\nfound herself walking in at the front-\ndoor again.  A little provoked, she\ndrew back, and after looking every-\nwhere for the queen (whom she spied\nout at last, a long way off), she\nthought she would try the plan, this\ntime, of walking in the opposite direc-\ntion.\nIt succeeded beautifully. She had\nnot been walking a minute before she\nfound herself face to face with the\nRed Queen, and full in sight of the hill\nshe had been so long aiming at.\n‘Where do you come from?’ said\nthe Red Queen.   ‘And where are\nyou going?  Look up, speak nicely,\nand don’t twiddle your fingers all the\ntime.’\nAlice attended to all these directions, and explained, as well as she could, that\nshe had lost her way.\n‘I don’t know what you mean by\nyour\nway,’ said the Queen, ‘all the ways\nabout here belong to\nme\n– but why did you come out here at all?’ she added in\na kinder tone. ‘Curtsey while you’re thinking what to say, it saves time.’\nAlice wondered a little at this, but she was too much in awe of the Queen to\ndisbelieve it. ‘I’ll try it when I go home,’ she thought to herself, ‘the next time\nI’m a little late for dinner.’\n‘It’s time for you to answer now,’ the Queen said, looking at her watch, ‘open\nyour mouth a\nlittle\nwider when you speak, and always say “your Majesty.” ’\n‘I only wanted to see what the garden was like, your Majesty – ’\n‘That’s right,’ said the Queen, patting her on the head, which Alice didn’t like\nat all, ‘though, when you say “garden,” –\nI’ve\nseen gardens, compared with which\nthis would be a wilderness.’\nAlice didn’t dare to argue the point, but went on: ‘ – and I thought I’d try and\nfind my way to the top of that hill – ’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":16},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:17","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n15\n‘When you say “hill,” ’ the Queen interrupted, ‘\nI\ncould show you hills, in\ncomparison with which you’d call that a valley.’\n‘No, I shouldn’t,’ said Alice, surprised into contradicting her at last, ‘a hill\ncan’t\nbe a valley, you know. That would be nonsense – ’\nThe Red Queen shook her head, ‘You may call it “nonsense” if you like,’ she\nsaid, ‘but\nI’ve\nheard nonsense, compared with which that would be as sensible as\na dictionary!’\nAlice curtseyed again, as she was afraid from the Queen’s tone that she was\na\nlittle\noffended: and they walked on in silence till they got to the top of the\nlittle hill.\nFor some minutes Alice stood without speaking, looking out in all directions\nover the country – and a most curious country it was. There were a number of tiny\nlittle brooks running straight across\nit from side to side,  and the\nground between was divided up\ninto squares by a number of lit-\ntle green hedges, that reached from\nbrook to brook.\n‘I declare it’s marked out just\nlike a large chessboard!’ Alice said\nat last.  ‘There ought to be some\nmen moving about somewhere –\nand so there are!’ She added in a tone of delight, and her heart began to beat\nquick with excitement as she went on. ‘It’s a great huge game of chess that’s be-\ning played – all over the world – if this\nis\nthe world at all, you know. Oh, what\nfun it is! How I\nwish\nI was one of them! I wouldn’t mind being a Pawn, if only\nI might join – though of course I should\nlike\nto be a Queen, best.’\nShe glanced rather shyly at the\nreal Queen as she said this, but her\ncompanion only smiled pleasantly,\nand said, ‘That’s easily managed. You\ncan be the White Queen’s Pawn, if\nyou like, as Lily’s too young to play;\nand you’re in the Second Square to\nbegin with:  when you get to the\nEighth Square you’ll be a Queen – ’\nJust at this moment, somehow or other, they began to run.\nAlice never could quite make out, in thinking it over afterwards, how it was\nthat they began: all she remembers is, that they were running hand in hand, and\nthe Queen went so fast that it was all she could do to keep up with her; and still the\nQueen kept crying ‘Faster! Faster!’ but Alice felt she\ncould not\ngo faster, though","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":17},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:18","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n16\nshe had not breath left to say so.\nThe most curious part of the thing was, that the trees and the other things\nround them never changed their places at all: however fast they went, they never\nseemed to pass anything. ‘I wonder if all the things move along with us?’ thought\npoor puzzled Alice. And the Queen seemed to guess her thoughts, for she cried,\n‘Faster! Don’t try to talk!’\nNot that Alice had any idea of doing\nthat\n. She felt as if she would never be\nable to talk again, she was getting so much out of breath: and still the Queen cried\n‘Faster! Faster!’ and dragged her along. ‘Are we nearly there?’ Alice managed to\npant out at last.\n‘Nearly there!’ the Queen repeated. ‘Why, we passed it ten minutes ago!\nFaster!’ And they ran on for a time in silence, with the wind whistling in Alice’s\nears, and almost blowing her hair off her head, she fancied.\n‘Now! Now!’ cried the Queen. ‘Faster! Faster!’ And they went so fast that\nat last they seemed to skim through the air, hardly touching the ground with their\nfeet, till suddenly, just as Alice was getting quite exhausted, they stopped, and she\nfound herself sitting on the ground, breathless and giddy.\nThe Queen propped her up against a tree, and said kindly, ‘You may rest a little\nnow.’\nAlice looked round her in great surprise. ‘Why, I do believe we’ve been under\nthis tree the whole time! Everything’s just as it was!’\n‘Of course it is,’ said the Queen, ‘what would you have it?’\n‘Well, in\nour\ncountry,’ said Alice, still panting a little, ‘you’d generally get to\nsomewhere else – if you ran very fast for a long time, as we’ve been doing.’\n‘A slow sort of country!’ said the Queen. ‘Now,\nhere\n, you see, it takes all the\nrunning\nyou\ncan do, to keep in the same place. If you want to get somewhere else,\nyou must run at least twice as fast as that!’\n‘I’d rather not try, please!’ said Alice. ‘I’m quite content to stay here – only\nI\nam\nso hot and thirsty!’\n‘I know what\nyou’d\nlike!’ the Queen said good-naturedly, taking a little box\nout of her pocket. ‘Have a biscuit?’\nAlice thought it would not be civil to say ‘No,’ though it wasn’t at all what she\nwanted. So she took it, and ate it as well as she could: and it was\nvery\ndry; and\nshe thought she had never been so nearly choked in all her life.\n‘While you’re refreshing yourself,’ said the Queen, ‘I’ll just take the measure-\nments.’ And she took a ribbon out of her pocket, marked in inches, and began\nmeasuring the ground, and sticking little pegs in here and there.\n‘At the end of two yards,’ she said, putting in a peg to mark the distance,\n‘I shall give you your directions – have another biscuit?’\n‘No, thank you,’ said Alice, ‘one’s\nquite\nenough!’\n‘Thirst quenched, I hope?’ said the Queen.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":18},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:19","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER II.  THE GARDEN OF LIVE FLOWERS\n17\nAlice did not know what to say to this, but luckily the Queen did not wait for\nan answer, but went on. ‘At the end of\nthree\nyards I shall repeat them – for fear of\nyour forgetting them. At the end of\nfour\n, I shall say good-bye. And at the end of\nfive\n, I shall go!’\nShe had got all the pegs put in by this time, and Alice looked on with great\ninterest as she returned to the tree, and then began slowly walking down the row.\nAt the two-yard peg she faced round, and said, ‘A pawn goes two squares in\nits first move, you know. So you’ll go\nvery\nquickly through the Third Square – by\nrailway, I should think – and you’ll find yourself in the Fourth Square in no time.\nWell,\nthat\nsquare belongs to Tweedledum and Tweedledee – the Fifth is mostly\nwater – the Sixth belongs to Humpty Dumpty – But you make no remark?’\n‘I – I didn’t know I had to make one – just then,’ Alice faltered out.\n‘You\nshould\nhave said, “It’s extremely kind of you to tell me all this” – how-\never, we’ll suppose it said – the Seventh Square is all forest – however, one of the\nKnights will show you the way – and in the Eighth Square we shall be Queens\ntogether, and it’s all feasting and fun!’ Alice got up and curtseyed, and sat down\nagain.\nAt the next peg the Queen turned again, and this time she said, ‘Speak in\nFrench when you can’t think of the English for a thing – turn out your toes as you\nwalk – and remember who you are!’ She did not wait for Alice to curtsey this\ntime, but walked on quickly to the next peg, where she turned for a moment to say\n‘good-bye,’ and then hurried on to the last.\nHow it happened, Alice never knew, but exactly as she came to the last peg, she\nwas gone. Whether she vanished into the air, or whether she ran quickly into the\nwood (‘and she\ncan\nrun very fast!’ thought Alice), there was no way of guessing,\nbut she was gone, and Alice began to remember that she was a Pawn, and that it\nwould soon be time for her to move.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":19},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:20","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter III\nLooking-Glass Insects\nOf course the first thing to do was to make a grand survey of the country she was\ngoing to travel through. ‘It’s something very like learning geography,’ thought\nAlice, as she stood on tiptoe in hopes of being able to see a little further. ‘Princi-\npal rivers – there\nare\nnone. Principal mountains – I’m on the only one, but I don’t\nthink it’s got any name. Principal towns – why, what\nare\nthose creatures, mak-\ning honey down there? They can’t be bees – nobody ever saw bees a mile off,\nyou know – ’ and for some time she stood silent, watching one of them that was\nbustling about among the flowers, poking its proboscis into them, ‘just as if it was\na regular bee,’ thought Alice.\nHowever, this was anything but a regular bee: in fact it was an elephant – as\nAlice soon found out, though the idea quite took her breath away at first. ‘And\nwhat enormous flowers they must be!’ was her next idea. ‘Something like cottages\nwith the roofs taken off, and stalks put to them – and what quantities of honey\nthey must make! I think I’ll go down and – no, I won’t\njust\nyet,’ she went on,\nchecking herself just as she was beginning to run down the hill, and trying to find\nsome excuse for turning shy so suddenly. ‘It’ll never do to go down among them\nwithout a good long branch to brush them away – and what fun it’ll be when they\nask me how I like my walk. I shall say – “Oh, I like it well enough – ” ’ (here\ncame the favourite little toss of the head), ‘ “only it was so dusty and hot, and the\nelephants did tease so!” ’\n‘I think I’ll go down the other way,’ she said after a pause, ‘and perhaps I may\nvisit the elephants later on. Besides, I do so want to get into the Third Square!’\nSo with this excuse she ran down the hill and jumped over the first of the six\nlittle brooks.\n*    *    *    *    *    *    *    *    *    *    *\n18","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":20},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:21","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n19\n‘Tickets, please!’ said the Guard, putting his head in at the window. In a mo-\nment everybody was holding out a ticket: they were about the same size as the\npeople, and quite seemed to fill the carriage.\n‘Now then! Show your ticket, child!’ the Guard went on, looking angrily\nat Alice. And a great many voices all said together (‘like the chorus of a song,’\nthought Alice), ‘Don’t keep him waiting, child! Why, his time is worth a thousand\npounds a minute!’\n‘I’m afraid I haven’t got one,’ Alice said in a frightened tone, ‘there wasn’t\na ticket-office where I came from.’ And again the chorus of voices went on. ‘There\nwasn’t room for one where she came from. The land there is worth a thousand\npounds an inch!’\n‘Don’t make excuses,’ said the Guard, ‘you should have bought one from the\nengine-driver.’ And once more the chorus of voices went on with ‘The man that\ndrives the engine. Why, the smoke alone is worth a thousand pounds a puff!’\nAlice thought to herself, ‘Then there’s no use in speaking.’ The voices didn’t\njoin in this time, as she hadn’t spoken, but to her great surprise, they all\nthought\nin\nchorus (I hope you understand what\nthinking in chorus\nmeans – for I must confess\nthat\nI\ndon’t), ‘Better say nothing at all. Language is worth a thousand pounds\na word!’\n‘I shall dream about a thousand pounds tonight, I know I shall!’ thought Alice.\nAll this time the Guard was looking at her, first through a telescope, then\nthrough a microscope, and then through an opera-glass. At last he said, ‘You’re\ntravelling the wrong way,’ and shut up the window and went away.\n‘So young a child,’ said the gentleman sitting opposite to her (he was dressed\nin white paper), ‘ought to know which way she’s going, even if she doesn’t know\nher own name!’ A Goat, that was\nsitting next to the gentleman in\nwhite, shut his eyes and said in\na loud voice, ‘She ought to know\nher way to the ticket-office, even if\nshe doesn’t know her alphabet!’\nThere was a Beetle sitting next\nto the Goat (it was a very queer\ncarriage-full of passengers alto-\ngether), and, as the rule seemed\nto be that they should all speak in\nturn,\nhe\nwent on with ‘She’ll have\nto go back from here as luggage!’\nAlice couldn’t see who was sitting beyond the Beetle, but a hoarse voice spoke\nnext. ‘Change engines – ’ it said, and was obliged to leave off.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":21},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:22","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n20\n‘It sounds like a horse,’ Alice thought to herself. And an extremely small\nvoice, close to her ear, said, ‘You might make a joke on that – something about\n“horse” and “hoarse,” you know.’\nThen a very gentle voice in the distance said, ‘She must be labelled “Lass,\nwith care,” you know – ’\nAnd after that other voices went on (‘What a number of people there are in\nthe carriage!’ thought Alice), saying, ‘She must go by post, as she’s got a head\non her – ’ ‘She must be sent as a message by the telegraph – ’ ‘She must draw the\ntrain herself the rest of the way – ’ and so on.\nBut the gentleman dressed in white paper leaned forwards and whispered in\nher ear, ‘Never mind what they all say, my dear, but take a return-ticket every time\nthe train stops.’\n‘Indeed I shan’t!’ Alice said rather impatiently. ‘I don’t belong to this railway\njourney at all – I was in a wood just now – and I wish I could get back there.’\n‘You might make a joke on\nthat\n,’ said the little voice close to her ear, ‘some-\nthing about “you\nwould\nif you could,” you know.’\n‘Don’t tease so,’ said Alice, looking about in vain to see where the voice came\nfrom, ‘if you’re so anxious to have a joke made, why don’t you make one your-\nself?’\nThe little voice sighed deeply; it was\nvery\nunhappy, evidently, and Alice would\nhave said something pitying to comfort it, ‘If it would only sigh like other people!’\nshe thought. But this was such a wonderfully small sigh, that she wouldn’t have\nheard it at all, if it hadn’t come\nquite\nclose to her ear. The consequence of this\nwas that it tickled her ear very much, and quite took off her thoughts from the\nunhappiness of the poor little creature.\n‘I know you are a friend,’ the little voice went on, ‘a dear friend, and an old\nfriend. And you won’t hurt me, though I\nam\nan insect.’\n‘What kind of insect?’  Alice inquired a little anxiously.  What she really\nwanted to know was, whether it could sting or not, but she thought this wouldn’t\nbe quite a civil question to ask.\n‘What, then you don’t – ’ the little voice began, when it was drowned by\na shrill scream from the engine, and everybody jumped up in alarm, Alice among\nthe rest.\nThe Horse, who had put his head out of the window, quietly drew it in and said,\n‘It’s only a brook we have to jump over.’ Everybody seemed satisfied with this,\nthough Alice felt a little nervous at the idea of trains jumping at all. ‘However,\nit’ll take us into the Fourth Square, that’s some comfort!’ she said to herself. In\nanother moment she felt the carriage rise straight up into the air, and in her fright\nshe caught at the thing nearest to her hand, which happened to be the Goat’s beard.\n*    *    *    *    *    *    *    *    *    *    *","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":22},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:23","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n21\nBut the beard seemed to melt away as she touched it, and she found herself\nsitting quietly under a tree – while the Gnat (for that was the insect she had been\ntalking to) was balancing itself on a twig just over her head, and fanning her with\nits wings.\nIt certainly was a\nvery\nlarge Gnat, ‘about the size of a chicken,’ Alice thought.\nStill, she couldn’t feel nervous with it, after they had been talking together so long.\n‘ – then you don’t like all insects?’ the Gnat went on, as quietly as if nothing\nhad happened.\n‘I like them when they can talk,’ Alice said. ‘None of them ever talk, where\nI\ncome from.’\n‘What sort of insects do you rejoice in, where\nyou\ncome from?’ the Gnat\ninquired.\n‘I don’t\nrejoice\nin insects at all,’ Alice explained, ‘because I’m rather afraid of\nthem – at least the large kinds. But I can tell you the names of some of them.’\n‘Of course they answer to their names?’ the Gnat remarked carelessly.\n‘I never knew them do it.’\n‘What’s the use of their having names,’ the Gnat said, ‘if they won’t answer to\nthem?’\n‘No use to\nthem\n,’ said Alice; ‘but it’s useful to the people who name them,\nI suppose. If not, why do things have names at all?’\n‘I can’t say,’ the Gnat replied. ‘Further on, in the wood down there, they’ve\ngot no names – however, go on with your list of insects: you’re wasting time.’\n‘Well, there’s the Horse-fly,’ Alice began, counting off the names on her fin-\ngers.\n‘All right,’ said the Gnat, ‘half\nway up that bush you’ll see a Rocking-\nhorse-fly, if you look.   It’s made\nentirely of wood,  and gets about\nby swinging itself from branch to\nbranch.’\n‘What does it live on?’  Alice\nasked, with great curiosity.\n‘Sap and sawdust,’ said the Gnat.\n‘Go on with the list.’\nAlice looked up at the Rocking-horse-fly with great interest, and made up her\nmind that it must have been just repainted, it looked so bright and sticky; and then\nshe went on.\n‘And there’s the Dragon-fly.’\n‘Look on the branch above your head,’ said the Gnat, ‘and there you’ll find\na snap-dragon-fly. Its body is made of plum-pudding, its wings of holly-leaves,\nand its head is a raisin burning in brandy.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":23},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:24","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n22\n‘And what does it live on?’\n‘Frumenty and mince pie,’ the\nGnat replied; ‘and it makes its nest in\na Christmas box.’\n‘And then there’s the Butterfly,’\nAlice went on, after she had taken\na good look at the insect with its head\non fire, and had thought to herself,\n‘I wonder if that’s the reason insects\nare so fond of flying into candles – be-\ncause they want to turn into Snap-dragon-flies!’\n‘Crawling at your feet,’ said the Gnat (Alice drew her feet back in some alarm),\n‘you may observe a Bread-and-Butterfly. Its wings are thin slices of Bread-and-\nbutter, its body is a crust, and its head is a lump of sugar.’\n‘And what does\nit\nlive on?’\n‘Weak  tea  with  cream  in  it.’\nA new difficulty came into Alice’s\nhead.   ‘Supposing it couldn’t find\nany?’ she suggested.\n‘Then it would die, of course.’\n‘But that must happen very often,’\nAlice remarked thoughtfully.\n‘It always happens,’ said the Gnat.\nAfter this, Alice was silent for\na minute or two, pondering. The Gnat amused itself meanwhile by humming\nround and round her head: at last it settled again and remarked, ‘I suppose you\ndon’t want to lose your name?’\n‘No, indeed,’ Alice said, a little anxiously.\n‘And yet I don’t know,’ the Gnat went on in a careless tone, ‘only think how\nconvenient it would be if you could manage to go home without it! For instance, if\nthe governess wanted to call you to your lessons, she would call out “come here –\n,” and there she would have to leave off, because there wouldn’t be any name for\nher to call, and of course you wouldn’t have to go, you know.’\n‘That would never do, I’m sure,’ said Alice, ‘the governess would never think\nof excusing me lessons for that. If she couldn’t remember my name, she’d call me\n”Miss!” as the servants do.’\n‘Well, if she said “Miss,” and didn’t say anything more,’ the Gnat remarked,\n‘of course you’d miss your lessons. That’s a joke. I wish\nyou\nhad made it.’\n‘Why do you wish\nI\nhad made it?’ Alice asked. ‘It’s a very bad one.’\nBut the Gnat only sighed deeply, while two large tears came rolling down its\ncheeks.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":24},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:25","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n23\n‘You shouldn’t make jokes,’ Alice said, ‘if it makes you so unhappy.’\nThen came another of those melancholy little sighs, and this time the poor\nGnat really seemed to have sighed itself away, for, when Alice looked up, there\nwas nothing whatever to be seen on the twig, and, as she was getting quite chilly\nwith sitting still so long, she got up and walked on.\nShe very soon came to an open field, with a wood on the other side of it: it\nlooked much darker than the last wood, and Alice felt a\nlittle\ntimid about going\ninto it. However, on second thoughts, she made up her mind to go on, ‘for I cer-\ntainly won’t go\nback\n,’ she thought to herself, and this was the only way to the\nEighth Square.\n‘This must be the wood,’ she said thoughtfully to herself, ‘where things have\nno names. I wonder what’ll become of\nmy\nname when I go in? I shouldn’t like\nto lose it at all – because they’d have to give me another, and it would be almost\ncertain to be an ugly one. But then the fun would be trying to find the creature that\nhad got my old name! That’s just like the advertisements, you know, when people\nlose dogs – “A\nNSWERS TO THE NAME OF\n‘D\nASH\n’;\nHAD ON A BRASS COLLAR\n” –\njust fancy calling everything you met “Alice,” till one of them answered! Only\nthey wouldn’t answer at all, if they were wise.’\nShe was rambling on in this way when she reached the wood; it looked very\ncool and shady. ‘Well, at any rate it’s a great comfort,’ she said as she stepped\nunder the trees, ‘after being so hot, to get into the – into\nwhat\n?’ she went on,\nrather surprised at not being able to think of the word. ‘I mean to get under the –\nunder the – under\nthis\n, you know!’ putting her hand on the trunk of the tree.\n‘What\ndoes\nit call itself, I wonder? I do believe it’s got no name – why, to be sure\nit hasn’t!’\nShe stood silent for a minute, thinking; then she suddenly began again, ‘Then\nit really\nhas\nhappened, after all! And now, who am I? I\nwill\nremember, if I can!\nI’m determined to do it!’ But being determined didn’t help much, and all she\ncould say, after a great deal of puzzling, was, ‘L,\nI know\nit begins with L!’\nJust then a Fawn came wandering by; it looked at Alice with its large gentle\neyes, but didn’t seem at all frightened. ‘Here then! Here then!’ Alice said, as she\nheld out her hand and tried to stroke it; but it only started back a little, and then\nstood looking at her again.\n‘What do you call yourself?’ the Fawn said at last. Such a soft sweet voice it\nhad!\n‘I wish I knew!’ thought poor Alice. She answered, rather sadly, ‘Nothing,\njust now.’\n‘Think again,’ it said, ‘that won’t do.’\nAlice thought, but nothing came of it. ‘Please, would you tell me what\nyou\ncall yourself?’ she said timidly. ‘I think that might help a little.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":25},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:26","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER III.  LOOKING-GLASS INSECTS\n24\n‘I’ll tell you, if you’ll move a lit-\ntle further on,’ the Fawn said. ‘I can’t\nremember here.’\nSo they walked on together through\nthe wood, Alice with her arms clasped\nlovingly round the soft neck of the\nFawn, till they came out into another\nopen field, and here the Fawn gave\na sudden bound into the air, and shook\nitself free from Alice’s arms.  ‘I’m\na Fawn!’ it cried out in a voice of de-\nlight, ‘and, dear me! you’re a human\nchild!’ A sudden look of alarm came\ninto its beautiful brown eyes, and in\nanother moment it had darted away at\nfull speed.\nAlice stood looking after it, almost ready to cry with vexation at having lost\nher dear little fellow-traveller so suddenly. ‘However, I know my name now.’ she\nsaid, ‘that’s\nsome\ncomfort. Alice – Alice – I won’t forget it again. And now, which\nof these finger-posts ought I to follow, I wonder?’\nIt was not a very difficult question to answer, as there was only one road\nthrough the wood, and the two finger-posts both pointed along it. ‘I’ll settle it,’\nAlice said to herself, ’when the road divides and they point different ways.’\nBut this did not seem likely to happen. She went on and on, a long way, but\nwherever the road divided there were sure to be two finger-posts pointing the same\nway, one marked ‘T\nO\nT\nWEEDLEDUM\n’\nS HOUSE\n’ and the other ‘T\nO THE HOUSE\nOF\nT\nWEEDLEDEE\n.’\n‘I do believe,’ said Alice at last, ‘that they live in the same house! I wonder\nI never thought of that before – But I can’t stay there long. I’ll just call and say\n“how d’you do?” and ask them the way out of the wood. If I could only get to the\nEighth Square before it gets dark!’ So she wandered on, talking to herself as she\nwent, till, on turning a sharp corner, she came upon two fat little men, so suddenly\nthat she could not help starting back, but in another moment she recovered herself,\nfeeling sure that they must be.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":26},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:27","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter IV\nTweedledum and Tweedledee\nThey were standing under a tree, each\nwith an arm round the other’s neck,\nand Alice knew which was which in\na moment, because one of them had\n‘D\nUM\n’ embroidered on his collar, and\nthe other ‘D\nEE\n.’ ‘I suppose they’ve\neach got “T\nWEEDLE\n” round at the\nback of the collar,’ she said to herself.\nThey stood so still that she quite\nforgot they were alive, and she was\njust looking round to see if the word\n‘T\nWEEDLE\n’ was written at the back of each collar, when she was startled by\na voice coming from the one marked ‘D\nUM\n.’\n‘If you think we’re wax-works,’ he said, ‘you ought to pay, you know. Wax-\nworks weren’t made to be looked at for nothing, nohow!’\n‘Contrariwise,’ added the one marked ‘D\nEE\n,’ ‘if you think we’re alive, you\nought to speak.’\n‘I’m sure I’m very sorry,’ was all Alice could say; for the words of the old song\nkept ringing through her head like the ticking of a clock, and she could hardly help\nsaying them out loud:\n‘Tweedledum and Tweedledee\nAgreed to have a battle;\nFor Tweedledum said Tweedledee\nHad spoiled his nice new rattle.\nJust then flew down a monstrous crow,\nAs black as a tar-barrel;\nWhich frightened both the heroes so,\nThey quite forgot their quarrel.’\n25","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":27},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:28","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n26\n‘I know what you’re thinking about,’ said Tweedledum, ‘but it isn’t so, nohow.’\n‘Contrariwise,’ continued Tweedledee, ‘if it was so, it might be; and if it were\nso, it would be; but as it isn’t, it ain’t. That’s logic.’\n‘I was thinking,’ Alice said very politely, ‘which is the best way out of this\nwood: it’s getting so dark. Would you tell me, please?’\nBut the little men only looked at each other and grinned.\nThey looked so exactly like a couple of great schoolboys, that Alice couldn’t\nhelp pointing her finger at Tweedledum, and saying ‘First Boy!’\n‘Nohow!’ Tweedledum cried out briskly, and shut his mouth up again with\na snap.\n‘Next Boy!’ said Alice, passing on to Tweedledee, though she felt quite certain\nhe would only shout out ‘Contrariwise!’ and so he did.\n‘You’ve been wrong!’ cried Tweedledum. ‘The first thing in a visit is to say\n“How d’ye do?” and shake hands!’ And here the two brothers gave each other\na hug, and then they held out the two hands that were free, to shake hands with her.\nAlice did not like shaking hands with either of them first, for fear of hurting the\nother one’s feelings; so, as the best way out of the difficulty, she took hold of both\nhands at once: the next moment they were dancing round in a ring. This seemed\nquite natural (she remembered afterwards), and she was not even surprised to hear\nmusic playing: it seemed to come from the tree under which they were dancing,\nand it was done (as well as she could make it out) by the branches rubbing one\nacross the other, like fiddles and fiddle-sticks.\n‘But it certainly\nwas\nfunny,’ (Alice said afterwards, when she was telling her\nsister the history of all this,) ‘to find myself singing “H\nERE WE GO ROUND THE\nMULBERRY BUSH\n.” I don’t know when I began it, but somehow I felt as if I’d\nbeen singing it a long long time!’\nThe other two dancers were fat, and very soon out of breath. ‘Four times\nround is enough for one dance,’ Tweedledum panted out, and they left off dancing\nas suddenly as they had begun: the music stopped at the same moment.\nThen they let go of Alice’s hands, and stood looking at her for a minute: there\nwas a rather awkward pause, as Alice didn’t know how to begin a conversation\nwith people she had just been dancing with. ‘It would never do to say “How d’ye\ndo?”\nnow\n,’ she said to herself, ‘we seem to have got beyond that, somehow!’\n‘I hope you’re not much tired?’ she said at last.\n‘Nohow. And thank you\nvery\nmuch for asking,’ said Tweedledum.\n‘So much obliged!’ added Tweedledee. ‘You like poetry?’\n‘Y-e-es, pretty well –\nsome\npoetry,’ Alice said doubtfully. ‘Would you tell me\nwhich road leads out of the wood?’\n‘What shall I repeat to her?’ said Tweedledee, looking round at Tweedledum\nwith great solemn eyes, and not noticing Alice’s question.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":28},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:29","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n27\n‘ “T\nHE\nW\nALRUS AND THE\nC\nARPENTER\n” is the longest,’ Tweedledum replied,\ngiving his brother an affectionate hug.\nTweedledee began instantly:\n‘The sun was shining – ’\nHere Alice ventured to interrupt him. ‘If it’s\nvery\nlong,’ she said, as politely\nas she could, ‘would you please tell me first which road – ’\nTweedledee smiled gently, and began again:\n‘The sun was shining on the sea,\nShining with all his might:\nHe did his very best to make\nThe billows smooth and bright –\nAnd this was odd, because it was\nThe middle of the night.\nThe moon was shining sulkily,\nBecause she thought the sun\nHad got no business to be there\nAfter the day was done –\n“It’s very rude of him,” she said,\n“To come and spoil the fun!”\nThe sea was wet as wet could be,\nThe sands were dry as dry.\nYou could not see a cloud, because\nNo cloud was in the sky:\nNo birds were flying over head –\nThere were no birds to fly.\nThe Walrus and the Carpenter\nWere walking close at hand;\nThey wept like anything to see","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":29},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:30","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n28\nSuch quantities of sand:\n“If this were only cleared away,”\nThey said, “it\nwould\nbe grand!”\n“If seven maids with seven mops\nSwept it for half a year,\nDo you suppose,” the Walrus said,\n“That they could get it clear?”\n“I doubt it,” said the Carpenter,\nAnd shed a bitter tear.\n“O Oysters, come and walk with us!”\nThe Walrus did beseech.\n“A pleasant walk, a pleasant talk,\nAlong the briny beach:\nWe cannot do with more than four,\nTo give a hand to each.”\nThe eldest Oyster looked at him.\nBut never a word he said:\nThe eldest Oyster winked his eye,\nAnd shook his heavy head –\nMeaning to say he did not choose\nTo leave the oyster-bed.\nBut four young oysters hurried up,\nAll eager for the treat:\nTheir coats were brushed, their faces washed,\nTheir shoes were clean and neat –\nAnd this was odd, because, you know,\nThey hadn’t any feet.\nFour other Oysters followed them,\nAnd yet another four;\nAnd thick and fast they came at last,\nAnd more, and more, and more –\nAll hopping through the frothy waves,\nAnd scrambling to the shore.\nThe Walrus and the Carpenter\nWalked on a mile or so,\nAnd then they rested on a rock\nConveniently low:\nAnd all the little Oysters stood\nAnd waited in a row.\n“The time has come,” the Walrus said,\n“To talk of many things:","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":30},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:31","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n29\nOf shoes – and ships – and sealing-wax –\nOf cabbages – and kings –\nAnd why the sea is boiling hot –\nAnd whether pigs have wings.”\n“But wait a bit,” the Oysters cried,\n“Before we have our chat;\nFor some of us are out of breath,\nAnd all of us are fat!”\n“No hurry!” said the Carpenter.\nThey thanked him much for that.\n“A loaf of bread,” the Walrus said,\n“Is what we chiefly need:\nPepper and vinegar besides\nAre very good indeed –\nNow if you’re ready Oysters dear,\nWe can begin to feed.”\n“But not on us!” the Oysters cried,\nTurning a little blue,\n“After such kindness, that would be\nA dismal thing to do!”\n“The night is fine,” the Walrus said\n“Do you admire the view?\n“It was so kind of you to come!\nAnd you are very nice!”\nThe Carpenter said nothing but\n“Cut us another slice:\nI wish you were not quite so deaf –\nI’ve had to ask you twice!”\n“It seems a shame,” the Walrus said,\n“To play them such a trick,","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":31},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:32","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n30\nAfter we’ve brought them out so far,\nAnd made them trot so quick!”\nThe Carpenter said nothing but\n“The butter’s spread too thick!”\n“I weep for you,” the Walrus said.\n“I deeply sympathize.”\nWith sobs and tears he sorted out\nThose of the largest size.\nHolding his pocket handkerchief\nBefore his streaming eyes.\n“O Oysters,” said the Carpenter.\n“You’ve had a pleasant run!\nShall we be trotting home again?”\nBut answer came there none –\nAnd that was scarcely odd, because\nThey’d eaten every one.’\n‘I like the Walrus best,’ said Alice, ‘because you see he was a\nlittle\nsorry for\nthe poor oysters.’\n‘He ate more than the Carpenter, though,’ said Tweedledee. ‘You see he held\nhis handkerchief in front, so that the Carpenter couldn’t count how many he took:\ncontrariwise.’\n‘That was mean!’ Alice said indignantly. ‘Then I like the Carpenter best – if\nhe didn’t eat so many as the Walrus.’\n‘But he ate as many as he could get,’ said Tweedledum.\nThis was a puzzler. After a pause, Alice began, ‘Well! They were\nboth\nvery\nunpleasant characters – ’ Here she checked herself in some alarm, at hearing some-\nthing that sounded to her like the puffing of a large steam-engine in the wood near\nthem, though she feared it was more likely to be a wild beast. ‘Are there any lions\nor tigers about here?’ she asked timidly.\n‘It’s only the Red King snoring,’ said Tweedledee.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":32},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:33","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n31\n‘Come and look at him!’  the\nbrothers cried, and they each took one\nof Alice’s hands, and led her up to\nwhere the King was sleeping.\n‘Isn’t he a\nlovely\nsight?’  said\nTweedledum.\nAlice couldn’t say honestly that he\nwas. He had a tall red night-cap on,\nwith a tassel, and he was lying crum-\npled up into a sort of untidy heap, and\nsnoring loud – ‘fit to snore his head off!’ as Tweedledum remarked.\n‘I’m afraid he’ll catch cold with lying on the damp grass,’ said Alice, who was\na very thoughtful little girl.\n‘He’s dreaming now,’ said Tweedledee, ‘and what do you think he’s dreaming\nabout?’\nAlice said ‘Nobody can guess that.’\n‘Why, about\nyou\n!’ Tweedledee exclaimed, clapping his hands triumphantly.\n‘And if he left off dreaming about you, where do you suppose you’d be?’\n‘Where I am now, of course,’ said Alice.\n‘Not you!’ Tweedledee retorted contemptuously. ‘You’d be nowhere. Why,\nyou’re only a sort of thing in his dream!’\n‘If that there King was to wake,’ added Tweedledum, ‘you’d go out – bang! –\njust like a candle!’\n‘I shouldn’t!’ Alice exclaimed indignantly. ‘Besides, if\nI’m\nonly a sort of thing\nin his dream, what are\nyou\n, I should like to know?’\n‘Ditto’ said Tweedledum.\n‘Ditto, ditto’ cried Tweedledee.\nHe shouted this so loud that Alice couldn’t help saying, ‘Hush! You’ll be\nwaking him, I’m afraid, if you make so much noise.’\n‘Well, it no use\nyour\ntalking about waking him,’ said Tweedledum, ‘when\nyou’re only one of the things in his dream. You know very well you’re not real.’\n‘I\nam\nreal!’ said Alice and began to cry.\n‘You won’t make yourself a bit realler by crying,’ Tweedledee remarked, ‘the-\nre’s nothing to cry about.’\n‘If I wasn’t real,’ Alice said – half-laughing through her tears, it all seemed so\nridiculous – ‘I shouldn’t be able to cry.’\n‘I hope you don’t suppose those are real tears?’ Tweedledum interrupted in\na tone of great contempt.\n‘I know they’re talking nonsense,’ Alice thought to herself, ‘and it’s foolish\nto cry about it.’ So she brushed away her tears, and went on as cheerfully as she","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":33},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:34","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n32\ncould. ‘At any rate I’d better be getting out of the wood, for really it’s coming on\nvery dark. Do you think it’s going to rain?’\nTweedledum spread a large umbrella over himself and his brother, and looked\nup into it. ‘No, I don’t think it is,’ he said, ’at least – not under\nhere\n. Nohow.’\n‘But it may rain\noutside\n?’\n‘It may – if it chooses,’ said Tweedledee, ‘we’ve no objection. Contrariwise.’\n‘Selfish things!’ thought Alice, and she was just going to say ‘Good-night’ and\nleave them, when Tweedledum sprang out from under the umbrella and seized her\nby the wrist.\n‘Do you see\nthat\n?’ he said, in a voice choking with passion, and his eyes grew\nlarge and yellow all in a moment, as he pointed with a trembling finger at a small\nwhite thing lying under the tree.\n‘It’s only a rattle,’ Alice said, after a careful examination of the little white\nthing. ‘Not a rattle\nsnake\n, you know,’ she added hastily, thinking that he was fright-\nened, ‘only an old rattle – quite old and broken.’\n‘I knew it was!’ cried Tweedledum, beginning to stamp about wildly and tear\nhis hair. ‘It’s spoilt, of course!’ Here he looked at Tweedledee, who immediately\nsat down on the ground, and tried to\nhide himself under the umbrella.\nAlice laid her hand upon his arm,\nand said in a soothing tone, ‘You\nneedn’t be so angry about an old rat-\ntle.’\n‘But it isn’t old!’  Tweedledum\ncried, in a greater fury than ever. ‘It’s\nnew, I tell you – I bought it yester-\nday – my nice new\nrattle\n!’ and his\nvoice rose to a perfect scream.\nAll this time Tweedledee was trying his best to fold up the umbrella, with\nhimself in it: which was such an extraordinary thing to do, that it quite took off\nAlice’s attention from the angry brother. But he couldn’t quite succeed, and it\nended in his rolling over, bundled up in the umbrella, with only his head out: and\nthere he lay, opening and shutting his mouth and his large eyes – ‘looking more\nlike a fish than anything else,’ Alice thought.\n‘Of course you agree to have a battle?’ Tweedledum said in a calmer tone.\n‘I suppose so,’ the other sulkily replied, as he crawled out of the umbrella,\n‘only\nshe\nmust help us to dress up, you know.’\nSo the two brothers went off hand-in-hand into the wood, and returned in\na minute with their arms full of things – such as bolsters, blankets, hearth-rugs,\ntable-cloths, dish-covers and coal-scuttles. ‘I hope you’re a good hand at pinning","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":34},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:35","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n33\nand tying strings?’ Tweedledum re-\nmarked.  ‘Every one of these things\nhas got to go on, somehow or other.’\nAlice said afterwards she had\nnever seen such a fuss made about\nanything in all her life – the way those\ntwo bustled about – and the quantity\nof things they put on – and the trou-\nble they gave her in tying strings and\nfastening buttons – ‘Really they’ll be\nmore like bundles of old clothes than anything else, by the time they’re ready!’\nshe said to herself, as she arranged a bolster round the neck of Tweedledee, ‘to\nkeep his head from being cut off,’ as he said.\n‘You know,’ he added very gravely, ‘it’s one of the most serious things that can\npossibly happen to one in a battle – to get one’s head cut off.’\nAlice laughed aloud, but she managed to turn it into a cough, for fear of hurting\nhis feelings.\n‘Do I look very pale?’ said Tweedledum, coming up to have his helmet tied\non. (He\ncalled\nit a helmet, though it certainly looked much more like a saucepan.)\n‘Well – yes – a\nlittle\n,’ Alice replied gently.\n‘I’m very brave generally,’ he went on in a low voice, ‘only to-day I happen to\nhave a headache.’\n‘And\nI’ve\ngot a toothache!’ said Tweedledee, who had overheard the remark.\n‘I’m far worse off than you!’\n‘Then you’d better not fight to-day,’ said Alice, thinking it a good opportunity\nto make peace.\n‘We\nmust\nhave a bit of a fight, but I don’t care about going on long,’ said\nTweedledum. ‘What’s the time now?’\nTweedledee looked at his watch, and said ‘Half-past four.’\n‘Let’s fight till six, and then have dinner,’ said Tweedledum.\n‘Very well,’ the other said, rather sadly, ‘and\nshe\ncan watch us – only you’d\nbetter not come\nvery\nclose,’ he added, ‘I generally hit everything I can see – when\nI get really excited.’\n‘And\nI\nhit everything within reach,’ cried Tweedledum, ‘whether I can see it\nor not!’\nAlice laughed. ‘You must hit the\ntrees\npretty often, I should think,’ she said.\nTweedledum looked round him with a satisfied smile. ‘I don’t suppose,’ he\nsaid, ‘there’ll be a tree left standing, for ever so far round, by the time we’ve\nfinished!’\n‘And all about a rattle!’ said Alice, still hoping to make them a\nlittle\nashamed\nof fighting for such a trifle.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":35},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:36","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IV.  TWEEDLEDUM AND TWEEDLEDEE\n34\n‘I shouldn’t have minded it so much,’ said Tweedledum, ‘if it hadn’t been\na new one.’\n‘I wish the monstrous crow would come!’ thought Alice.\n‘There’s only one sword, you know,’ Tweedledum said to his brother, ‘but you\ncan have the umbrella – it’s quite as sharp. Only we must begin quick. It’s getting\nas dark as it can.’\n‘And darker,’ said Tweedledee.\nIt was getting dark so suddenly that Alice thought there must be a thunder-\nstorm coming on. ‘What a thick black cloud that is!’ she said. ‘And how fast it\ncomes! Why, I do believe it’s got wings!’\n‘It’s the crow!’ Tweedledum cried out in a shrill voice of alarm and the two\nbrothers took to their heels and were out of sight in a moment.\nAlice ran a little way into the wood, and stopped under a large tree. ‘It can\nnever get at me\nhere\n,’ she thought, ‘it’s far too large to squeeze itself in among the\ntrees. But I wish it wouldn’t flap its wings so – it makes quite a hurricane in the\nwood – here’s somebody’s shawl being blown away!’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":36},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:37","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter V\nWool and Water\nShe caught the shawl as she spoke, and looked about for the owner: in another\nmoment the White Queen came running wildly through the wood, with both arms\nstretched out wide, as if she were flying, and Alice very civilly went to meet her\nwith the shawl.\n‘I’m very glad I happened to be in the way,’ Alice said, as she helped her to\nput on her shawl again.\nThe White Queen only looked at her in a helpless frightened sort of way, and\nkept repeating something in a whisper to herself that sounded like ‘bread-and-\nbutter, bread-and-butter,’ and Alice felt that if there was to be any conversation at\nall, she must manage it herself. So she began rather timidly, ‘Am I addressing the\nWhite Queen?’\n‘Well, yes, if you call that a-dressing,’ The Queen said. ‘It isn’t\nmy\nnotion of\nthe thing, at all.’\nAlice thought it would never do to have an argument at the very beginning of\ntheir conversation, so she smiled and said, ‘If your Majesty will only tell me the\nright way to begin, I’ll do it as well as I can.’\n‘But I don’t want it done at all!’ groaned the poor Queen. ‘I’ve been a-dressing\nmyself for the last two hours.’\nIt would have been all the better, as it seemed to Alice, if she had got some\none else to dress her, she was so dreadfully untidy. ‘Every single thing’s crooked,’\nAlice thought to herself, ‘and she’s all over pins! – may I put your shawl straight\nfor you?’ she added aloud.\n‘I don’t know what’s the matter with it!’ the Queen said, in a melancholy\nvoice. ‘It’s out of temper, I think. I’ve pinned it here, and I’ve pinned it there, but\nthere’s no pleasing it!’\n‘It\ncan’t\ngo straight, you know, if you pin it all on one side,’ Alice said, as she\ngently put it right for her; ‘and, dear me, what a state your hair is in!’\n35","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":37},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:38","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n36\n‘The brush has got entangled in\nit!’ the Queen said with a sigh. ‘And\nI lost the comb yesterday.’\nAlice carefully released the brush\nand did her best to get the hair into\norder. ‘Come, you look rather better\nnow!’ she said, after altering most of\nthe pins. ‘But really you should have\na lady’s maid!’\n‘I’m sure I’ll take you with plea-\nsure!’  the Queen said, ‘Twopence\na week and jam every other day.’\nAlice couldn’t help laughing, as\nshe said, ‘I don’t want you to hire\nme\n– and I don’t care for jam.’\n‘It’s very good jam,’  said the\nQueen.\n‘Well, I don’t want any\nto-day\n, at\nany rate.’\n‘You couldn’t have it if you\ndid\nwant it,’ the Queen said. ‘The rule is, jam\nto-morrow and jam yesterday – but never jam to-day.’\n‘It\nmust\ncome sometimes to “jam to-day,” ’ Alice objected.\n‘No, it can’t,’ said the Queen. ‘It’s jam every\nother\nday: to-day isn’t any\nother\nday, you know.’\n‘I don’t understand you,’ said Alice. ‘It’s dreadfully confusing!’\n‘That’s the effect of living backwards,’ the Queen said kindly, ‘it always makes\none a little giddy at first – ’\n‘Living backwards!’ Alice repeated in great astonishment. ‘I never heard of\nsuch a thing!’\n‘ – but there’s one great advantage in it, that one’s memory works both ways.’\n‘I’m sure\nmine\nonly works one way,’ Alice remarked. ‘I can’t remember things\nbefore they happen.’\n‘It’s a poor sort of memory that only works backwards,’ the Queen remarked.\n‘What sort of things do\nyou\nremember best?’ Alice ventured to ask.\n‘Oh, things that happened the week after next,’ the Queen replied in a careless\ntone. ‘For instance, now,’ she went on, sticking a large piece of plaster [band-\naid] on her finger as she spoke, ‘there’s the King’s Messenger. He’s in prison now,\nbeing punished and the trial doesn’t even begin till next Wednesday: and of course\nthe crime comes last of all.’\n‘Suppose he never commits the crime?’ said Alice.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":38},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:39","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n37\n‘That  would  be  all  the  better,\nwouldn’t it?’  the Queen said, as she\nbound the plaster round her finger with\na bit of ribbon.\nAlice felt there was no denying\nthat\n.\n‘Of course it would be all the better,’ she\nsaid, ’but it wouldn’t be all the better his\nbeing punished.’\n‘You’re wrong\nthere\n, at any rate,’ said\nthe Queen, ‘were\nyou\never punished?’\n‘Only for faults,’ said Alice.\n‘And you were all the better for it,\nI know!’ the Queen said triumphantly.\n‘Yes, but then I\nhad\ndone the things\nI was punished for,’ said Alice, ‘that\nmakes all the difference.’\n‘But if you\nhadn’t\ndone them,’ the\nQueen said, ‘that would have been bet-\nter still; better, and better, and better!’ Her voice went higher with each ‘better,’\ntill it got quite to a squeak at last.\nAlice was just beginning to say ‘There’s a mistake somewhere – ,’ when the\nQueen began screaming so loud that she had to leave the sentence unfinished. ‘Oh,\noh, oh!’ shouted the Queen, shaking her hand about as if she wanted to shake it\noff. ‘My finger’s bleeding! Oh, oh, oh, oh!’\nHer screams were so exactly like the whistle of a steam-engine, that Alice had\nto hold both her hands over her ears.\n‘What\nis\nthe matter?’ she said, as soon as there was a chance of making herself\nheard. ‘Have you pricked your finger?’\n‘I haven’t pricked it\nyet\n,’ the Queen said, ‘but I soon shall – oh, oh, oh!’\n‘When do you expect to do it?’ Alice asked, feeling very much inclined to\nlaugh.\n‘When I fasten my shawl again,’ the poor Queen groaned out, ‘the brooch will\ncome undone directly. Oh, oh!’ As she said the words the brooch flew open, and\nthe Queen clutched wildly at it, and tried to clasp it again.\n‘Take care!’ cried Alice. ‘You’re holding it all crooked!’ And she caught at\nthe brooch; but it was too late: the pin had slipped, and the Queen had pricked her\nfinger.\n‘That accounts for the bleeding, you see,’ she said to Alice with a smile. ‘Now\nyou understand the way things happen here.’\n‘But why don’t you scream now?’ Alice asked, holding her hands ready to put\nover her ears again.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":39},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:40","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n38\n‘Why, I’ve done all the screaming already,’ said the Queen. ‘What would be\nthe good of having it all over again?’\nBy this time it was getting light. ‘The crow must have flown away, I think,’\nsaid Alice, ‘I’m so glad it’s gone. I thought it was the night coming on.’\n‘I wish\nI\ncould manage to be glad!’ the Queen said. ‘Only I never can re-\nmember the rule. You must be very happy, living in this wood, and being glad\nwhenever you like!’\n‘Only it is so\nvery\nlonely here!’ Alice said in a melancholy voice; and at the\nthought of her loneliness two large tears came rolling down her cheeks.\n‘Oh, don’t go on like that!’ cried the poor Queen, wringing her hands in\ndespair. ‘Consider what a great girl you are. Consider what a long way you’ve\ncome to-day. Consider what o’clock it is. Consider anything, only don’t cry!’\nAlice could not help laughing at this, even in the midst of her tears. ‘Can\nyou\nkeep from crying by considering things?’ she asked.\n‘That’s the way it’s done,’ the Queen said with great decision, ‘nobody can do\ntwo things at once, you know. Let’s consider your age to begin with – how old are\nyou?’\n‘I’m seven and a half exactly.’\n‘You needn’t say “exactually,” ’ the Queen remarked, ‘I can believe it without\nthat. Now I’ll give\nyou\nsomething to believe. I’m just one hundred and one, five\nmonths and a day.’\n‘I can’t believe\nthat\n!’ said Alice.\n‘Can’t you?’ the Queen said in a pitying tone. ‘Try again: draw a long breath,\nand shut your eyes.’\nAlice laughed. ‘There’s no use trying,’ she said, ‘one\ncan’t\nbelieve impossible\nthings.’\n‘I daresay you haven’t had much practice,’ said the Queen. ‘When I was your\nage, I always did it for half-an-hour a day. Why, sometimes I’ve believed as many\nas six impossible things before breakfast. There goes the shawl again!’\nThe brooch had come undone as she spoke, and a sudden gust of wind blew\nthe Queen’s shawl across a little brook. The Queen spread out her arms again, and\nwent flying after it, and this time she succeeded in catching it for herself. ‘I’ve got\nit!’ she cried in a triumphant tone. ‘Now you shall see me pin it on again, all by\nmyself!’\n‘Then I hope your finger is better now?’ Alice said very politely, as she crossed\nthe little brook after the Queen.\n*    *    *    *    *    *    *    *    *    *    *\n‘Oh, much better!’ cried the Queen, her voice rising to a squeak as she went\non. ‘Much be-etter! Be-etter! Be-e-e-etter! Be-e-ehh!’ The last word ended in\na long bleat, so like a sheep that Alice quite started.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":40},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:41","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n39\nShe looked at the Queen, who\nseemed to have suddenly wrapped\nherself up in wool. Alice rubbed her\neyes, and looked again. She couldn’t\nmake out what had happened at all.\nWas she in a shop?  And was that\nreally – was it really a\nsheep\nthat\nwas sitting on the other side of the\ncounter? Rub as she could, she could\nmake nothing more of it: she was in\na little dark shop, leaning with her el-\nbows on the counter, and opposite to\nher was an old Sheep, sitting in an\narm-chair knitting, and every now and\nthen leaving off to look at her through\na great pair of spectacles.\n‘What is it you want to buy?’ the\nSheep said at last, looking up for a moment from her knitting.\n‘I don’t\nquite\nknow yet,’ Alice said, very gently. ‘I should like to look all\nround me first, if I might.’\n‘You may look in front of you, and on both sides, if you like,’ said the Sheep,\n‘but you can’t look\nall\nround you – unless you’ve got eyes at the back of your\nhead.’\nBut these, as it happened, Alice had\nnot\ngot: so she contented herself with\nturning round, looking at the shelves as she came to them.\nThe shop seemed to be full of all manner of curious things – but the oddest\npart of it all was, that whenever she looked hard at any shelf, to make out exactly\nwhat it had on it, that particular shelf was always quite empty: though the others\nround it were crowded as full as they could hold.\n‘Things flow about so here!’ she said at last in a plaintive tone, after she had\nspent a minute or so in vainly pursuing a large bright thing, that looked sometimes\nlike a doll and sometimes like a work-box, and was always in the shelf next above\nthe one she was looking at. ‘And this one is the most provoking of all – but I’ll\ntell you what – ’ she added, as a sudden thought struck her, ‘I’ll follow it up to the\nvery top shelf of all. It’ll puzzle it to go through the ceiling, I expect!’\nBut even this plan failed: the ‘thing’ went through the ceiling as quietly as\npossible, as if it were quite used to it.\n‘Are you a child or a teetotum?’ the Sheep said, as she took up another pair of\nneedles. ‘You’ll make me giddy soon, if you go on turning round like that.’ She\nwas now working with fourteen pairs at once, and Alice couldn’t help looking at\nher in great astonishment.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":41},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:42","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n40\n‘How\ncan\nshe knit with so many?’ the puzzled child thought to herself. ‘She\ngets more and more like a porcupine every minute!’\n‘Can you row?’ the Sheep asked, handing her a pair of knitting- needles as she\nspoke.\n‘Yes, a little – but not on land – and not with needles – ’ Alice was beginning\nto say, when suddenly the needles turned into oars in her hands, and she found\nthey were in a little boat, gliding\nalong between banks: so there was\nnothing for it but to do her best.\n‘Feather!’ cried the Sheep, as she\ntook up another pair of needles.\nThis didn’t sound like a remark\nthat needed any answer, so Alice said\nnothing, but pulled away. There was\nsomething very queer about the wa-\nter, she thought, as every now and\nthen the oars got fast in it, and would\nhardly come out again.\n‘Feather!  Feather!’  the Sheep\ncried again,  taking more needles.\n‘You’ll be catching a crab directly.’\n‘A dear little crab!’ thought Alice.\n‘I should like that.’\n‘Didn’t you hear me say “Feather”?’ the Sheep cried angrily, taking up quite\na bunch of needles.\n‘Indeed I did,’ said Alice, ‘you’ve said it very often – and very loud. Please,\nwhere\nare\nthe crabs?’\n‘In the water, of course!’ said the Sheep, sticking some of the needles into her\nhair, as her hands were full. ‘Feather, I say!’\n‘\nWhy\ndo you say “feather” so often?’ Alice asked at last, rather vexed. ‘I’m\nnot a bird!’\n‘You are,’ said the Sheep, ‘you’re a little goose.’\nThis offended Alice a little, so there was no more conversation for a minute\nor two, while the boat glided gently on, sometimes among beds of weeds (which\nmade the oars stick fast in the water, worse then ever), and sometimes under trees,\nbut always with the same tall river-banks frowning over their heads.\n‘Oh, please! There are some scented rushes!’ Alice cried in a sudden transport\nof delight. ‘There really are – and\nsuch\nbeauties!’\n‘You needn’t say “please” to\nme\nabout ’em,’ the Sheep said, without looking\nup from her knitting, ‘I didn’t put ’em there, and I’m not going to take ’em away.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":42},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:43","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n41\n‘No, but I meant – please, may we wait and pick some?’ Alice pleaded. ‘If\nyou don’t mind stopping the boat for a minute.’\n‘How am\nI\nto stop it?’ said the Sheep. ‘If you leave off rowing, it’ll stop of\nitself.’\nSo the boat was left to drift down the stream as it would, till it glided gently\nin among the waving rushes. And then the little sleeves were carefully rolled up,\nand the little arms were plunged in elbow-deep to get the rushes a good long way\ndown before breaking them off – and for a while Alice forgot all about the Sheep\nand the knitting, as she bent over the side of the boat, with just the ends of her\ntangled hair dipping into the water – while with bright eager eyes she caught at\none bunch after another of the darling scented rushes.\n‘I only hope the boat won’t tipple over!’ she said to herself. ‘Oh,\nwhat\na lovely\none! Only I couldn’t quite reach it.’ And it certainly\ndid\nseem a little provoking\n(‘almost as if it happened on purpose,’ she thought) that, though she managed to\npick plenty of beautiful rushes as the boat glided by, there was always a more\nlovely one that she couldn’t reach.\n‘The prettiest are always further!’ she said at last, with a sigh at the obstinacy\nof the rushes in growing so far off, as, with flushed cheeks and dripping hair and\nhands, she scrambled back into her place, and began to arrange her new-found\ntreasures.\nWhat mattered it to her just then that the rushes had begun to fade, and to lose\nall their scent and beauty, from the very moment that she picked them? Even real\nscented rushes, you know, last only a very little while – and these, being dream-\nrushes, melted away almost like snow, as they lay in heaps at her feet – but Alice\nhardly noticed this, there were so many other curious things to think about.\nThey hadn’t gone much farther before the blade of one of the oars got fast in\nthe water and\nwouldn’t\ncome out again (so Alice explained it afterwards), and the\nconsequence was that the handle of it caught her under the chin, and, in spite of\na series of little shrieks of ‘Oh, oh, oh!’ from poor Alice, it swept her straight off\nthe seat, and down among the heap of rushes.\nHowever, she wasn’t hurt, and was soon up again: the Sheep went on with her\nknitting all the while, just as if nothing had happened. ‘That was a nice crab you\ncaught!’ she remarked, as Alice got back into her place, very much relieved to\nfind herself still in the boat.\n‘Was it? I didn’t see it,’ said Alice, peeping cautiously over the side of the\nboat into the dark water. ‘I wish it hadn’t let go – I should so like to see a little\ncrab to take home with me!’ But the Sheep only laughed scornfully, and went on\nwith her knitting.\n‘Are there many crabs here?’ said Alice.\n‘Crabs, and all sorts of things,’ said the Sheep, ‘plenty of choice, only make\nup your mind. Now, what\ndo\nyou want to buy?’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":43},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:44","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER V.  WOOL AND WATER\n42\n‘To buy!’ Alice echoed in a tone that was half astonished and half frightened –\nfor the oars, and the boat, and the river, had vanished all in a moment, and she was\nback again in the little dark shop.\n‘I should like to buy an egg, please,’ she said timidly. ‘How do you sell them?’\n‘Fivepence farthing for one – Twopence for two,’ the Sheep replied.\n‘Then two are cheaper than one?’ Alice said in a surprised tone, taking out her\npurse.\n‘Only you\nmust\neat them both, if you buy two,’ said the Sheep.\n‘Then I’ll have\none\n, please,’ said Alice, as she put the money down on the\ncounter. For she thought to herself, ‘They mightn’t be at all nice, you know.’\nThe Sheep took the money, and put it away in a box: then she said ‘I never put\nthings into people’s hands – that would never do – you must get it for yourself.’\nAnd so saying, she went off to the other end of the shop, and set the egg upright\non a shelf.\n‘I wonder\nwhy\nit wouldn’t do?’ thought Alice, as she groped her way among\nthe tables and chairs, for the shop was very dark towards the end. ‘The egg seems\nto get further away the more I walk towards it. Let me see, is this a chair? Why,\nit’s got branches, I declare! How very odd to find trees growing here! And actually\nhere’s a little brook! Well, this is the very queerest shop I ever saw!’\n*    *    *    *    *    *    *    *    *    *    *\nSo she went on, wondering more and more at every step, as everything turned\ninto a tree the moment she came up to it, and she quite expected the egg to do\nthe same.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":44},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:45","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter VI\nHumpty Dumpty\nHowever, the egg only got larger and\nlarger, and more and more human:\nwhen she had come within a few\nyards of it, she saw that it had eyes\nand a nose and mouth; and when she\nhad come close to it, she saw clearly\nthat it was\nHumpty Dumpty\nhimself.\n‘It can’t be anybody else!’ she said to\nherself. ‘I’m as certain of it, as if his\nname were written all over his face.’\nIt might have been written a hundred times, easily, on\nthat enormous face. Humpty Dumpty was sitting with his\nlegs crossed, like a Turk, on the top of a high wall – such\na narrow one that Alice quite wondered how he could keep\nhis balance – and, as his eyes were steadily fixed in the\nopposite direction, and he didn’t take the least notice of\nher, she thought he must be a stuffed figure after all.\n‘And how exactly like an egg he is!’ she said aloud, standing with her hands\nready to catch him, for she was every moment expecting him to fall.\n‘It’s\nvery\nprovoking,’ Humpty Dumpty said after a long silence, looking away\nfrom Alice as he spoke, ‘to be called an egg –\nvery\n!’\n‘I said you\nlooked\nlike an egg, Sir,’ Alice gently explained. ‘And some eggs\nare very pretty, you know’ she added, hoping to turn her remark into a sort of\na compliment.\n‘Some people,’ said Humpty Dumpty, looking away from her as usual, ‘have\nno more sense than a baby!’\nAlice didn’t know what to say to this: it wasn’t at all like conversation, she\nthought, as he never said anything to\nher\n; in fact, his last remark was evidently\n43","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":45},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:46","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n44\naddressed to a tree – so she stood and softly repeated to herself: –\n‘Humpty Dumpty sat on a wall:\nHumpty Dumpty had a great fall.\nAll the King’s horses and all the King’s men\nCouldn’t put Humpty Dumpty in his place again.’\n‘That last line is much too long for the poetry,’ she added, almost out loud,\nforgetting that Humpty Dumpty would hear her.\n‘Don’t stand there chattering to yourself like that,’ Humpty Dumpty said, look-\ning at her for the first time, ‘but tell me your name and your business.’\n‘My\nname\nis Alice, but – ’\n‘It’s a stupid enough name!’ Humpty Dumpty interrupted impatiently. ‘What\ndoes it mean?’\n‘\nMust\na name mean something?’ Alice asked doubtfully.\n‘Of course it must,’ Humpty Dumpty said with a short laugh, ‘\nMy\nname means\nthe shape I am – and a good handsome shape it is, too. With a name like yours,\nyou might be any shape, almost.’\n‘Why do you sit out here all alone?’  said Alice, not wishing to begin an\nargument.\n‘Why, because there’s nobody with me!’ cried Humpty Dumpty. ‘Did you\nthink I didn’t know the answer to\nthat\n? Ask another.’\n‘Don’t you think you’d be safer down on the ground?’ Alice went on, not with\nany idea of making another riddle, but simply in her good-natured anxiety for the\nqueer creature. ‘That wall is so\nvery\nnarrow!’\n‘What tremendously easy riddles you ask!’ Humpty Dumpty growled out. ‘Of\ncourse I don’t think so! Why, if ever I\ndid\nfall off – which there’s no chance of –\nbut\nif\nI did – ’ Here he pursed his lips and looked so solemn and grand that Alice\ncould hardly help laughing. ‘\nIf\nI did fall,’ he went on, ‘\nThe king has promised\nme – with his very own mouth\n– to – to – ’\n‘To send all his horses and all his men,’ Alice interrupted, rather unwisely.\n‘Now I declare that’s too bad!’ Humpty Dumpty cried, breaking into a sudden\npassion. ‘You’ve been listening at doors – and behind trees – and down chimneys –\nor you couldn’t have known it!’\n‘I haven’t, indeed!’ Alice said very gently. ‘It’s in a book.’\n‘Ah, well! They may write such things in a\nbook\n,’ Humpty Dumpty said in\na calmer tone. ‘That’s what you call a History of England, that is. Now, take\na good look at me! I’m one that has spoken to a King,\nI\nam: mayhap you’ll never\nsee such another: and to show you I’m not proud, you may shake hands with\nme!’ And he grinned almost from ear to ear, as he leant forwards (and as nearly as\npossible fell off the wall in doing so) and offered Alice his hand. She watched him\na little anxiously as she took it. ‘If he smiled much more, the ends of his mouth","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":46},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:47","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n45\nmight meet behind,’ she thought, ‘and then I don’t know what would happen to\nhis head! I’m afraid it would come off!’\n‘Yes, all his horses and all his men,’ Humpty Dumpty went on. ‘They’d pick\nme up again in a minute,\nthey\nwould! However, this conversation is going on\na little too fast: let’s go back to the last remark but one.’\n‘I’m afraid I can’t quite remember it,’ Alice said very politely.\n‘In that case we start fresh,’ said Humpty Dumpty, ‘and it’s my turn to choose\na subject – ’ (‘He talks about it just as if it was a game!’ thought Alice.) ‘So here’s\na question for you. How old did you say you were?’\nAlice made a short calculation, and said ‘Seven years and six months.’\n‘Wrong!’ Humpty Dumpty exclaimed triumphantly. ‘You never said a word\nlike it!’\n‘I though you meant “How old\nare\nyou?” ’ Alice explained.\n‘If I’d meant that, I’d have said it,’ said Humpty Dumpty.\nAlice didn’t want to begin another argument, so she said nothing.\n‘Seven years and six months!’ Humpty Dumpty repeated thoughtfully. ‘An\nuncomfortable sort of age. Now if you’d asked\nmy\nadvice, I’d have said “Leave\noff at seven” – but it’s too late now.’\n‘I never ask advice about growing,’ Alice said indignantly.\n‘Too proud?’ the other inquired.\nAlice felt even more indignant at this suggestion. ‘I mean,’ she said, ‘that one\ncan’t help growing older.’\n‘\nOne\ncan’t, perhaps,’ said Humpty Dumpty, ‘but\ntwo\ncan. With proper assis-\ntance, you might have left off at seven.’\n‘What a beautiful belt you’ve got on!’ Alice suddenly remarked.\n(They had had quite enough of the subject of age, she thought: and if they\nreally were to take turns in choosing subjects, it was her turn now.) ‘At least,’ she\ncorrected herself on second thoughts, ‘a beautiful cravat, I should have said – no,\na belt, I mean – I beg your pardon!’ she added in dismay, for Humpty Dumpty\nlooked thoroughly offended, and she began to wish she hadn’t chosen that subject.\n‘If I only knew,’ she thought to herself, ‘which was neck and which was waist!’\nEvidently Humpty Dumpty was very angry, though he said nothing for a mi-\nnute or two. When he\ndid\nspeak again, it was in a deep growl.\n‘It is a –\nmost\n–\nprovoking\n– thing,’ he said at last, ‘when a person doesn’t\nknow a cravat from a belt!’\n‘I know it’s very ignorant of me,’ Alice said, in so humble a tone that Humpty\nDumpty relented.\n‘It’s a cravat, child, and a beautiful one, as you say. It’s a present from the\nWhite King and Queen. There now!’\n‘Is it really?’ said Alice, quite pleased to find that she\nhad\nchosen a good\nsubject, after all.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":47},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:48","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n46\n‘They gave it me,’ Humpty Dumpty continued thoughtfully, as he crossed one\nknee over the other and clasped his hands round it, ‘they gave it me – for an\nun-birthday present.’\n‘I beg your pardon?’ Alice said with a puzzled air.\n‘I’m not offended,’ said Humpty Dumpty.\n‘I mean, what\nis\nan un-birthday present?’\n‘A present given when it isn’t your birthday, of course.’\nAlice considered a little. ‘I like birthday presents best,’ she said at last.\n‘You don’t know what you’re talking about!’ cried Humpty Dumpty. ‘How\nmany days are there in a year?’\n‘Three hundred and sixty-five,’ said Alice.\n‘And how many birthdays have you?’\n‘One.’\n‘And if you take one from three hundred and sixty-five, what remains?’\n‘Three hundred and sixty-four, of course.’\nHumpty Dumpty looked doubtful. ‘I’d rather see that done on paper,’ he said.\nAlice couldn’t help smiling as she took out her memorandum-book and work-\ned the sum for him:\n365\n-    1\n364\nHumpty Dumpty took the book, and looked at it carefully. ‘That seems to be done\nright – ’ he began.\n‘You’re holding it upside down!’ Alice interrupted.\n‘To be sure I was!’ Humpty Dumpty said gaily, as she turned it round for\nhim. ‘I thought it looked a little queer. As I was saying, that\nseems\nto be done\nright – though I haven’t time to look it over thoroughly just now – and that shows\nthat there are three hundred and sixty-four days when you might get un-birthday\npresents – ’\n‘Certainly,’ said Alice.\n‘And only\none\nfor birthday presents, you know. There’s glory for you!’\n‘I don’t know what you mean by “glory,” ’ Alice said.\nHumpty Dumpty smiled contemptuously. ‘Of course you don’t – till I tell you.\nI meant “there’s a nice knock-down argument for you!” ’\n‘But “glory” doesn’t mean “a nice knock-down argument,” ’ Alice objected.\n‘When\nI\nuse a word,’ Humpty Dumpty said in rather a scornful tone, ‘it means\njust what I choose it to mean – neither more nor less.’\n‘The question is,’ said Alice, ‘whether you\ncan\nmake words mean so many\ndifferent things.’\n‘The question is,’ said Humpty Dumpty, ‘which is to be master – that’s all.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":48},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:49","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n47\nAlice was too much puzzled to say anything, so after a minute Humpty Dump-\nty began again. ‘They’ve a temper, some of them – particularly verbs, they’re the\nproudest – adjectives you can do anything with, but not verbs – however,\nI\ncan\nmanage the whole lot of them! Impenetrability! That’s what\nI\nsay!’\n‘Would you tell me, please,’ said Alice ‘what that means?’\n‘Now you talk like a reasonable child,’ said Humpty Dumpty, looking very\nmuch pleased. ‘I meant by “impenetrability” that we’ve had enough of that sub-\nject, and it would be just as well if you’d mention what you mean to do next, as\nI suppose you don’t mean to stop here all the rest of your life.’\n‘That’s a great deal to make one word mean,’ Alice said in a thoughtful tone.\n‘When I make a word do a lot of work like that,’ said Humpty Dumpty, ‘I al-\nways pay it extra.’\n‘Oh!’ said Alice. She was too much puzzled to make any other remark.\n‘Ah, you should see ’em come round me of a Saturday night,’ Humpty Dumpty\nwent on, wagging his head gravely from side to side, ‘for to get their wages, you\nknow.’\n(Alice didn’t venture to ask what he paid them with; and so you see I can’t tell\nyou\n.)\n‘You seem very clever at explaining words, Sir,’ said Alice. ‘Would you kindly\ntell me the meaning of the poem called “J\nABBERWOCKY\n”?’\n‘Let’s hear it,’ said Humpty Dumpty. ‘I can explain all the poems that were\never invented – and a good many that haven’t been invented just yet.’\nThis sounded very hopeful, so Alice repeated the first verse:\n’Twas brilling, and the slithy toves\nDid gyre and gimble in the wabe;\nAll mimsy were the borogoves,\nAnd the mome raths outgrabe.\n‘That’s enough to begin with,’ Humpty Dumpty interrupted, ‘there are plenty of\nhard words there. “\nBrilling\n” means four o’clock in the afternoon – the time when\nyou begin\nbroiling\nthings for dinner.’\n‘That’ll do very well,’ said Alice, ‘and “\nslithy\n”?’\n‘Well, “\nslithy\n” means “lithe and slimy.” “Lithe” is the same as “active.” You\nsee it’s like a portmanteau – there are two meanings packed up into one word.’\n‘I see it now,’ Alice remarked thoughtfully, ‘and what are “\ntoves\n”?’\n‘Well, “\ntoves\n” are something like badgers – they’re something like lizards –\nand they’re something like corkscrews.’\n‘They must be very curious looking creatures.’\n‘They are that,’ said Humpty Dumpty, ‘also they make their nests under sun-\ndials – also they live on cheese.’\n‘And what’s the “\ngyre\n” and to “\ngimble\n”?’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":49},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:50","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n48\n‘To “\ngyre\n” is to go round and\nround like a gyroscope. To “\ngimble\n”\nis to make holes like a gimlet.’\n‘And “\nthe wabe\n” is the grass-plot\nround a sun-dial, I suppose?’ said Al-\nice, surprised at her own ingenuity.\n‘Of course it is. It’s called “\nwabe\n,”\nyou know, because it goes a long way\nbefore it, and a long way behind it – ’\n‘And a long way beyond it on each\nside,’ Alice added.\n‘Exactly so. Well, then, “\nmimsy\n”\nis “\nflimsy and miserable\n” (there’s an-\nother portmanteau for you).   And\na “\nborogove\n” is a thin shabby-looking\nbird with its feathers sticking out all\nround – something like a live mop.’\n‘And then “\nmome raths\n”?’ said Alice. ‘I’m afraid I’m giving you a great deal\nof trouble.’\n‘Well, a “\nrath\n” is a sort of green pig: but “\nmome\n” I’m not certain about. I think\nit’s short for “\nfrom home\n” – meaning that they’d lost their way, you know.’\n‘And what does “\noutgrabe\n” mean?’\n‘Well, “\noutgrabing\n” is something between bellowing and whistling with a kind\nof sneeze in the middle: however, you’ll hear it done, maybe – down in the wood\nyonder – and when you’ve once heard it you’ll be\nquite\ncontent. Who’s been\nrepeating all that hard stuff to you?’\n‘I read it in a book,’ said Alice. ‘But I had some poetry repeated to me, much\neasier than that, by – Tweedledee, I think it was.’\n‘As to poetry, you know,’ said Humpty Dumpty, stretching out one of his great\nhands, ‘\nI\ncan repeat poetry as well as other folk, if it comes to that – ’\n‘Oh, it needn’t come to that!’ Alice hastily said, hoping to keep him from\nbeginning.\n‘The piece I’m going to repeat,’ he went on without noticing her remark, ‘was\nwritten entirely for your amusement.’\nAlice felt that in that case she really\nought\nto listen to it, so she sat down, and\nsaid ‘Thank you’ rather sadly.\n‘In winter, when the fields are white,\nI sing this song for your delight –\nonly I don’t sing it,’ he added, as an explanation.\n‘I see you don’t,’ said Alice.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":50},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:51","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n49\n‘If you can\nsee\nwhether I’m singing or not, you’ve sharper eyes than most.’\nHumpty Dumpty remarked severely. Alice was silent.\n‘In spring, when woods are getting green,\nI’ll try and tell you what I mean.’\n‘Thank you very much,’ said Alice.\n‘In summer, when the days are long,\nPerhaps you’ll understand the song:\nIn autumn, when the leaves are brown,\nTake pen and ink, and write it down.’\n‘I will, if I can remember it so long,’ said Alice.\n‘You needn’t go on making remarks like that,’ Humpty Dumpty said, ‘they’re\nnot sensible, and they put me out.’\n‘I sent a message to the fish:\nI told them “This is what I wish.”\nThe little fishes of the sea,\nThey sent an answer back to me.\nThe little fishes’ answer was\n“We cannot do it, Sir, because – ” ’\n‘I’m afraid I don’t quite understand,’ said Alice.\n‘It gets easier further on,’ Humpty Dumpty replied.\n‘I sent to them again to say\n“It will be better to obey.”\nThe fishes answered with a grin,\n“Why, what a temper you are in!”\nI told them once, I told them twice:\nThey would not listen to advice.\nI took a kettle large and new,\nFit for the deed I had to do.\nMy heart went hop, my heart went thump;\nI filled the kettle at the pump.\nThen some one came to me and said,\n“The little fishes are in bed.”\nI said to him, I said it plain,\n“Then you must wake them up again.”\nI said it very loud and clear;\nI went and shouted in his ear.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":51},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:52","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n50\nHumpty Dumpty raised his voice almost\nto a scream as he repeated this verse, and\nAlice thought with a shudder, ‘I wouldn’t\nhave been the messenger for\nanything\n!’\n‘But he was very stiff and proud;\nHe said “You needn’t shout so loud!”\nAnd he was very proud and stiff;\nHe said “I’d go and wake them, if – ”\nI took a corkscrew from the shelf:\nI went to wake them up myself.\nAnd when I found the door was locked,\nI pulled and pushed and kicked and knocked.\nAnd when I found the door was shut,\nI tried to turn the handle, but – ’\nThere was a long pause.\n‘Is that all?’ Alice timidly asked.\n‘That’s  all,’  said  Humpty  Dumpty.\n‘Good-bye.’\nThis was rather sudden, Alice thought: but, after such a\nvery\nstrong hint that\nshe ought to be going, she felt that it would hardly be civil to stay. So she got up,\nand held out her hand. ‘Good-bye, till we meet again!’ she said as cheerfully as\nshe could.\n‘I shouldn’t know you again if we\ndid\nmeet,’ Humpty Dumpty replied in a dis-\ncontented tone, giving her one of his fingers to shake; ‘you’re so exactly like other\npeople.’\n‘The face is what one goes by, generally,’ Alice remarked in a thoughtful tone.\n‘That’s just what I complain of,’ said Humpty Dumpty. ‘Your face is the same\nas everybody has – the two eyes, so – ’ (marking their places in the air with this\nthumb) ‘nose in the middle, mouth under. It’s always the same. Now if you had\nthe two eyes on the same side of the nose, for instance – or the mouth at the top –\nthat would be\nsome\nhelp.’\n‘It wouldn’t look nice,’ Alice objected. But Humpty Dumpty only shut his\neyes and said ‘Wait till you’ve tried.’\nAlice waited a minute to see if he would speak again, but as he never opened\nhis eyes or took any further notice of her, she said ‘Good-bye!’ once more, and,\ngetting no answer to this, she quietly walked away: but she couldn’t help saying\nto herself as she went, ‘Of all the unsatisfactory – ’ (she repeated this aloud, as\nit was a great comfort to have such a long word to say) ‘of all the unsatisfactory","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":52},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:53","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VI.  HUMPTY DUMPTY\n51\npeople I\never\nmet – ’ She never finished the sentence, for at this moment a heavy\ncrash shook the forest from end to end.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":53},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:54","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter VII\nThe Lion and the Unicorn\nThe next moment soldiers came run-\nning through the wood, at first in twos\nand threes, then ten or twenty to-\ngether, and at last in such crowds that\nthey seemed to fill the whole forest.\nAlice got behind a tree, for fear of be-\ning run over, and watched them go by.\nShe thought that in all her life\nshe had never seen soldiers so uncer-\ntain on their feet: they were always\ntripping over something or other, and\nwhenever one went down, several\nmore always fell over him, so that the\nground was soon covered with little\nheaps of men.\nThen came the horses.  Having\nfour feet, these managed rather better\nthan the foot-soldiers: but even\nthey\nstumbled now and then; and it seemed to be\na regular rule that, whenever a horse stumbled the rider fell off instantly. The con-\nfusion got worse every moment, and Alice was very glad to get out of the wood\ninto an open place, where she found the White King seated on the ground, busily\nwriting in his memorandum-book.\n‘I’ve sent them all!’ the King cried in a tone of delight, on seeing Alice. ‘Did\nyou happen to meet any soldiers, my dear, as you came through the wood?’\n‘Yes, I did,’ said Alice, ‘several thousand, I should think.’\n‘Four thousand two hundred and seven, that’s the exact number,’ the King\nsaid, referring to his book. ‘I couldn’t send all the horses, you know, because two\nof them are wanted in the game. And I haven’t sent the two Messengers, either.\n52","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":54},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:55","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n53\nThey’re both gone to the town. Just look along the road, and tell me if you can see\neither of them.’\n‘I see nobody on the road,’ said Alice.\n‘I only wish\nI\nhad such eyes,’ the King remarked in a fretful tone. ‘To be able\nto see Nobody! And at that distance, too! Why, it’s as much as\nI\ncan do to see real\npeople, by this light!’\nAll this was lost on Alice, who was still looking intently along the road, shad-\ning her eyes with one hand. ‘I see somebody now!’ she exclaimed at last. ‘But\nhe’s coming very slowly – and what curious attitudes he goes into!’ (For the mes-\nsenger kept skipping up and down, and wriggling like an eel, as he came along,\nwith his great hands spread out like fans on each side.)\n‘Not at all,’ said the King. ‘He’s an Anglo-Saxon Messenger – and those are\nAnglo-Saxon attitudes. He only does them when he’s happy. His name is Haigha.’\n(He pronounced it so as to rhyme with ’mayor.’)\n‘I love my love with an H,’ Alice couldn’t help beginning, ‘because he is\nHappy. I hate him with an H, because he is Hideous. I fed him with – with – with\nHam-sandwiches and Hay. His name is Haigha, and he lives – ’\n‘He lives on the Hill,’ the King remarked simply, without the least idea that he\nwas joining in the game, while Alice was still hesitating for the name of a town\nbeginning with H. ‘The other Messenger’s called Hatta. I must have\ntwo\n, you\nknow – to come and go. One to come, and one to go.’\n‘I beg your pardon?’ said Alice.\n‘It isn’t respectable to beg,’ said the King.\n‘I only meant that I didn’t understand,’ said Alice. ‘Why one to come and one\nto go?’\n‘Didn’t I tell you?’ the King repeated impatiently. ‘I must have Two – to fetch\nand carry. One to fetch, and one to carry.’\nAt this moment the Messenger arrived; he was far too much out of breath to\nsay a word, and could only wave his hands about, and make the most fearful faces\nat the poor King.\n‘This young lady loves you with an H,’ the King said, introducing Alice in the\nhope of turning off the Messenger’s attention from himself – but it was no use –\nthe Anglo-Saxon attitudes only got more extraordinary every moment, while the\ngreat eyes rolled wildly from side to side.\n‘You alarm me!’ said the King, ‘I feel faint – Give me a ham sandwich!’\nOn which the Messenger, to Alice’s great amusement, opened a bag that hung\nround his neck, and handed a sandwich to the King, who devoured it greedily.\n‘Another sandwich!’ said the King.\n‘There’s nothing but hay left now,’ the Messenger said, peeping into the bag.\n‘Hay, then,’ the King murmured in a faint whisper.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":55},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:56","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n54\nAlice was glad to see that it re-\nvived him a good deal. ‘There’s noth-\ning like eating hay when you’re faint,’\nhe remarked to her, as he munched\naway.\n‘I should think throwing cold wa-\nter over you would be better,’ Alice\nsuggested, ‘or some sal-volatile.’\n‘I didn’t say there was nothing\nbetter\n,’ the King replied. ‘I said there\nwas nothing\nlike\nit.’ Which Alice did\nnot venture to deny.\n‘Who did you pass on the road?’ the King went on, holding out his hand to\nthe Messenger for some more hay.\n‘Nobody,’ said the Messenger.\n‘Quite right,’ said the King, ‘this young lady saw him too. So of course No-\nbody walks slower than you.’\n‘I do my best,’ the Messenger said in a sulky tone, ‘I’m sure nobody walks\nmuch faster than I do!’\n‘He can’t do that,’ said the King, ‘or else he’d have been here first. However,\nnow you’ve got your breath, you may tell us what’s happened in the town.’\n‘I’ll whisper it,’ said the Messenger, putting his hands to his mouth in the shape\nof a trumpet, and stooping so as to get close to the King’s ear. Alice was sorry\nfor this, as she wanted to hear the news too. However, instead of whispering, he\nsimply shouted at the top of his voice ‘They’re at it again!’\n‘Do you call\nthat\na whisper?’ cried the poor King, jumping up and shaking\nhimself. ‘If you do such a thing again, I’ll have you buttered! It went through and\nthrough my head like an earthquake!’\n‘It would have to be a very tiny earthquake!’ thought Alice. ‘Who are at it\nagain?’ she ventured to ask.\n‘Why the Lion and the Unicorn, of course,’ said the King.\n‘Fighting for the crown?’\n‘Yes, to be sure,’ said the King, ‘and the best of the joke is, that it’s\nmy\ncrown\nall the while! Let’s run and see them.’ And they trotted off, Alice repeating to\nherself, as she ran, the words of the old song –\n‘The Lion and the Unicorn were fighting for the crown:\nThe Lion beat the Unicorn all round the town.\nSome gave them white bread, some gave them brown;\nSome gave them plum-cake and drummed them out of town.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":56},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:57","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n55\n‘Does – the one – that wins – get the crown?’ she asked, as well as she could,\nfor the run was putting her quite out of breath.\n‘Dear me, no!’ said the King. ‘What an idea!’\n‘Would you – be good enough,’ Alice panted out, after running a little further,\n‘to stop a minute – just to get – one’s breath again?’\n‘I’m\ngood\nenough,’ the King said, ‘only I’m not strong enough. You see, a mi-\nnute goes by so fearfully quick. You might as well try to stop a Bandersnatch!’\nAlice had no more breath for talking, so they trotted on in silence, till they\ncame in sight of a great crowd, in the middle of which the Lion and Unicorn were\nfighting. They were in such a cloud\nof dust, that at first Alice could not\nmake out which was which; but she\nsoon managed to distinguish the Uni-\ncorn by his horn.\nThey placed themselves close to\nwhere Hatta, the other messenger,\nwas standing watching the fight, with\na cup of tea in one hand and a piece of\nbread-and-butter in the other.\n‘He’s only just out of prison, and\nhe hadn’t finished his tea when he was\nsent in,’ Haigha whispered to Alice, ‘and they only give them oyster-shells in\nthere – so you see he’s very hungry and thirsty. How are you, dear child?’ he\nwent on, putting his arm affectionately round Hatta’s neck.\nHatta looked round and nodded, and went on with his bread and butter.\n‘Were you happy in prison, dear child?’ said Haigha.\nHatta looked round once more, and this time a tear or two trickled down his\ncheek: but not a word would he say.\n‘Speak, can’t you!’ Haigha cried impatiently. But Hatta only munched away,\nand drank some more tea.\n‘Speak, won’t you!’ cried the King. ‘How are they getting on with the fight?’\nHatta made a desperate effort, and swallowed a large piece of bread-and-butter.\n‘They’re getting on very well,’ he said in a choking voice, ‘each of them has been\ndown about eighty-seven times.’\n‘Then I suppose they’ll soon bring the white bread and the brown?’ Alice\nventured to remark.\n‘It’s waiting for ’em now,’ said Hatta, ‘this is a bit of it as I’m eating.’\nThere was a pause in the fight just then, and the Lion and the Unicorn sat\ndown, panting, while the King called out ‘Ten minutes allowed for refreshments!’\nHaigha and Hatta set to work at once, carrying rough trays of white and brown\nbread. Alice took a piece to taste, but it was\nvery\ndry.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":57},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:58","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n56\n‘I don’t think they’ll fight any more to-day,’ the King said to Hatta, ‘go and\norder the drums to begin.’ And Hatta went bounding away like a grasshopper.\nFor a minute or two Alice stood silent, watching him. Suddenly she brightened\nup. ‘Look, look!’ she cried, pointing eagerly. ‘There’s the White Queen running\nacross the country! She came flying out of the wood over yonder – How fast those\nQueens\ncan\nrun!’\n‘There’s some enemy after her, no doubt,’ the King said, without even looking\nround. ‘That wood’s full of them.’\n‘But aren’t you going to run and help her?’ Alice asked, very much surprised\nat his taking it so quietly.\n‘No use, no use!’ said the King. ‘She runs so fearfully quick. You might as\nwell try to catch a Bandersnatch! But I’ll make a memorandum about her, if you\nlike – She’s a dear good creature,’ he repeated softly to himself, as he opened his\nmemorandum-book. ‘Do you spell “creature” with a double “e”?’\nAt this moment the Unicorn sauntered by them, with his hands in his pockets.\n‘I had the best of it this time?’ he said to the King, just glancing at him as he\npassed.\n‘A little – a little,’ the King replied, rather nervously. ‘You shouldn’t have run\nhim through with your horn, you know.’\n‘It didn’t hurt him,’ the Unicorn said carelessly, and he was going on, when\nhis eye happened to fall upon Alice: he turned round rather instantly, and stood\nfor some time looking at her with an air of the deepest disgust.\n‘What – is – this?’ he said at last.\n‘This is a child!’ Haigha replied eagerly, coming in front of Alice to introduce\nher, and spreading out both his hands towards her in an Anglo-Saxon attitude. ‘We\nonly found it to-day. It’s as large as life, and twice as natural!’\n‘I always thought they were fabulous monsters!’ said the Unicorn. ‘Is it alive?’\n‘It can talk,’ said Haigha, solemnly.\nThe Unicorn looked dreamily at Alice, and said ‘Talk, child.’\nAlice could not help her lips curling up into a smile as she began, ‘Do you\nknow, I always thought Unicorns were fabulous monsters, too! I never saw one\nalive before!’\n‘Well, now that we\nhave\nseen each other,’ said the Unicorn, ‘if you’ll believe\nin me, I’ll believe in you. Is that a bargain?’\n‘Yes, if you like,’ said Alice.\n‘Come, fetch out the plum-cake, old man!’ the Unicorn went on, turning from\nher to the King. ‘None of your brown bread for me!’\n‘Certainly – certainly!’ the King muttered, and beckoned to Haigha. ‘Open\nthe bag!’ he whispered. ‘Quick! Not that one – that’s full of hay!’\nHaigha took a large cake out of the bag, and gave it to Alice to hold, while he\ngot out a dish and carving-knife. How they all came out of it Alice couldn’t guess.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":58},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:59","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n57\nIt was just like a conjuring-\ntrick, she thought.\nThe Lion had joined them\nwhile this was going on:  he\nlooked very tired and sleepy,\nand his eyes were half shut.\n‘What’s this!’ he said, blinking\nlazily at Alice, and speaking in\na deep hollow tone that sounded\nlike the tolling of a great bell.\n‘Ah, what\nis\nit, now?’ the\nUnicorn cried eagerly. ‘You’ll\nnever guess! I couldn’t.’\nThe Lion looked at Alice wearily. ‘Are you animal – vegetable – or mineral?’\nhe said, yawning at every other word.\n‘It’s a fabulous monster!’ the Unicorn cried out, before Alice could reply.\n‘Then hand round the plum-cake, Monster,’ the Lion said, lying down and\nputting his chin on this paws. ‘And sit down, both of you,’ (to the King and the\nUnicorn), ‘fair play with the cake, you know!’\nThe King was evidently very uncomfortable at having to sit down between the\ntwo great creatures; but there was no other place for him.\n‘What a fight we might have for the crown,\nnow\n!’ the Unicorn said, looking\nslyly up at the crown, which the poor King was nearly shaking off his head, he\ntrembled so much.\n‘I should win easy,’ said the Lion.\n‘I’m not so sure of that,’ said the Unicorn.\n‘Why, I beat you all round the town, you chicken!’ the Lion replied angrily,\nhalf getting up as he spoke.\nHere the King interrupted, to prevent the quarrel going on: he was very ner-\nvous, and his voice quite quivered. ‘All round the town?’ he said. ‘That’s a good\nlong way. Did you go by the old bridge, or the market-place? You get the best\nview by the old bridge.’\n‘I’m sure I don’t know,’ the Lion growled out as he lay down again. ‘There\nwas too much dust to see anything. What a time the Monster is, cutting up that\ncake!’\nAlice had seated herself on the bank of a little brook, with the great dish on\nher knees, and was sawing away diligently with the knife. ‘It’s very provoking!’\nshe said, in reply to the Lion (she was getting quite used to being called ‘the\nMonster’). ‘I’ve cut several slices already, but they always join on again!’\n‘You don’t know how to manage Looking-glass cakes,’ the Unicorn remarked.\n‘Hand it round first, and cut it afterwards.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":59},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:60","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VII.  THE LION AND THE UNICORN\n58\nThis sounded nonsense, but Alice very obediently got up, and carried the dish\nround, and the cake divided itself into three pieces as she did so. ‘\nNow\ncut it up,’\nsaid the Lion, as she returned to her place with the empty dish.\n‘I say, this isn’t fair!’ cried the Unicorn, as Alice sat with the knife in her\nhand, very much puzzled how to begin. ‘The Monster has given the Lion twice as\nmuch as me!’\n‘She’s kept none for herself, anyhow,’ said the Lion. ‘Do you like plum-cake,\nMonster?’\nBut before Alice could answer him, the drums began.\nWhere the noise came from, she couldn’t make out: the air seemed full of it,\nand it rang through and through her head till she felt quite deafened. She started\nto her feet and sprang across the little brook in her terror,\n*    *    *    *    *    *    *    *    *    *    *\nand had just time to see the Lion and the Unicorn rise to their feet, with angry\nlooks at being interrupted in their feast, before she dropped to her knees, and put\nher hands over her ears, vainly trying to shut out the dreadful uproar.\n‘If\nthat\ndoesn’t “drum them out of town,” ’ she thought to herself, ‘nothing\never will!’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":60},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:61","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter VIII\nIt’s My Own Invention\nAfter a while the noise seemed gradually to die away, till all was dead silence, and\nAlice lifted up her head in some alarm. There was no one to be seen, and her first\nthought was that she must have been dreaming about the Lion and the Unicorn\nand those queer Anglo-Saxon Messengers. However, there was the great dish still\nlying at her feet, on which she had tried to cut the plum-cake, ‘So I wasn’t dream-\ning, after all,’ she said to herself, ‘unless – unless we’re all part of the same dream.\nOnly I do hope it’s\nmy\ndream, and not the Red King’s! I don’t like belonging to\nanother person’s dream,’ she went on in a rather complaining tone, ‘I’ve a great\nmind to go and wake him, and see what happens!’\nAt this moment her thoughts were interrupted by a loud shouting of ‘Ahoy!\nAhoy! Check!’ and a Knight dressed in crimson armour came galloping down\nupon her, brandishing a great club. Just as he reached her, the horse stopped\nsuddenly, ‘You’re my prisoner!’ the Knight cried, as he tumbled off his horse.\nStartled as she was, Alice was more frightened for him than for herself at the\nmoment, and watched him with some anxiety as he mounted again. As soon as\nhe was comfortably in the saddle, he began once more ‘You’re my – ’ but here\nanother voice broke in ‘Ahoy! Ahoy! Check!’ and Alice looked round in some\nsurprise for the new enemy.\nThis time it was a White Knight. He drew up at Alice’s side, and tumbled\noff his horse just as the Red Knight had done: then he got on again, and the two\nKnights sat and looked at each other for some time without speaking. Alice looked\nfrom one to the other in some bewilderment.\n‘She’s\nmy\nprisoner, you know!’ the Red Knight said at last.\n‘Yes, but then\nI\ncame and rescued her!’ the White Knight replied.\n‘Well, we must fight for her, then,’ said the Red Knight, as he took up his\nhelmet (which hung from the saddle, and was something the shape of a horse’s\nhead), and put it on.\n59","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":61},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:62","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n60\n‘You will observe the Rules\nof Battle, of course?’  the White\nKnight remarked, putting on his\nhelmet too.\n‘I always do,’ said the Red\nKnight, and they began banging\naway at each other with such fury\nthat Alice got behind a tree to be\nout of the way of the blows.\n‘I wonder, now, what the Rules\nof Battle are,’ she said to herself,\nas she watched the fight, timidly\npeeping out from her hiding-place,\n‘one Rule seems to be, that if one\nKnight hits the other, he knocks\nhim off his horse, and if he misses, he tumbles off himself – and another Rule\nseems to be that they hold their clubs with their arms, as if they were Punch and\nJudy – What a noise they make when they tumble! Just like a whole set of fire-\nirons falling into the fender! And how quiet the horses are! They let them get on\nand off them just as if they were tables!’\nAnother Rule of Battle, that Alice had not noticed, seemed to be that they\nalways fell on their heads, and the battle ended with their both falling off in this\nway, side by side: when they got up again, they shook hands, and then the Red\nKnight mounted and galloped off.\n‘It was a glorious victory, wasn’t it?’ said the White Knight, as he came up\npanting.\n‘I don’t know,’ Alice said doubtfully. ‘I don’t want to be anybody’s prisoner.\nI want to be a Queen.’\n‘So you will, when you’ve crossed the next brook,’ said the White Knight. ‘I’ll\nsee you safe to the end of the wood – and then I must go back, you know. That’s\nthe end of my move.’\n‘Thank you very much,’ said Alice. ‘May I help you off with your helmet?’ It\nwas evidently more than he could manage by himself; however, she managed to\nshake him out of it at last.\n‘Now one can breathe more easily,’ said the Knight, putting back his shaggy\nhair with both hands, and turning his gentle face and large mild eyes to Alice. She\nthought she had never seen such a strange-looking soldier in all her life.\nHe was dressed in tin armour, which seemed to fit him very badly, and he had\na queer-shaped little deal box fastened across his shoulder, upside-down, and with\nthe lid hanging open. Alice looked at it with great curiosity.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":62},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:63","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n61\n‘I see you’re admiring my little box.’ the Knight said in a friendly tone. ‘It’s\nmy own invention – to keep clothes and sandwiches in. You see I carry it upside-\ndown, so that the rain can’t get in.’\n‘But the things can get\nout\n,’ Alice gently remarked. ‘Do you know the lid’s\nopen?’\n‘I didn’t know it,’ the Knight said, a shade of vexation passing over his face.\n‘Then all the things must have fallen out! And the box is no use without them.’\nHe unfastened it as he spoke, and was just going to throw it into the bushes, when\na sudden thought seemed to strike him, and he hung it carefully on a tree. ‘Can\nyou guess why I did that?’ he said to Alice.\nAlice shook her head.\n‘In hopes some bees may make a nest in it – then I should get the honey.’\n‘But you’ve got a bee-hive – or something like one – fastened to the saddle,’\nsaid Alice.\n‘Yes, it’s a very good bee-hive,’ the Knight said in a discontented tone, ‘one\nof the best kind. But not a single bee has come near it yet. And the other thing is\na mouse-trap. I suppose the mice keep the bees out – or the bees keep the mice\nout, I don’t know which.’\n‘I was wondering what the mouse-trap was for,’ said Alice. ‘It isn’t very likely\nthere would be any mice on the horse’s back.’\n‘Not very likely, perhaps,’ said the Knight, ‘but if they\ndo\ncome, I don’t choose\nto have them running all about.’\n‘You see,’ he went on after a pause, ‘it’s as well to be provided for\neverything\n.\nThat’s the reason the horse has all those anklets round his feet.’\n‘But what are they for?’ Alice asked in a tone of great curiosity.\n‘To guard against the bites of sharks,’ the Knight replied. ‘It’s an invention of\nmy own. And now help me on. I’ll go with you to the end of the wood – What’s\nthe dish for?’\n‘It’s meant for plum-cake,’ said Alice.\n‘We’d better take it with us,’ the Knight said. ‘It’ll come in handy if we find\nany plum-cake. Help me to get it into this bag.’\nThis took a very long time to manage, though Alice held the bag open very\ncarefully, because the Knight was so\nvery\nawkward in putting in the dish: the first\ntwo or three times that he tried he fell in himself instead. ‘It’s rather a tight fit, you\nsee,’ he said, as they got it in a last; ‘There are so many candlesticks in the bag.’\nAnd he hung it to the saddle, which was already loaded with bunches of carrots,\nand fire-irons, and many other things.\n‘I hope you’ve got your hair well fastened on?’ he continued, as they set off.\n‘Only in the usual way,’ Alice said, smiling.\n‘That’s hardly enough,’ he said, anxiously. ‘You see the wind is so\nvery\nstrong\nhere. It’s as strong as soup.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":63},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:64","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n62\n‘Have you invented a plan for keeping the hair from being blown off?’ Alice\nenquired.\n‘Not yet,’ said the Knight. ‘But I’ve got a plan for keeping it from\nfalling\noff.’\n‘I should like to hear it, very much.’\n‘First you take an upright stick,’ said the Knight. ‘Then you make your hair\ncreep up it, like a fruit-tree. Now the reason hair falls off is because it hangs\ndown\n– things never fall\nupwards\n, you know. It’s a plan of my own invention. You\nmay try it if you like.’\nIt didn’t sound a comfortable plan, Alice thought, and for a few minutes she\nwalked on in silence, puzzling over the idea, and every now and then stopping to\nhelp the poor Knight, who certainly was\nnot\na good rider.\nWhenever the horse stopped (which it did very often), he fell off in front; and\nwhenever it went on again (which it generally did rather suddenly), he fell off\nbehind. Otherwise he kept on pretty\nwell, except that he had a habit of now\nand then falling off sideways; and as\nhe generally did this on the side on\nwhich Alice was walking, she soon\nfound that it was the best plan not to\nwalk\nquite\nclose to the horse.\n‘I’m afraid you’ve not had much\npractice in riding,’ she ventured to\nsay, as she was helping him up from\nhis fifth tumble.\nThe Knight looked very much sur-\nprised, and a little offended at the re-\nmark. ‘What makes you say that?’ he\nasked, as he scrambled back into the\nsaddle, keeping hold of Alice’s hair\nwith one hand, to save himself from falling over on the other side.\n‘Because people don’t fall off quite so often, when they’ve had much practice.’\n‘I’ve had plenty of practice,’ the Knight said very gravely, ‘plenty of practice!’\nAlice could think of nothing better to say than ‘Indeed?’ but she said it as\nheartily as she could. They went on a little way in silence after this, the Knight\nwith his eyes shut, muttering to himself, and Alice watching anxiously for the next\ntumble.\n‘The great art of riding,’ the Knight suddenly began in a loud voice, waving\nhis right arm as he spoke, ‘is to keep – ’ Here the sentence ended as suddenly\nas it had begun, as the Knight fell heavily on the top of his head exactly in the\npath where Alice was walking. She was quite frightened this time, and said in an\nanxious tone, as she picked him up, ’I hope no bones are broken?’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":64},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:65","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n63\n‘None to speak of,’ the Knight said, as if he didn’t mind breaking two or three\nof them. ‘The great art of riding, as I was saying, is – to keep your balance\nproperly. Like this, you know – ’\nHe let go the bridle, and stretched out both his arms to show Alice what he\nmeant, and this time he fell flat on his back, right under the horse’s feet.\n‘Plenty of practice!’ he went on repeating, all the time that Alice was getting\nhim on his feet again. ‘Plenty of practice!’\n‘It’s too ridiculous!’ cried Alice, losing all her patience this time. ‘You ought\nto have a wooden horse on wheels, that you ought!’\n‘Does that kind go smoothly?’ the Knight asked in a tone of great interest,\nclasping his arms round the horse’s neck as he spoke, just in time to save himself\nfrom tumbling off again.\n‘Much more smoothly than a live horse,’ Alice said, with a little scream of\nlaughter, in spite of all she could do to prevent it.\n‘I’ll get one,’ the Knight said thoughtfully to himself. ‘One or two – several.’\nThere was a short silence after this, and then the Knight went on again. ‘I’m\na great hand at inventing things. Now, I daresay you noticed, that last time you\npicked me up, that I was looking rather thoughtful?’\n‘You\nwere\na little grave,’ said Alice.\n‘Well, just then I was inventing a new way of getting over a gate – would you\nlike to hear it?’\n‘Very much indeed,’ Alice said politely.\n‘I’ll tell you how I came to think of it,’ said the Knight. ‘You see, I said to\nmyself, “The only difficulty is with the feet: the\nhead\nis high enough already.”\nNow, first I put my head on the top of the gate – then I stand on my head – then\nthe feet are high enough, you see – then I’m over, you see.’\n‘Yes, I suppose you’d be over when that was done,’ Alice said thoughtfully,\n‘but don’t you think it would be rather hard?’\n‘I haven’t tried it yet,’ the Knight said, gravely, ‘so I can’t tell for certain – but\nI’m afraid it\nwould\nbe a little hard.’\nHe looked so vexed at the idea, that Alice changed the subject hastily. ‘What\na curious helmet you’ve got!’ she said cheerfully. ‘Is that your invention too?’\nThe Knight looked down proudly at his helmet, which hung from the saddle.\n‘Yes,’ he said, ‘but I’ve invented a better one than that – like a sugar loaf. When\nI used to wear it, if I fell off the horse, it always touched the ground directly. So\nI had a\nvery\nlittle way to fall, you see – But there\nwas\nthe danger of falling\ninto\nit, to be sure. That happened to me once – and the worst of it was, before I could\nget out again, the other White Knight came and put it on. He thought it was his\nown helmet.’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":65},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:66","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n64\nThe knight looked so solemn about it that Alice did not dare to laugh. ‘I’m\nafraid you must have hurt him,’ she said in a trembling voice, ‘being on the top of\nhis head.’\n‘I had to kick him, of course,’ the Knight said, very seriously. ‘And then he\ntook the helmet off again – but it took hours and hours to get me out. I was as fast\nas – as lightning, you know.’\n‘But that’s a different kind of fastness,’ Alice objected.\nThe Knight shook his head. ‘It was all kinds of fastness with me, I can assure\nyou!’ he said. He raised his hands in some excitement as he said this, and instantly\nrolled out of the saddle, and fell\nheadlong into a deep ditch.\nAlice ran to the side of the\nditch to look for him.  She was\nrather startled by the fall, as for\nsome time he had kept on very\nwell, and she was afraid that he re-\nally\nwas\nhurt this time. However,\nthough she could see nothing but\nthe soles of his feet, she was much\nrelieved to hear that he was talking\non in his usual tone. ‘All kinds of fastness,’ he repeated, ‘but it was careless of\nhim to put another man’s helmet on – with the man in it, too.’\n‘How\ncan\nyou go on talking so quietly, head downwards?’ Alice asked, as she\ndragged him out by the feet and laid him in a heap on the bank.\nThe Knight looked surprised at the question. ‘What does it matter where my\nbody happens to be?’ he said. ‘My mind goes on working all the same. In fact,\nthe more head downwards I am, the more I keep inventing new things.’\n‘Now the cleverest thing of the sort that I ever did,’ he went on after a pause,\n‘was inventing a new pudding during the meat- course.’\n‘In time to have it cooked for the next course?’ said Alice. ‘Well, not the\nnext\ncourse,’ the Knight said in a slow thoughtful tone, ‘no, certainly not the next\ncourse\n.’\n‘Then it would have to be the next day. I suppose you wouldn’t have two\npudding-courses in one dinner?’\n‘Well, not the\nnext\nday,’ the Knight repeated as before, ‘not the next\nday\n. In\nfact,’ he went on, holding his head down, and his voice getting lower and lower,\n‘I don’t believe that pudding ever\nwas\ncooked! In fact, I don’t believe that pudding\never\nwill\nbe cooked! And yet it was a very clever pudding to invent.’\n‘What did you mean it to be made of?’ Alice asked, hoping to cheer him up,\nfor the poor Knight seemed quite low-spirited about it.\n‘It began with blotting paper,’ the Knight answered with a groan.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":66},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:67","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n65\n‘That wouldn’t be very nice, I’m afraid – ’\n‘Not very nice\nalone\n,’ he interrupted, quite eagerly, ‘but you’ve no idea what\na difference it makes mixing it with other things – such as gunpowder and sealing-\nwax. And here I must leave you.’ They had just come to the end of the wood.\nAlice could only look puzzled: she was thinking of the pudding.\n‘You are sad,’ the Knight said in an anxious tone, ‘let me sing you a song to\ncomfort you.’\n‘Is it very long?’ Alice asked, for she had heard a good deal of poetry that day.\n‘It’s long,’ said the Knight, ‘but very,\nvery\nbeautiful. Everybody that hears me\nsing it – either it brings the\ntears\ninto their eyes, or else – ’\n‘Or else what?’ said Alice, for the Knight had made a sudden pause.\n‘Or else it doesn’t, you know. The name of the song is called “H\nADDOCKS\n’\nE\nYES\n.” ’\n‘Oh, that’s the name of the song, is it?’ Alice said, trying to feel interested.\n‘No, you don’t understand,’ the Knight said, looking a little vexed. ‘That’s\nwhat the name is\ncalled\n. The name really\nis\n“T\nHE\nA\nGED\nA\nGED\nM\nAN\n.” ’\n‘Then I ought to have said “That’s what the\nsong\nis called”?’ Alice corrected\nherself.\n‘No, you oughtn’t: that’s quite another thing! The\nsong\nis called “W\nAYS\nA\nND\nM\nEANS\n”: but that’s only what it’s\ncalled\n, you know!’\n‘Well, what\nis\nthe song, then?’ said Alice, who was by this time completely\nbewildered.\n‘I was coming to that,’ the Knight said. ‘The song really\nis\n“A-S\nITTING\nO\nN\nA G\nATE\n”, and the tune’s my own invention.’\nSo saying, he stopped his horse and let the reins fall on its neck: then, slowly\nbeating time with one hand, and with a faint smile lighting up his gentle foolish\nface, as if he enjoyed the music of his song, he began.\nOf all the strange things that Alice saw in her journey through the Looking-\nglass, this was the one that she always remembered most clearly. Years afterwards\nshe could bring the whole scene back again, as if it had been only yesterday – the\nmild blue eyes and kindly smile of the Knight – the setting sun gleaming through\nhis hair, and shining on his armour in a blaze of light that quite dazzled her – the\nhorse quietly moving about, with the reins hanging loose on his neck, cropping\nthe grass at her feet – and the black shadows of the forest behind – all this she\ntook in like a picture, as, with one hand shading her eyes, she leant against a tree,\nwatching the strange pair, and listening, in a half dream, to the melancholy music\nof the song.\n‘But the tune\nisn’t\nhis own invention,’ she said to herself, ‘it’s “I G\nIVE\nT\nHEE\nA\nLL\n, I C\nAN\nN\nO\nM\nORE\n.” ’ She stood and listened very attentively, but no tears\ncame into her eyes.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":67},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:68","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n66\n‘I’ll tell thee everything I can;\nThere’s little to relate.\nI saw an aged aged man,\nA-sitting on a gate.\n“Who are you, aged man?” I said,\n“and how is it you live?”\nAnd his answer trickled through my head\nLike water through a sieve.\nHe said “I look for butterflies\nThat sleep among the wheat:\nI make them into mutton-pies,\nAnd sell them in the street.\nI sell them unto men,” he said,\n“Who sail on stormy seas;\nAnd that’s the way I get my bread –\nA trifle, if you please.”\nBut I was thinking of a plan\nTo dye one’s whiskers green,\nAnd always use so large a fan\nThat they could not be seen.\nSo, having no reply to give\nTo what the old man said,\nI cried, “Come, tell me how you live!”\nAnd thumped him on the head.\nHis accents mild took up the tale:\nHe said “I go my ways,\nAnd when I find a mountain-rill,\nI set it in a blaze;","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":68},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:69","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n67\nAnd thence they make a stuff they call\nRolands’ Macassar Oil –\nYet twopence-halfpenny is all\nThey give me for my toil.”\nBut I was thinking of a way\nTo feed oneself on batter,\nAnd so go on from day to day\nGetting a little fatter.\nI shook him well from side to side,\nUntil his face was blue:\n“Come, tell me how you live,” I cried,\n“And what it is you do!”\nHe said “I hunt for haddocks’ eyes\nAmong the heather bright,\nAnd work them into waistcoat-buttons\nIn the silent night.\nAnd these I do not sell for gold\nOr coin of silvery shine\nBut for a copper halfpenny,\nAnd that will purchase nine.\n“I sometimes dig for buttered rolls,\nOr set limed twigs for crabs;\nI sometimes search the grassy knolls\nFor wheels of Hansom-cabs.\nAnd that’s the way” (he gave a wink)\n“By which I get my wealth –\nAnd very gladly will I drink\nYour Honour’s noble health.”\nI heard him then, for I had just\nCompleted my design\nTo keep the Menai bridge from rust\nBy boiling it in wine.\nI thanked him much for telling me\nThe way he got his wealth,\nBut chiefly for his wish that he\nMight drink my noble health.\nAnd now, if e’er by chance I put\nMy fingers into glue\nOr madly squeeze a right-hand foot\nInto a left-hand shoe,\nOr if I drop upon my toe","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":69},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:70","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n68\nA very heavy weight,\nI weep, for it reminds me so,\nOf that old man I used to know –\nWhose look was mild, whose speech was slow,\nWhose hair was whiter than the snow,\nWhose face was very like a crow,\nWith eyes, like cinders, all aglow,\nWho seemed distracted with his woe,\nWho rocked his body to and fro,\nAnd muttered mumblingly and low,\nAs if his mouth were full of dough,\nWho snorted like a buffalo –\nThat summer evening, long ago,\nA-sitting on a gate.’\nAs the Knight sang the last words of the ballad, he gathered up the reins, and\nturned his horse’s head along the road by which they had come. ‘You’ve only\na few yards to go,’ he said, ‘down the hill and over that little brook, and then\nyou’ll be a Queen – But you’ll stay and see me off first?’ he added as Alice turned\nwith an eager look in the direction to which he pointed. ‘I shan’t be long. You’ll\nwait and wave your handkerchief when I get to that turn in the road? I think it’ll\nencourage me, you see.’\n‘Of course I’ll wait,’ said Alice, ‘and thank you very much for coming so\nfar – and for the song – I liked it very much.’\n‘I hope so,’ the Knight said doubtfully, ‘but you didn’t cry so much as I thought\nyou would.’\nSo they shook hands, and then the Knight rode slowly away into the forest.\n‘It won’t take long to see him\noff\n, I expect,’ Alice said to herself, as she stood\nwatching him. ‘There he goes! Right on his head as usual! However, he gets on\nagain pretty easily – that comes of having so many things hung round the horse – ’\nSo she went on talking to herself, as she watched the horse walking leisurely along\nthe road, and the Knight tumbling off, first on one side and then on the other. After\nthe fourth or fifth tumble he reached the turn, and then she waved her handkerchief\nto him, and waited till he was out of sight.\n‘I hope it encouraged him,’ she said, as she turned to run down the hill, ‘and\nnow for the last brook, and to be a Queen! How grand it sounds!’ A very few\nsteps brought her to the edge of the brook. ‘The Eighth Square at last!’ she cried\nas she bounded across,\n*    *    *    *    *    *    *    *    *    *    *\nand threw herself down to rest on a lawn as soft as moss, with little flower-beds\ndotted about it here and there. ‘Oh, how glad I am to get here! And what\nis","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":70},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:71","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER VIII.  IT’S MY OWN INVENTION\n69\nthis on my head?’ she exclaimed in a tone of dismay, as she put her hands up to\nsomething very heavy, and fitted tight all round her head.\n‘But how\ncan\nit have got there without my knowing it?’ she said to herself, as\nshe lifted it off, and set it on her lap to make out what it could possibly be.\nIt was a golden crown.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":71},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:72","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter IX\nQueen Alice\n‘Well, this\nis\ngrand!’ said Alice. ‘I never expected I should be a Queen so soon –\nand I’ll tell you what it is, your majesty,’ she went on in a severe tone (she was\nalways rather fond of scolding herself), ‘it’ll never do for you to be lolling about\non the grass like that! Queens have to be dignified, you know!’\nSo she got up and walked about – rather stiffly just at first, as she was afraid\nthat the crown might come off: but she comforted herself with the thought that\nthere was nobody to see her, ‘and if I really am a Queen,’ she said as she sat down\nagain, ‘I shall be able to manage it quite well in time.’\nEverything was happening so\noddly that she didn’t feel a bit sur-\nprised at finding the Red Queen\nand the White Queen sitting close\nto her, one on each side:  she\nwould have liked very much to ask\nthem how they came there, but she\nfeared it would not be quite civil.\nHowever, there would be no harm,\nshe thought, in asking if the game\nwas over. ‘Please, would you tell\nme – ’ she began, looking timidly at the Red Queen.\n‘Speak when you’re spoken to!’ The Queen sharply interrupted her.\n‘But if everybody obeyed that rule,’ said Alice, who was always ready for\na little argument, ‘and if you only spoke when you were spoken to, and the other\nperson always waited for\nyou\nto begin, you see nobody would ever say anything,\nso that – ’\n‘Ridiculous!’ cried the Queen. ‘Why, don’t you see, child – ’ here she broke\noff with a frown, and, after thinking for a minute, suddenly changed the subject of\nthe conversation. ‘What do you mean by “If you really are a Queen”? What right\n70","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":72},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:73","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n71\nhave you to call yourself so? You can’t be a Queen, you know, till you’ve passed\nthe proper examination. And the sooner we begin it, the better.’\n‘I only said “if”!’ poor Alice pleaded in a piteous tone.\nThe two Queens looked at each other, and the Red Queen remarked, with\na little shudder, ‘She\nsays\nshe only said “if” – ’\n‘But she said a great deal more than that!’ the White Queen moaned, wringing\nher hands, ‘Oh, ever so much more than that!’\n‘So you did, you know,’ the Red Queen said to Alice. ‘Always speak the\ntruth – think before you speak – and write it down afterwards.’\n‘I’m sure I didn’t mean – ’ Alice was beginning, but the Red Queen interrupted\nher impatiently.\n‘That’s just what I complain of! You\nshould\nhave meant! What do you suppose\nis the use of child without any meaning? Even a joke should have some meaning –\nand a child’s more important than a joke, I hope. You couldn’t deny that, even if\nyou tried with both hands.’\n‘I don’t deny things with my\nhands\n,’ Alice objected.\n‘Nobody said you did,’ said the Red Queen. ‘I said you couldn’t if you tried.’\n‘She’s in that state of mind,’ said the White Queen, ‘that she wants to deny\nsomething\n– only she doesn’t know what to deny!’\n‘A nasty, vicious temper,’ the Red Queen remarked; and then there was an\nuncomfortable silence for a minute or two.\nThe Red Queen broke the silence by saying to the White Queen, ‘I invite you\nto Alice’s dinner-party this afternoon.’\nThe White Queen smiled feebly, and said ‘And I invite\nyou\n.’\n‘I didn’t know I was to have a party at all,’ said Alice; ‘but if there is to be one,\nI think\nI\nought to invite the guests.’\n‘We gave you the opportunity of doing it,’ the Red Queen remarked, ‘but\nI daresay you’ve not had many lessons in manners yet?’\n‘Manners are not taught in lessons,’ said Alice. ‘Lessons teach you to do sums,\nand things of that sort.’\n‘And you do Addition?’ the White Queen asked. ‘What’s one and one and one\nand one and one and one and one and one and one and one?’\n‘I don’t know,’ said Alice. ‘I lost count.’\n‘She can’t do Addition,’ the Red Queen interrupted. ‘Can you do Subtraction?\nTake nine from eight.’\n‘Nine from eight I can’t, you know,’ Alice replied very readily, ‘but – ’\n‘She can’t do Subtraction,’ said the White Queen. ‘Can you do Division?\nDivide a loaf by a knife – what’s the answer to that?’\n‘I suppose – ’ Alice was beginning, but the Red Queen answered for her.\n‘Bread-and-butter, of course. Try another Subtraction sum. Take a bone from\na dog: what remains?’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":73},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:74","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n72\nAlice considered. ‘The bone wouldn’t remain, of course, if I took it – and\nthe dog wouldn’t remain; it would come to bite me – and I’m sure I shouldn’t\nremain!’\n‘Then you think nothing would remain?’ said the Red Queen.\n‘I think that’s the answer.’\n‘Wrong, as usual,’ said the Red Queen, ‘the dog’s temper would remain.’\n‘But I don’t see how – ’\n‘Why, look here!’ the Red Queen cried. ‘The dog would lose its temper,\nwouldn’t it?’\n‘Perhaps it would,’ Alice replied cautiously.\n‘Then if the dog went away, its temper would remain!’ the Queen exclaimed\ntriumphantly.\nAlice said, as gravely as she could, ‘They might go different ways.’ But she\ncouldn’t help thinking to herself, ‘What dreadful nonsense we\nare\ntalking!’\n‘She can’t do sums a\nbit\n!’ the Queens said together, with great emphasis.\n‘Can\nyou\ndo sums?’ Alice said, turning suddenly on the White Queen, for she\ndidn’t like being found fault with so much.\nThe Queen gasped and shut her eyes. ‘I can do Addition, if you give me time –\nbut I can do Subtraction, under\nany\ncircumstances!’\n‘Of course you know your ABC?’ said the Red Queen.\n‘To be sure I do.’ said Alice.\n‘So do I,’ the White Queen whispered, ‘we’ll often say it over together, dear.\nAnd I’ll tell you a secret – I can read words of one letter! Isn’t\nthat\ngrand! How-\never, don’t be discouraged. You’ll come to it in time.’\nHere the Red Queen began again. ‘Can you answer useful questions?’ she\nsaid. ‘How is bread made?’\n‘I know\nthat\n!’ Alice cried eagerly. ‘You take some flour – ’\n‘Where do you pick the flower?’ the White Queen asked. ‘In a garden, or in\nthe hedges?’\n‘Well, it isn’t\npicked\nat all,’ Alice explained, ‘it’s\nground\n– ’\n‘How many acres of ground?’ said the White Queen. ‘You mustn’t leave out\nso many things.’\n‘Fan her head!’ the Red Queen anxiously interrupted. ‘She’ll be feverish after\nso much thinking.’ So they set to work and fanned her with bunches of leaves, till\nshe had to beg them to leave off, it blew her hair about so.\n‘She’s all right again now,’ said the Red Queen. ‘Do you know Languages?\nWhat’s the French for fiddle-de-dee?’\n‘Fiddle-de-dee’s not English,’ Alice replied gravely.\n‘Who ever said it was?’ said the Red Queen.\nAlice thought she saw a way out of the difficulty this time. ‘If you’ll tell me\nwhat language “fiddle-de-dee” is, I’ll tell you the French for it!’ she exclaimed","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":74},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:75","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n73\ntriumphantly.\nBut the Red Queen drew herself up rather stiffly, and said ‘Queens never make\nbargains.’\n‘I wish Queens never asked questions,’ Alice thought to herself.\n‘Don’t let us quarrel,’ the White Queen said in an anxious tone. ‘What is the\ncause of lightning?’\n‘The cause of lightning,’ Alice said very decidedly, for she felt quite certain\nabout this, ‘is the thunder – no, no!’ she hastily corrected herself. ‘I meant the\nother way.’\n‘It’s too late to correct it,’ said the Red Queen, ‘when you’ve once said a thing,\nthat fixes it, and you must take the consequences.’\n‘Which reminds me – ’ the White Queen said, looking down and nervously\nclasping and unclasping her hands, ‘we had\nsuch\na thunderstorm last Tuesday –\nI mean one of the last set of Tuesdays, you know.’\nAlice was puzzled. ‘In\nour\ncountry,’ she remarked, ‘there’s only one day at\na time.’\nThe Red Queen said, ‘That’s a poor thin way of doing things. Now\nhere\n, we\nmostly have days and nights two or three at a time, and sometimes in the winter\nwe take as many as five nights together – for warmth, you know.’\n‘Are five nights warmer than one night, then?’ Alice ventured to ask.\n‘Five times as warm, of course.’\n‘But they should be five times as\ncold\n, by the same rule – ’\n‘Just so!’ cried the Red Queen. ‘Five times as warm,\nand\nfive times as cold –\njust as I’m five times as rich as you are,\nand\nfive times as clever!’\nAlice sighed and gave it up. ‘It’s exactly like a riddle with no answer!’ she\nthought.\n‘Humpty Dumpty saw it too,’ the White Queen went on in a low voice, more\nas if she were talking to herself. ‘He came to the door with a corkscrew in his\nhand – ’\n‘What did he want?’ said the Red Queen.\n‘He said he\nwould\ncome in,’ the White Queen went on, ‘because he was look-\ning for a hippopotamus. Now, as it happened, there wasn’t such a thing in the\nhouse, that morning.’\n‘Is there generally?’ Alice asked in an astonished tone.\n‘Well, only on Thursdays,’ said the Queen.\n‘I know what he came for,’ said Alice, ‘he wanted to punish the fish, be-\ncause – ’\nHere the White Queen began again. ‘It was\nsuch\na thunderstorm, you can’t\nthink!’ (‘She\nnever\ncould, you know,’ said the Red Queen.) ‘And part of the roof\ncame off, and ever so much thunder got in – and it went rolling round the room in","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":75},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:76","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n74\ngreat lumps – and knocking over the tables and things – till I was so frightened,\nI couldn’t remember my own name!’\nAlice thought to herself, ‘I never should\ntry\nto remember my name in the\nmiddle of an accident! Where would be the use of it?’ but she did not say this\naloud, for fear of hurting the poor Queen’s feeling.\n‘Your Majesty must excuse her,’ the Red Queen said to Alice, taking one of\nthe White Queen’s hands in her own, and gently stroking it, ‘she means well, but\nshe can’t help saying foolish things, as a general rule.’\nThe White Queen looked timidly at Alice, who felt she\nought\nto say something\nkind, but really couldn’t think of anything at the moment.\n‘She never was really well brought up,’ the Red Queen went on, ‘but it’s amaz-\ning how good-tempered she is! Pat her on the head, and see how pleased she’ll\nbe!’ But this was more than Alice had courage to do.\n‘A little kindness – and putting her hair in papers – would do wonders with\nher – ’\nThe White Queen gave a deep sigh, and laid her head on Alice’s shoulder.\n‘I\nam\nso sleepy?’ she moaned.\n‘She’s tired, poor thing!’ said the Red Queen. ‘Smooth her hair – lend her\nyour nightcap – and sing her a soothing lullaby.’\n‘I haven’t got a nightcap with me,’ said Alice, as she tried to obey the first\ndirection, ‘and I don’t know any soothing lullabies.’\n‘I must do it myself, then,’ said the Red Queen, and she began:\n‘Hush-a-by lady, in Alice’s lap!\nTill the feast’s ready, we’ve time for a nap:\nWhen the feast’s over, we’ll go to the ball –\nRed Queen, and White Queen, and Alice, and all!’\n‘And now you know the words,’ she added, as she put her head down on Alice’s\nother shoulder, ‘just sing it through to\nme\n. I’m getting sleepy, too.’ In another\nmoment both Queens were fast asleep, and snoring loud.\n‘What\nam\nI to do?’ exclaimed\nAlice, looking about in great per-\nplexity, as first one round head, and\nthen the other, rolled down from\nher shoulder, and lay like a heavy\nlump in her lap.  ‘I don’t think\nit\never\nhappened before, that any\none had to take care of two Queens\nasleep at once! No, not in all the\nHistory of England – it couldn’t,\nyou know, because there never was","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":76},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:77","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n75\nmore than one Queen at a time. Do wake up, you heavy things!’ she went on in\nan impatient tone; but there was no answer but a gentle snoring.\nThe snoring got more distinct every minute, and sounded more like a tune: at\nlast she could even make out the words, and she listened so eagerly that, when the\ntwo great heads vanished from her lap, she hardly missed them.\nShe was standing before an arched doorway over which were the words ‘Q\nUEEN\nA\nLICE\n’ in large letters, and on each side of the arch there was a bell-handle; one\nwas marked ‘V\nISITORS\n’ B\nELL\n’, and the other ‘S\nERVANTS\n’ B\nELL\n’.\n‘I’ll wait till the song’s over,’ thought Alice, ‘and then I’ll ring – the –\nwhich\nbell must I ring?’ she went on, very much puzzled by the names. ‘I’m not a visitor,\nand I’m not a servant. There\nought\nto be one marked ‘Q\nUEEN\n’, you know – ’\nJust then the door opened a little way, and a creature with a long beak put its\nhead out for a moment and said ‘No admittance till the week after next!’ and shut\nthe door again with a bang.\nAlice knocked and rang in vain for a long time, but at last, a very old Frog, who\nwas sitting under a tree, got up and hobbled slowly towards her; he was dressed\nin bright yellow, and had enormous\nboots on.\n‘What is it, now?’ the Frog said in\na deep hoarse whisper.\nAlice turned round, ready to find\nfault with anybody. ‘Where’s the ser-\nvant whose business it is to answer the\ndoor?’ she began angrily.\n‘Which door?’ said the Frog.\nAlice almost stamped with irrita-\ntion at the slow drawl in which he\nspoke. ‘\nThis\ndoor, of course!’\nThe Frog looked at the door with\nhis large dull eyes for a minute: then\nhe went nearer and rubbed it with his\nthumb, as if he were trying whether\nthe paint would come off; then he\nlooked at Alice.\n‘To answer the door?’ he said. ‘What’s it been asking of?’ He was so hoarse\nthat Alice could scarcely hear him.\n‘I don’t know what you mean,’ she said.\n‘I talks English, doesn’t I?’ the Frog went on. ‘Or are you deaf? What did it\nask you?’\n‘Nothing!’ Alice said impatiently. ‘I’ve been knocking at it!’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":77},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:78","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n76\n‘Shouldn’t do that – shouldn’t do that – ’ the Frog muttered. ‘Vexes it, you\nknow.’ Then he went up and gave the door a kick with one of his great feet. ‘You\nlet\nit\nalone,’ he panted out, as he hobbled back to his tree, ‘and it’ll let\nyou\nalone,\nyou know.’\nAt this moment the door was flung open, and a shrill voice was heard singing:\n‘To the Looking-glass world it was Alice that said,\n“I’ve a sceptre in hand, I’ve a crown on my head;\nLet the Looking-glass creatures, whatever they be,\nCome and dine with the Red Queen, the White Queen, and me.” ’\nAnd hundreds of voices joined in the chorus:\n‘Then fill up the glasses as quick as you can,\nAnd sprinkle the table with buttons and bran:\nPut cats in the coffee, and mice in the tea –\nAnd welcome Queen Alice with thirty-times-three!’\nThen followed a confused noise of cheering, and Alice thought to herself,\n‘Thirty times three makes ninety. I wonder if any one’s counting?’ In a minute\nthere was silence again, and the same shrill voice sang another verse:\n‘ “O Looking-glass creatures,” quothe Alice, “draw near!\n’Tis an honour to see me, a favour to hear:\n’Tis a privilege high to have dinner and tea\nAlong with the Red Queen, the White Queen, and me!” ’\nThen came the chorus again:\n‘Then fill up the glasses with treacle and ink,\nOr anything else that is pleasant to drink:\nMix sand with the cider, and wool with the wine –\nAnd welcome Queen Alice with ninety-times-nine!’\n‘Ninety times nine!’ Alice repeated in despair, ‘Oh, that’ll never be done! I’d\nbetter go in at once – ’ and there was a dead silence the moment she appeared.\nAlice glanced nervously along the table, as she walked up the large hall, and\nnoticed that there were about fifty guests, of all kinds: some were animals, some\nbirds, and there were even a few flowers among them. ‘I’m glad they’ve come\nwithout waiting to be asked,’ she thought, ‘I should never have known who were\nthe right people to invite!’\nThere were three chairs at the head of the table; the Red and White Queens\nhad already taken two of them, but the middle one was empty. Alice sat down in\nit, rather uncomfortable in the silence, and longing for some one to speak.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":78},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:79","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n77\nAt last the Red Queen began.\n‘You’ve missed the soup and fish,’ she\nsaid. ‘Put on the joint!’ And the wait-\ners set a leg of mutton before Alice,\nwho looked at it rather anxiously, as\nshe had never had to carve a joint be-\nfore.\n‘You look a little shy; let me in-\ntroduce you to that leg of mutton,’\nsaid the Red Queen.  ‘Alice – Mut-\nton; Mutton – Alice.’ The leg of mut-\nton got up in the dish and made a lit-\ntle bow to Alice; and Alice returned\nthe bow, not knowing whether to be\nfrightened or amused.\n‘May I give you a slice?’ she said,\ntaking up the knife and fork, and look-\ning from one Queen to the other.\n‘Certainly not,’ the Red Queen\nsaid, very decidedly, ‘it isn’t etiquette to cut any one you’ve been introduced to.\nRemove the joint!’  And the waiters carried it off, and brought a large plum-\npudding in its place.\n‘I won’t be introduced to the pudding, please,’ Alice said rather hastily, ‘or we\nshall get no dinner at all. May I give you some?’\nBut the Red Queen looked sulky, and growled ‘Pudding – Alice; Alice – Pud-\nding. Remove the pudding!’ and the waiters took it away so quickly that Alice\ncouldn’t return its bow.\nHowever, she didn’t see why the Red Queen should be the only one to give\norders, so, as an experiment, she called out ‘Waiter! Bring back the pudding!’\nand there it was again in a moment like a conjuring-trick. It was so large that she\ncouldn’t help feeling a\nlittle\nshy with it, as she had been with the mutton; however,\nshe conquered her shyness by a great effort and cut a slice and handed it to the\nRed Queen.\n‘What impertinence!’ said the Pudding. ‘I wonder how you’d like it, if I were\nto cut a slice out of\nyou\n, you creature!’\nIt spoke in a thick, suety sort of voice, and Alice hadn’t a word to say in reply:\nshe could only sit and look at it and gasp.\n‘Make a remark,’ said the Red Queen, ‘it’s ridiculous to leave all the conver-\nsation to the pudding!’\n‘Do you know, I’ve had such a quantity of poetry repeated to me to-day,’ Alice\nbegan, a little frightened at finding that, the moment she opened her lips, there","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":79},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:80","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n78\nwas dead silence, and all eyes were fixed upon her; ‘and it’s a very curious thing,\nI think – every poem was about fishes in some way. Do you know why they’re so\nfond of fishes, all about here?’\nShe spoke to the Red Queen, whose answer was a little wide of the mark. ‘As\nto fishes,’ she said, very slowly and solemnly, putting her mouth close to Alice’s\near, ‘her White Majesty knows a lovely riddle – all in poetry – all about fishes.\nShall she repeat it?’\n‘Her Red Majesty’s very kind to mention it,’ the White Queen murmured into\nAlice’s other ear, in a voice like the cooing of a pigeon. ‘It would be\nsuch\na treat!\nMay I?’\n‘Please do,’ Alice said very politely.\nThe White Queen laughed with delight, and stroked Alice’s cheek. Then she\nbegan:\n‘ “First, the fish must be caught.”\nThat is easy: a baby, I think, could have caught it.\n“Next, the fish must be bought.”\nThat is easy: a penny, I think, would have bought it.\n“Now cook me the fish!”\nThat is easy, and will not take more than a minute.\n“Let it lie in a dish!”\nThat is easy, because it already is in it.\n“Bring it here! Let me sup!”\nIt is easy to set such a dish on the table.\n“Take the dish-cover up!”\nAh,\nthat\nis so hard that I fear I’m unable!\nFor it holds it like glue –\nHolds the lid to the dish, while it lies in the middle:\nWhich is easiest to do,\nUn-dish-cover the fish, or dishcover the riddle?’\n‘Take a minute to think about it, and then guess,’ said the Red Queen. ‘Mean-\nwhile, we’ll drink your health – Queen Alice’s health!’ she screamed at the top\nof her voice, and all the guests began drinking it directly, and very queerly they\nmanaged it: some of them put their glasses upon their heads like extinguishers,\nand drank all that trickled down their faces – others upset the decanters, and drank\nthe wine as it ran off the edges of the table – and three of them (who looked like\nkangaroos) scrambled into the dish of roast mutton, and began eagerly lapping up\nthe gravy, ‘just like pigs in a trough!’ thought Alice.\n‘You ought to return thanks in a neat speech,’ the Red Queen said, frowning at\nAlice as she spoke.","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":80},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:81","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n79\n‘We must support you, you know,’ the White Queen whispered, as Alice got\nup to do it, very obediently, but a little frightened.\n‘Thank you very much,’ she whispered in reply, ‘but I can do quite well with-\nout.’\n‘That wouldn’t be at all the thing,’ the Red Queen said very decidedly: so\nAlice tried to submit to it with a good grace.\n(‘And they\ndid\npush so!’ she said afterwards, when she was telling her sister\nthe history of the feast. ‘You would have thought they wanted to squeeze me flat!’)\nIn fact it was rather difficult for her to keep in her place while she made her\nspeech: the two Queens pushed her so, one on each side, that they nearly lifted her\nup into the air: ‘I rise to return thanks – ’ Alice began; and she really\ndid\nrise as\nshe spoke, several inches; but she got hold of the edge of the table, and managed\nto pull herself down again.\n‘Take care of yourself!’ screamed the White Queen, seizing Alice’s hair with\nboth her hands. ‘Something’s going to happen!’\nAnd then (as Alice afterwards described it) all sorts of\nthings happened in a moment. The candles all grew up to\nthe ceiling, looking something like a bed of rushes with\nfireworks at the top. As to the bottles, they each took\na pair of plates, which they hastily fitted on as wings,\nand so, with forks for legs, went fluttering about in all\ndirections: ‘and very like birds they look,’ Alice thought\nto herself, as well as she could in the dreadful confusion\nthat was beginning.\nAt this moment she heard a hoarse\nlaugh at her side, and turned to see\nwhat was the matter with the White\nQueen; but, instead of the Queen,\nthere was the leg of mutton sitting\nin the chair.  ‘Here I am!’  cried\na voice from the soup tureen, and Al-\nice turned again, just in time to see\nthe Queen’s broad good-natured face\ngrinning at her for a moment over the\nedge of the tureen, before she disap-\npeared into the soup.\nThere was not a moment to be lost. Already several of the guests were lying\ndown in the dishes, and the soup ladle was walking up the table towards Alice’s\nchair, and beckoning to her impatiently to get out of its way.\n‘I can’t stand this any longer!’ she cried as she jumped up and seized the\ntable-cloth with both hands: one good pull, and plates, dishes, guests, and candles","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":81},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:82","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER IX.  QUEEN ALICE\n80\ncame crashing down together in a heap on the floor.\n‘And as for\nyou\n,’ she went on, turning fiercely upon the Red Queen, whom she\nconsidered as the cause of all the mischief – but the Queen was no longer at her\nside – she had suddenly dwindled down to the size of a little doll, and was now\non the table, merrily running round and round after her own shawl, which was\ntrailing behind her.\nAt any other time, Alice would have felt surprised at this, but she was far too\nmuch excited to be surprised at anything\nnow\n. ‘As for\nyou\n,’ she repeated, catching\nhold of the little creature in the very act of jumping over a bottle which had just\nlighted upon the table, ‘I’ll shake you into a kitten, that I will!’","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":82},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:83","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter X\nShaking\nShe took her off the table as she spoke, and shook her backwards and forwards\nwith all her might.  The Red Queen made no resistance whatever; only her face\ngrew very small, and her eyes got large and green: and still, as Alice went on\nshaking her, she kept on growing shorter – and fatter – and softer – and rounder –\nand –\n81","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":83},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:84","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter XI\nWaking\n– and it really\nwas\na kitten, after all.\n82","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":84},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:85","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"Chapter XII\nWhich Dreamed It?\n‘Your majesty shouldn’t purr so loud,’ Alice said, rubbing her eyes, and addressing\nthe kitten, respectfully, yet with some severity. ‘You woke me out of oh! such\na nice dream! And you’ve been along with me, Kitty – all through the Looking-\nglass world. Did you know it, dear?’\nIt is a very inconvenient habit of kittens (Alice had once made the remark)\nthat, whatever you say to them, they\nalways\npurr. ‘If they would only purr for\n“yes” and mew for “no,” or any rule of that sort,’ she had said, ‘so that one could\nkeep up a conversation! But how\ncan\nyou talk with a person if they always say the\nsame thing?’\nOn this occasion the kitten only\npurred: and it was impossible to guess\nwhether it meant ‘yes’ or ‘no.’\nSo Alice hunted among the chess-\nmen on the table till she had found\nthe Red Queen; then she went down\non her knees on the hearth-rug, and\nput the kitten and the Queen to\nlook at each other.  ‘Now, Kitty!’\nshe cried, clapping her hands tri-\numphantly.  ‘Confess that was what\nyou turned into!’\n(‘But it wouldn’t look at it,’ she\nsaid, when she was explaining the\nthing afterwards to her sister, ‘it turned away its head, and pretended not to see\nit: but it looked a\nlittle\nashamed of itself, so I think it\nmust\nhave been the Red\nQueen.’)\n‘Sit up a little more stiffly, dear!’ Alice cried with a merry laugh. ‘And curtsey\nwhile you’re thinking what to – what to purr. It saves time, remember!’ And\n83","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":85},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:86","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"CHAPTER XII.  WHICH DREAMED IT?\n84\nshe caught it up and gave it one little kiss, ‘just in honour of having been a Red\nQueen.’\n‘Snowdrop, my pet!’ she went on, looking over her shoulder at the White Kit-\nten, which was still patiently undergoing its toilet, ‘when\nwill\nDinah have finished\nwith your White Majesty, I wonder? That must be the reason you were so untidy\nin my dream – Dinah! do you know that you’re scrubbing a White Queen? Really,\nit’s most disrespectful of you!\n‘And what did\nDinah\nturn to, I wonder?’ she prattled on, as she settled com-\nfortably down, with one elbow in the rug, and her chin in her hand, to watch the\nkittens. ‘Tell me, Dinah, did you turn to Humpty Dumpty? I\nthink\nyou did – how-\never, you’d better not mention it to your friends just yet, for I’m not sure.\n‘By the way, Kitty, if only you’d been really with me in my dream, there was\none thing you\nwould\nhave enjoyed – I had such a quantity of poetry said to me, all\nabout fishes! To-morrow morning you shall have a real treat. All the time you’re\neating your breakfast, I’ll repeat ‘T\nHE\nW\nALRUS AND THE\nC\nARPENTER\n’ to you;\nand then you can make believe it’s oysters, dear!\n‘Now, Kitty, let’s consider who it was that dreamed it all. This is a serious\nquestion, my dear, and you should\nnot\ngo on licking your paw like that – as if\nDinah hadn’t washed you this morning! You see, Kitty, it\nmust\nhave been either\nme or the Red King. He was part of my dream, of course – but then I was part of\nhis dream, too!\nWas\nit the Red King, Kitty? You were his wife, my dear, so you\nought to know – Oh, Kitty,\ndo\nhelp to settle it! I’m sure your paw can wait!’ But\nthe provoking kitten only began on the other paw, and pretended it hadn’t heard\nthe question.\nWhich do\nyou\nthink it was?","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":86},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:87","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"A boat beneath a sunny sky,\nLingering onward dreamily\nIn an evening of July –\nChildren three that nestle near,\nEager eye and willing ear,\nPleased a simple tale to hear –\nLong has paled that sunny sky;\nEchoes fade and memories die.\nAutumn frosts have slain July.\nStill she haunts me, phantomwise,\nAlice moving under skies\nNever seen by waking eyes.\nChildren yet, the tale to hear,\nEager eye and willing ear,\nLovingly shall nestle near.\nIn a Wonderland they lie,\nDreaming as the days go by,\nDreaming as the summers die;\nEver drifting down the stream –\nLingering in the golden gleam –\nLife, what is it but a dream?","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":87},{"id":"./test/fixtures/pdf/through-the-looking-glass-book.pdf:88","title":"Through the Looking Glass and What Alice Found There","author":"Lewis Carroll","body":"T\nHE\nE\nND","filePath":"./test/fixtures/pdf/through-the-looking-glass-book.pdf","pageNumber":88},{"id":"./test/fixtures/pdf/sicp.pdf:1","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Structure and Interpretation\nof Computer Programs\nHarold Abelson and \nGerald Jay Sussman\nwith Julie Sussman, \nforeword by Alan J. Perlis\nUnofficial Texinfo Format \n2.andresraba5.2\nsecond edition","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":1},{"id":"./test/fixtures/pdf/sicp.pdf:2","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"©1996 by The Massachusetts Institute of Technology\nStructure and Interpretation of Computer Programs,\nsecond edition\nHarold Abelson and Gerald Jay Sussman\nwith Julie Sussman, foreword by Alan J. Perlis\nThis work is licensed under a Creative Commons\nAttribution-NonCommercial-ShareAlike 3.0 Unported License\n(\ncc by-nc-sa\n3.0\n). Based on a work at\nmitpress.mit.edu\n.\nThe\nmit\nPress\nCambridge, Massachusetts\nLondon, England\nMcGraw-Hill Book Company\nNew York, St. Louis, San Francisco,\nMontreal, Toronto\nUnofficial Texinfo Format\n2.andresraba5.2\n(February 10, 2014),\nbased on\n2.neilvandyke4\n(January 10, 2007).\n日本語：\nby\nminghai\nbased on 2.andresraba5.2 (March 31, 2014).","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":2},{"id":"./test/fixtures/pdf/sicp.pdf:3","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"目次\n非公式\nTexinfo\nフォーマット\nix\n非公式日本語版\nxi\n献辞\nxiii\n前書き\nxiv\n第二版 序文\nxix\n第一版 序文\nxxi\n謝辞\nxxiv\n1\n手続を用いた抽象化の構築\n1\n1.1\nプログラミングの要素\n. . . . . . . . . . . . . . . . . . . .\n4\n1.1.1\n式\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\n1.1.2\n名前付けと環境\n. . . . . . . . . . . . . . . . . . . .\n8\n1.1.3\n組み合わせの評価\n. . . . . . . . . . . . . . . . . .\n9\n1.1.4\n複合手続\n. . . . . . . . . . . . . . . . . . . . . . .\n12\n1.1.5\n手続適用の置換モデル\n. . . . . . . . . . . . . . . .\n14\n1.1.6\n条件式と述語\n. . . . . . . . . . . . . . . . . . . . .\n17\n1.1.7\n例\n:\nニュートン法による平方根\n. . . . . . . . . . .\n21\n1.1.8\nブラックボックス抽象化としての手続\n. . . . . . .\n26\niii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":3},{"id":"./test/fixtures/pdf/sicp.pdf:4","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.2\n手続とそれが生成するプロセス\n. . . . . . . . . . . . . . .\n31\n1.2.1\n線形再帰と反復\n. . . . . . . . . . . . . . . . . . . .\n32\n1.2.2\n木再帰\n. . . . . . . . . . . . . . . . . . . . . . . . .\n37\n1.2.3\n増加のオーダー\n. . . . . . . . . . . . . . . . . . . .\n42\n1.2.4\n指数計算\n. . . . . . . . . . . . . . . . . . . . . . .\n44\n1.2.5\n最大公約数\n. . . . . . . . . . . . . . . . . . . . . .\n48\n1.2.6\n例\n:\n素数判定\n. . . . . . . . . . . . . . . . . . . . .\n50\n1.3\n高階手続による抽象の形式化\n. . . . . . . . . . . . . . . .\n57\n1.3.1\n引数としての手続\n. . . . . . . . . . . . . . . . . .\n58\n1.3.2\nlambda\nを用いた手続の構築\n. . . . . . . . . . . . .\n64\n1.3.3\n汎用手法としての手続\n. . . . . . . . . . . . . . . .\n69\n1.3.4\n返り値としての手続\n. . . . . . . . . . . . . . . . .\n74\n2\nデータを用いた抽象化の構築\n82\n2.1\nデータ抽象化のイントロダクション\n. . . . . . . . . . . .\n86\n2.1.1\n例\n:\n分数のための数値演算命令\n. . . . . . . . . . .\n86\n2.1.2\n抽象化バリア\n. . . . . . . . . . . . . . . . . . . . .\n91\n2.1.3\nデータにより何が意味されるのか\n. . . . . . . . .\n94\n2.1.4\n延長課題\n:\n区間演算\n. . . . . . . . . . . . . . . . .\n97\n2.2\n階層データと閉包性\n. . . . . . . . . . . . . . . . . . . . .\n101\n2.2.1\n列の表現\n. . . . . . . . . . . . . . . . . . . . . . .\n103\n2.2.2\n階層構造\n. . . . . . . . . . . . . . . . . . . . . . .\n113\n2.2.3\n慣習的インターフェイスとしての列\n. . . . . . . .\n119\n2.2.4\n例\n:\nピクチャー言語\n. . . . . . . . . . . . . . . . .\n133\n2.3\n記号データ\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n149\n2.3.1\nクォート\n. . . . . . . . . . . . . . . . . . . . . . .\n150\n2.3.2\n例\n:\n記号微分\n. . . . . . . . . . . . . . . . . . . . .\n153\n2.3.3\n例\n:\n集合を表現する\n. . . . . . . . . . . . . . . . .\n159\n2.3.4\n例\n:\nハフマン符号化木\n. . . . . . . . . . . . . . . .\n170\n2.4\n抽象データの多重表現\n. . . . . . . . . . . . . . . . . . . .\n178\n2.4.1\n複素数のための表現\n. . . . . . . . . . . . . . . . .\n181\n2.4.2\nタグ付きデータ\n. . . . . . . . . . . . . . . . . . . .\n184\n2.4.3\nデータ適従プログラミングと付加性\n. . . . . . . .\n188\niv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":4},{"id":"./test/fixtures/pdf/sicp.pdf:5","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2.5\nジェネリック命令を持つシステム\n. . . . . . . . . . . . .\n198\n2.5.1\nジェネリックな数値演算命令\n. . . . . . . . . . . .\n199\n2.5.2\n異なる型のデータを組み合わす\n. . . . . . . . . . .\n205\n2.5.3\n例\n:\n記号代数\n. . . . . . . . . . . . . . . . . . . . .\n214\n3\nモジュール方式、オブジェクト、状態\n229\n3.1\n代入と局所状態\n. . . . . . . . . . . . . . . . . . . . . . . .\n230\n3.1.1\n局所状態変数\n. . . . . . . . . . . . . . . . . . . . .\n231\n3.1.2\n代入導入の利点\n. . . . . . . . . . . . . . . . . . . .\n238\n3.1.3\n代入導入のコスト\n. . . . . . . . . . . . . . . . . .\n242\n3.2\n評価の環境モデル\n. . . . . . . . . . . . . . . . . . . . . .\n249\n3.2.1\n評価のルール\n. . . . . . . . . . . . . . . . . . . . .\n251\n3.2.2\n単純な手続の適用\n. . . . . . . . . . . . . . . . . .\n254\n3.2.3\n局所状態のレポジトリとしてのフレーム\n. . . . .\n257\n3.2.4\n内部定義\n. . . . . . . . . . . . . . . . . . . . . . .\n262\n3.3\nミュータブルデータによるモデリング\n. . . . . . . . . . .\n265\n3.3.1\nミュータブルなリスト構造\n. . . . . . . . . . . . .\n266\n3.3.2\nキューの表現\n. . . . . . . . . . . . . . . . . . . . .\n277\n3.3.3\nテーブルの表現\n. . . . . . . . . . . . . . . . . . . .\n283\n3.3.4\nデジタル回路のシミュレータ\n. . . . . . . . . . . .\n291\n3.3.5\n制約伝播\n. . . . . . . . . . . . . . . . . . . . . . .\n304\n3.4\n並行性\n:\n時間が本質\n. . . . . . . . . . . . . . . . . . . . . .\n316\n3.4.1\n並行システム内の時間の性質\n. . . . . . . . . . . .\n318\n3.4.2\n並行性制御のための仕組み\n. . . . . . . . . . . . .\n323\n3.5\nストリーム\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n338\n3.5.1\nストリームとは遅延化リスト\n. . . . . . . . . . . .\n339\n3.5.2\n無限ストリーム\n. . . . . . . . . . . . . . . . . . . .\n348\n3.5.3\nストリームパラダイムの利用\n. . . . . . . . . . . .\n357\n3.5.4\nストリームと遅延評価\n. . . . . . . . . . . . . . . .\n371\n3.5.5\n関数型プログラムのモジュール化とオブジェクト\nのモジュール化\n. . . . . . . . . . . . . . . . . . . .\n378\nv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":5},{"id":"./test/fixtures/pdf/sicp.pdf:6","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4\nメタ言語抽象化\n385\n4.1\nメタ循環評価機\n. . . . . . . . . . . . . . . . . . . . . . . .\n388\n4.1.1\n評価機の核\n. . . . . . . . . . . . . . . . . . . . . .\n390\n4.1.2\n式の表現\n. . . . . . . . . . . . . . . . . . . . . . .\n395\n4.1.3\n評価機のデータ構造\n. . . . . . . . . . . . . . . . .\n403\n4.1.4\n評価機をプログラムとして実行する\n. . . . . . . .\n408\n4.1.5\nプログラムとしてのデータ\n. . . . . . . . . . . . .\n411\n4.1.6\n内部定義\n. . . . . . . . . . . . . . . . . . . . . . .\n415\n4.1.7\n構文分析を実行から分離する\n. . . . . . . . . . . .\n421\n4.2  Scheme\n上でのバリエーション\n—\n遅延評価\n. . . . . . . .\n426\n4.2.1\n正規順と適用順\n. . . . . . . . . . . . . . . . . . . .\n427\n4.2.2\n遅延評価を持つインタプリタ\n. . . . . . . . . . . .\n429\n4.2.3\n遅延化リストとしてのストリーム\n. . . . . . . . .\n438\n4.3  Scheme\n上でのバリエーション\n—\n非決定性演算\n. . . . .\n440\n4.3.1  amb\nと検索\n. . . . . . . . . . . . . . . . . . . . . .\n443\n4.3.2\n非決定性プログラムの例\n. . . . . . . . . . . . . .\n447\n4.3.3\nAmb\n評価機の実装\n. . . . . . . . . . . . . . . . . .\n456\n4.4\n論理プログラミング\n. . . . . . . . . . . . . . . . . . . . .\n469\n4.4.1\n演繹的情報検索\n. . . . . . . . . . . . . . . . . . . .\n473\n4.4.2\nクエリシステムの働き方\n. . . . . . . . . . . . . .\n486\n4.4.3\n論理プログラミングは記号論理学なのか\n?\n. . . . .\n496\n4.4.4\nクエリシステムの実装\n. . . . . . . . . . . . . . . .\n502\n4.4.4.1\nドライバループとインスタンス化\n. . . .\n502\n4.4.4.2\n評価機\n. . . . . . . . . . . . . . . . . . .\n504\n4.4.4.3\nパターンマッチングによりアサーション\nを見つける\n. . . . . . . . . . . . . . . . .\n508\n4.4.4.4\nルールとユニフィケーション\n. . . . . . .\n511\n4.4.4.5\nデータベースの保守\n. . . . . . . . . . . .\n515\n4.4.4.6\nストリーム命令\n. . . . . . . . . . . . . .\n519\n4.4.4.7\nクエリ構文手続\n. . . . . . . . . . . . . .\n520\n4.4.4.8\nフレームと束縛\n. . . . . . . . . . . . . .\n523\nvi","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":6},{"id":"./test/fixtures/pdf/sicp.pdf:7","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5\nレジスタマシンによる演算\n528\n5.1\nレジスタマシンの設計\n. . . . . . . . . . . . . . . . . . . .\n530\n5.1.1\nレジスタマシンを記述するための言語\n. . . . . . .\n533\n5.1.2\n機械設計における抽象化\n. . . . . . . . . . . . . .\n537\n5.1.3\nサブルーチン\n. . . . . . . . . . . . . . . . . . . . .\n540\n5.1.4\n再帰実装にスタックを使用する\n. . . . . . . . . . .\n544\n5.1.5\n命令の要約\n. . . . . . . . . . . . . . . . . . . . . .\n551\n5.2\nレジスタマシンシミュレータ\n. . . . . . . . . . . . . . . .\n552\n5.2.1\nマシンモデル\n. . . . . . . . . . . . . . . . . . . . .\n554\n5.2.2\nアセンブラ\n. . . . . . . . . . . . . . . . . . . . . .\n559\n5.2.3\n各命令に対する実行手続の生成\n. . . . . . . . . . .\n563\n5.2.4\n機械のパフォーマンスの監視\n. . . . . . . . . . . .\n571\n5.3\n記憶域の割当とガベージコレクション\n. . . . . . . . . . .\n574\n5.3.1\nベクタとしてのメモリ\n. . . . . . . . . . . . . . . .\n575\n5.3.2\n無限のメモリの幻想を維持する\n. . . . . . . . . . .\n581\n5.4\n明示的制御評価機\n. . . . . . . . . . . . . . . . . . . . . .\n589\n5.4.1\n明示制御評価機の核\n. . . . . . . . . . . . . . . . .\n591\n5.4.2\n列の評価と末尾再帰\n. . . . . . . . . . . . . . . . .\n598\n5.4.3\n条件文、代入、定義\n. . . . . . . . . . . . . . . . .\n601\n5.4.4\n評価機を実行する\n. . . . . . . . . . . . . . . . . .\n604\n5.5\nコンパイル\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n610\n5.5.1\nコンパイラの構造\n. . . . . . . . . . . . . . . . . .\n614\n5.5.2\n式のコンパイル\n. . . . . . . . . . . . . . . . . . . .\n619\n5.5.3\n組み合わせのコンパイル\n. . . . . . . . . . . . . .\n627\n5.5.4\n命令列のコンパイル\n. . . . . . . . . . . . . . . . .\n635\n5.5.5\nコンパイルされたコードの例\n. . . . . . . . . . . .\n638\n5.5.6\nレキシカルアドレッシング\n. . . . . . . . . . . . .\n650\n5.5.7\nコンパイル済みコードと評価機の連結\n. . . . . . .\n655\n参考文献\n664\n課題リスト\n672\n図一覧\n674\nvii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":7},{"id":"./test/fixtures/pdf/sicp.pdf:8","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"索引\n675\n奥付\n685\nviii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":8},{"id":"./test/fixtures/pdf/sicp.pdf:9","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"非公式\nTexinfo\nフォーマット\nこれは\nsicp\nの第二版非公式\nTexinfo\n版です。\nあなたは恐らくこれを\nEmacs\nの\nInfo\nモードの様なハイパーテキストブラ\nウザで読んでいることでしょう。他にも\nT\nE\nX\nで組版した物を画面や印刷して\n読んでいるかもしれませんがそれはバカバカしい上に高くつきます。\n公式に無料で公開された\nhtml\n-and-\ngif\n版を\nLytha Ayth\nが最初に私的に、\n2001\n年\n4\n月の長い\nEmacs Lovefest Weekend\nの間に非公式\nTexinfo\n版\n(\nutf\n)\nバ\nージョン\n1\nへと変換しました。\nutf\nは\nhtml\n版よりも検索がより簡単です。また寄付された古い\n386\nの様\nな質素な計算機上で行う人々にとってよりアクセスが容易です。\n386\nは理論的\nには\nLinux\n、\nEmacs\n、\nScheme\nインタプリタを同時に実行できます。しかし多く\nの\n386\nは恐らく\nNetscape\nと必要な\nX Window System\nを事前に芽の出かけた\n資金不足の若いハッカーに\nthrashing\n(\nスラッシング\n)\nの概念を教えることなしに\n動かすことはできないでしょう。\nUTF\nはまた圧縮無しでも\n1.44\nmb\nのフロッピ\nーディスケットに収まります。これはインターネットや\nLAN\nへの接続環境の\n無い\nPC\nにインストールする場合に役立つでしょう。\nTexinfo\nへの変換は可能な範囲での直接的な翻字でした。\nT\nE\nX-to-\nhtml\n変\n換の様にある程度の破れが含まれること無しにはできませんでした。非公式\nTexInfo\n形式においては図が「失なわれた技術」であるアスキーアートによる\n下手糞な\n”\n復活\n”\nを被りました。また多量の上付き文字と下付き文字のいくつ\nかの変換の間に不明瞭さによる変換の失敗が含まれてしまった可能性が大いに\nあります。読者への課題として残されたと予測します。しかし、最低でも\n“\n以\n上\n”\nの記号を\n<u>&gt;</u>\nと符号化することで我等の勇敢な宇宙飛行士を危険\nに晒すようなことはしませんでした。\nもしあなたが\nsicp.texi\nを変更しエラーを訂正したり、アスキーアート\nを向上させたなら\n@set utfversion utfversion\nの行を更新し、あなたの修\nix","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":9},{"id":"./test/fixtures/pdf/sicp.pdf:10","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"正を反映して下さい。例えば、もしあなたが\nLytha\nのバージョン\n1\nで開始し、\nあなたの名前が\nBob\nなら、改訂版は\n1.bob1\n,\n1.bob2\n, ...,\n1.bob\nn\nです。また\nutfversiondate\nも更新して下さい。もしあなたが自分の改訂版を\nWeb\n上で\n配布したいのなら文字列\n“sicp.texi”\nをファイルや\nWeb\nページのどこかに埋め\n込んでおけば人々にとって\nWeb\n検索エンジンから探すことが簡単になるでし\nょう。\n非公式\nTexinfo\n形式は寛大にも自由の下に配布された\nhtml\n版の魂を引き\n継いでいると信じられています。しかし、いつ誰かの法律家の大艦隊が良心に\n基づく小さな事に対して非常に腹を立て何かを行わなければならなくなるかも\nしれません。ですのであなたのフルネームを使ったり、あなたのアカウントや\nマシン名を含む\nInfo,\ndvi\n, PostScript,\npdf\n形式を配布する前に良く良く考えて\n下さい。\nPeath, Lytha Ayth\n付録\n:\nAbelson\nと\nSussman\nによる\nsicp\nのビデオレクチャーもご覧下さい。\nmit csail\n,\nmit ocw\n.\n付録\n2:\n上記は\n2001\n年の元の\nutf\nの紹介です。\n10\n年後、\nutf\nは一変しました。\n数学上の記号と式は適切に組版され、図はベクターグラフィックにより描かれ\nています。元のテキスト形式とアスキーアートの図は今でも\nTexinfo\nのソース\nに残っていますが、\nInfo\n形式でコンパイルした場合のみ表示されます。電子書\n籍リーダーとタブレットの夜明けに画面上で\npdf\nを読むことは正式に、最早バ\nカバカしいことでは無くなりました。楽しんで下さい！\nA.R, May, 2011\nx","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":10},{"id":"./test/fixtures/pdf/sicp.pdf:11","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"非公式日本語版\nSICP\nはかつて第一版、第二版共に日本にて公式に翻訳が商業出版されてい\nました。第二版を出版していたピアソン桐原が\n2013\n年\n8\n月に\nピアソングルー\nプから撤退し技術書の取扱を終了したため\n、日本語で\nSICP\nを読む機会は失わ\nれました。このことがこの翻訳を行うことの契機となりました。\n実際にはその後、\n2014\n年\n1\n月付近に、寛大にも第二版の訳者、和田英一先\n生がオンライン上にて\nSICP\nの訳書、\n「計算機プログラムの構造と解釈」\n全文\nを公開して下さいました。この時点でこの非公式日本語版の価値は随分と小さ\nくなりました。\nしかし、その時、既に\n3\n章まで翻訳していたこと、そして非公式\nTexInfo\n版が\n2013\n年\n11\n月に大改訂を行い、当初の日本語には正式に対応していない\ntexi2pdf\nから変更を行い、\nXeLaTeX\nを採用したために、日本語でも美しい組版\nができる可能性が出てきたことが、この原稿を廃棄することを押し止めました。\nSICP\nのライセンスについてはインターネットアーカイブにて調べてみま\nした。\n2001\n年\n1\n月に\nMIT\nが\nSICP\nを寛大にもオンラインで無料で読むことが\nできるように公開された時にはライセンスが指定されていませんでした。\n2008\n年\n4\n月に\nMIT\nは\nSICP\nのライセンスを\nCC BY-NC\nと指定しました。\nその後ライセンスは\n2011\n年\n10\n月に一旦\nCC BY-SA\nに変更されます。そして\n2\n年後の\n2013\n年\n9\n月に再び\nCC BY-NC\nへと戻されました。この事実が\nSICP\n原文のライセンスの解釈を難しくしています。ライセンスの変更はオーナーの\n自由ですが、ライセンシーはコンテンツ取得時のライセンスを尊重すれば良い\nからです。\n最初に非公式\nTexInfo\n版を作成した\nLytha Ayth\nはライセンス指定の無い\nSICP\n公開を\nWeb\n文化に基づくものだと理解しました。次に\nLaTeX\nの組版を\n開発した\nAndres Raba\nは\nCC BY-SA\nに基き正式な許諾の下、\nPDF\n版を作成し\nました。私の翻訳は\nPDF\n版のライセンスである\nCC BY-SA\nに従うことが求め\nxi","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":11},{"id":"./test/fixtures/pdf/sicp.pdf:12","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"られます。しかし、現在の\nMIT\nが非商業を求めていることを鑑みて、\nRaba\n氏\nに許可を頂いた上で非商業制約を追加した\ncc by-nc-sa\n3.0\nにてリリースする\nことにしました。\nCC BY-NC\n、及び\nBY-SA\nは共に翻訳の許可を明記しています。従ってこの\n翻訳には\nLytha\nが心配したような法的問題は起こらないと信じています。しか\nし同時に、法的問題は常に一方的に起こされることがあることもまた現実です。\n従って読者の皆様には常にネットワーク上のデータは\n(\nそしてプログラムも\n!)\n消えてなくなってしまうシャボン玉であることを忘れずに御用心願います。\nTeX\n、\nLaTeX\n環境の日本語対応を進めて下さった全ての関係者の皆様に\n感謝します。特に最新の情報を常に更新し続けて下さっている\nTeX Wiki\nの奥\n村 晴彦氏、\nW32TeX\nを自動でインストールし更新可能な\nTeX\nインストーラ\n作\n者の阿部 紀行氏、\nXeLaTeX\n向け日本語パッケージ\n“ZXjatype”\nを開発して下\nさった八登 崇之氏に感謝致します。\n海外では\nSICP\nの新しい形の開発が非常に盛んです。\nPDF\nはもちろん、\nepub\nやインタラクティブ版、\nKindle\n版\n(mobi\n形式\n)\n、\nClojure\nや\nJavaScript\nによる\nSICP\n等が公開されています。この翻訳は\nCC BY-NC-SA\nですので非商業であ\nればそのような派生や翻案に利用することが可能です。日本でも\nSICP\nの世界\nが広がっていくことを期待しています。\nxii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":12},{"id":"./test/fixtures/pdf/sicp.pdf:13","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"献辞\nこの本を、尊敬と賛美を込めて、コンピュータの中に住む妖精に捧げます。\n“\nコンピュータサイエンスに関わる私達にとってコンピュータを使\n用することを楽しむことはとても大事だと私は考えます。コンピ\nュータサイエンスが始まった時、それはとても多くの楽しみに溢\nれていました。ご存知のとおり、お金を払うお客様達は時折酷く\n騙されました。そして暫くして私達は彼らの不満を真面目に受け\n取り始めてしまいました。私達は考え始めてしまったのです。成\n功裏に、障害の無い完全なコンピュータの使用法について私達に\n責任があるのではないかと。私はそうは思いません。私は、私達が\nコンピュータサイエンスを伸展し、新しい方向に向かわせ、そし\nて仲間達と共に楽しむことに責任があると考えます。私はコンピ\nュータサイエンスの現場が楽しむことの感覚を失わないことを望\nみます。さらに、我々が伝道師になることは望みません。自分が聖\n書のセールスマンだとは思わないで下さい。世界には既にそのよ\nうな人が溢れています。あなたが他の人々が学ぶコンピュータ利\n用法について何を知っているでしょう。コンピュータ利用に成功\nする鍵があなたの手の中にのみあるとは決っして思わないで下さ\nい。私が思うに、そして期待することは、あなたの手の中にあるも\nのは知性です。それはあなたが初めて計算機に出会った時よりも\nより多くのことを知ることができる能力であり、それはより多く\nのことを生むことができるのです。\n”\n—Alan J. Perlis (April 1, 1922 – February 7, 1990)\nxiii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":13},{"id":"./test/fixtures/pdf/sicp.pdf:14","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"前書き\n教育者、将軍、栄養士、精神分析医、そして両親はプログラムします。軍隊、\n学生、そしていくつかの社会はプログラムされます。大きな問題に対する解決\nは一連のプログラムを利用します。それらのほとんどは途中でひょっこり表れ\nます。これらのプログラムは手近な問題に特化されて現れる成果に溢れていま\nす。プログラミングを独立した知的な活動として理解するためにはあなたはコ\nンピュータプログラミングに向かわねばなりません。コンピュータプログラム\nを読み、書かねばなりません。それも数多くです。そのプログラムが何につい\nてであるか、またはどのような適用を担うのかは多くは関係ありません。重要\nなことはそれらがどのように実行され、どれだけ滑らかに他のプログラムに対\nしてより大きなプログラムの作成のために適合するのかです。プログラマは部\n分の完全性と集合の妥当性の両方を追求せねばなりません。この本では\n“\nプロ\nグラム\n”\nの使用はデジタル計算機上にて実行されるための\nLisp\nの方言で書かれ\nたプログラムの創造、実行、それに学習に焦点を当てています。\nLisp\nの使用は\nプログラム記述の表記法のみを制約、制限し、私達が何をプログラムするかに\nついては影響を与えません。\nこの本の主題は\n3\nつの事象に焦点を当てます。人の心、コンピュータプロ\nグラムの集合、そしてコンピュータです。全てのコンピュータプログラムは人\nの心の中で生まれる現実の、または精神的な過程のモデルです。これらの過程\nは人の経験と思考から浮かび上がり、数はとても多く、詳細は入り組んで、い\nつでも部分的にしか理解されません。それらはコンピュータプログラムにより\n稀にしか永遠の充足としてモデル化されることはありません。従って、例え私\n達のプログラムが注意深く手作りされた別個の記号の集合だとしても、連動す\nる機能の寄せ集めだとしても、それらは絶えず発展します。私達のモデルの知\n覚がより深まるにつれ、増えるにつれ、一般化されるにつれ、モデルが究極的\nに準安定な位置に逹っするまで変更を行い、その中には依然として私達が格闘\nxiv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":14},{"id":"./test/fixtures/pdf/sicp.pdf:15","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"するモデルが存在します。コンピュータプログラミングに関連する歓喜の源は\nプログラムとして表現された仕組みの心の中とコンピュータ上で絶え間無く続\nく発展であり、それにより生まれる知力の爆発です。もし技巧が私達の夢を解\n釈するならば、コンピュータはプログラムとして現わされるそれらを実行する\nのです！\nその力全てに対して、コンピュータは厳しい親方です。そのプログラムは\n正しくなければなりません。私達が伝えたいと望む事柄は委細全て正確に伝え\nられねばなりません。全ての他の象徴的な活動と同じく、私達は議論を通して\nプログラムの心理を確信するようになります。\nLisp\nそれ自身に意味論を割り\n当てることも可能です。\n(\nところでこれはまた別のモデルです\n)\n。そしてもしプ\nログラムの機能を指定できるのなら、例えば述語論理においてなら、論理の証\n明方法が容認可能な正確性の議論に使用できます。残念なことにプログラムが\n巨大で複雑になるにつれ、そしてほとんど常にそうなるのですが、仕様の妥当\n性、一貫性、正確さそれら自身が疑わしくなります。そのため完全に形式化さ\nれた正確さの議論は巨大なプログラムには伴いません。巨大プログラムは小さ\nな物から成長するため正確さに確信を持てる標準的なプログラム構造の武器庫\nを開発することは重要です。私達はこれを\nidiom(\nイディオム\n)\nと呼びます。そ\nしてそれらを組み合わせて価値が検証された構成技術を用いてより大きな構造\nにすることを学びます。これらの技術はこの本の中で長々と扱われます。そし\nてそれらを理解することはプログラミングと呼ばれるプロメテウスの進取性\n(Promethean enterprise)\nに参加するのに絶対に必要なことです。他の何事でも\nなく、強力な構成技術を暴き熟達することは巨大で重要なプログラムを作成す\nる能力を加速します。反対に、巨大なプログラムを書くことはとても苦労が多\nいため、私達は多大な機能や詳細を巨大プログラムに合うように減らす新しい\n手法を開発することを促されています。\nプログラムとは異なり、コンピュータは物理法則に従わなければなりませ\nん。もしそれらを迅速に動かしたいのならば\n—\n状態変更当たり\n2\n、\n3\nナノ秒で\n—\nコンピュータは電子を極小の距離で転送せねばなりません\n(\n高々\n1\n1\n2\nフィー\nト\n)\n。巨大な数の端子により生じる熱は空間に集中しますがこれは取り除かね\nばなりません。精緻な工学の技芸が機能の多重度と端子の密度の間のバランス\nを取るために開発されました。任意のイベントにおいて、ハードウェアは常に\n私達がプログラムを行うのに気にするよりもよりプリミティブなレベルで動作\nします。私達の\nLisp\nプログラムを\n“\n機械の\n”\nプログラムに変換する処理はそれ\n自体が私達がプログラムする抽象モデルです。それらの学習と作成はとても多\nくの見識をプログラミングの自由裁量なモデルに関連する組織的なプログラム\nに対して与えます。もちろんコンピュータそれ自身もそのようにモデル化可能\nxv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":15},{"id":"./test/fixtures/pdf/sicp.pdf:16","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"です。そのことを考えてみましょう。最小の物理スイッチング要素の振舞は量\n子力学でモデル化され、微分方程式により記述され、その詳細な振舞は近似値\nの数値演算により獲得され、それはコンピュータプログラムにより表現され、\nそれはコンピュータ上で実行され、それは組み立てられ\n...!\n3\nつの焦点を別々に判別することは戦術上の利便性の問題でしかありませ\nん。例え良く言われるように全てが頭の中にあるとしても、この論理的分割は\nこれらの焦点の間の記号的通信量の加速を引き起します。焦点の豊かさ、活力、\n潜在力は人間の経験の中で人生自体の発展により増加します。最良時には焦点\nの間の関係は準安定になります。コンピュータは絶対に十分に大きく、速くは\nなりません。ハードウェア技術の全ての飛躍的進歩がより大規模なプログラミ\nング計画、新しい組織化原理、抽象モデルの向上へと導きます。読者の全員が\n自身に対し繰り返し\n“\nどの終点に向かって\n?\nどの終端に向かって\n?”\nと問わねば\nなりません。しかしあまり問い過ぎてもいけません。ほろ苦い哲学の便秘のた\nめにプログラミングの楽しさを逸っしてしまいます。\n私達が書くプログラムの間で、いくつか\n(\nしかし絶対に十分ではない\n)\nは厳\n格な数学上の関数、例えばソートや数列の最大値を見つける、素数性判定、平\n方根を求める等が実行されます。私達はそのようなプログラムをアルゴリズム\nと呼びます。多数の物がそれらの最適な振舞を、特に\n2\nつの重要なパラメタで\nある実行時間とデータストレージの必要量に関して知られています。プログラ\nマは良いアルゴリズムとイディオムを獲得しなければなりません。例えいくつ\nかのプログラムが厳格な仕様に反しても、それらのパフォーマンスに関して見\n積り、常に改善に努めることはプログラマの責務です。\nLisp\nは\n“\n生存者\n”\nであり、約四半世紀の間利用されてきました。活発なプ\nログラミング言語の中で\nFortran\nのみがより長い人生を経ています。両者の言\n語はアプリケーションの重要な領域のプログラミング上の必要性に対処してき\nました。\nFortran\nは科学と工学の演算に対して、\nLisp\nは人口知能に対してです。\nこれらの\n2\nつの領域は重要で有り続けており、それらのプログラマはこれら\n2\nつの言語に専念しているため、\nLisp\nと\nFortran\nは少なくとももう四半期は活発\nに使われ続けることでしょう。\nLisp\nは変化します。このテキストで使用される\nScheme\n方言はオリジナル\nの\nLisp\nから発展しいくつかの重要な手法に関して異なっています。違いには\n変数束縛に対する静的スコーピングや関数の値として関数の生成を許可して\nいる点等が含まれます。その意味構造において\nScheme\nは初期の\nLisp\nと同等\nに\nAlgol 60\nに近い物です。\nAlgol 60\nは再び現役となることはないでしょうが、\nScheme\nと\nPascal\nの遺伝子に受け継がれています。これらの\n2\nつの言語の周り\nに集った言語よりも、もう\n2\nつの異なる文化の流通貨幣としての\n2\nつの言語\nxvi","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":16},{"id":"./test/fixtures/pdf/sicp.pdf:17","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を見つけることのほうが難しいでしょう。\nPascal\nはピラミッドを建築するため\nの物です\n—\n印象的で、息を飲むような、軍隊が重いブロックを所定の位置に\n押すことで建築された静的な構造物です。\nLisp\nは有機体を構築するための物で\nす\n—\n印象的で、息を飲むような、小分隊が不安定で無数のより単純な有機体\nを所定の位置に嵌め込むことで構築された動的な構築物です。使用された体系\n化の原則は両者の場合で同じです。ただし並外れて重要な違いが\n1\nつありま\nす。個々の\nLisp\nプログラマに委ねられた任意のエクスポート可能な機能の数\nは\nPascal\nの進取性の中に見つかるそれらよりも桁違いに多いのです。\nLisp\nプ\nログラムは機能のライブラリを膨らませます。その機能の実用性はそれらを生\n成したアプリケーションを越えます。\nLisp\n生来のデータ構造であるリストがそ\nのような実用性の成長の大きな原因です。簡単な構造と自然なリストの適用可\n能性が驚くべき程に非特異的に機能に反映されています。\nPascal\nでは宣言可能\nなデータ構造の過剰さがカジュアルな連携を抑止し、ペナルティを科す機能の\n中に特殊化することを促しています。\n1\nつのデータ構造の上で操作する\n100\nの\n機能を持つほうが\n10\nのデータ構造の上で操作する\n10\nの機能を持つよりも優れ\nています。結果としてピラミッドは\n1000\n年の間変わらぬままでいなければな\nりません。有機体は発展するか滅びます。\nこの違いを説明するためにはこの本の中にある教材と課題の扱いを任意の\n初級課程の\nPascal\nを用いるテキストのそれと比べてみて下さい。\nmit\nだけが消\n費できる、そこで見つかる血統書付きの良馬のためのものという幻想の下で苦\n悩しないで下さい。学生が誰であるかとかどこで利用されるかが問題ではあり\nません。まさに、\nLisp\nプログラミングに対して真剣な本はどんな物であるべき\nかが問題です。\nこれはプログラミングに関するテキストであることに注意して下さい。人\n口知能の仕事のための予習に使われる他の多くの\nLisp\nの本とは違います。結\n局、ソフトウェア工学と人口知能の重大なプログラミングの課題は研究がより\n大きくなるにつれシステムとして融合する傾向にあります。このことがなぜ\nそのような\nLisp\nへの興味が人工知能の外側で大きくなっているのかを説明し\nます。\n誰かがそのゴールから予測したように、人口知能研究は多くの明確なプロ\nグラミング上の問題を生成しました。他のプログラミング文化ではこの相次ぐ\n問題は新しい言語を生みます。実際にどんなとても大きなプログラミングタス\nクにおいても効果的な体系化原理はタスクモジュール内の情報量を言語の発明\nを通してコントロールし、分離することです。これらの言語は私達、人間が最\nも良く操作を行うシステムの境界へと辿り着くに従いプリミティブではなくな\nっていく傾向にあります。結果として、そのようなシステムは何度も複製され\nxvii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":17},{"id":"./test/fixtures/pdf/sicp.pdf:18","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"た複雑な言語処理機能を含みます。\nLisp\nはとてもシンプルな文法と意味論を持\nち、パースが初歩的なタスクとして扱えます。従ってパースの技術は\nLisp\nプロ\nグラムにおいてはほとんどルール無用の役割を演じます。そして言語処理機の\n構築は巨大な\nLisp\nシステムの変化と成長の程度に対しほとんど障害になりま\nせん。最後に、全ての\nLisp\nプログラマにより負われている義務と自由に対して\n責任を持つものこそがこのとても単純な文法と意味論です。数行のサイズを越\nえる\nLisp\nプログラムなら自由裁量による関数で満たすことなく書くことはで\nきません。開発し、合わせる。合わせて、また開発する！括弧の入れ子の中に\n自身の考えを記述する\nLisp\nプログラマに乾杯。\nAlan J. Perlis\nNew Haven, Connecticut\nxviii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":18},{"id":"./test/fixtures/pdf/sicp.pdf:19","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"第二版 序文\nソフトウェアが他の何物にも似ていないと言うことはできるでし\nょうか。それが捨てられるべき物だと。つまり、常にシャボン玉だ\nと見なすことだと。\n—Alan J. Perlis\nこの本の中の教材は\n1980\n年から\nmit\nの入門者レベルの計算機科学の科目の中\n心となる物です。私達はこの教材を\n4\n年間、最初の版が出版された時点で教え\nてきました。そしてこの第二版が出現するまでにさらに\n12\n年が経過しました。\n私達の成果が広く受け入れられ、他のテキストに取り込まれていることを喜ば\nしく思っています。私達の生徒がこの本の考えとプログラムを学び新しい計算\n機システムと言語の核としてそれらを組み込んでいるのを見てきました。古代\nのタルムードの多義語の文字認識では、私達の生徒が開発者になってくれまし\nた。そのような能力有る学生と熟練した開発者を得たことはとても幸運なこと\nでした。\nこの版を準備するにあたって、私達自身の教育上の経験と\nmit\nや他の同僚\n達からのコメントにより提案された幾百もの説明を統合しました。この本の中\nの主なプログラミングシステムの多くを包括的数値演算システム、インタプリ\nタ、レジスタマシンシミュレータ、コンパイラを含めて再設計しました。そして\n全てのプログラム例を、任意の\nieee\nScheme\n標準\n(\nIEEE 1990\n)\nに従う\nScheme\n実装がそられのコードを実行できることを確実にするために、書き直しました。\nこの版はいくつかの新しいテーマを重視しています。これらの内、最も重\n要なものは計算モデル内での時間を取り扱うための異なる取り組みにより演じ\nられる中心的な役割です。状態を伴うオブジェクト、並行プログラミング、関\n数型プログラミング、遅延評価、そして非決定性プログラミングです。私達は\n並行性と非決定性に関わる新しい節を含め、そしてこのテーマをこの本を通し\nxix","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":19},{"id":"./test/fixtures/pdf/sicp.pdf:20","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"てまとめることを試みました。\nこの本の第一版は\nmit\nの一学期の科目の講義概要を密接に追っていました。\n第二版の全ての新しい教材により、一学期で全てをカバーすることは不可能と\nなりました。そのためインストラクタは選択をしなければなりません。私達自\n身の教育現場では、時々論理プログラミング\n(\nSection 4.4\n)\nを飛ばします。学生\nにはレジスタマシンのシミュレータを使用させるのでその実装\n(\nSection 5.2\n)\nは\nカバーしません。そしてコンパイラ\n(\nSection 5.5\n)\nは概観のみを大雑把に教えて\nいます。それでもこれは依然として強烈な授業です。何人かのインストラクタ\nは最初の\n3\n章から\n4\n章のみをカバーし、他の教材を続きの授業に残したいと願\nうでしょう。\nWorld-Wide-Web\nサイト\nhttp://mitpress.mit.edu/sicp\nはこの本のユーザ\nへのサポートを提供します。これにはこの本のプログラム、プログラミング課\n題のサンプル、補助教材、ダウンロード可能な\nLisp\nの\nScheme\n方言の実装が含\nまれます。\nxx","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":20},{"id":"./test/fixtures/pdf/sicp.pdf:21","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"第一版 序文\nコンピュータはヴァイオリンのような物です。初心者が最初に蓄\n音機、そして次にヴァイオリンを試すことを想像して下さい。彼\nは後者の音は酷いと言います。これが人間主義者と多くの計算機\n科学者から聞こえてくる議論です。計算機のプログラムは特定の\n目的には良い物だ、しかし柔軟性が無いと彼らは言います。ヴァ\nイオリンやタイプライタだって同じです。あなたがその使い方を\n学ぶまでは。\n—Marvin Minsky, “Why Programming Is a Good Medium for Ex-\npressing Poorly-Understood and Sloppily-Formulated Ideas”\n“The Structure and Interpretation of Computer Programs”(SICP,\n計算機プロ\nグラムの構造と解釈\n)\nはマサチューセッツ工科大学\n(MIT)\nでの入門者レベルの\n計算機科学の科目です。\nmit\nにて電気工学、または計算機工学を専攻する全て\nの学生が\n“\n共通コアカリキュラム\n”\nの\n4\nつの内の\n1\nつとして履修しなければな\nりません。共通コアカリキュラムは回路と線形システムについて\n2\nつの科目と\nデジタルシステムの設計についての科目を含みます。私達はこの科目の開発を\n1978\n年から行なってきました。そしてこの教材を現行様式として\n1980\n年の秋\nから、\n600\n名から\n700\n名の学生に毎年、教えてきました。これらの学生の多く\nは少し、または全くの事前の公式な計算機利用についてのトレーニングを受け\nてはいませんでした。ただし、多くは事前に計算機で少々遊んだ経験が有り、\nほんの少数は広範囲のプログラミングの経験やハードウェア設計の経験があり\nました。\n私達のこの計算機科学の入門科目の設計は\n2\nつの主な関心事を反映してい\nます。\n1\nつは、コンピュータ言語はコンピュータに命令を実行させるための単\nなる方法等ではなく、新しい種類の方法論に関する考えを表現するための公式\nxxi","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":21},{"id":"./test/fixtures/pdf/sicp.pdf:22","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"なメディアであるという考えを証明することです。従ってプログラムは人々が\n読むために書かれねばならず、そしてただ偶然に機械にとって実行する物でな\nければなりません。\n2\nつ目は、このレベルの科目により扱われる本質的な教材\nとは、特定のプログラミング言語が構築する構文ではなく、また特定の関数を\n効率的に演算するための賢いアルゴリズムでもなく、増してアルゴリズムと演\n算基盤の数理解析でないという信念です。そうではなく、大きなソフトウェア\nシステムの知的な複雑性をコントロールするために用いる技術でなければなり\nません。\n私達の目標は、この教科を完了した学生がプログラミングの美学とスタイ\nルの原理に対して必ず良い感触を得ることです。学生達が大きなシステムの複\n雑性をコントロールするための主な技術の能力を得られなければなりません。\n学生達が\n50\nページの長さのプログラムを、それが模範的なスタイルで書かれ\nているのならば、読めるようにならなければなりません。学生達がプログラム\nの変更を行う時に、元の作者の魂とスタイルを維持しながら安心できなければ\nなりません。\nこれらのスキルは決してコンピュータプログラミングに対して独自なこ\nとではありません。私達が教え、利用する技術は全ての工学設計に対して共\n通な物です。私達は適切な場合に、詳細を隠す抽象概念を構築することによ\nり複雑性をコントロールします。標準的な、良く理解された部品を\n“mix and\nmatch”(\n様々な物をうまく組み合わせる方法\n)\nの方法により組み合わせること\nにより、システムを構築することを可能にする慣習的なインターフェイスを確\n立することで、複雑性をコントロールします。私達は設計を記述するための新\nしい言語を確立することで複雑性をコントロールします。そして各言語は設計\nの特定の側面を重要視し、他の側面の重要性を緩和します。\n私達のこの教科に対する取り組み方の根底を成す物は、\n“\n計算機科学\n”\nは科\n学ではなく、その意義は計算機とは関係が無いという信念です。計算機革命と\nは私達の考え方と私達の考えの表現方法における革命です。この変化の本質を\n恐らく最もうまく言い表わすのは\nprocedural epistemology\n(\n手続的認識論\n)—\n古\n典的な数学上の主題により取られるより宣言的な視点に対立する、命令型の視\n点からの知識構造の研究\n—\nの出現でしょう。数学は\n“\n何であるか\n”\nの概念を正\n確に扱うためのフレームワークを提供します。計算機の使用は\n“\n行い方\n”\nの概\n念を正確に扱うためのフレームワークを提供します。\n私達の教材を教えるにあたって、プログラミング言語\nLisp\nの一方言を使用\nします。私達は正式にこの言語を教えることはしません。する必要がないから\nです。ただそれを使用し、そして学生は\n2\n、\n3\n日で習熟してしまいます。これは\nLisp\nの様な言語の\n1\nつの利点です。これらの言語は複合式を形成する方法があ\nxxii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":22},{"id":"./test/fixtures/pdf/sicp.pdf:23","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"まり多くありません。そしてほとんど構文構造が存在しません。形式的な特性\nの全ては一時間もあればカバーできます。まるでチェスのルールの様なもので\nす。少しの時間の後にはこの言語の構文上の詳細を忘れてしまいます。\n(\nほとん\nど存在しないからです\n)\n。そして本当の問題\n—\n私達が演算したい物を把握する\nこと、どのように問題を扱いやすい部分へと分解するか、そしてどのようにそ\nの部品上で働くかについて取り掛かります。\nLisp\nのもう\n1\nつの利点は私達が知\nっている他のどの言語よりもプログラムを分解したモジュラに対するより多く\nの大規模な戦略をサポートする\n(\nしかし強制はしない\n)\nことです。手続化とデー\nタ抽象化を行い、公開関数を用いて処理の共通なパターンを獲得し、代入とデ\nータの変更を用いて局所状態のモデル化を行い、プログラムの部品をストリー\nムと遅延評価に結び付け、簡単に組込言語を実装することができます。これら\n全てがインタラクティブ\n(\n相互作用\n)\nな環境にインクリメンタル\n(\n漸増的な\n)\nプ\nログラム設計、構築、テスト、デバッグのための優れたサポートと共に組込ま\nれています。私達は前例の無い力と洗練さを供えた素晴しいツールを創り出し\nた\nJohn McCarthy\nを始めとする全ての世代の\nLisp wizard(\nウィザード、魔法使\nい、最上級のプログラマの賞賛を込めた呼び名\n)\nに感謝します。\n私達が用いる\nLisp\nの方言、\nScheme\nは\nLisp\nと\nAlgol\nの力と洗練を一緒にも\nたらそうとしました。\nLisp\nからは単純な構文から導き出されるメタ言語の力、\nデータオブジェクトとしてのプログラムの単一の表現、ガベージコレクション\nを持つヒープ上に取得されるデータを得ました。\nAlgol\nからは\nAlgol\n委員会に\n在籍したプログラム設計の開拓者からの贈り物であるレキシカルスコープとブ\nロック構造を得ました。私達は\nJohn Reynolds\nと\nPeter Landin\nの\nChurch(\nチ\nャーチ\n)\nの\n푙푎푚푏푑푎\n-calculus(\nラムダ演算\n)\nのプログラミング言語の構造に対す\nる関係についての彼等の洞察に対して言及したいと願います。またコンピュー\nタがこの世界に現れる何十年も前にこの領域を偵察された数学者達に対する恩\n義も忘れておりません。これらの開拓者には\nAlonzo Church, Barkley Rosser,\nStephen Kleene, Haskell Curry\n等が含まれております。\nxxiii","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":23},{"id":"./test/fixtures/pdf/sicp.pdf:24","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"謝辞\nこの本とこのカリキュラムの開発を手助けして下さった多くの人々に感謝\n致します。\n私達の教科は明らかに\n1960\n年代の終わりに\nmit\nにて\nJack Wozencraft\nと\nArthur Evans, Jr.\nにより教えられたプログラミング言語学と\n휆\n演算上の素晴\nしい科目、\n“6.231”\nの知的末裔です。\n私達は\nRobert Fano\nに大きな借りがあります。彼は\nmit\nの電気工学と計算\n機科学の導入部のカリキュラムを再編成し、工学設計の原理を重視しました。\n彼はこの進取性への着手に導き、またこの本への発展の元となる最初の教科ノ\nートのまとめを記述しました。\n私達が教えようとするプログラミングのスタイルと美学の多くは\nGuy\nLewis Steele Jr.\nの協力の下に開発されました。彼は初期の\nScheme\nの開発に\nおいて\nGerald Jay Sussman\nと協力を行いました。加えて\nDavid Turner, Peter\nHenderson, Dan Friedman, David Wise, Will Clinger\nが私達にこの本の中に現\nれる関数型プログラミングのテクニックの多くを教えてくれました。\nJoel Moses\nは私達に巨大システムの構造化について教えてくれました。彼\nの記号演算のための\nMacsyma\nシステムにおける経験が、人は制御の複雑性を\n回避し、データの体系化に集中してモデル化されていく世界の真の構造を反映\nするべきだという見識を与えてくれました。\nMarvin Minsky\nと\nSeymour Papert\nは私達のプログラミングに関する態度\nの多くと、私達の知的な生活内にそれの場所を形作りました。彼等に対して、\n考えを探求するための式の意味を演算が与えることについての理解に借りがあ\nります。そうでなければ、正確に取り扱うためには複雑過ぎることになってし\nまいます。彼らは学生のプログラムを書き、変更する能力が、その中で探求が\n自然な活動になる強力なメディアを提供すると強調します。\n私達はまたプログラミングは大いに楽しく、このプログラミングの楽しみ\nxxiv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":24},{"id":"./test/fixtures/pdf/sicp.pdf:25","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"をサポートするために十分に注意しなければならない点について\nAlan Perlis\nに強く同意します。この楽しみの一部は作業中の偉大な職人達を観察すること\nから得られます。私達は幸運なことに、\nBill Gosper\nと\nRichard Greenblatt\nの\n下で見習いプログラマでいることができました。\n私達のカリキュラムの開発に貢献して下さった全ての人々を特定するこ\nとは難しいことです。私達は過去\n15\n年私達と共に働き、多くの時間を私達\nの教科に費してくれた全ての講師、口答の指導者、チューターに、特に、\nBill\nSiebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson,\nRod Brooks, Lynn Stein and Peter Szolovits\nに感謝します。私達は特に卓越\nした教育上の貢献として現在はウェルズリーの\nFranklyn Turbak\nに感謝しま\nす。彼の学部生向け指導要項は私達皆が目指す基準を打ち立てました。\nJerry\nSaltzer\nと\nJim Miller\nには私達が並行性のミステリーに取り組むのを手助けし\nて下さったことに感謝します。そして\nPeter Szolovits\nと\nDavid McAllester\nに\nは\nChapter 4\nにおける非決定性評価の説明に対する貢献に感謝します。\n多くの人々は他大学でこの資料を紹介するのに大きな努力を費してくださ\nいました。私達が親密に働いたそれらの人々の幾人かはイスラエル工科大学\nの\nJacob Katzenelson\n、カリフォルニア大学アーバイン校の\nHardy Mayer\n、オ\nックスフォード大学の\nJoe Stoy\n、パデュー大学の\nElisha Sacks\n、ノルウェー技\n術科学大学の\nJan Komorowski\nです。私達は他大学においてこの科目を受け入\nれることで主要な教育の賞を受けた同僚達を非常に誇りに思います。この中\nにはイェール大学の\nKenneth Yip\n、カリフォルニア大学バークリー校の\nBrian\nHarvey\n、コーネル大学の\nDan Huttenlocher\nを含みます。\nAl Moyé\nは私たちのためにこの教材を\nHP\nの技術者達に教える手筈とこ\nのレクチャーのビデオテープの製品化を準備してくれました。私たちはまた\n才能あるインストラクター達にも感謝致します。具体的には\nJim Miller, Bill\nSiebert, Mike Eisenberg\nです。彼等はこれらのテープを組み込んで生涯教育の\nコースを設計し、世界中の大学と業界にて教育を行いました。\n他国の多くの教育者が多大な時間を第一版の翻訳に費して下さいました。\nMichel Briand, Pierre Chamard, and André Pic\nはフランス語版をプロデュー\nスして下さいました。\nSusanne Daniels-Herold\nはドイツ語版をプロデュースし\nて下さいました。元吉文男は日本語版をプロデュースして下さいました。私た\nちはどなたが中国語版をプロデュースして下さったのか知りません。しかし\n“\n未許可\n”\nの翻訳の題材として選ばれたことを光栄に思います。\n私たちが教育の目的のために使用する\nScheme\nシステムの開発に技術的\nな貢献をされた全ての人々を列挙することは難しいことです。\nGuy Steele\nに\n加えて、主要なウィザードの中には\nChris Hanson, Joe Bowbeer, Jim Miller,\nxxv","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":25},{"id":"./test/fixtures/pdf/sicp.pdf:26","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Guillermo Rozas, Stephen Adams\nが含まれます。多大な時間を費して下さっ\nた他の人々は\nRichard Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil\nMayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma\nChaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd\nCass, Patrick O’Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, An-\nthony Courtemanche, Henry M. Wu, Andrew Berlin,\nそれに\nRuth Shyu\nです。\nmit\nの実装を越えて、私たちは\nieee\nの\nScheme\n標準仕様について働い\nた多くの人々に感謝したいと思います。\n푅\n4\n푅푆\nを編集した\nWilliam Clinger\nと\nJonathan Rees\n、\nieee\n標準を準備した\nChris Haynes, David Bartley, Chris\nHanson, Jim Miller\nを含みます。\nDan Friedman\nは長い間\nScheme\nコミュニティのリーダーでした。コミュニ\nティの広範な仕事は言語設計の問題を越えて、\nSchemer’s Inc.\nによる\nEdScheme\nを基にした高校生向けカリキュラムや\nMike Eisenberg\nや\nBrian Harvey\nと\nMatthew Wright\nによる素晴しい本のような、特筆すべき教育上のイノベーシ\nョンを含むまでに至りました。\n私たちはこの本を現実にすることに貢献して下さった人々の働きに感謝致\nします。特に\nmit\n出版の\nTerry Ehling, Larry Cohen, Paul Bethge\nです。\nElla\nMazel\nは素晴しいカバーの絵を見つけてくれました。第二版に対しては特にこ\nの本のデザインを助けてくれた\nBernard\nと\nElla\nの\nMazel\n夫妻、非凡な\nT\nE\nX\nウ\nィザードである\nDavid Jones\nに感謝致します。私たちはまた新しいドラフト\nに対し洞察力のあるコメントをして下さった読者の方々、\nJacob Katzenelson,\nHardy Mayer, Jim Miller,\nそして特に\nBrian Harvey\nに対して、\nJulie\nが彼の本\nSimply Scheme\nに行ったように、この本に行ってくれたことを感謝致します。\n最後に、何年にも渡ったこの仕事を励まして下さった組織のサポートに感\n謝したいと思います。\nHewlett-Packard\nからのサポートを可能にして下さった\nIra Goldstein\nと\nJoel Birnbaum\n、それに\ndarpa\nからのサポートを可能にして\n下さった\nBob Kahn\nを含みます。\nxxvi","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":26},{"id":"./test/fixtures/pdf/sicp.pdf:27","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1\n手続を用いた抽象化の構築\n心がその中で、その力を単純な考えの上に発揮する\n“\n心の働き\n”\nは、\n主としてこれら\n3\nつです。\n1.\nいくつかの簡単な考えを\n1\nつの複合\n物に組み合わせます。全ての複雑な考えはこのようにして作られ\nます。\n2. 2\nつの考えをそれが簡単であるか複雑であるかに係らず\n一緒にもたらし、お互いに合わせることでそれらを統合すること\nは無しに、全ての関係性の考えを得ることで、一度にそれらを見\n渡します。\n3.\n考えをそれらの実在に付随する全ての他の考えから\n分離します。これは抽象化と呼ばれ、このようにして全てのその\n一般的な考えは作られます。\n—John Locke,\nAn Essay Concerning Human Understanding\n(1690)\n私達は\ncomputational process\n(\n演算プロセス\n)\nについて学びます。演算プロセス\nとは抽象的な存在でコンピュータの中に複数が住んでいます。それらが進化す\nるとプロセスは\ndata\n(\nデータ\n)\nと呼ばれるまた別の抽象的な物を扱います。プロ\nセスの進化は\nprogram\n(\nプログラム\n)\nと呼ばれるルールのパターン\n(\n型、類型\n)\nに\nより命じられます。人はプログラムを作成してプロセスに命ずるのです。つま\nり私達はコンピュータの精霊に私達の呪文で魔法をかけるのです。\n演算プロセスは本当に魔法使いの精霊の考えに似ています。それは見たり\n触れたりはできません。物理的な物では構成されていません。しかしとてもリ\nアルな存在です。知的な仕事を行います。質問にも答えます。銀行でお金を払\n1","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":27},{"id":"./test/fixtures/pdf/sicp.pdf:28","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ったり、工場でロボットの腕をコントロールすることで世界に影響を与えるこ\nとも可能です。私達が利用するプロセスに魔法をかけるプログラムとは魔法使\nいの呪文のような物です。難解な秘伝の\nprogramming languages\n(\nプログラミン\nグ言語\n)\nの中で記号的表現にて慎重に組み立てられプロセスに実行してほしい\nタスク\n(\n仕事、任務\n)\nを指示します。\n演算プロセスは、正しく動くコンピュータでは、精密に正しくプログラム\nを実行します。従って魔法使いの見習いのように、初心者のプログラマは魔法\nの結果について理解し、予測することを学ばねばなりません。例えプログラム\nの小さなエラー（通常は\nbugs\n(\nバグ\n)\n、または\nglitches\n(\nグリッチ\n、誤作動\n)\nと呼ば\nれます）でも複雑で予測不可能な結果をもたらす場合もあるのです。\n幸運なことに、プログラムを学ぶことは魔法を学ぶことより少しも危険で\nはありません。私達が相手にする精霊は都合良く安全な方法で封じ込まれてい\nます。しかし、実際の世界でのプログラミングには注意力、専門知識、堅実さ\nを必要とします。例えば\nCAD(\n計算機による設計支援\n)\nプログラムの小さなバ\nグが飛行機やダムの最悪な崩壊に繋ったり、工業ロボットの自己破壊を起こし\nたりします。\nソフトウェアエンジニアのマスター達は最終的にプロセスが望まれたタス\nクを実行することに自信を持てるだけの技能を、プログラムの構築に対して\n持っています。彼らは前もってシステムの行いを図で説明することができま\nす。予測不可能な問題が最悪な結果をもたらさぬようプログラムをどのように\n構造化を行うのか知っています。そして問題が発生した時にはプログラムの\ndebug\n(\nデバッグ\n、バグ取り\n)\nを行えます。良い設計のコンピュータシステムは、\n良い設計の自動車や原子炉のようにモジュール方式で設計されており、パーツ\nは個別に組み立て、置き換え、デバッグが可能です。\nLisp\nプログラミング\n私達はプロセスを記述するのに適切な言語を必要とします。この目的に対\nしプログラミング言語\nLisp\nを利用します。私達の日々の考えが通常、自然言語\n（例えば英語やフランス語、日本語）で表されるように、定量的な現象が数学\nの記号で表されるように、手続的な思考は\nLisp\nで表現されます。\nLisp\nは\n1950\n年代後半に\nrecursion equations\n(\n再帰方程式\n)\nと呼ばれるある種の論理表現に関\nする推論のための形式化として開発されました。この言語は\nJohn McCarthy\nにより着想され、彼の論文\n“\n記号式の再帰方程式とそれらの機械による演算\n”\n(\nMcCarthy 1960\n)\nを基にしています。\n数学上の形式主義としての始まりにも関わらず、\nLisp\nは実用的なプログラ\n2","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":28},{"id":"./test/fixtures/pdf/sicp.pdf:29","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ミング言語です。\nLisp\ninterpreter\n(\nインタプリタ\n、逐次翻訳処理器\n)\nは\nLisp\n言\n語にて記述されたプロセスを実行する機械です。最初の\nLisp\nインタプリタは\nMcCarthy\nと\nmit\n研究所の人工知能部門の同僚、学生による手助けにて実装さ\nれました。\n1\nLisp\nはその名前を\nLIst Processing(\nリスト処理\n)\nの頭文字から取っ\nており、記号微分や代数式の積分の様なプログラミング上の問題に着手するた\nめの記号操作能力を提供するために設計されました。この目的のためにアトム\nとリストとして知られる新しいデータオブジェクトを含みます。これはその時\n代の他の全ての言語から著しく際立たせる物でした。\nLisp\nは計画的な設計の取り組みから生まれた製品ではありませんでした。\nそうではなく、非公式に試験的なやり方で、ユーザの要求と実利的な実装上の\n考慮への対応として発展しました。\nLisp\nの非公式な進化は何年も続き、\nLisp\nユ\nーザのコミュニティは伝統的に言語の\n“\n公式な\n”\nどんな定義の公表に対しても\n抵抗しました。この進化は初期構想の柔軟性と洗練さと共に、今日世界中で広\nく使用される言語で\n2\n番目に古い\n(Fortran\nのみがより古い\n)\n言語として、\nLisp\nに継続的に最新のプログラム設計についての考えを受け入れることを可能にし\nてきました。従って\nLisp\nは今では複数の方言の系統が存在し、それらはオリジ\nナルの機能の多くを共有しながらも、お互いに大きな違いを持ちます。この本\nで使用される\nLisp\nの方言は\nScheme\nと呼ばれます。\n2\n実験的であるという特徴と記号操作の重要性のため、\nLisp\nは初期において\nは数値演算に対し少くとも\nFortran\nとの比較にてとても非効率でした。しかし\n年を追って、プログラムを機械語に変換し、数値演算を適度に効率良く実行可\n1\nLisp 1 Programmer’s Manual\nは\n1960\n年に初出し、\nLisp 1.5 Programmer’s Manual\n(\nMcCarthy et al. 1965\n)\nは\n1962\n年に出版されました。\nLisp\nの初期の歴史は\nMcCarthy\n1978\nにて説明されています。\n2\n1970\n年代に最もメジャーな\nLisp\nプログラムの記述に用いられた\n2\nつの方言は\nmit\nのプロジェクト\nmac\nで開発された\nMacLisp (\nMoon 1978\n;\nPitman 1983\n)\nと\nBolt\nBeranek and Newman Inc.\nと\nXerox Palo Alto\n研究センターににて開発された\nInterlisp\n(\nTeitelman 1974\n)\nでした。\nPortable Standard Lisp (\nHearn 1969\n;\nGriss 1981\n)\nは簡単に、\n異なるマシンの間で移植可能にするよう設計された\nLisp\n方言です。\nMacLisp\nはカリフ\nォルニア大学バークレー校により開発された\nFranz Lisp\nや\nmit\n人口知能研究所が\nLisp\nをとても効率良く実行するために設計した特定目的プロセッサ\n(\n処理機\n)\nをベースにした\nZetalisp (\nMoon and Weinreb 1981\n)\nといったいくつかの下位方言を生みました。この本\nで使用する\nLisp\n方言は\nSheme (\nSteele and Sussman 1975\n)\nと呼ばれ、\n1975\n年に\nmit\n人\n口知能研究所の\nGuy Lewis Steele Jr.\nと\nGerald Jay Sussman\nにより開発され、後に\nmit\nにて教育目的のために再実装されました。\nCommon Lisp (\nSteele 1982\n,\nSteele 1990\n)\nは\nLisp\nコミュニティにより初期の\nLisp\n方言の機能を集約し、\nLisp\nの業界標準を作成する\nために開発されました。\nCommon Lisp\nは\n1994\n年に\nansi\n標準\n(\nANSI 1994\n)\nになりまし\nた。\n3","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":29},{"id":"./test/fixtures/pdf/sicp.pdf:30","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"能な\nLisp\nコンパイラが開発されました。特別なアプリケーションに対しては\nLisp\nは最高の効果を発揮しています。\n3\nLisp\nは今でもどうしようもなく非効率\nであるという古い評判を乗り越えられてはいませんが、\nLisp\nは今では多くのア\nプリケーションにて、効率が問題の中心ではない場合において利用されていま\nす。例えば\nLisp\nは\nOS\nのシェル言語やエディタの拡張言語、\nCAD\nシステム等\nにおいて選択言語となっています。\nもし\nLisp\nがメインストリームの言語でなければなぜ私達はプログラミング\nの議論のためのフレームワークとしてそれを用いるのでしょうか\n?\nなぜならこ\nの言語は重要なプログラミング構成概念とデータ構造を学ぶため、またそれら\nをサポートする言語上の機能にそれらを関連付けするために、言語自身を洗練\nされた媒体と成す個有の機能を持っているためです。これらの機能で最も著し\nい物は、\nLisp\nによる\nprocedures\n(\n手続\n)\nと呼ばれるプロセスの記述が、それ自身\nが\nLisp\nのデータとして表現され、また操作されることが可能であるという事\n実です。これの重要性は、伝統的な\n“\n受動的な\n”\nデータと\n“\n能動的な\n”\nプロセス\nとの間の区別をぼかす能力に依存する、強力なプログラム設計のテクニックが\n存在するということです。私達がそれを発見するにつれ、手続をデータとして\n扱う\nLisp\nの柔軟性は\nLisp\nをこれらのテクニックを探求するのに、既存で最も\n便利な言語の\n1\nつとします。手続をデータとして表現する能力はまた、\nLisp\nを\n他のプログラムをデータとして操作しなければならないプログラムを書く目的\nに対し洗練された言語にします。例えばコンピュータ言語に対応するインタプ\nリタやコンパイラのようなプログラムです。これらの考慮点に加えて、\nLisp\nに\nよるプログラミングはとても楽しいのです。\n1.1\nプログラミングの要素\n強力なプログラミング言語はコンピュータにタスクの実行を指示するだけ\nではありません。そのような言語は私達がプロセスについての自らの考えを体\n系化するフレームワークとしての役目を担います。従って言語を記述する時、\n簡単なアイデアを組み合わせてより複雑なアイデアを形成するという手段をそ\nの言語が提供することには特に注意を払わねばなりません。強力な言語全てが\n3\nそのような特別なアプリケーションの\n1\nつは自然科学上の重大な計算、太陽系の動き\nの統合におけるブレイクスルーでした。これは以前の結果より二桁も良く、太陽系の活動\nが混沌であることを実演しました。この計算は全て\nLisp\nで書かれたソフトウェアツール\nの手助けにより実装された新しい統合アルゴリズム、特定目的のコンパイラ、特定目的\nの計算機により可能となりました。\n(\nAbelson et al. 1992\n;\nSussman and Wisdom 1992\n)\n4","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":30},{"id":"./test/fixtures/pdf/sicp.pdf:31","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これを達成するために３つのメカニズムを持っています。\n•\nプリミティブな式\n,\n言語に関わる最も単純な要素を表現する\n•\n合成化の手段\n,\nこれにより、より単純なものより複合要素が構築される\n•\n抽象化の手段\n,\nこれにより複合要素は名前を付けて個体として扱える\nプログラミングにおいては２つの種類の要素を扱います。手続\n(procedure)\nと\nデータです。（後でそれらはあまりはっきりとは区別できないことを明かしま\nす。）簡単に説明するとデータは操作対象の\n“\n物\n”\nで手続はデータの操作のため\nのルールの記述です。従って強力なプログラミング言語はどれもプリミティブ\n(\n原始的な、最低レベルの、組込の\n)\nなデータとプリミティブな手続を記述可能\nでなければならず、また手続とデータを合成化、抽象化する手法を持たなけれ\nばなりません。\nこの章では単純な数値データのみを扱うことにより、手続構築のためのル\nールに集中します。\n4\n後の章では同じこれらのルールにより複合データもまた\n構築できることを学びます。\n1.1.1\n式\nプログラミングを始める１つの簡単な方法はいくつかの典型的な対話\nを\nLisp\nの方言である\nScheme\nのインタプリタを用いて試してみることで\nす。コンピュータの端末の前に座っていると想像してみてください。あなた\nが\nexpression\n(\n式\n)\nを入力するとインタプリタはその式の\nevaluation\n(\n評価\n)\nの結\n果を表示することで応答します。\n4\n数値を\n“\n単純なデータ\n”\nと特徴付けるのは公然なウソです。実際に数値の扱いは任意\nのプログラミング言語において最も油断ならない、混乱を招く要素です。いくつかの典\n型的な問題は次のものです。いくつかのコンピュータシステムは\n2\nのような\nintegers\n(\n整\n数\n)\nと\n2.71\nのような\nreal numbers\n(\n実数\n)\nの区別をします。実数\n2.00\nは整数\n2\nとは異なる\nでしょうか？整数に用いられる算術演算は実数に対する物と同じでしょうか？\n6\nを\n2\nで\n割ったら\n3?\nそれとも\n3.0?\nどれだけ大きな数値を表示できますか\n?\n精度は少数何桁まで\n正しく表わされますか\n?\n整数の範囲は実数の範囲と同じですか\n?\nもちろんこれらの質問\nの他にも丸めと切り捨てに関する誤差の問題の蓄積といった数値解析の科学全体が存在\nします。この本のフォーカスは大規模なプログラム設計であり数値演算向けのテクニッ\nクではないのでこれらの問題は無視することにします。この章の数値演算の例では非整\n数演算において精度上正確な桁数に制限を持つ算術演算を用いる場合に一般的な丸めの\n方法を示します。\n5","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":31},{"id":"./test/fixtures/pdf/sicp.pdf:32","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"あなたが入力するプリミティブな式の一種として数値があります。\n(\nより正\n確にはあなたが入力する式は\n10\n進数の数値を表す数字から成り立ちます。\n)\nも\nし数値を\nLisp\nに与えた場合、\n486\nインタプリタは以下を表示することで応答します。\n5\n486\n数値を表す式はプリミティブな手続を表す式\n(\n例えば\n+\nや\n*\n)\nと接続することで\n複合式を形成し、それら数値に対し手続を適用することを表現します。例えば\n:\n(+ 137 349)\n486\n(- 1000 334)\n666\n(* 5 99)\n495\n(/ 10 5)\n2\n(+ 2.7 10)\n12.7\nこれらのような式は括弧の中の式のリストを区切ることにより形成され手続の\n適用を示し、\ncombinations\n(\n組み合わせ\n)\nと呼ばれます。リストの最も左の要素\nは\noperator\n(\nオペレータ\n、\n演算子\n)\nと呼ばれ、他の要素は\noperand\n(\nオペランド\n、被\n演算数\n)\nと呼ばれます。組み合わせの値はオペレータにより与えられた手続を\nオペランドの値である\narguments\n(\n引数\n)\nに適用することで得られます。\nオペレータをオペランドの左に置く決まりは\nprefix notation\n(\n前置表記法\n)\nとして知られています。最初の内は数学の決まりから明らかに逸脱するので混\n乱するかもしれません。しかし、前置表記法にはいくつかの利点が存在します。\nその\n1\nつは以下の例のように、任意の数の引数を取る手続に適応できること\nです。\n5\nこの本を通して、ユーザの入力とインタプリタが表示した応答を区別したい場合、傾\nいた文字で表します。\n6","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":32},{"id":"./test/fixtures/pdf/sicp.pdf:33","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(+ 21 35 12 7)\n75\n(* 25 4 12)\n1200\n曖昧さが全くありません。オペレータが常に最も左の要素であり、合成全体は\n括弧で区切られているためです。\n前置表記法の\n2\nつ目の利点は直接的な方法にて組み合わせを\nnested\n(\nネス\nト、入れ子\n)\nにすることが可能です。つまり、組み合わせの要素それ自体が組\nみ合わせである場合です。\n(+ (* 3 5) (- 10 6))\n19\n原理的にはそのようなネストの深さと\nLisp\nインタプリタが評価可能な式全体\nの複雑さには制限がありません。しかし私達人間は以下のような比較的単純な\n式でも混乱してしまいます。\n(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))\nインタプリタは直ちに\n57\nだと評価するでしょう。このような式を次のような\n形式で記述することで私達自身を助けることが可能です。\n(+ (* 3\n(+ (* 2 4)\n(+ 3 5)))\n(+ (- 10 7)\n6))\npretty-printing\n(\nプリティプリント\n、整形\n)\nとして知られるフォーマットの決ま\nりに個々の長いオペランドを従わせることで、オペランドが垂直方向で位置合\nわせされます。結果的に式の構造が明確にインデント\n(\n字下げ\n)\nされることにな\nります。\n6\n例え複雑な式でもインタプリタは常に同じ基本的なサイクルにて処理を行\nいます。式を端末から読み、その式を評価し、結果を表示します。この操作モ\n6\n典型的な\nLisp\nシステムは式を整形しユーザを手助けするための機能を提供します。\n特に便利な\n2\nつの機能において、\n1\nつは新しい行がどこで始まろうとも自動的に正しい\n整形位置にインデントします。もう\n1\nつは右括弧が入力された時に対応する左括弧がハ\nイライトされます。\n7","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":33},{"id":"./test/fixtures/pdf/sicp.pdf:34","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ードはしばしばインタプリタが\nread-eval-print loop\n(REPL:\nレプル\n)\nで実行され\nていると呼ばれます。特に明示的にインタプリタに式の値を表示しろと命令す\nる必要がないことに注意して下さい。\n7\n1.1.2\n名前付けと環境\nプログラミング言語の重要な特徴は演算対象を参照するための名前を利用\nするためにそれが提供する手段です。名前は\nvalue\n(\n値\n)\nとしてオブジェクトを持\nつ\nvariable\n(\n変数\n)\nを識別します。\nLisp\nの方言\nScheme\nでは対象に\ndefine\n(\n定義\n)\nを用いて名前を付けます。以\n下のように入力すると\n(\ndefine\nsize\n2)\nインタプリタは名前\nsize\nと値\n2\nを関連付けます。\n8\n一度名前\nsize\nが数値\n2\nに\n関連付けられれば値\n2\nを名前で参照することが可能です。\nsize\n2\n(* 5\nsize\n)\n10\nより多くの\ndefine\nの使用例を見ましょう。\n(\ndefine\npi\n3.14159)\n(\ndefine\nradius\n10)\n(*\npi\n(*\nradius\nradius\n))\n314.159\n(\ndefine\ncircumference\n(* 2\npi\nradius\n))\ncircumference\n62.8318\n7\nLisp\nは各式が値を持つという決まりに従います。\nLisp\nが非効率な言語であるという\n古い噂と共に、この決まりが\nAlan Perils\nによる\nOscar Wilde\nをもじった皮肉のネタ元\nになっています。曰く\n“Lisp\nプログラマは全ての値を知っているがそのコストはどれに\nついても知らない\n”\n8\nこの本ではインタプリタの定義に対する評価の応答を表示しません。とても実装依\n存であるためです。\n8","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":34},{"id":"./test/fixtures/pdf/sicp.pdf:35","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"define\nは言語の最も単純な抽象化の手段です。簡単な名前を使用して合\n成命令の結果を参照することを可能にします。例えば上の例で計算した\ncircumference\n(\n円周\n)\nです。一般的に演算対象はとても複雑な構造を持ち、\nそれを覚えて使用時に詳細を繰り返し記述することはとても面倒です。実際に、\n複雑なプログラムは少しづつ複雑さを増していく演算対象を\n1\nつづつ構築して\n組み立てられます。インタプリタはこのプログラム組立の各ステップに特に便\n利です。なぜなら名前とオブジェクトの関連性が連続した対話を通して少しづ\nつ作成可能なためです。この機能は漸進的開発とプログラムのテストを促進し、\nLisp\nプログラムが通常数多くの比較的単純な手続により構成される理由です。\n値に記号を関連付け、後にそれらを取り出すことがあるのは、インタプリ\nタが名前とオブジェクトのペアを追跡するためのある種のメモリを持たなけれ\nばいけないことを意味することは明白でしょう。このメモリは\nenvironment\n(\n環\n境\n)(\nより正確には\nglobal environment\n(\nグローバル環境\n、大域環境\n)\n、演算には複\n数の異なる環境が利用されることを後に学ぶため\n)\nと呼ばれます。\n.\n9\n1.1.3\n組み合わせの評価\nこの章の目標の\n1\nつは手続的な思考上の問題を分離することです。代表例\nとして、組み合わせの評価においてインタプリタはそれ自身が手続に従うこと\nを考えてみましょう。\n組み合わせを評価するため、以下を行います\n1.\n組み合わせの部分式を評価する\n2.\n最も左の部分式\n(\nオペレータ\n)\nの値である手続を他の部分式\nの値である引数\n(\nオペランド\n)\nに対し適用する\nこの単純なルールでさえ、一般的な過程におけるいくつかの重要な点を示しま\nす。最初に第一のステップが組み合わせの評価過程を達成すためには先に組み\n合わせの各要素の評価過程の実行を行う必要があります。従って評価ルールは\n事実上\nrecursive\n(\n再帰\n)\n的です。つまり評価ルールの\n1\nステップとしてそれ自身\nを実行する必要性があります。\n10\n9\nChapter 3\nにてこの環境という概念がインタプリタがどのように働くか、またどのよ\nうにインタプリタを実装するかにおいて重要であることを示します。\n10\n評価ルールが第一のステップの部分として組み合わせの最も左の要素を評価しなけ\nればいけないというのは奇妙に写るかもしれません。この時点ではそれは\n+\nや\n*\nが表す\n足し算やかけ算のような組込のプリミティブな手続でしかないためです。後に組み合わ\n9","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":35},{"id":"./test/fixtures/pdf/sicp.pdf:36","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"15\n26\n242\n390\n7\n53\n64\n+\n*\n*\n+\nFigure 1.1:\n部分的組合せの値を示す木表現\n再帰の考えがいかに簡潔に、深くネストした複合式を表現できるかに注目\nしてください。再帰でなければとても複雑な経過に見えてしまうでしょう。例\nえば以下の式を評価してみます。\n(* (+ 2 (* 4 6))\n(+ 3 5 7))\nこの式は評価ルールが\n4\nつの異なる組み合わせに適用される必要があります。\nこの過程を式の組立を木形式にて表現することで図解することが可能です。\nFigure 1.1\nをご覧下さい。各組み合わせは枝の付いたノードで表され、枝には\nオペレータと別の組み合わせへの茎となるオペランドが付いています。終端ノ\nード\n(\n他のノードへのと続く枝の無い物\n)\nはオペレータか数値を表しています。\n評価を木の用語で表すと、オペランドの値は上へと流れていくことが想像でき\nます。終端ノードから始まり上のレベル、さらに上のレベルにて合成されます。\n一般的に、再帰は階層的な木のような対象を扱うのにとても強力な技術です。\n実際に評価ルールの\n“\n値を情報に流す\n”\n形式は\ntree accumulation\n(\n集積木\n)\nとし\nて知られます。\n次に第一ステップの適用の繰り返しが、組み合わせでなく、プリミティブな式、\n例えば数値や組込オペレータ、その他の名前を評価することが必要となる点へ\nと導くことに注目して下さい。以下を規定することにより、プリミティブな場\n合を取り扱います。\n•\n数字の値はそれが意味する値です\nせのオペレータそのものが組み合わせである場合を扱えることが便利であることを学び\nます。\n10","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":36},{"id":"./test/fixtures/pdf/sicp.pdf:37","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n組込オペレータの値は機械語の列であり対応する操作を実行します。\n•\nその他の名前の値は現在の環境にてその名前に対応するオブジェクト\nです。\n2\nつ目のルールは\n+\nと\n*\nのような記号もまたグローバル\n(\n大域\n)\n環境に含まれて\nおり、それらの\n“\n値\n”\nとして一連の機械語命令に関係付けられていると規定すこ\nとにより、\n3\n番目のルールの特別な場合であると見做すことができます。注意\nすべき鍵となる点は式の中の記号の意味の決定に環境が果たす役割です。\nLisp\nのようなインタラクティブな言語では\n(+ x 1)\nのような式の値について記号\nx\n(\nまたはの\n+\nのような記号についてさえ\n)\n意味を与える環境の説明無しに話すこ\nとは無意味です。\nChapter 3\nにて学びますが、評価が行われる文脈を提供する環\n境の一般的概念は我々がプログラムの実行を理解する上で重要な役割を果たし\nます。\n上で与えられた評価ルールが定義を扱わないことにも注意して下さい。例\nえば\n(define x 3)\nの評価は\ndefine\nを\n2\nつの引数、シンボル\nx\nの値と\n3\nに適\n用しません。\ndefine\nの目的はまさに\nx\nに対する値の関連付けだからです。\n(\nつ\nまり\n(define x 3)\nは合成式ではありません。\n)\nそのような一般的な評価ルールに対する例外は\n特別形式\nと呼ばれます。\ndefine\nは特別形式の一例に過ぎません。すぐに他の例に出会うことになりま\nす。特別な形式は全てそれ自身の評価ルールを持ちます。色々な種類の式\n(\nそ\nれぞれが関連する評価ルールを持つ\n)\nはプログラミング言語の構文を構成しま\nす。他の多くのプログラミング言語と比較して\nLisp\nはとても簡単な構文を持\nちます。式の評価ルールは簡単な一般ルールと少しの特別な形式にて説明可能\nです。\n11\n11\n事物をより統一的な方法で表記可能な、簡単で便利な代替的表面構造である特別な\n構文形式を、\nPeter Landin\nの作成した語句ですが、\nsyntactic sugar\n(\nシンタックスシュ\nガー、\n構文糖\n)\nと呼ぶ場合があります。他言語のユーザと比較して\nLisp\nプログラマは一\n般に構文上の問題に気をつかいません。\n(Pascal\nのマニュアルを調査するとどれだけ多く\nのページが構文の記述に割り当てられているのかに気付くのとは逆です。\n)\nこの構文の軽\n視は\nLisp\nの柔軟性の理由の一部になります。\nLisp\nの柔軟性は表面上の構文の変更を簡単\nにします。また多くの\n“\n便利な\n”\n構文の構築を見かける理由にも繋ります。それらの構文\nは言語をあまり統一的でないものにし、プログラムが巨大で複雑になるにつれ元の価値\nよりも多くの問題を起こすことになります。\nAlan Peril\n曰く、\n“\n構文糖はセミコロンの癌\nを引き起こす\n”\n11","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":37},{"id":"./test/fixtures/pdf/sicp.pdf:38","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.1.4\n複合手続\n他の強力なプログラミング言語に必ず存在する要素をいくつか\nLisp\nでも確\n認しました。\n•\n数値と算術命令はプリミティブなデータと手続です。\n•\n組み合わせのネストは演算の結合手法を提供します。\n•\n名前と値を関連付けする定義は抽象化の限定された手法を与えます。\nここでは\nprocedure definitions\n(\n手続の定義\n)\nを学びます。より強力な抽象化のテ\nクニックであり組み立てられた操作に名前を与え、\n1\nつの単位としてアクセス\n可能にします。\n“\n二乗の値\n”\nをどのように表現するかから始めましょう。\n“\n二乗の値を求め\nるためにはその値をその値自身にかける\n”\nと言えるでしょう。\n(\ndefine\n(\nsquare\nx\n) (*\nx\nx\n))\nこれを以下のように理解することが可能です。\n(define (square    x)\n(*\nx\nx))\n|\n|\n|\n|\n|\n|\n定義  二乗する\nx\nを   かける\nx\nを\nx\nで\n.\nここで\nsquare\nと名付けられた\ncompound procedure\n(\n複合手続\n)\nが出てきました。\nこの手続はある数値をそれ自身にてかけ算することを表しています。かけられ\nる数には\nx\nという名前が付けられており代名詞が自然言語にて果たすのと同\nじ役割を果たします。この定義の評価はこの複合手続を作成し、私達はそれに\nsquare\nという名前を与えています。\n12\n一般的な手続の定義形式は以下の通りです。\n(\ndefine\n(\n⟨\nname\n⟩\n⟨\nformal parameters\n⟩\n)\n⟨\nbody\n⟩\n)\n⟨\nname\n⟩\nはその環境における手続定義に関連付けられる記号です。\n13\n⟨\nformal parameters\n⟩\nは手続の中で利用される名前で手続の関連する引数を参照します。\n⟨\nbody\n⟩\nは\n12\nここでは次の\n2\nつを区別できるようになることが本当に重要だと言えます。\n1\nつは手\n続を名前を付けずに作成すること、もう\n1\nつは既に作成された手続に名前を付けること\nです。どのように行うかについては\nSection 1.3.2\nにて学びます。\n13\nこの本では一般的な式の構文をかぎ括弧にて閉じたイタリックの記号\n—\n例えば、\n⟨\nname\n⟩\n—\nを用いて実際に式が利用される時に埋められるべき式中の\n“\n枠\n”\nを示します。\n12","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":38},{"id":"./test/fixtures/pdf/sicp.pdf:39","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"形式上のパラメータが手続が適用される実際の引数に置換される時、手続の適\n用における値を返す式です。\n14\n⟨\nname\n⟩\nと\n⟨\nformal parameters\n⟩\nは括弧を用い\nてグループ化され、実際の手続呼出しのように定義されます。\nsquare\nを定義したので使ってみましょう。\n(\nsquare\n21)\n441\n(\nsquare\n(+ 2 5))\n49\n(\nsquare\n(\nsquare\n3))\n81\nsquare\nを構築要素として他の手続の構築に用いることも可能です。例えば、\n푥\n2\n+ 푦\n2\nは次のように表現できます。\n(+ (\nsquare\nx\n) (\nsquare\ny\n))\n2\nつの数値を引数として取りそれらの二乗の和を求める\nsum-of-squares\nを定\n義することも簡単です。\n(\ndefine\n(\nsum-of-squares\nx\ny\n)\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\nsum-of-squares\n3 4)\n25\nsum-of-squares\nをさらに別の手続構築に利用することもできます。\n(\ndefine\n(\nf\na\n)\n(\nsum-of-squares\n(+\na\n1) (*\na\n2)))\n(\nf\n5)\n136\n複合手続はプリミティブな手続と全く同じように利用可能です。実際に上の\nsum-of-squares\nの定義を見ても\nsquare\nが\n+\nや\n*\nのようにインタプリタに組\n込まれているのか、複合手続として定義されているのか見分けがつかないでし\nょう。\n14\nより実際には、手続のボディは連続する式です。この場合インタプリタは連続する各\n式を順に評価し最後の式の値を手続適用全体の値として返します。\n13","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":39},{"id":"./test/fixtures/pdf/sicp.pdf:40","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.1.5\n手続適用の置換モデル\nオペレータの名前が合成式を示す合成を評価する時、インタプリタは\nSection 1.1.3\nで説明した合成式のオペレータがプリミティブである場合とほぼ\n同じ手順を追います。インタプリタは合成の各要素を評価し、\n(\n合成のオペレー\nタの値である\n)\n手続を\n(\n合成のオペランドである\n)\n引数に対して適用します。\nプリミティブな手続を引数に対して適用するメカニズムはインタプリタに\n組込まれていることが想像できます。複合手続に対しては適用プロセスは以下\nのようになります。\n複合手続を引数に適用するために、手続のボディを、各形式パラ\nメタを対応する引数にて置換してから評価します。\n過程を説明するために以下のコンビネーションを評価してみましょう。\n(\nf\n5)\nf\nは\nSection 1.1.4\nにて定義された手続です。\nf\nのボディを取得することから始め\nます。\n(\nsum-of-squares\n(+\na\n1) (*\na\n2))\nThen we replace the formal parameter\na\nby the argument 5:\n次に形式パラメタ\nの\na\nを引数\n5\nで置き換えます。\n(\nsum-of-squares\n(+ 5 1) (* 5 2))\n従って問題は\n2\nつのオペランドとオペレータ\nsum-of-squares\nに換算されます。\nこの組み合わせの評価は\n3\nつの部分問題に分かれます。まずオペレータを評価\nして適用する手続を得て、オペランドを評価して引数を得る必要があります。\nさて\n(+ 5 1)\nは\n6\nになり、\n(* 5 2)\nは\n10\nになりますので\nsum-of-squares\n手続\nを\n6\nと\n10\nに適用しなければなりません。これらの値は\nsum-of-squares\nのボ\nディのパラメタ\nx\nと\ny\nを置き換え、式は以下のように置換されます。\n(+ (\nsquare\n6) (\nsquare\n10))\nsquare\nの定義を用いるとこれはさらに以下のように置換されます。\n(+ (* 6 6) (* 10 10))\n乗算を置換することで以下になります。\n(+ 36 100)\n14","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":40},{"id":"./test/fixtures/pdf/sicp.pdf:41","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最終的には次のとおりです。\n136\nここまで説明したプロセスは手続適用の\nsubstitution model\n(\n置換モデル\n、代入\nモデル\n)\nと呼ばれます。この章にて扱われた手続の過程においては、手続適用\nの\n“\n意味\n”\nを決定するモデルとして捉えることができます。しかし、強調すべき\n2\nつの事があります。\n•\n代入の目的は私達が手続適用について考えることを手助けすることであ\nり、インタプリタが実際にどのように働くかの説明を与えることではあ\nりません。典型的なインタプリタは手続のテキストを操作することで形\n式手続に値を代入することで手続適用を評価することはしません。実際\nには\n“\n代入\n”\nは形式パラメタにローカルの環境を用いることで行われま\nす。このことについてはより完全に\nChapter 3\nと\nChapter 4\nにてインタプ\nリタの実装の詳細について調査する時に議論します。\n•\nこの本のコース全体ではインタプリタがどのように働くかについて、一\n連の徐々に精巧なモデルを紹介して行きます。最終的にはインタプリタ\nとコンパイラの完全な実装を\nChapter 5\nで見せます。代入モデルはこれら\nのモデルの最初\n—\n評価手続について正式な考え得るための始まりに過ぎ\nません。一般的に科学とエンジニアリングについての事象をモデリング\nする場合、単純化した不完全なモデルから始めます。より詳細な調査を\n行うにつれ、これらの単純なモデルは不適切になり、より正確なモデル\nにて置き換えられます。置換モデルもまた例外ではありません。実際に\nChapter 3\nで示しますが手続を\n“mutable(\n変わりやすい\n)\nデータ\n”\nと共に\n扱う場合に置換モデルは破綻し、より複雑な手続適用のモデルにより置\nき換えなければならなくなります。\n15\n適用順 対 正規順\nSection 1.1.3\nで与えられた評価の記述に従えば、インタプリタは最初にオペ\nレータとオペランドを評価し、次に結果の手続を結果の引数に適用します。評\n15\n代入のアイデアの簡明性にもかかわらず、代入手続の厳密な数学上の定義を与える\nことは驚くほど複雑になることが知られています。問題は手続の形式パラメタの名前と\n手続が適用される式で利用されている\n(\n同じである可能性のある\n)\n名前の間の混乱の可能\n性から生じます。実際に論理とプログラミング意味論の文献における\n代入\nの間違った定\n義には長い歴史があります。\nStoy 1977\nの代入に関する注意深い議論を参照下さい。\n15","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":41},{"id":"./test/fixtures/pdf/sicp.pdf:42","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"価の仕方はこれだけではありません。代替としての評価モデルはオペランドを\nそれらの値が必要になるまで評価しません。その代わりに最初はオペランドの\n式にそれがプリミティブなオペレータのみ持つまでパラメタで置換します。そ\nれから評価を実行します。この手法を用いた場合、\n(f 5)\nの評価は展開の流れ\nに従って進行します。\n(\nsum-of-squares\n(+ 5 1) (* 5 2))\n(+    (\nsquare\n(+ 5 1))\n(\nsquare\n(* 5 2))  )\n(+    (* (+ 5 1) (+ 5 1))    (* (* 5 2) (* 5 2)))\n簡約が続きます。\n(+\n(* 6 6)\n(* 10 10))\n(+\n36\n100)\n136\n今回も前回の評価モデルと同じ答になりました。しかし経過が異なります。具\n体的には\n(+ 5 1)\nと\n(* 5 2)\nがここではそれぞれ二回づつ実行されます。式\n(* x x)\nにおける\nx\nがそれぞれ\n(+ 5 1)\nと\n(* 5 2)\nに置き換えることで換算\nされているのに相当していています。\nこの代替である\n“\n完全に展開してから簡約する\n”\n評価方法は\n正規順序評価\nとして知られています。一方、\n“\n引数を評価してから適用\n”\nする方法はインタプ\nリタが実際に利用するもので\n適用順序評価\nと呼ばれます。、\n(\nこの本の最初の\n2\nつの章の手続全てを含めて\n)\n代入を使用してモデリング可能、かつ正当な値を\n生む手続適用において正規順序と適用順序の評価は同じ値を生むことが見てと\nれるでしょう。\n(\n正規順序と適用順序の評価が同じ値を返さない\n“\n不当な\n”\n値の\n例は\nExercise 1.5\nをご覧下さい\n)\nLisp\nは適用順序評価を用いています。理由の一部は上の\n(+ 5 1)\nと\n(* 5\n2)\nで示されたような式の複数回評価を避けることで付加的な効率を得るため\nです。そしてより重要な理由は正規順序評価は代入によりモデル化可能な手続\nの範囲を離れる時の取扱がとても複雑なためです。一方で、正規順序評価はと\nても価値のあるツールです。その意味のいくらかを\nChapter 3\nと\nChapter 4\nに\nて調査します。\n16\n16\nChapter 3\nでは\nstream processing\n(\nストリーム処理\n)\nを紹介します。これは一見し\nて\n“\n無限\n”\nのデータ構造を正規順評価の制約形式に立脚して取り扱う手法です。\nSection\n4.2\nでは\nScheme\nインタプリタを変更し\nScheme\nの正規順異種を作成します。\n16","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":42},{"id":"./test/fixtures/pdf/sicp.pdf:43","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.1.6\n条件式と述語\nこの時点で私達が定義可能な種類の手続の表現力はとても限られています。\nテストを作成し、テストの結果により異なる命令を実行する方法が無いためで\nす。例えば数値の絶対値を演算する手続を定義できません。数値が正、負、零\nであるかテストを行いルールに従い異なる場合に対し異なる行動をしなければ\nなりません。\n|푥| =\n⎧\n{\n⎨\n{\n⎩\n푥    푖푓    푥 > 0,\n0    푖푓    푥 = 0,\n−푥    푖푓    푥 < 0.\nこの考えは\ncase analysis\n(\nケース分析、\n事例分析\n)\nと呼び\nLisp\nにはそのよう\nなケース分析のための特別な形式が存在します。\ncond\n(“conditional”(\n条件文\n)\nを表わす\n)\nと呼ばれ、以下のように利用されます。\n(\ndefine\n(\nabs\nx\n)\n(\ncond\n((>\nx\n0)\nx\n)\n((=\nx\n0) 0)\n((<\nx\n0) (-\nx\n))))\n条件式の一般的な形式は以下のとおりです。\n(\ncond\n(\n⟨푝\n1\n⟩\n⟨푒\n1\n⟩\n)\n(\n⟨푝\n2\n⟩\n⟨푒\n2\n⟩\n)\n...\n(\n⟨푝\n푛\n⟩\n⟨푒\n푛\n⟩\n))\n記号\ncond\nから構成され、続く括弧で括った複数の式のペア\n(\n⟨푝⟩\n⟨푒⟩\n)\nclauses\n(\nクローズ\n、節\n)\nと呼ばれます。各ペアの最初の式は\npredicate\n(\n述語\n) —\n値\nが真か偽になる式です。\n17\n17\n“\n真か偽のどちかに解釈される\n”\nとは次を意味します。\nScheme\nでは\n2\nつの区別され\nる値が存在し、それらは\n#t\nと\n#f\nの定数で示されます。インタプリタが述語の値をチェ\nックする時、\n#f\nを偽と訳します。それ以外の任意の値は全て真だと扱われます。\n(\n従って\n#t\nを与えることは論理的には必要ありません。しかしそのほうが便利です。\n)\nこの本で\nは\ntrue\nと\nfalse\nという名前を用います。それらは\n#t\nと\n#f\nという値にそれぞれ関連付\nけられます。\n17","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":43},{"id":"./test/fixtures/pdf/sicp.pdf:44","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"条件式は次のように評価されます。まず述語\n⟨푝\n1\n⟩\nが最初に評価されます。\nもしその値が偽であれば次に\n⟨푝\n2\n⟩\nが評価されます。もし\n⟨푝\n2\n⟩\nの値もまた偽で\nあるならば、その次は\n⟨푝\n3\n⟩\nが評価されます。この過程は値が真となる述語が見\nつかるまで続きます。その場合インタプリタは対応するクローズの\nconsequent\nexpression\n(\n結果式\n)\n⟨푒⟩\nの値が条件式の値として返されます。もし真となる\n⟨푝⟩\nが見つからない場合には\ncond\nの値は未定義です。\n述語という単語は真か偽を返す手続に利用されます。真か偽と評価される\n式にも用いられます。絶対値の手続\nabs\nはプリミティブな述語\n>\n,\n<\n,\n=\nを利用し\nます。\n18\nこれらは\n2\nつの数値を引数として取り最初の数が\n2\nつ目の数に対し式の順\nに、より大きい、より小さい、等しいかどうかテストを行い適宜に真か偽を返\nします。\n絶対値の手続を書くもう\n1\nつの方法が次です。\n(\ndefine\n(\nabs\nx\n)\n(\ncond\n((<\nx\n0) (-\nx\n))\n(\nelse\nx\n)))\nこれは日本語で\n“\nもし\n푥\nが零より小さい場合\n−푥\nを返す。そうでなければ\n푥\nを\n返す\n”\nと表現できます。\nelse\nは特別なシンボルで\ncond\nの最後の節\n(\nクローズ\n)\nの\n⟨푝⟩\nの場所にて利用可能です。こうすることで\ncond\nがその値として対応す\nる\n⟨푒⟩\nの値をそれ以前のクローズ全てが回避された場合に返すことが可能で\nす。本当の所はここで\n⟨푝⟩\nに常に値が真となる任意の式を使用することも可能\nです。\n次はさらにもう\n1\nつ別の絶対値手続の書き方です。\n(\ndefine\n(\nabs\nx\n)\n(\nif\n(<\nx\n0)\n(-\nx\n)\nx\n))\nこれは特別な形式の\nif\nという制約のある条件の型を使用しており、ケース分\n析にて正確に\n2\nつのケースが存在する場合に用います。\nif\n式の一般的な形式は\n以下のとおりです。\n(\nif\n⟨\npredicate\n⟩\n⟨\nconsequent\n⟩\n⟨\nalternative\n⟩\n)\n18\nabs\nはまた\n“\nマイナス\n”\n演算子\n-\nを使用します。\n(- x)\nのように単一のオペランドに\n利用された時、符号の反転を示します。\n18","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":44},{"id":"./test/fixtures/pdf/sicp.pdf:45","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"if\n式を評価するためにインタプリタは式の\n⟨\npredicate\n⟩\nの部分を評価すること\nから始めます。もし\n⟨\npredicate\n⟩\nの評価が真値になる場合、インタプリタは次に\n⟨\nconsequent\n⟩\nを評価しその値を返します。そうでなければ\n⟨\nalternative\n⟩\nを評価\nしその値を返します。\n19\n<\nや\n=\n,\n>\nのようなプリミティブな述語に追加して論理複合命令が存在し、\n複合述語を構築することを可能にします。最も良く利用される\n3\nつは以下の物\nです。\n•\n(and\n⟨푒\n1\n⟩   ...   ⟨푒\n푛\n⟩\n)\nインタプリタは式\n⟨푒⟩\nを左から右へ\n1\nつずつ評価します。もし\n⟨푒⟩\nのど\nれかが偽と評価された場合\nand\n式の値は偽となり、残りの\n⟨푒⟩\nは評価さ\nれません。もし全ての\n⟨푒⟩\nの評価が真となれば\nand\n式の値は最後の値に\nなります。\n•\n(or\n⟨푒\n1\n⟩   ...   ⟨푒\n푛\n⟩\n)\nインタプリタは式\n⟨푒⟩\nを\n1\nつずつ左から右へ評価します。もし\n⟨푒⟩\nのど\nれかが真と評価されればその値が\nor\n式の値として返され、\n⟨푒⟩\nの残りは\n評価されません。もし全ての\n⟨푒⟩\nが偽と評価された場合、\nor\nの値は偽と\nなります。\n•\n(not\n⟨푒⟩\n)\nnot\n式の値は式\n⟨푒⟩\nが偽と評価される時は真であり、そうでなければ偽\nとなります。\nand\nと\nor\nが特別な形式であり手続ではないことに注意して下さい。部分式が\n全て評価される必要が無いためです。\nnot\nは通常の手続です。\nこれらがどのように利用されるかの例として、数値\n푥\nが\n5 < 푥 < 10\nの値域\nに存在するかという条件は次のように表現されます。\n(\nand\n(>\nx\n5) (<\nx\n10))\n別の例として、ある数値が別の数値に対し等しいかより大きいかを示す述語は\n以下の通りです。\n(\ndefine\n(>=\nx\ny\n) (\nor\n(>\nx\ny\n) (=\nx\ny\n)))\n19\nif\nと\ncond\nの小さな違いは\ncond\nの各クローズの\n⟨푒⟩\nは連続する式になっても良いこ\nとです。もし対応する\n⟨푝⟩\nが真になる場合、\n⟨푒⟩\n内の式は順に評価され連なりの最後の式\nの値が\ncond\nの値として返されます。しかし\nif\n式の中では\n⟨\nconsequent\n⟩\nと\n⟨\nalternative\n⟩\nは単一の式でなければなりません\n19","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":45},{"id":"./test/fixtures/pdf/sicp.pdf:46","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"または代替法として\n(\ndefine\n(>=\nx\ny\n) (\nnot\n(<\nx\ny\n)))\nExercise 1.1:\n以下の一連の式について、各式に対するインタプリ\nタの応答としての表示結果は何か\n?\n式の列は下記に表示された順\nで評価されるものと考えよ。\n10\n(+ 5 3 4)\n(- 9 1)\n(/ 6 2)\n(+ (* 2 4) (- 4 6))\n(\ndefine\na\n3)\n(\ndefine\nb\n(+\na\n1))\n(+\na\nb\n(*\na\nb\n))\n(=\na\nb\n)\n(\nif\n(\nand\n(>\nb\na\n) (<\nb\n(*\na\nb\n)))\nb\na\n)\n(\ncond\n((=\na\n4) 6)\n((=\nb\n4) (+ 6 7\na\n))\n(\nelse\n25))\n(+ 2 (\nif\n(>\nb\na\n)\nb\na\n))\n(* (\ncond\n((>\na\nb\n)\na\n)\n((<\na\nb\n)\nb\n)\n(\nelse\n-1))\n(+\na\n1))\nExercise 1.2:\n以下の式を接頭辞形式にて翻訳せよ\n5 + 4 + (2 − (3 − (6 +\n4\n5\n)))\n3(6 − 2)(2 − 7)\n.\nExercise 1.3:\n3\nつの数値を引数として取り、内\n2\nつの大きな数値\nの二乗の和を返す手続を定義せよ。\n20","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":46},{"id":"./test/fixtures/pdf/sicp.pdf:47","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 1.4:\n我々の評価モデルがオペレータが複合式である組み\n合わせを可能にすることを観察せよ。この観察結果を用いて次の\n手続の挙動を説明せよ\n:\n(\ndefine\n(\na-plus-abs-b\na\nb\n)\n((\nif\n(>\nb\n0) + -)\na\nb\n))\nExercise 1.5:\nBen Bitdiddle\nは自分が直面するインタプリタが適用\n順評価と正規順評価のどちらを用いるか決定するテストを開発し\nた。まず以下の\n2\nつの手続を定義する。\n(\ndefine\n(\np\n) (\np\n))\n(\ndefine\n(\ntest\nx\ny\n)\n(\nif\n(=\nx\n0) 0\ny\n))\n次に以下の式を評価する。\n(\ntest\n0 (\np\n))\nBen\nは適用順評価を用いるインタプリタではどのような挙動を観\n察するだろうか\n? Ben\nは正規順評価を用いるインタプリタではど\nのような挙動を観察するだろうか\n?\nあなたの回答を説明せよ。\n(\n特別\n形式の\nif\nはインタプリタが適用順評価でも正規順評価でも同じ挙\n動を行うと仮定せよ\n:\n述語式が最初に評価され、結果が\nconsequent\nと\nalternative\nのどちらを評価するか決定する\n)\n1.1.7\n例\n:\nニュートン法による平方根\nここまでで説明された通り、手続は普通の数学の関数にとても似ています。\n手続は\n1\nつ以上のパラメタにより決定される値を特定します。しかし数学の関\n数と計算機の手続の間には重要な違いが存在します。手続は効果的である必要\nがあります。\nその一例として、平方根の演算問題について考えましょう。\nsquare-root\n関\n数を以下のように定義できます。\n√\n푥  =   푡ℎ푒  푦  푠푢푐ℎ  푡ℎ푎푡  푦 ≥ 0  푎푛푑  푦\n2\n= 푥.\nこれは完全に正しい数学の関数です。これを用いてある数値が他の数値の\n平方根であるか分かりますし、平方根の一般的な事実を導出可能です。しかし\n21","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":47},{"id":"./test/fixtures/pdf/sicp.pdf:48","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"一方でこの定義は手続の記述ではありません。与えられた数値から実際どのよ\nうにして平方根を求めるのか、これはほとんど何も教えてくれません。この定\n義を疑似\nLisp\nにて言い換えようとも問題の何の手助けにもなりません。\n(\ndefine\n(\nsqrt\nx\n)\n(\nthe\ny\n(\nand\n(>=\ny\n0)\n(= (\nsquare\ny\n)\nx\n))))\nこれはただ問題を提起するだけです。\n関数と手続の間の対称性は事物の属性の説明と行いの説明との間の一般的\n区別に関する反映です。または時には宣言的知識と手続的知識の間の区別だと\n参照できるでしょう。数学では通常宣言的\n(what is)\n記述を用い、コンピュー\nタサイエンスでは通常手続的\n(how to)\n記述を用います。\n20\n人はどのようにして平方根を求めることができるのでしょうか\n?\n最も一般\n的な方法はニュートンの漸次接近法を用いる方法です。ニュートン法はある数\n値\n푥\nの平方根の推定値として\n푦\nを持つ場合に、より良い推定値\n(\n実際の平方根\nにより近い値\n)\nを求めるために\n푦\nと\n푥/푦\nの平均を取るという簡単な操作を実行\nします。\n21\n例として、\n2\nの平方根は以下のようにして求められます。推定値の\n初期値を\n1\nとします\n:\n推定値  商\n平均\n1\n(2/1) = 2\n((2 + 1)/2) = 1.5\n1.5\n(2/1.5) = 1.3333\n((1.3333 + 1.5)/2) = 1.4167\n1.4167    (2/1.4167) = 1.4118    ((1.4167 + 1.4118)/2) = 1.4142\n1.4142    ...\n...\n20\n宣言的、手続的記述は数学とコンピュータサイエンスのように実際に深く関わって\nいます。例えばプログラムの生成した答が\n“\n正しい\n”\nということはプログラムについて宣\n言的な文を作成することです。プログラムが正しいことを証明するための立証技術を目\n的とした非常に多くの研究が存在します。この問題の技術的難度の多くは\n(\nプログラムが\n構築される\n)\n手続的文と\n(\n事象を推論するのに用いられる\n)\n宣言的文との間の移行に関連\nします。関連領域において、プログラミング言語の設計における現在の重要な領域は超\n高水準言語と呼ばれる物の調査です。それは実際にプログラムを宣言的文の用語にて作\n成します。その意図はインタプリタを十分に洗練することでプログラマより与えられた\n“what is”\nの知識より\n“how to”\nの知識を自動的に生成可能とします。これは一般的には\n可能ではありませんが、成果が達成された重要な領域が存在します。この考え方につい\nては\nChapter 4\nにて再度触れることに致します。\n21\nこの平方根アルゴリズムは実際にはニュートン法の特別なケースです。ニュートン\n法は方程式の根を求める一般的な技法です。平方根アルゴリズム自体はアレキサンドリ\nアの\nHeron\nにより\na.d.\n1\n世紀に開発されました。一般的なニュートン法を\nLisp\nの手続に\nよりどのように表わすかについては\nSection 1.3.4\nにて学びます。\n22","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":48},{"id":"./test/fixtures/pdf/sicp.pdf:49","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この過程を繰り返すことにより平方根のより良い近似値を得られます。\nでは手続の表現にてこの過程を形式化してみましょう。\nradicand(\n被開法数\n:\n根号の中身。平方根を求める値\n)\nと\nguess(\n推定値\n)\nを用います。もし推定値の品\n質が十分であれば終了します。そうでなければ処理をより良い推定値にて繰り\n返さなければなりません。この基本的戦略を手続として以下のように記述しま\nした。\n(\ndefine\n(\nsqrt-iter\nguess\nx\n)\n(\nif\n(\ngood-enough?\nguess\nx\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\nx\n)\nx\n)))\n推定値は旧推定値と商の平均を取ることで改善されます。\n(\ndefine\n(\nimprove\nguess\nx\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\naverage\nの定義は以下です。\n(\ndefine\n(\naverage\nx\ny\n)\n(/ (+\nx\ny\n) 2))\n“\n十分に良い\n”\nの定義を決めねばなりません。以下に説明しますが、これは本当\nはあまり良いテストではありません。\n(\nExercise 1.7\nをご覧下さい\n)\n考え方は回\n答を十分に近い値にするために、その二乗と被開法数の差が事前に決定した許\n容誤差\n(\nここでは\n0.001)\nより小さくなるまで改善します。\n22\n(\ndefine\n(\ngood-enough?\nguess\nx\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n最後にどのように始めるかが必要です。例えば任意の数値の平方根の推定値を\n常に\n1\nとすることも可能です。\n23\n22\n通常は述語にはクエスチョンマークで終わる名前を与えます。そうすることでそれ\nが述語だと理解できるようにです。これは単にスタイル上の慣例です。インタプリタの\n受け取り方に関する限り、クエスチョンマークは通常の文字でしかありません。\n23\n推定値の初期値を\n1\nではなく\n1.0\nと表現していることに注意して下さい。これは多\nくの\nLisp\nの実装では何の違いもありません。しかし\nmit\nScheme\nは整数と少数の値を\n厳格に区別します。\n2\nつの整数を割ると少数ではなく分数を返します。例として\n10\nを\n6\nで割ると\n5/3\nを返します。しかし\n10.0\nを\n6.0\nで割れば\n1.6666666666666667\nを返すので\nす。\n(\n分数の演算の実装法については\nSection 2.1.1\nで学びます。\n)\nもし推定値の初期値を\nsquare-root\nプログラムにおいて\n1\nにして開始した場合、\n푥\nも実際に整数である場合には\n23","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":49},{"id":"./test/fixtures/pdf/sicp.pdf:50","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nsqrt\nx\n)\n(\nsqrt-iter\n1.0\nx\n))\nこの定義をインタプリタに入力すれば\nsqrt\nを他の手続のように利用可能です。\n(\nsqrt\n9)\n3.00009155413138\n(\nsqrt\n(+ 100 37))\n11.704699917758145\n(\nsqrt\n(+ (\nsqrt\n2) (\nsqrt\n3)))\n1.7739279023207892\n(\nsquare\n(\nsqrt\n1000))\n1000.000369924366\nsqrt\nプログラムはまた私達がここまでで紹介した単純な手続き型言語が\nC\nや\nPascal\nで記述可能などんな純粋数値演算プログラムを書くのにも十分であるこ\nとを示しています。これには驚かれるかもしれません。私達はまだコンピュー\nタに何かを繰り返し繰り返し行わせるどのような繰り返し\n(\nループ\n)\n要素もこ\nの言語には入れていないためです。一方で\nSqrt-iter\nはどのように繰り返しが\n特別な記法を全く使わずに通常の手続呼出能力のみで成し遂げられるかを実演\nして見せています。\n24\nExercise 1.6:\nAlyssa P. Hacker\nはなぜ\nif\nが特別形式として提供さ\nれる必要があるのか理解できなかった。\n“\nなぜ\ncond\nを用いた通常\n手続として定義できないのだろう\n?”\nと彼女は訝った。\nAlyssa\nの友\n達である\nEva Lu Ator\nはこれは実際にできると主張し、\nif\nの新バ\nージョンを定義した。\n(\ndefine\n(\nnew-if\npredicate\nthen-clause\nelse-clause\n)\n(\ncond\n(\npredicate\nthen-clause\n)\n(\nelse\nelse-clause\n)))\n全ての続く\nsquare-root\nの演算により生成される値は少数ではなく分数になります。分\n数と少数を混ぜた演算は少数を返します。従って推定値の初期値を\n1.0\nにすることで全\nての続く値を少数にすることが可能です。\n24\n反復実装における手続呼出上の効率の問題を気にされている読者の方は\nSection\n1.2.1\nの\n“\n末尾再帰\n”\n上の備考に注目して下さい\n24","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":50},{"id":"./test/fixtures/pdf/sicp.pdf:51","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Eva\nは\nAlyssa\nに対してプログラムのデモを行った。\n(\nnew-if\n(= 2 3) 0 5)\n5\n(\nnew-if\n(= 1 1) 0 5)\n喜びながら\nAlyssa\nは\nnew-if\nを用いて\nsquare-root\nプログラムを書\nき直した。\n(\ndefine\n(\nsqrt-iter\nguess\nx\n)\n(\nnew-if\n(\ngood-enough?\nguess\nx\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\nx\n)\nx\n)))\nAlyssa\nが平方根の計算にこれの使用を試した時に何が起こるだろ\nうか\n?\nExercise 1.7:\n平方根の演算で使用された\ngood-enough?\nテストは\nとても小さい数値の平方根を見つける場合にはあまり効果的では\nないだろう。また実際のコンピュータでは数値演算命令はほとん\nど常に精度に制限のある状態で実行される。これが我々のテスト\nをとても大きな数値に対して不適切にする。ここまでの記述につ\nいてテストがどのように小さな値と大きな値にて失敗するか例を\n用いて説明せよ。\ngood-enough?\n実装の代替戦略は\nguess\nがある試\n行から次に向けどのように変化するか監視し、変化が推定値の割\n合においてとても小さい時に止めることである。このような終了\nテストを用いる\nsquare-root\nを設計せよ。これは小さな、及び、大\nきな数値に対してより良く働くだろうか\n?\nExercise 1.8:\n立方根に対するニュートン法は\n푦\nが\n푥\nの立方根であ\nる場合において以下の値により良く近似される。\n푥/푦\n2\n+ 2푦\n3\n.\nこの式を用いて\nsquare-root\nに類似した\ncube-root\nを実装せよ。\n(\nSection 1.3.4\nにてこれらの\nsquare-root\nと\ncube-root\nの抽象化とし\nての汎用なニュートン法の実装方法を学習します。\n)\n25","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":51},{"id":"./test/fixtures/pdf/sicp.pdf:52","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"sqrt\n|\nsqrt-iter\n/\n\\\ngood-enough    improve\n/     \\\n\\\nsquare    abs\naverage\nFigure 1.2:\nsqrt\nプログラムの手続分解\n1.1.8\nブラックボックス抽象化としての手続\nsqrt\nは私達にとり相互に定義された手続の集合により定義されたプロセス\nの例でした。\nsqrt-iter\nの定義が\nrecursive\n(\n再帰的\n)\nであることに注意して下さ\nい。再帰とは手続がそれ自身の語により定義されていることです。手続をそれ\n自体の名前を用いて定義する考え方は不安になるかもしれません。そのような\n“\n循環的\n”\nな定義がどのようにしてつじつまを合わせるのか全く不明に見える\nかもしれません。コンピュータにより実行するために良く定義された手続には\n指定が足りなく見えるかもしれません。これについては\nSection 1.2\nにてより注\n意深く触れることにします。最初はしかし\nsqrt\nの例にて説明されたいくつか\n別の重要な点について考えましょう。\n平方根を演算する問題が自然にいくつかの部分的な問題へ分割されること\nに注意して下さい。推定値が十分に良いかどのように判断するか、推定値をど\nのように改善するか、等です。これらのタスクの\n1\nつ\n1\nつは分離された手続に\nより達成されます。\nsqrt\nプログラム全体は\n(\nFigure 1.2\nにて表される\n)\n手続の群\nれに見てとることが可能です。この図が問題を部分問題へと分解することを映\nし出しています。\nこの分解戦略の重要性はプログラムを部分\n—\n最初の\n10\n行、次の\n10\n行、その他\nへと分割するような単純なものではありません。そうではなく、各手続が他の\n手続の定義にてモジュールとして利用可能な特定のタスクを担うことが不可欠\nです。例えば\ngood-enough?\n手続を\nsquare\nの語を用いて定義する時、\nsquare\n手続を\n“\nブラックボックス\n”\nとして考えることが可能です。その時、その手続\nがどのように結果を計算するのか気にしていません。それが二乗を計算すると\nいう事実のみです。二乗がどのように計算されるかという詳細は隠し、後の時\n点で考慮することが可能です。実際に\ngood-enough?\n手続について考える限り、\n26","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":52},{"id":"./test/fixtures/pdf/sicp.pdf:53","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"square\nは手続では無く手続の抽象化に過ぎないのです。\n手続の抽象化\nと呼ば\nれるものです。この抽象化のレベルでは二乗を計算するどんな手続も等しく相\n応しいのです。\n従って返り値のみを考えるため、以下の\n2\nつの二乗する手続は区別不可能\nとなります。それぞれが数値の引数を取りその数値の二乗を値として生成しま\nす。\n25\n(\ndefine\n(\nsquare\nx\n) (*\nx\nx\n))\n(\ndefine\n(\nsquare\nx\n) (\nexp\n(\ndouble\n(\nlog\nx\n))))\n(\ndefine\n(\ndouble\nx\n) (+\nx\nx\n))\n従って手続定義は詳細を隠すことができなければなりません。手続のユーザは\nその手続を彼等自身で書いたとは限りません。しかし他のプログラマからブラ\nックボックスとして取得したかもしれません。ユーザはその手続がどのように\n実装されているのかそれを使用するためには知る必要が無いのです。\nローカル名\n手続のユーザにとっては問題とならない手続実装の詳細の\n1\nつには手続の\n形式パラメタに対する実装者が選択した名前があります。従って以下の異なる\n手続は区別不可能でなければなりません。\n(\ndefine\n(\nsquare\nx\n) (*\nx\nx\n))\n(\ndefine\n(\nsquare\ny\n) (*\ny\ny\n))\nこの指針\n—\n手続の意味はその作者が使用したパラメタの名前から独立すべき\nである\n—\nは表面上では自明なことに思えますがそこから導きださえる結論は\n重要です。最も単純な結論は手続のパラメタ名はその手続のボディに対してロ\nーカルであるべきというものです。例えば、まず\nsquare-root\n手続の中の\ngood-\nenough?\nの定義においては\nsquare\nを使用しました。\n(\ndefine\n(\ngood-enough?\nguess\nx\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n))\n0.001))\n25\nこれら手続のどちらがより効率的な実装であるかは全く明確ではありません。これ\nは実行環境依存です。\n“\n明白な\n”\n実装が効率的ではない機械が存在します。広範な対数と\n逆対数のテーブルをとても効率の良い方法で持つ機械について考えてみて下さい\n27","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":53},{"id":"./test/fixtures/pdf/sicp.pdf:54","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"good-enough?\nの作者の意図する所は第一引数の二乗が第二引数にて与えられ\nた許容差の範囲であるかを決定することです。\ngood-enough?\nの作者が\nguess\nを第一引数の参照に用い\nx\nを第二引数に用いたことが見てとれます。\nsquare\nの\n引数は\nguess\nです。もし\nsquare\nの作者が\nx\nを\n(\n上で見たように\n)\n使用した場合\ngood-enough?\nの\nx\nは\nsquare\nの\nx\nとは異ならなければならないことがわかりま\nす。手続\nsquare\nの実行は\ngood-enough?\nの\nx\nの値に影響を与えてはいけませ\nん。なぜならその\nx\nの値は\nsquare\nが演算を終えた後にも\ngood-enough?\nにて\n必要だからです。\nもしパラメタがそれらが関連する手続のボディに対してローカルでない場\n合、\nsquare\nのパラメタ\nx\nは\ngood-enough?\nのパラメタ\nx\nと混同される可能性が\nあります。そして\ngood-enough?\nの挙動はどのバージョンの\nsquare\nを利用す\nるかに依存するでしょう。従って\nsquare\nは私達が望んだブラックボックスで\nはなくなるでしょう。\n手続の形式パラメタは手続定義においてとても特別な役割を持ちます。形\n式パラメタにはどんな名前を用いてもかまわないのです。そのような名前\nは\nbound variable\n(\n束縛変数\n)\nと呼ばれます。そして手続定義はその形式パラメ\nタを\nbinds\n(\n束縛\nする\n)\nと呼びます。もし束縛変数が静的に定義中においてリネ\nームされても手続定義の意味は変わりません。\n26\nもし変数が束縛されていなけ\nればそれは\nfree\n(\n自由\n)\nだと呼びます。束縛が名前を定義する式の集合はその名\n前の\nscope\n(\nスコープ\n)\nと呼ばれます。手続定義においてはその手続の形式パラ\nメタとして宣言された束縛変数はその手続のボディをそのスコープとします。\n上記の\ngood-enough?\nの定義において、\nguess\nと\nx\nは束縛変数ですが、\n<\n,\n-\n,\nabs\n,\nsquare\nは自由です。私達が選んだ\nguess\nと\nx\nの名前が、\n<\n,\n-\n,\nabs\n,\nsquare\nと異なり区別可能である限り、\ngood-enough?\nの意味はそれらの名前か\nら独立せねばなりません。\n(\nもし\nguess\nを\nabs\nにリネームした場合、変数\nabs\nを\ncapturing\n(\n占領\n)\nすることでバグを持ち込むことになるでしょう。自由変数を\n束縛に変化させます\n)\nしかしながら\ngood-enough?\nの意味はその自由変数の名\n前からは独立していません。記号\nabs\nは\n(\nこの定義の外部の\n)\n数値の絶対値を求\nめる手続に名付けられているという事実に当然、依存します。もし\ncos\nを\nabs\nにその定義において置き換えれば\ngood-enough?\nは異なる関数を計算すること\nでしょう。\n26\n静的なリネームのコンセプトは実際には微妙で正式に定義するのは難しいことです。\n有名な論理学者達も恥しい間違いをここで犯してきました\n28","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":54},{"id":"./test/fixtures/pdf/sicp.pdf:55","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"内部定義とブロック構造\n私達は今の所、一種類の名前の分離について学びました。手続の形式パラ\nメタは手続のボディに対してローカルです。\nsquare-root\nプログラムは我々が望\nむだろう名前使用をコントロールする別な方法を示します。\n(\ndefine\n(\nsqrt\nx\n)\n(\nsqrt-iter\n1.0\nx\n))\n(\ndefine\n(\nsqrt-iter\nguess\nx\n)\n(\nif\n(\ngood-enough?\nguess\nx\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\nx\n)\nx\n)))\n(\ndefine\n(\ngood-enough?\nguess\nx\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n(\ndefine\n(\nimprove\nguess\nx\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\nこのプログラムの問題は\nsqrt\nのユーザにとって重要な手続は\nsqrt\nのみである\nことです。他の手続\n(\nsqrt-iter\n,\ngood-enough?\n,\nimprove\n)\nは彼らにとって余計\nなものです。ユーザは他に\ngood-enough?\nという名の手続を、\nsquare-root\nプロ\nグラムと一緒に使用する他のプログラムの一部として定義することができませ\nん。なぜなら\nsqrt\nがそれを必要とするからです。この問題は多くの異なるプロ\nグラマにより巨大システムを構築する場合に特に深刻な問題となります。例え\nば数値演算の巨大ライブラリの構築において、多くの数値演算関数は一連の近\n似値演算として計算されるため補助的な手続として\ngood-enough?\nと\nimprove\nと名付けられた手続を持つかもしれません。私達は部分手続を局所化し\nsqrt\nの中に隠したいと思うでしょう。そうすれば\nsqrt\nが他の一連の近似値演算と\n共存し、それぞれが自身のプライベートな\ngood-enough?\n手続を持つことがで\nきます。これを可能にするために手続はその手続に対して局所的な内部定義を\n持つことが可能です。例えば\nsqaure-root\nプログラムは以下のように書き換え\nることが可能です。\n(\ndefine\n(\nsqrt\nx\n)\n(\ndefine\n(\ngood-enough?\nguess\nx\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n(\ndefine\n(\nimprove\nguess\nx\n) (\naverage\nguess\n(/\nx\nguess\n)))\n(\ndefine\n(\nsqrt-iter\nguess\nx\n)\n(\nif\n(\ngood-enough?\nguess\nx\n)\n29","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":55},{"id":"./test/fixtures/pdf/sicp.pdf:56","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"guess\n(\nsqrt-iter\n(\nimprove\nguess\nx\n)\nx\n)))\n(\nsqrt-iter\n1.0\nx\n))\nこのような定義の入れ子は\nblock structure\n(\nブロック構造\n)\nと呼ばれ、最も単純\nな名前パッケージ問題解決に基本的に正しい解決方法です。しかしより良いア\nイデアがここに隠れています。補助的な手続を内在化させることに加えてそれ\nらを簡潔化することができます。\nx\nは\nsqrt\nに束縛されているため、\nsqrt\nの内\n部に定義された手続\ngood-enough?\n,\nimprove\n,\nsqrt-iter\nは\nx\nのスコープ内に\nあります。従って\nx\nを明示的にこれらの手続それぞれに渡す必要はありません。\nその代わりに\nx\nを以下で示すように内部の定義にて自由変数にすることができ\nます。そして\nx\nは包括する手続\nsqrt\nが呼ばれた時にその値を得ます。このよ\nうな規律を\nlexical scoping\n(\nレキシカルスコープ\n)\nと呼びます。\n27\n(\ndefine\n(\nsqrt\nx\n)\n(\ndefine\n(\ngood-enough?\nguess\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n(\ndefine\n(\nimprove\nguess\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\n(\ndefine\n(\nsqrt-iter\nguess\n)\n(\nif\n(\ngood-enough?\nguess\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\n))))\n(\nsqrt-iter\n1.0))\nブロック構造は巨大なプログラムを取扱の簡単な部品に分割するために広範囲\nにて利用されます。\n28\nブロック構造の考え方はプログラミング言語\nAlgol 60\nに起源を持ちます。多くの先進的なプログラミング言語に存在し、巨大プログ\nラム構築の体系化を手助けする重要なツールです。\n27\nレキシカルスコープは手続内の自由変数が包括する手続定義により作られた束縛を\n参照するため用いられるよう指示します。それはつまり、手続が定義された環境の中で\nそれらが探されることを意味します。これがどのように働くのか、その詳細については\n第\n3\n章にて環境とインタプリタの詳細な挙動について学ぶ時に理解します。\n28\n組込定義は手続本体の最初に来なければなりません。相互依存の定義と使用を行う\nプログラムの実行結果についてはこのような管理も責任を持つことができません\n30","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":56},{"id":"./test/fixtures/pdf/sicp.pdf:57","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.2\n手続とそれが生成するプロセス\n私達はプログラミングの要素について考えてきました。プリミティブな算\n術演算子を用いこれらの演算子を組み合わせ、その合成演算子を複合手続とし\nて定義することで抽象化を行ってきました。しかしそれらは私達がプログラム\nをどのように書くか知っていると言えるためには十分ではありません。私達の\n状況はチェスにおいて各駒がどのように動くのかルールを覚えたが典型的な序\n盤や戦術、戦略について何も知らない人に似ています。チェスの初心者棋士の\nように、私達はまだこの領域での慣習としての一般的パターンを知りません。\n私達はどの手が打つ価値があるのか\n(\nどの手続が定義する価値があるのか\n)\nの\n知識を欠いています。打った手の\n(\n手続実行の\n)\n結果を予想する経験を欠いてい\nます。\n熟慮下の行動の結果を思い描く能力はエキスパートプログラマになるため\nに重大です。それはどんな統合的、かつ創造的な活動についても同じです。熟\n練の写真家になるには例えば、景色の見方を学び、各可能な露出と現像条件の\n組み合わせにおいて各領域がどれだけ暗く写真に表れるかを知らなければなり\nません。そうして初めてフレームの計画、光量、露出、現像を逆向きに推測し\nて望んだ効果を得ることが可能となります。プログラミングにおいてもまた同\nじです。プロセスが取り得る行動がどのような進行を経るのか計画し、プログ\nラムを用いてプロセスをコントロールします。\nエキスパートになるためには、数多くの種類の手続により生成されるプロ\nセスを心に描けられるようにならなければなりません。そのようなスキルを開\n発した後に初めて望んだ挙動を示すプログラムを信頼できる形で構築する方法\nを学ぶことが可能になります。\n手続は計算過程の\nlocal evolution\n(\n局所展開\n)\nのためのパターンです。プロセ\nスの各ステージが以前のステージの上にどのように構築されるかを指定します。\nここで手続により局所展開が指示されたプロセスの全体的な、または\nglobal\n(\n大\n域的\n)\nな挙動について説明を行えればと思います。しかしこれは一般的にはと\nても難しいので、最低でもいくつかのプロセス展開の典型的パターンについて\n説明することを試してみましょう。\nこの節では簡単な手続により生成されたプロセスのためのいくつかの共通\nな\n“\n形\n”\nについて検討してみます。またこれらのプロセスが時間と記憶域の重\n要な計算資源をどの程度消費するかについても調査してみます。ここで考慮す\nる手続はとても簡単なものです。それらの役割は写真撮影におけるテストパタ\nーンにより演じられる様なものです。非常に単純化した原型的なパターンであ\nり、それら自身の目的に沿った現実的な例ではありません。\n31","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":57},{"id":"./test/fixtures/pdf/sicp.pdf:58","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(factorial 6)\n(* 6 (factorial 5))\n(* 6 (* 5 (factorial 4)))\n(* 6 (* 5 (* 4 (factorial 3))))\n(* 6 (* 5 (* 4 (* 3 (factorial 2)))))\n(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))\n(* 6 (* 5 (* 4 (* 3 (* 2 1)))))\n(* 6 (* 5 (* 4 (* 3 2))))\n(* 6 (* 5 (* 4 6)))\n(* 6 (* 5 24))\n(* 6 120)\n720 \nFigure 1.3:\n6!\nを求めるための線形再帰プロセス\n1.2.1\n線形再帰と反復\n階乗を求める関数を考えることから始めましょう。定義を以下に示します。\n푛! = 푛 ⋅ [(푛 − 1) ⋅ (푛 − 2) ... 3 ⋅ 2 ⋅ 1] = 푛 ⋅ (푛 − 1)!\n階乗を計算する方法は数多くあります。\n1\nつの方法は任意の正の整数\n푛\nに\nおいて、\n푛!\nは\n푛\nと\n(푛 − 1)!\nの積に等しいという観察結果を利用します。\n푛! = 푛 ⋅ [(푛 − 1)\ṅ\n(푛 − 2) ... 3 ⋅ 2 ⋅ 1] = 푛 ⋅ (푛 − 1)! .\n従って\n(푛 − 1)!\nを演算し、\n푛\nを掛けることで\n푛!\nを求めることが可能です。\nもし\n1!\nが\n1\nに等しいという規約を追加すればこの観察結果は直接手続に翻訳\nできます。\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1)\n1\n(*\nn\n(\nfactorial\n(-\nn\n1)))))\nSection 1.1.5\nの置換モデルを用いてこの手続が\n6!\nの計算を実行する様子を\nFigure 1.3\nに示すように観察できます。\n32","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":58},{"id":"./test/fixtures/pdf/sicp.pdf:59","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"では階乗の演算について異なる視点を得てみましょう。\n푛!\nを計算するルールを\n最初に\n1\nを\n2\nで掛け、その結果を\n3\nに掛け、次に\n4\nに掛け\n푛\nに辿り着くまで繰\nり返すと説明することも可能でした。より形式的には、積の実行と、\n1\nから\n푛\nまでカウントするカウンタとを一緒に保持します。カウンタと積は同時にある\nステップから次へとルールに従い変更されると言うことでこの演算を説明でき\nます。\nproduct\n←\ncounter\n*\nproduct\ncounter\n←\ncounter\n+ 1\nそして\n푛!\nとはカウンタが\n푛\nを越えた時点での積の値であると規定します。\n再び、今までの階乗を求める手続の説明を次のように書き換えられます。\n29\n(\ndefine\n(\nfactorial\nn\n)\n(\nfact-iter\n1 1\nn\n))\n(\ndefine\n(\nfact-iter\nproduct\ncounter\nmax-count\n)\n(\nif\n(>\ncounter\nmax-count\n)\nproduct\n(\nfact-iter\n(*\ncounter\nproduct\n)\n(+\ncounter\n1)\nmax-count\n)))\n前回と同じく、置換モデルを用いて\n6!\nの演算を\nFigure 1.4\nとして示します。\n2\nつのプロセスを比べてみて下さい。\n1\nつの見方としては、これらは全く異\nなるように見えます。両者は同じ数学の関数を同じ領域で計算し、それぞれが\n푛!\nを求めるのに\n푛\nに比例したステップ数を必要とします。実際に両者のプロ\nセスが全く同じ一連の乗算を実行し、全く折なじ一連の部分的な積を得ます。\n29\n実際のプログラムでは恐らく前の節で紹介したブロック構造を\nfact-iter\nの定義を\n隠すために用いるでしょう。\n(\ndefine\n(\nfactorial\nn\n)\n(\ndefine\n(\niter\nproduct\ncounter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\niter\n(*\ncounter\nproduct\n)\n(+\ncounter\n1))))\n(\niter\n1 1))\nここでそれを避けたのは一度に考えなければならなことを最小にするためです。\n33","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":59},{"id":"./test/fixtures/pdf/sicp.pdf:60","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(factorial 6)\n(fact-iter 1 1 6)\n(fact-iter 1 2 6)\n(fact-iter 2 3 6)\n(fact-iter 6 4 6)\n(fact-iter 24 5 6)\n(fact-iter 120 6 6)\n(fact-iter 720 7 6)\n720\nFigure 1.4:\n6!\nを求めるための線形反復プロセス\n一方で\n2\nつのプロセスの\n“\n形\n”\nを考えた時、全く異なった展開をしていること\nに気がつきます。\n最初のプロセスについて考えます。置換モデルが\nFigure 1.3\nで示す展開の後、収\n縮する形を明らかにします。展開は\ndeferred operations\n(\n遅延演算\n)\nの連鎖\n(\nこの\nケースでは乗算の連なり\n)\n構築プロセスとして起こります。収縮は演算が実際\nに実行されることにより起こります。このタイプのプロセス、遅延演算の連鎖\nとして示される物、は\nrecursive process\n(\n再帰プロセス\n)\nと呼ばれます。このプロ\nセスの実行にはインタプリタが後の実行ための操作の過程を記録する必要があ\nります。\n푛!\nの演算では遅延乗算の連鎖の流さ、それに従い追跡の必要な情報の\n量が、\n푛\nに従い線形に\n(\n푛\nに比例して\n)\nステップ数と同様に増加します。このよ\nうなプロセスは\nlinear recursive process\n(\n線形再帰プロセス\n)\nと呼ばれます。\n対照的に、\n2\nつ目のプロセスは展開も収縮もしません。各ステップにおいて\n追跡が必要な物はどの\n푛\nに対しても変数\nproduct\n,\ncounter\n,\nmax-count\nの現在\n値です。これを\niterative process\n(\n反復プロセス\n)\nと呼びます。一般的に、反復プ\nロセスは限られた数の\nstate variables\n(\n状態変数\n)\nにより状態が、集約されること\nが可能な物です。状態変数がプロセスが状態毎にどのように更新されるかとい\nう固定ルールとプロセスが停止する条件を指定する\n(\n任意の\n)\n終了試験と一緒\nに用います。\n푛!\nの演算では\n푛\nに従い必要なステップ数が線形に増加します。こ\nのようなプロセスは\nlinear iterative process\n(\n線形反復プロセス\n)\nと呼ばれます。\n2\nつのプロセスの対称性は他の見方もできます。反復の場合、プログラムの\n変数は任意のポイントにおいてプロセスの状態について完全な描写を提供しま\nす。もしステップの間で計算を停止した場合に、計算の再開を行うのに必要な\n全てはインタプリタに対し\n3\nつのプログラム変数の値を提供することです。再\n34","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":60},{"id":"./test/fixtures/pdf/sicp.pdf:61","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"帰プロセスではそうはいきません。この場合、いくつかの追加の\n“\n隠された\n”\n情\n報が存在し、インタプリタにより保持されており、プログラムの変数には保存\nされていません。その情報には遅延命令の連鎖を辿る中での\n“\nプロセスの現在\n地\n”\nが示されています。鎖が長い程、より多くの情報が保持される必要があり\nます。\n30\n反復と再帰の対称性において、再帰\nプロセス\nの概念と再帰\n手続\nの概念を混\n同しないように注意せねばなりません。私達が手続を再帰だと説明する時、手\n続の定義が\n(\n直接、または間接的に\n)\nその手続自身を参照するという構文上の\n事実を参照します。しかし私達がプロセスが以下のパターン、例えば、線形再\n帰に従うと説明する時、私達はプロセスがどのように展開するかについて話し\nており、手続がどのように書かれているかという構文については話していませ\nん。\nfact-iter\nのような再帰手続を反復プロセスの生成として参照することは\n当惑させるかもしれません。しかし、そのプロセスは実際に反復的です。その\n状態は\n3\nつの状態変数により完全に補足されインタプリタはプロセスを実行す\nるために\n3\nつの変数のみを追跡する必要があるのみです。\nプロセスとプロシジャ\n(\n手続\n)\nの区別が混乱を招き易いのは多く\n(Ada\nや\nPascal\n、\nC\n言語を含む\n)\n一般的言語の実装が例えプロセスが本質的に反復で記\n述されていても任意の再帰手続の逐次翻訳が手続呼出の回数に伴い多くのメモ\nリ容量を消費するためです。結果としてこれらの言語は反復プロセスのみを特\n別な目的の\n“\nループ構成概念\n”\nである\ndo\n,\nrepeat\n,\nuntil\n,\nfor\n,\nwhile\nのような\n物を用いて記述可能です。私達が\nChapter 5\nにて考える\nScheme\nの実装はこの短\n所を共有しません。例え反復プロセスが再帰手続により記述されていても定量\n的な記憶域にて実行します。この属性を持つ実装は\ntail-recursive\n(\n末尾再帰\n)\nと\n呼ばれます。末尾再帰の実装を用いれば反復は一般的な手続呼出メカニズムを\n用いて表現可能であり、特別な反復構成概念は構文糖としてのみ実益のあるも\nのとなります。\n31\n30\nChapter 5\nにてレジスタマシン上での手続の実装について議論する時に、任意の反復\nプロセスが\n“\nハードウェア内にて\n”\n固定数のレジスタ集合と補助的なメモリの無い機械で\nあると認識できることを学びます。対照的に、再帰プロセスを理解するには\nstack\n(\nスタッ\nク\n)\nとして知られる補助的なデータ構造が必要です。\n31\n末尾再帰は長い間コンパイラの最適化のための裏技として知られてきました。末尾\n再帰の一貫した意味論における基本は\nCarl\nHewitt (1977)\nにより与えられました。彼は\nそれを演算の\n“\nメッセージパッシング\n”\nモデルにて説明しました。\nChapter 3\nにて議論し\nます。これに影響を受けて、\nGerald Jay Sussman\nと\nGuy Lewis Steele Jr. (\nSteele and\nSussman 1975\n参照\n)\nは\nScheme\nのための末尾再帰インタプリタを構築しました。\nSteele\nは後に末尾再帰が手続呼出をコンパイルするのにどれだけ自然な方法の結果であるかを\n示しました\n(\nSteele 1977\n)\n。\nScheme\nの\nieee\n標準仕様は\nScheme\nの実装が末尾再帰である\n35","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":61},{"id":"./test/fixtures/pdf/sicp.pdf:62","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 1.9:\n次の\n2\nつの各手続は\n2\nつの正の整数を加算する手段\nを定義している。手続\ninc\nは引数を\n1\n増やし、\ndec\nは引数を\n1\n減\nらす。\n(\ndefine\n(+\na\nb\n)\n(\nif\n(=\na\n0)\nb\n(\ninc\n(+ (\ndec\na\n)\nb\n))))\n(\ndefine\n(+\na\nb\n)\n(\nif\n(=\na\n0)\nb\n(+ (\ndec\na\n) (\ninc\nb\n))))\n置換モデルを用いて各手続が\n(+ 4 5)\nの評価において生成するプ\nロセスを図示せよ。これらのプロセスは反復であるか、再帰であ\nるか\n?\nExercise 1.10:\n以下の手続はアッカーマン関数と呼ばれる数学の関\n数を計算する。\n(\ndefine\n(\nA\nx\ny\n)\n(\ncond\n((=\ny\n0) 0)\n((=\nx\n0) (* 2\ny\n))\n((=\ny\n1) 2)\n(\nelse\n(\nA\n(-\nx\n1) (\nA\nx\n(-\ny\n1))))))\n以下の式の値はいくつであるか\n?\n(\nA\n1 10)\n(\nA\n2 4)\n(\nA\n3 3)\nA\nが上で定義された手続である時、以下の手続について考察せよ。\n(\ndefine\n(\nf\nn\n) (\nA\n0\nn\n))\n(\ndefine\n(\ng\nn\n) (\nA\n1\nn\n))\n(\ndefine\n(\nh\nn\n) (\nA\n2\nn\n))\n(\ndefine\n(\nk\nn\n) (* 5\nn\nn\n))\n푛\nが正の整数である場合に手続\nf\n,\ng\n,\nh\nにより計算される関数の数\n学上の定義について簡明に答えよ。例として\n(k n)\nは\n5푛\n2\nを計算\nする。\nことを必須要件としています。\n36","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":62},{"id":"./test/fixtures/pdf/sicp.pdf:63","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.2.2\n木再帰\nもう\n1\nつの演算の一般的パターンは\ntree recursion\n(\n木再帰\n)\nと呼ばれます。\n例として、フィボナッチ数の計算について考えてみましょう。各数値は先行す\nる\n2\nつの数の和となります。\n0,  1,  1,  2,  3,  5,  8,  13,  21,  ... .\n一般に、フィボナッチ数は次のルールにて定義可能です。\n퐹 푖푏(푛) =\n⎧\n{\n⎨\n{\n⎩\n0\n푖푓  푛 = 0,\n1\n푖푓  푛 = 1,\n퐹 푖푏(푛 − 1) + 퐹 푖푏(푛 − 2)\n표푡ℎ푒푟푤푖푠푒.\n私達は直ぐにこの定義をフィボナッチ数を計算する再帰手続の定義に翻訳\nが可能です。\n(\ndefine\n(\nfib\nn\n)\n(\ncond\n((=\nn\n0) 0)\n((=\nn\n1) 1)\n(\nelse\n(+ (\nfib\n(-\nn\n1))\n(\nfib\n(-\nn\n2))))))\nこの計算のパターンについて考えてみましょう。\n(fib 5)\nを計算するには\n(fib\n4)\nと\n(fib 3)\nを計算します。\n(fib 4)\nを計算するには\n(fib 3)\nと\n(fib 2)\nを\n計算します。一般的に展開されたプロセスは\nFigure 1.5\nで示すように木のよう\nに見えます。枝が各レベル\n(\n最下層を除く\n)\nにて\n2\nつに分かれることに注意して\n下さい。これが\nfib\n手続が実行される度に毎回、自身を二回呼び出す事実を反\n映しています。\nこの手続は典型的な木再帰としは有益です。しかしフィボナッチ数の計算\nするには酷い方法です。あまりにも冗長的な計算を行うためです。\nFigure 1.5\nに\nおいて\n(fib 3)\nの計算全体が\n—\nほぼ仕事の半分が\n—\n重複していることに注意\nして下さい。実際には手続が\n(fib 1)\nや\n(fib 0)\nの演算回数\n(\n上記の木全体に\nおいての葉の数\n)\nが正確に\nFib(\n푛 + 1\n)\nであることを示すのは難しくありません。\nこれがどれだけ悪い考え方であるかを知るためには\nFib(\n푛\n)\nの値が\n푛\nに対し指\n数関数的に増加することを示すことができます。より正確には\nFib(\n푛\n)\nは以下\nの条件の場合に\n휑\n푛\n/\n√\n5\nに最も近い整数になります。\n(\nExercise 1.13\n参照\n)\n37","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":63},{"id":"./test/fixtures/pdf/sicp.pdf:64","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"                             fib5\n               fib4                       fib3\n        fib3          fib2          fib2       fib1\n                                                 1\n   fib2    fib1   fib1   fib0   fib1    fib0\n             1      1      0      1       0\nfib1   fib0\n1      0\nFigure 1.5:\n(fib 5)\nを求める際に生成された木再帰プロセス\n휑 =\n1 +\n√\n5\n2\n≈ 1.6180\n휑\nは\ngolden ratio\n(\n黄金比\n)\nであり次の等式を満たします。\n휑\n2\n= 휑 + 1.\n従ってプロセスは入力に伴ない指数関数的に増加するステップ数を要します。\n一方で要求される記憶域は入力に対し線形にしか増加しません。なぜなら計算\n過程の任意のポイントにおいて、木の中のどのノードが上にあるのかのみ追跡\nする必要があるためです。一般的に、木再帰プロセスにおいて必要とされるス\nテップ数は木の中のノードの数に比例します。必要とされる記憶域は木の最大\nの深さに対して比例します。\nフィボナッチ数の計算を反復プロセスに定式化することも可能です。この\n考えは\n푎\nと\n푏\nの整数のペアを用い、\nFib(1) = 1\nと\nFib(0) = 0\nの初期化を行い、\n以下の変換を同時に行うというものです。\n푎    ←    푎 + 푏,\n푏    ←    푎.\n38","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":64},{"id":"./test/fixtures/pdf/sicp.pdf:65","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この変換を\n푛\n回行った後に\n푎\nと\n푏\nがそれぞれ\nFib(\n푛 + 1\n)\nと\nFib(\n푛\n)\nに等しいこ\nとを示すのは難しくありません。従ってフィボナッチ数を反復的に以下の手続\nを用いて計算可能です。\n(\ndefine\n(\nfib\nn\n)\n(\nfib-iter\n1 0\nn\n))\n(\ndefine\n(\nfib-iter\na\nb\ncount\n)\n(\nif\n(=\ncount\n0)\nb\n(\nfib-iter\n(+\na\nb\n)\na\n(-\ncount\n1))))\nこの\nFib(\n푛\n)\nを計算する\n2\nつ目の方法は線形反復です。\n2\nつの方法により要求さ\nれるステップ数の差は\n—1\nつは\n푛\nに対し線形、もう\n1\nつは\nFib(\n푛\n)\n自身の値の\n速さで増加\n—\nは例え入力値が小さくても非常に大きくなります。\nこれより木再帰プロセスが役に立たないと結論づけるべきではありません。\n数値ではなく階層構造のデータを操作するプロセスを考えた場合、木再帰は自\n然で強力なツールです。\n32\nしかし、例え数値演算においても木再帰はプログラ\nムの設計と理解を手助けするのに役立ちます。例えば最初の\nfib\n手続は\n2\nつ目\nに比べてとても非効率ですが、より直感的でフィボナッチ数列の定義と\nLisp\n翻\n訳の違いは大差がありません。反復アルゴリズムの定式化は計算が\n3\nつの状態\n変数に再定義できることに気付く必要があります。\n例\n:\n両替方法を数える\n反復的フィボナッチアルゴリズムに至るには多少の知恵が必要です。一方\nで、次の問題について考えてみて下さい：\n$1.00\nを両替するにはいくつの方法\nがあるでしょうか\n? 50\nセント、\n25\nセント、\n10\nセント、\n5\nセント、\n1\nセント硬貨\nがあります。より一般的に、任意の量の金額に対して両替方法がいくつ存在す\nるか計算する手続を書くことができますか\n?\nこの問題には再帰手続としての簡単な答が存在します。利用可能なコイン\nのタイプをある順序で並べると考えてみましょう。すると以下の関係が成り立\nちます。\n푛\n種類の硬貨を用いて金額\n푎\nの両替方法の数は\n•\n最初の種類の硬貨を除いた残り全てを用いた金額\n푎\nの両替方法の数、\nプラス\n32\nこれの例は\nSection 1.1.3\n:\nインタプリタ自身が木再帰プロセスを用いて式を評価する\nことから暗示されます\n39","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":65},{"id":"./test/fixtures/pdf/sicp.pdf:66","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n푑\nが最初の種類の硬貨の額面である場合に、\n푛\n種類の硬貨全てを用いて\n金額\n푎 − 푑\nの両替方法の数\nなぜこれが正しいのか考えるためには両替方法が\n2\nつのグループに分けられる\nことに注目します。最初の種類の硬貨を用いないものと、用いるものです。従\nってある金額に対する両替方法の数の総数は最初の種類の硬貨を全く使わない\n量に対する両替方法の数と最初のコインを用いる両替方法の数の和です。しか\nし後者の数は最初の種類の硬貨を用いた後の残りの金額に対する両替方法の数\nに等しくなります。\n従って与えられた金額の両替問題から少ない種類の硬貨を用いたより少な\nい金額の両替問題へと再帰的に縮小することが可能です。この集約ルールにつ\nいて注意深く考えてください。そして自分自身でそのルールを用いて以下の縮\n退ケースを指定した場合アルゴリズムを記述できるように準備して下さい。\n33\n•\nもし\n푎\nが\n0\nである場合、両替方法は\n1\nと数える\n•\nもし\n푎\nが\n0\n未満の場合、両替方法は\n0\nと数える\n•\nもし\n푛\nが\n0\nの場合、両替方法は\n0\nと数える\nこの記述は簡単に再帰手続に翻訳できます。\n(\ndefine\n(\ncount-change\namount\n) (\ncc\namount\n5))\n(\ndefine\n(\ncc\namount\nkinds-of-coins\n)\n(\ncond\n((=\namount\n0) 1)\n((\nor\n(<\namount\n0) (=\nkinds-of-coins\n0)) 0)\n(\nelse\n(+ (\ncc\namount\n(-\nkinds-of-coins\n1))\n(\ncc\n(-\namount\n(\nfirst-denomination\nkinds-of-coins\n))\nkinds-of-coins\n)))))\n(\ndefine\n(\nfirst-denomination\nkinds-of-coins\n)\n(\ncond\n((=\nkinds-of-coins\n1) 1)\n((=\nkinds-of-coins\n2) 5)\n((=\nkinds-of-coins\n3) 10)\n((=\nkinds-of-coins\n4) 25)\n((=\nkinds-of-coins\n5) 50)))\n33\n例えば\n5\nセント硬貨と\n1\nセント硬貨を用いて\n10\nセントの両替を行う問題に縮退ルー\nルをどのように適用するか詳細を通して見て下さい\n40","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":66},{"id":"./test/fixtures/pdf/sicp.pdf:67","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nfirst-denomination\n手続は利用可能な硬貨の種類の数を入力に取り、最初の\n種類の硬貨の額面を返します。ここでは硬貨は最大額面から最小への順に並ん\nでいると仮定しますが、どのような順でもうまく行きます\n)\nこれで元々の質問\nである\n$1\nの両替について回答ができます。\n(\ncount-change\n100)\n292\ncount-change\nは\nfib\nの最初の実装と同様に冗長な木再帰プロセスを生成しま\nす。\n(292\nが演算されるのに暫く時間がかかるでしょう\n)\n一方で結果を求めるの\nにより良いアルゴリズムをどのように設計するかは自明ではありません。この\n問題は読者への宿題とします。木再帰プロセスはとても非効率ですが多くの場\n合、指示と理解が簡単であることが人々に対し、ユーザが両者の世界の良い面\nを得られる、木再帰手続をより効率的で等価な手続へと変換を行う\n“\n賢いコン\nパイラ\n”\nの設計を提案する方向に向かわせています。\n34\nExercise 1.11:\n関数\n푓\nは\n푛 < 3\nの場合\n푓(푛) = 푛\nと\n푛 ≥ 3\nの場合、\n푓(푛) = 푓(푛 − 1) + 2푓(푛 − 2) + 3푓(푛 − 3)\nのルールの下に定義さ\nれる。\n푓\nを演算する手続を再帰プロセスを用いて書け。また\n푓\nを\n演算する手続を反復プロセスを用いて書け。\n34\n冗長な演算に対処する\n1\nつの取り組み方法は自動的に値のテーブルを演算結果に従\nい構築することです。手続をある引数に適用するよう要求される度に、最初にその値が\n既にテーブルに存在するかを確認します。その場合、冗長な演算を防ぐことが可能です。\nこの戦略は\ntabulation\n(\n表形式化\n)\nや\nmemoization\n(\nメモ化\n)\nとして知られ直感的な方法で\n実装が可能です。表形式化は時折、\n(\ncount-change\nのような\n)\n指数関数的なステップ数を\n要するプロセスを、入力に対し時間と記憶域の要求が線形に増加するプロセスへと変換\nするのに利用されます。\n(\nExercise 3.27\n参照\n)\n41","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":67},{"id":"./test/fixtures/pdf/sicp.pdf:68","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 1.12:\n以下の数値のパターンは\nPascal’s triangle\n(\nパスカル\nの三角形\n)\nと呼ばれる。\n1\n1   1\n1   2   1\n1   3   3   1\n1   4   6   4   1\n. . .\n三角の端の数値は全て\n1\nであり、三角内部の各数値はそれの上\n2\nつの数値の和である。\n35\nExercise 1.13:\nFib(\n푛\n)\nが\n휑\n푛\n/\n√\n5\nに最も近い整数であることを証\n明せよ。\n휑 = (1 +\n√\n5)\n/\n2\nとする。ヒント：\n휓 = (1 −\n√\n5)\n/\n2\nと置\nく。帰納法とフィボナッチ数の定義\n(\nSection 1.2.2\n参照\n)\nを用いて\nFib(\n푛\n) =\n(휑\n푛\n− 휓\n푛\n)/\n√\n5\nであることを証明せよ。\n1.2.3\n増加のオーダー\n前節の例ではプロセスが消費する計算資源の割合が大幅に異なることを示\nしました。この違いを説明する\n1\nつの便利な方法には\norder of growth\n(\n増加のオ\nーダー\n)\nの記法を用いて入力が大きくなるにつれプロセスが要求するリソース\n(\n資源\n)\nの総体的量の説明を得ることがあります。\n푛\nが問題サイズを測るパラメータ、\n푅(푛)\nをサイズ\n푛\nの問題に対しプロセ\nスが要求するリソースの量だとします。前節の例では\n푛\nを与えられた関数が何\n回計算されるかの数としました。しかし他の可能性もあります。例えば、もし\n私達のゴールが数値の平方根の近似値を求めることであれば、\n푛\nを必要な精度\nの桁数と取ることもありえるでしょう。行列の乗算では\n푛\nを行列の行数と取る\n35\nパスカルの三角形の各要素は\nbinomial coefficients\n(\n二項係数\n)\nと呼ばれる。\n푛\n番目の\n行が\n(푥 + 푦)\n푛\nの展開式における各項の係数であるためである。係数を計算するこのパ\nターンは\nBlaise Pascal\nの\n1653\n年の確立理論の独創的な成果である\nTraité du triangle\narithmétique\nに記載された。\nKnuth (1973)\nによると、\n1303\n年に同様のパターンが中国\nの数学者、朱世傑により出版された\nSzu-yuen Yü-chien\n(“The Precious Mirror of the\nFour Elements”)(\n四元玉鑑\n)\nの中に記載されている。また\n12\n世紀のペルシャの詩人であ\nり数学者であった\nOmar Khayyam\n、同じく\n12\n世紀のインド人数学者\nBháscara Áchárya\nについても同様である。\n42","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":68},{"id":"./test/fixtures/pdf/sicp.pdf:69","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"かもしれません。一般的に与えられた問題を分析するのに望ましい問題の属性\nはいくつもあります。同様に、\n푅(푛)\nが使用される内部保管レジスタの数を量\nったり、実行された基本的機械語命令の数であったり等します。一度に固定数\nの命令を実行する計算機においては必要とされる時間は実行される基本的機械\n語命令の数に比例します。\nもし任意の十分に大きな\n푛\nの値に対して正の定数\n푘\n1\nと\n푘\n2\nが\n푛\nに独立し\nて存在し\n푘\n1\n푓(푛) ≤ 푅(푛) ≤ 푘\n2\n푓(푛)\nを満たす時、\n푅(푛)\nは増加の次数\nΘ(푓(푛))\nを持ち\n푅(푛)\n=\nΘ(푓(푛))\n(“\nシータ\n푓(푛)\n”\nと発音する\n)\nと記述されます。\n例として、\nSection 1.2.1\nで説明した階乗を求める線形再帰プロセスではス\nテップ数は入力\n푛\nに比例します。従ってこのプロセスに必要なステップ数は\nΘ(푛)\nに従い増加します。必要とされる記憶域もまた\nΘ(푛)\nに従い増加します。\n反復式階乗ではステップ数はまだ\nΘ(푛)\nですが、記憶域は\nΘ(1)\n—\n定数です。\n36\n木再帰フィボナッチ演算は\nΘ(휑\n푛\n)\nステップと記憶域\nΘ(푛)\nを必要とします。こ\nの時\n휑\nは\nSection 1.2.2\nで示したとおりの黄金比です。\n増加の次数はプロセスの行いについて概観的な説明のみを与えます。例え\nば\n푛\n2\nステップ、\n1000푛\n2\nステップ、\n3푛\n2\n+ 10푛 + 17\nステップを必要とするプ\nロセスは全て増加の次数は\nΘ(푛\n2\n)\nになります。一方で増加の次数は問題のサ\nイズを変更した場合にどの程度プロセスの挙動が変化するかを推測するのに実\n用的な指標です。\nΘ(푛)\nの線形プロセスに対しサイズを\n2\n倍にした場合、概ね\n2\n倍のリソースを使用します。指数関数的プロセスに対しては問題サイズを\n1\n増\nやす度、定数因子をリソース使用率にかけることになります。\nSection 1.2\nの最\n後にて増加の次数が対数である\n2\nつのアルゴリズムをでは、問題サイズを倍に\nした時に必要とするリソースが定数量増えることを調査します。\nExercise 1.14:\nSection 1.2.2\nの\ncount-change\n手続により\n11\nセント\nの両替を求めた場合に生成されるプロセスの木を図示せよ。量が\n増えるに従いこのプロセスにより使用される記憶域とステップ数\nの増加の次数はいくつか\n?\nExercise 1.15:\n(\nラジアンで指定される\n)\n角度の正弦値は\n푥\nが十分\nに小さい時\n푠푖푛 푥 ≈ 푥\nの近似式を用いることで計算できる。そし\n36\nこれらの文は多量の単純化を隠しています。例えばもしプロセスのステップ数を\n“\n機\n械語命令\n”\nとして数えたならば、例えば乗算に対し必要な機械語命令の数は乗算される\n2\nつの数に対し独立していると想定するでしょう。それはもし数値が十分に大きな場合は\n間違いです。同様の見解が記憶域に対する見積に対しても取られます。プロセスのデザ\nインと記述のように、プロセスの分析は抽象化の色々なレベルに対して行えます\n43","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":69},{"id":"./test/fixtures/pdf/sicp.pdf:70","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"て三角法の恒等式、\n푠푖푛 푥 = 3 푠푖푛\n푥\n3\n− 4 푠푖푛\n3\n푥\n3\nを用いて\nsin\nの引数の大きさを縮小することができる。\n(\nこの課題\nの目的では\n“\n十分に小さい\n”\nとはその大きさが\n0.1\nラジアンよりも\n大きくないこととする\n)\nこれらの考えが以下の手続に組込まれて\nいる。\n(\ndefine\n(\ncube\nx\n) (*\nx\nx\nx\n))\n(\ndefine\n(\np\nx\n) (- (* 3\nx\n) (* 4 (\ncube\nx\n))))\n(\ndefine\n(\nsine\nangle\n)\n(\nif\n(\nnot\n(> (\nabs\nangle\n) 0.1))\nangle\n(\np\n(\nsine\n(/\nangle\n3.0)))))\na\n手続\np\nは\n(sine 12.15)\nを評価した時、何回適用されるか\n?\nb\n(sine a)\nが評価された時、\nsine\n手続により生成されたプロ\nセスにより使用された\n(\n푎\nの関数としての\n)\n記憶域とステップ\n数の増加の次数を求めよ。\n1.2.4\n指数計算\n与えられた数値の指数関数を求める問題について考えましょう。基数\n푏\nと\n正の整数である指数\n푛\nを引数に取り\n푏\n푛\nを求める手続にします。再帰定義によ\nりこれを行う\n1\nつの方法は次の通りです。\n푏\n푛\n= 푏 ⋅ 푏\n푛−1\n,\n푏\n0\n= 1,\n早速、手続に翻訳します。\n(\ndefine\n(\nexpt\nb\nn\n)\n(\nif\n(=\nn\n0)\n1\n(*\nb\n(\nexpt\nb\n(-\nn\n1)))))\nこれは線形再帰プロセスであり、\nΘ(푛)\nステップと記憶域\nΘ(푛)\nを必要としま\nす。階乗と同様にすぐに等価な線形反復へと定式化可能です。\n44","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":70},{"id":"./test/fixtures/pdf/sicp.pdf:71","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nexpt\nb\nn\n)\n(\nexpt-iter\nb\nn\n1))\n(\ndefine\n(\nexpt-iter\nb\ncounter\nproduct\n)\n(\nif\n(=\ncounter\n0)\nproduct\n(\nexpt-iter\nb\n(-\ncounter\n1)\n(*\nb\nproduct\n))))\nこのバージョンは\nΘ(푛)\nステップと記憶域\nΘ(1)\nを必要とします。\n指数関数は二乗を連続して用いることでより少ないステップで計算できま\nす。例えば、\n푏\n8\nを以下のように計算するのではなく、\n푏 ⋅ (푏 ⋅ (푏 ⋅ (푏 ⋅ (푏 ⋅ (푏 ⋅ (푏 ⋅ 푏)))))) ,\n3\n回の乗算で求めることが可能です。\n푏\n2\n= 푏 ⋅ 푏,\n푏\n4\n= 푏\n2\n⋅ 푏\n2\n,\n푏\n8\n= 푏\n4\n⋅ 푏\n4\n.\nこの方法は\n2\nの冪乗である指数関数についてはうまく働きます。また連続\nする二乗の利点を一般的な指数関数の演算に対し以下のルールに従うことで利\n用可能です。\n푏\n푛\n= (푏\n푛/2\n)\n2\nif\n푛\nis even\n,\n푏\n푛\n= 푏 ⋅ 푏\n푛−1\nif\n푛\nis odd\n.\nこの方法を手続として表現します。\n(\ndefine\n(\nfast-expt\nb\nn\n)\n(\ncond\n((=\nn\n0) 1)\n((\neven?\nn\n) (\nsquare\n(\nfast-expt\nb\n(/\nn\n2))))\n(\nelse\n(*\nb\n(\nfast-expt\nb\n(-\nn\n1))))))\n整数が偶数であるかテストする述語はプリミティブな手続、\nremainder\nを用い\n以下のように定義される。\n(\ndefine\n(\neven?\nn\n)\n(= (\nremainder\nn\n2) 0))\n45","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":71},{"id":"./test/fixtures/pdf/sicp.pdf:72","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"fast-expt\nにより展開されるプロセスは\n푛\nの対数に従い記憶域とステップ数の\n両者が増加します。これを理解するために\n푏\n2푛\nを\nfast-expt\nを用いて演算する\nのに\n푏\n푛\nの演算よりただ\n1\n度のみ多くの乗算が必要であることに注目して下さ\nい。従って計算可能な指数のサイズは、可能な新規の乗算の度に\n(\n大体\n)\n倍にな\nります。このため\n푛\nの指数により必要とされる乗算の数は\n2\nを底とする\n푛\nの\n対数と同等の早さにて増加します。このプロセスは\nΘ(푙표푔 푛)\nで増加します。\n37\nΘ(푙표푔 푛)\nの増加と\nΘ(푛)\nの増加の違いは\n푛\nが大きくなる程顕著になりま\nす。例えば\n푛\n= 1000\nの時\nfast-expt\nは\n14\n回しか乗算を必要としません。\n38\n連続する二乗の考えを用いて対数ステップ数の指数関数を求める反復アルゴリ\nズムを考案することも可能です。\n(\nExercise 1.16\n参照\n)\nしかし反復アルゴリズム\nでは良くあることですが、これは再帰アルゴリズムのように直接的に書下すこ\nとができません。\n39\nKnuth 1981\nの\n4.6.3\n節にてこれと指数関数の他の方法につ\nいて完全な議論と分析を行っています。\nExercise 1.16:\n連続二乗と対数ステップ数を用いる\nfast-expt\nの\nような反復指数関数プロセスを展開する手続を設計せよ。\n(\nヒン\nト\n:\n(푏\n푛/2\n)\n2\n= (푏\n2\n)\n푛/2\nを用い、指数\n푛\n、基数\n푏\nと共に追加の状態変\n数\n푎\nを保持し状態変換を積\n푎푏\n푛\nが状態間において一定であるとい\nう方法にて定義せよ。プロセスの最初において\n푎\nは\n1\nを取り、回\n答はプロセスの終了時に\n푎\nの値として得られる。一般的に、状態\n間において一定である\ninvariant quantity\n(\n不変量\n)\nを定義する技法\nは反復アルゴリズムの設計を考える上で強力な方法である。\n)\nExercise 1.17:\nこの節における指数演算アルゴリズムは指数関数を\n乗算の繰り返しを用いて実行することを基本としている。同様な\n手段で、整数の乗算を加算の繰り返しを用いて実行することも可\n能だ。以下の乗算手続\n(\n私達の言語が足し算だけ可能で乗算はでき\nないと仮定する\n)\nは\nexpt\n手続の類似である。\n37\nより正確に言えば、必要とされる乗算の数は\n1\nから\n푛\nの基数\n2\nの対数未満と\n푛\nの\n二進数表現における\n1\nの数の和になります。この合計が常に\n푛\nの基数\n2\nの対数の\n2\n倍\nよりも小さくなります。オーダ\n(\n次数\n)\n記法の定義に従う任意の定数\n푘\n1\nと\n푘\n2\nにより、\n対数プロセスに対し、その対数の基数は問題ではないため、そのようなプロセス全ては\nΘ(푙표푔 푛)\nと説明されることが示されます\n38\n誰が数値を\n1000\n乗まで上げることを気にするのだろうかと思うかもしれません。\nSection 1.2.6\nを参照して下さい\n39\nこの反復アルゴリズムは古代から存在します。紀元前\n200\n年以前に\nÁchárya Pingala\nにより書かれた\nChandah-sutra\nには現れています\n46","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":72},{"id":"./test/fixtures/pdf/sicp.pdf:73","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(*\na\nb\n)\n(\nif\n(=\nb\n0)\n0\n(+\na\n(*\na\n(-\nb\n1)))))\nこのアルゴリズムは\nb\nに対し線形のステップ数を取る。今、和に\n加えて整数を倍にする\ndouble\nと偶数を\n2\nで割る\nhalve\nがあると\nする。これらを用いて\nfast-expt\nに類似して対数ステップ数を持\nつ乗算手続を設計せよ。\nExercise 1.18:\nExercise 1.16\nと\nExercise 1.17\nの結果を用いて反復プ\nロセスを生成する\n2\nつの整数を乗算する手続を考案せよ。足し算、\ndouble\n、\nhalve\nを用い対数ステップ数のアルゴリズムを使用するこ\nと。\n40\nExercise 1.19:\nフィボナッチ数を対数ステップ数にて求める巧み\nなアルゴリズムが存在する。\nSection 1.2.2\nの\nfib-iter\nにて\n푎\nと\n푏\n状態変数の変換\n푎 ← 푎 + 푏\nと\n푏 ← 푎\nを思い出そう。この変換を\n푇\nと呼び、\n1\nと\n0\nから始めて\n푛\n回繰り返して\n푇\nを適用した時に\nFib(\n푛 + 1\n)\nと\nFib(\n푛\n)\nのペアを算出することに注意せよ。言い換え\nれば、フィボナッチ数は変換\n푇\nの\n푛\n乗である\n푇\n푛\nをペア\n(1, 0)\nか\nら始めて適用するということである。ここで\n푇\nは\n푝 = 0\n、\n푞 = 1\nで\nある時の変換\n푇\n푝푞\nの特別な形であると考えてみよう。この時\n푇\n푝푞\nは\n(푎, 푏)\nを\n푎 ← 푏푞 + 푎푞 + 푎푝\nand\n푏 ← 푏푝 + 푎푞\nとする。もしそのよ\nうな変換\n푇\n푝푞\nを二回適用した場合にその効果は同形変換\n푇\n푝\n′\n푞\n′\nを\n一回適用した場合と同じであることを示せ。また\n푝\nと\n푞\nに対する\n푝\n′\nand\n푞\n′\nを求めよ。これは\nfast-expt\n手続におけるように、\n푇\n푛\nを連続する平方にて求める。これらを全て一緒に考慮して次の手\n続を完成させよ。これは対数ステップ数にて実行される。\n41\n(\ndefine\n(\nfib\nn\n)\n(\nfib-iter\n1 0 0 1\nn\n))\n(\ndefine\n(\nfib-iter\na\nb\np\nq\ncount\n)\n40\nこのアルゴリズムは時折\n“\nロシア農民のかけ算\n”\nとして知られており、古くから存在\nします。その使用例は最も古い数学の書籍の\n1\nつ、リンドパピルスにも見られます。こ\nれは紀元前\n1700\n年頃にエジプトの筆記者、\nA’h-mose\nにより書かれた\n(\nそしてより古い\n書物から写本された\n)\n本です。\n41\nこの課題は\nKaldewaij 1990\nの例をベースに\nJoe Stoy\nにより提案されました\n47","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":73},{"id":"./test/fixtures/pdf/sicp.pdf:74","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncond\n((=\ncount\n0)\nb\n)\n((\neven?\ncount\n)\n(\nfib-iter\na\nb\n⟨\n??\n⟩\n; compute\np\n’\n⟨\n??\n⟩\n; compute\nq\n’\n(/\ncount\n2)))\n(\nelse\n(\nfib-iter\n(+ (*\nb\nq\n) (*\na\nq\n) (*\na\np\n))\n(+ (*\nb\np\n) (*\na\nq\n))\np\nq\n(-\ncount\n1)))))\n1.2.5\n最大公約数\n2\nつの整数\n푎\nと\n푏\nの\nGreatest Common divisor(\ngcd\n:\n最大公約数\n)\nとは\n푎\nと\n푏\nの両者を余り無しで割り切れる最大の整数だと定義されます。例えば\n16\nと\n28\nの\ngcd\nは\n4\nです。\nChapter 2\nで分数の計算の実装方法について調査する時に\n分数を約分するために\ngcd\nを求められるようになる必要が出てきます。\n(\n分数\nを約分するためには分母と分子をそれらの\ngcd\nで割らねばなりません。例えば\n16/28\nは\n4/7\nになります\n) 2\nつの整数の\ngcd\nを求める\n1\nつの方法はそれらを因\n数分解し、共通因数を求める方法です。しかしより効率的な有名なアルゴリズ\nムが存在します。\nそのアルゴリズムの考えはもし\n푟\nが\n푎\nを\n푏\nで割った時の余りである場合に\n푎\nと\n푏\nの共通因数は正確に\n푏\nと\n푟\nの共通な因数であるという結果を基にしてい\nます。従って次の等式を利用可能です。\nGCD(a,b) = GCD(b,r)\n引き続いて\ngcd\nを求める問題からより小さな値の整数のペアの\ngcd\nを求める\n問題へと縮小していくことができます。例えば、\nGCD(206,40) = GCD(40,6)\n= GCD(6,4)\n= GCD(4,2)\n= GCD(2,0)\n= 2\n48","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":74},{"id":"./test/fixtures/pdf/sicp.pdf:75","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"上の例では\ngcd\n(206, 40)\nを\ngcd\n(2, 0)\nへと縮小しています。その答は\n2\nです。\n任意の\n2\nつの正の整数から始めて収縮を繰り返し実行することで常に最終的に\nは\n2\nつ目の数値が\n0\nであるペアにすることができます。その時、\ngcd\nの値はも\nう\n1\nつの値です。この\ngcd\nを求める方法は\nEuclid’s Algorithm\nユークリッドの\n互除法\n)\nとして知られています。\n42\nユークリッドの互除法を手続として表すのは簡単です。\n(\ndefine\n(\ngcd\na\nb\n)\n(\nif\n(=\nb\n0)\na\n(\ngcd\nb\n(\nremainder\na\nb\n))))\nこれが反復プロセスを生成し、そのステップ数は与えられた数値の対数で増加\nします。\nユークリッドの互除法により必要とされるステップ数が対数増加する事実\nがフィボナッチ数に対する興味深い関係を持ちます。\nLamé\nの定理\n:\nもしユークリッドの互除法があるペアの\ngcd\nを求め\nるのに\n푘\nステップを必要とする場合、必ずペアの小さな値が\n푘\n番\n目のフィボナッチ数より大きいか等しい。\n43\n42\nユークリッドの互除法はユークリッドの\nElements\n(\nおよそ紀元前\n300\n年の原論第\n7\n巻\n)\nに載っていたためにそう呼ばれます。\nKnuth (1973)\nによると最も古く良く知られた\n重要なアルゴリズムであると考えられるそうです。\n(\nExercise 1.18\n)\nの古代のエジプト人\nの乗算方法は確かにこれよりも古いのですが、\nKnuth\nの説明ではユークリッドのアルゴ\nリズムは最も古く知られた一般的なアルゴリズムとして紹介されたものであり、説明的\nな例の集合では無いとのことです\n43\nこの定理は\n1845\n年にフランスの数学者でありかつエンジニアでもある\nGabriel\nLamé\nにより証明されました。彼は数理物理学への貢献の第一人者としても有名です。こ\nの定理を証明するには\n푎\n푘\n≥ 푏\n푘\nであるペア\n(\n푎\n푘\n, 푏\n푘\n)\nがユークリッドの互除法にて\n푘\nステ\nップで停止するか考えます。証明は\n(푎\n푘+1\n, 푏\n푘+1\n) → (푎\n푘\n, 푏\n푘\n) → (푎\n푘−1\n, 푏\n푘−1\n)\nが縮小プ\nロセスにおける連続する\n3\nつのペアである場合、必ず\n푏\n푘+1\n≥ 푏\n푘\n+ 푏\n푘−1\nであることを基\nにします。この仮定を確認するために縮小ステップの変換定義が\n푎\n푘−1\n= 푏\n푘\n, 푏\n푘−1\n=\n“\n푎\n푘\nを\n푏\n푘\nで割った余り\n”\nであることについて考えます。\n2\nつ目の等式はある整数\n푞\nに\n対し\n푎\n푘\n=  푞푏\n푘\n+ 푏\n푘−1\nが成り立つことを意味します。\n푞\nは少なくとも\n1\nですから\n푎\n푘\n=  푞푏\n푘\n+ 푏\n푘−1\n≥  푏\n푘\n+ 푏\n푘−1\nが成り立ちます。しかし以前の収縮ステップより\n푏\n푘+1\n= 푎\n푘\nです。従って\n푏\n푘+1\n= 푎\n푘\n≥ 푏\n푘\n+ 푏\n푘−1\nが成り立ちます。これで先程の仮定は\n立証できました。アルゴリズムが停止するのに必要なステップ数を\n푘\nとした場合に、こ\nれで定理は\n푘\nを用いた数学的帰納法にて証明可能となりました。\n푘 = 1\nの時、これは単\nに\n푏\nが少なくとも\nFib(1) = 1\nと同じ大きさであることを必要としますので真です。次に\n푘\nに等しいかより小さい整数全てにおいて定理が真であると仮定します。そして\n푘 + 1\nで\n49","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":75},{"id":"./test/fixtures/pdf/sicp.pdf:76","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この定理を用いてユークリッドの互除法の増加のオーダーを推測することが可\n能です。\n푛\nが手続の入力値の小さな値だとします。もしプロセスが\n푘\nステッ\nプ必要とする場合、\n푛 ≥ 퐹 푖푏(푘) ≈ 휑\n푘\n/\n√\n5\nが必ず成り立ちます。従ってステ\nップ数\n푘\nは\n푛\nの\n(\n휑\nを底とする\n)\n対数で増加します。つまり増加のオーダーは\nΘ(푙표푔 푛)\nとなります。\nExercise 1.20:\nある手続が生成するプロセスはもちろんインタプリ\nタにより使用されるルールに依存する。例として上で説明した反\n復\ngcd\n手続について考える。この手続を\nSection 1.1.5\nで議論した正\n規順評価で解釈、実行したと想定する。\n(\nif\nに対する正規順評価ル\nールは\nExercise 1.5\nを参照\n)\n。置換法を\n(\n正規順に\n)\n用いて\n(gcd 206\n40)\nの評価により生成されるプロセスを説明せよ。次に実際に実\n行された\nremainder\n命令を示せ。\n(gcd 206 40)\nの正規順評価にお\nいて実際に実行された\nremainder\n命令は何回だろうか\n?\n適用順評\n価では\n?\n1.2.6\n例\n:\n素数判定\nこの節では整数\n푛\nが素数であるかをテストする\n2\nつの方法について述べま\nす。\n1\nつは増加のオーダーが\nΘ(\n√\n푛)\nであり、他は\n“\n確率的\n”\nなアルゴリズムで\n増加のオーダーが\nΘ(푙표푔 푛)\nです。この節の最後の課題ではこれらのアルゴリ\nズムに基づいたプログラミングのプロジェクトを提案します。\n約数を探す\n古代の時代から数学者は素数についての問題に魅惑されてきました。多く\nの人々が数値が素数であるかの決定法の問題に取り組んできました。数値が素\n数であるかのテストの\n1\nつの方法は数値の約数を求めることです。次のプログ\nラムは\n1\nより大きな最も小さい整因子\n(\n約数\n)\nを与えられた\n푛\nに対して求めま\nす。このプログラムはそれを直接的な方法、つまり\n2\nで始まる一連の整数によ\nり割り切れるかどうかをテストすることにより行います。\nも成立することを証明します。\n(푎\n푘+1\n, 푏\n푘+1\n) → (푎\n푘\n, 푏\n푘\n) → (푎\n푘−1\n, 푏\n푘−1\n)\nが縮小プロセ\nスにおける連続するペアである場合に、数学的帰納法の仮定より、\n푏\n푘−1\n≥ 퐹 푖푏(푘 − 1)\nと\n푏\n푘\n≥ 퐹 푖푏(푘)\nが成り立ちます。ここで先程フィボナッチ数の定義と共に証明した式を適\n用すると\n푏\n푘+1\n≥ 푏\n푘\n+ 푏\n푘−1\n≥ 퐹 푖푏(푘) + 퐹 푖푏(푘 − 1) = 퐹 푖푏(푘 + 1)\nが導出されます。これ\nで定理の証明は終了です。\n50","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":76},{"id":"./test/fixtures/pdf/sicp.pdf:77","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nsmallest-divisor\nn\n) (\nfind-divisor\nn\n2))\n(\ndefine\n(\nfind-divisor\nn\ntest-divisor\n)\n(\ncond\n((> (\nsquare\ntest-divisor\n)\nn\n)\nn\n)\n((\ndivides?\ntest-divisor\nn\n)\ntest-divisor\n)\n(\nelse\n(\nfind-divisor\nn\n(+\ntest-divisor\n1)))))\n(\ndefine\n(\ndivides?\na\nb\n) (= (\nremainder\nb\na\n) 0))\n数値が素数であるか以下のようにテストします\n:\n푛\nは\n푛\n自身が最小の約数であ\nる場合、かつその場合に限り素数である。\n(\ndefine\n(\nprime?\nn\n)\n(=\nn\n(\nsmallest-divisor\nn\n)))\nfind-divisor\nの終了条件はもし\n푛\nが素数でないならば\n√\n푛\nより小さいかまた\nは等しい約数を持つという事実に基づいています。\n44\nこれはこのアルゴリズム\nが\n1\nから\n√\n푛\nまでの約数についてのみテストすれば良いことを示します。結果\nとして、\n푛\nが素数であるかを判定するのに必要なステップ数の増加のオーダー\nは\nΘ(\n√\n푛)\nとなります。\nフェルマーテスト\nΘ(푙표푔 푛)\nの素数判定はフェルマーの小定理として知られる数論の結果に基\nづきます。\n45\nフェルマーの小定理\n:\n푛\nが素数かつ\n푎\nが\n푛\nより小さい任意の正の\n整数である時、\n푎\nの\n푛\n乗は法\n푛\nに関して\n푎\nと合同である。\n44\nもし\n푑\nが\n푛\nの約数である時、\n푛/푑\nもまた約数です。しかし\n푑\nと\n푛/푑\nの両者が共に\n√\n푛\nより大きいことは有りません\n45\nPierre de Fermat (1601-1665)\nは現在の整数論の創始者と考えられています。彼は多\nくの重要な数論上の事実について発見しました。しかし彼は通常その結果のみを公表し、\n証明を与えませんでした。フェルマーの小定理は彼が\n1640\n年に書いた手紙に記録されて\nいます。最初に出版された証明は\n1736\n年にオイラーにより与えられました。\n(\nそれより\n早く、同様の証明がライプニッツの出版されなかった原稿に見つかっています\n)\n。最も有\n名なフェルマーの数式は\n—\nフェルマーの最終定理として知られ\n— 1637\n年に彼の所有し\nた書籍\n(3\n世紀のギリシャ人数学者\nDiophantus\nによる\n)\nArithmetic\nに\n“\n私は真に驚くべ\nき証明を発見したが、書き残すにはこの余白は狭すぎる\n”\nという所感と共にメモされた\n物です。フェルマーの最終定理の証明を見つけることは数論において最も有名な挑戦の\n1\nつとなりました。完全な解はついに\n1995\n年にプリンストン大学の\nAndrew Wiles\nによ\nり与えられました。\n51","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":77},{"id":"./test/fixtures/pdf/sicp.pdf:78","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(2\nつの数値はその両方が\n푛\nで割った時に同じ余りを持つ場合、\ncongruent\nmodulo\n푛\n(\n法\n푛\nに関して合同\n)\nと呼ばれます。また\n푎\nを\n푛\nで割った時の余りは\n푎\nmodulo\n푛\nの\nremainder\n(\n剰余\n)\n、または単純に\n푎\nmodulo\n푛\nと呼ばれます。\n)\nもし\n푛\nが素数でなければ一般に\n푎 < 푛\nの多くの値は上記の関係を満しませ\nん。これが次の素数判定のアルゴリズムへと導きます\n:\nある値\n푛\nが与えられた\n時、\n푎 < 푛\nとなる乱数を取り\n푎\n푛\nmodulo\n푛\nの剰余を求めます。もし結果が\n푎\nに\n等しくない時、\n푛\nは確実に素数ではありません。もし\n푎\nに等しいならば\n푛\nが素\n数である確率は良いと言えます。ここで別の乱数\n푎\nを取り同じ方法でテストを\n行います。それもまた等式を満すのであれば\n푛\nが素数である確率はより確から\nしくなります。より多くの\n푎\nについて試験を行えば、結果の確からしらを増す\nことが可能です。このアルゴリズムはフェルマーテストとして知られています。\nフェルマーテストを実装するには\n(\nある数値の指数関数\nmodulo\n別の数値\n)\nを求める手続が必要です。\n(\ndefine\n(\nexpmod\nbase\nexp\nm\n)\n(\ncond\n((=\nexp\n0)\n1)\n((\neven?\nexp\n)\n(\nremainder\n(\nsquare\n(\nexpmod\nbase\n(/\nexp\n2)\nm\n))\nm\n))\n(\nelse\n(\nremainder\n(*\nbase\n(\nexpmod\nbase\n(-\nexp\n1)\nm\n))\nm\n))))\nこれは\nSection 1.2.4\nの\nfast-expt\n手続にとても似ています。連続する二乗を用\nいるため、ステップ数の増加は\n”\n指数\n”\n引数の対数になります。\n46\nフェルマーテストは\n1\nから\n푛−1\nまでの乱数\n푎\nを選択し、\n푎\nの\n푛\n乗の\nmodulo\n푛\nが\n푎\nに等しいかをチェックすることで行います。乱数\n푎\nは手続\nrandom\nを用\n46\n指数\n푒\nが\n1\nより大きい場合の縮小ステップは、任意の整数\n푥\n,\n푦\n,\n푚\nに対し\n푥\nmodulo\n푚\nと\n푦\nmodulo\n푚\nを別々に求め、これらを掛け、その結果の法\n푚\nに関する剰余を求め\nることで\n(\n푥\nと\n푦\nの積\nmodulo\n푚\n)\nを求めることができるという事実に基づきます。例え\nば\n푒\nが偶数の場合に\n푏\n푒/2\nmodulo\n푚\nを求め、その二乗を取り、法\n푚\nに関する剰余を得\nます。このテクニックはとても役に立ちます。\n푚\nよりもはるかに大きな数値を一切扱う\n必要無しに演算を行うことが可能だからです。\n(\nExercise 1.25\nと比較せよ\n)\n52","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":78},{"id":"./test/fixtures/pdf/sicp.pdf:79","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"いて選択しますが、それは\nScheme\nのプリミティブな手続に存在する前提です。\nrandom\nは入力の整数よりも少ない非負数な整数を返します。そのため\n1\nから\n푛 − 1\nの乱数を得るには\nrandom\nに\n푛 − 1\nを入力とし、結果に\n1\nを足します。\n(\ndefine\n(\nfermat-test\nn\n)\n(\ndefine\n(\ntry-it\na\n)\n(= (\nexpmod\na\nn\nn\n)\na\n))\n(\ntry-it\n(+ 1 (\nrandom\n(-\nn\n1)))))\n以下の手続はパラメータにより与えられた数値の回数分、テストを実行します。\nテストが毎回成功すれば\ntrue\nを、そうでなければ\nfalse\nを返します。\n(\ndefine\n(\nfast-prime?\nn\ntimes\n)\n(\ncond\n((=\ntimes\n0)\ntrue\n)\n((\nfermat-test\nn\n) (\nfast-prime?\nn\n(-\ntimes\n1)))\n(\nelse\nfalse\n)))\n確率的手法\nフェルマーテストは正確さが保証された多くの親しみのあるアルゴリズム\nとは性格が異なっています。ここでは得られた結果は確率的にのみ正しいと言\nえます。より正確には、\n푛\nが常にフェルマーテストに失敗するのであれば\n푛\nが\n素数でないことは確実です。しかし\n푛\nがテストをパスしたという結果は、とて\nも強い目安ではありますが、\n푛\nが素数であることを保証しません。ここで言い\nたかったのは任意の数値\n푛\nに対し、十分な回数のテストを行い\n푛\nが常にテス\nトをパスする場合、この素数判定が間違いである可能性は思い通りに小さくす\nることが可能だということでした。\n残念ながらこの主張は完全には正しくありません。実はフェルマーテスト\nを騙してしまう数値が存在します。\n푎 < 푛\nとなる全ての整数において、\n푛\nが素\n数ではなく、しかし、\n푎\n푛\nが\n푛\nを法とする\n푎\nに合同であるような数値\n푛\n。その\nような数値はとても稀です。そのためフェルマーテストは実際にとても信用が\n高いと言えます。\n47\n47\nフェルマーテストを騙してしまう数は\nCarmichael numbers\n(\nカーマイケル数\n)\nと呼\nばれとても稀であるということ以外はあまり良くわかっていません。\n100,000,000\n未満に\nは\n255\nのカーマイケル数が存在します。最小の物からいくつか上げると\n561, 1105, 1729,\n2465, 2821, 6601\nです。任意に選ばれたとても巨大な数値の素数性をテストする場合に\nフェルマーテストを騙す数値に当る確率はコンピュータが\n“\n正確な\n”\nアルゴリズムを実行\n53","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":79},{"id":"./test/fixtures/pdf/sicp.pdf:80","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"フェルマーテストのバリエーションには騙されない物も複数あります。こ\nれらのテストではフェルマーテストと同様に、整数\n푛\nの素数判定を乱数\n푎 < 푛\nを選択し、\n푛\nと\n푎\nに依る何らかの条件をチェックします。\n(\nそのようなテストの\n例は\nExercise 1.28\nを参照して下さい\n)\n。一方でフェルマーテストとは対照的に、\n任意の\n푛\nに対し\n푛\nが素数でなければ\n푎 < 푛\nの多くに対し条件が成立しないこ\nとを証明できます。従って\n푛\nがいくつかの乱数\n푎\nに対してテストが通るのであ\nれば、\n푛\nが素数である可能性は五分五分より高くなります。もし\n푛\nが\n2\nつの乱\n数である\n푎\nに対してテストを通れば、\n푛\nが素数である確率は\n4\n分の\n3\nよりも高\nくなります。テストを何度も乱数\n푎\nを選択しながら実行することでエラーの確\n率を思い通りに小さくすることが可能です。\nエラーの確率が自由裁量で小さくできることが証明可能なテストの存在\nはこのタイプのアルゴリズムへの興味を起こしました。それらは\nprobabilistic\nalgorithms\n(\n確率的アルゴリズム\n)\nと呼ばれます。この領域にはとても多くの研\n究活動が存在し、確率的アルゴリズムは多くの現場に効果的に適用されてきま\nした。\n48\nExercise 1.21:\nsmallest-divisor\n手続を用いて次の数値の最小の\n約数を求めよ：\n199\n、\n1999\n、\n19999\nExercise 1.22:\n多くの\nLisp\n実装は\nruntime\nと呼ばれるプリミテ\nィブな手続を持っておりそれはシステムが実行している間の\n(\n例\nえばマイクロ秒で測定された\n)\n時間を整数にて返す。次の\ntimed-\nprime-test\n手続は整数\n푛\nと共に呼んだ時、\n푛\nを表示し、\n푛\nが素数\nであるかチェックする。\n푛\nが素数であれば手続は\n3\nつのアスタリ\nスクとテスト実行に掛った時間を表示する。\n(\ndefine\n(\ntimed-prime-test\nn\n)\nする際に宇宙放射線がエラーを引き起す確率よりも低いです。\n2\nつ目の理由でなく、最初\nの理由からアルゴリズムを不適切だと考えることは数学とエンジニアリングの間の違い\nを示しています。\n48\n確率的素数判定法の最も特筆すべき適用例は暗号の領域です。現時点では任意の\n200\n桁の数値を因数分解することは計算能力上不可能ですが、そのような数値の素数判定は\nフェルマーテストにより数秒で行うことが可能です。この事実が\nRivest et al. (1977)\nに\nより提案された\n“\n解読不能な符号\n”\nを構築するためのテクニックの基を形成しました。そ\nの結果として\nRSA\nアルゴリズム\nは電子通信上のセキュリティを拡張するテクニックと\nして広く利用されるようになりました。このことと関連する開発により、素数の研究は\n一時は\n“\n純粋\n”\n数学のトピックの典型例でありその世界自身のためにのみ研究される物だ\nと考えられてきましたが、現在では暗号、電子資産の転送と情報検索に対する重要で現\n実的な適用例を持つことが判明しました。\n54","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":80},{"id":"./test/fixtures/pdf/sicp.pdf:81","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nnewline\n) (\ndisplay\nn\n) (\nstart-prime-test\nn\n(\nruntime\n)))\n(\ndefine\n(\nstart-prime-test\nn\nstart-time\n)\n(\nif\n(\nprime?\nn\n)\n(\nreport-prime\n(- (\nruntime\n)\nstart-time\n))))\n(\ndefine\n(\nreport-prime\nelapsed-time\n)\n(\ndisplay\n\"\n***\n\"\n) (\ndisplay\nelapsed-time\n))\nこの手続を用いて指定した範囲の連続した奇数について素数判定\nを行う手続、\nsearch-for-primes\nを書け。その手続を用いて\n1000\n、\n10,000\n、\n100,000\nより大きな素数を\n3\nつ見つけよ。各素数のテスト\nに必要な時間を記録せよ。テストアルゴリズムは\n10,000\n辺りの素\n数を判定する時、約\n√\n10\n倍、\n1000\n辺りの素数をテストするより\n時間がかかるはずである。あなたの結果はこれに従っているか\n?\n100,000\nや\n1,000,000\nのデータに対して\nΘ(\n√\n푛)\nの予想は当たって\nいるか\n?\nあなたの結果は演算に必要なステップ数に比例して実行\n時間が増えるという考えに矛盾していないか\n?\nExercise 1.23:\nこの節の最初で示された\nsmallest-divisor\n手続は\n必要の無いテストを数多く行っている：数値が\n2\nで割ることがで\nきるかチェックした後に、それがより大きな偶数にて割り切れる\nかチェックを行う必要は無い。これにより\ntest-divisor\nの値は\n2,\n3, 4, 5, 6,\n...\nではなく、\n2, 3, 5, 7, 9,\n...\nであるべきだと提案できる。\nこの変更を実装するために、入力が\n2\nであれば\n3\nを返し、それ以外\nでは入力に\n2\nを足した値を返す手続\nnext\nを定義せよ。\nsmallest-\ndivisor\n手続を変更し、\n(+ test-divisor 1)\nの代わりに\n(next\ntest-divisor)\nを使用せよ。\ntimed-prime-test\nをこの変更したバ\nージョンの\nsmallest-divisor\nを用いて\nExercise 1.22\nで見つけた\n12\nの素数に対しテストを行え。この変更はテストステップを半分\nにするため\n2\n倍速く実行されることをが予測される。この予測が\n確認できるだろうか\n?\nもしそうでなければ\n2\nつのアルゴリズムの\nスピードの比率はどのような値が確認できるか\n? 2\nと異なる結果を\nどのように説明するか\n?\nExercise 1.24:\nExercise 1.22\nの\ntimed-prime-test\n手続を変更し\nfast-prime?\n(\nフェルマー法\n)\nを用い、課題で見つけた\n12\nの素数を\nそれぞれテストせよ。フェルマーテストは\nΘ(푙표푔 푛)\nで増加するが、\n1000\nに近い素数をテストするのに必要な時間と比べ\n1,000,000\n付\n55","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":81},{"id":"./test/fixtures/pdf/sicp.pdf:82","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"近の素数をテストするのに必要な時間をどれ程と見繕うだろうか\n?\n実際との相違をどのように説明できるか\n?\nExercise 1.25:\nAlyssa P. Hacker\nは\nexpmod\nを書くにあたって多く\nの余分な仕事を行ったと文句を言った。結局のところ我々は既に\n指数演算のやり方を知っているのだから単純に以下のように書く\nことができたはずだと彼女は言った。\n(\ndefine\n(\nexpmod\nbase\nexp\nm\n)\n(\nremainder\n(\nfast-expt\nbase\nexp\n)\nm\n))\n彼女は正しいだろうか\n?\nこの手続は最初の素数判定と同様にうま\nく行えるだろうか\n?\nExercise 1.26:\nLouis Reasoner\nは\nExercise 1.24\nを行うのに随分と\n苦労した。彼の\nfast-prime?\nテストは彼の\nprime?\nテストよりも\n随分遅いようだ。\nLouis\nは友達の\nEva Lu Ator\nを呼んで助けを求め\nた。彼らが\nLouis\nのコードを試してみると、\nLouis\nが\nexpmod\n手続\nを\nsquare\n手続を呼ぶのでなく、明示的に乗算を用いていることを\n見つけた。\n(\ndefine\n(\nexpmod\nbase\nexp\nm\n)\n(\ncond\n((=\nexp\n0) 1)\n((\neven?\nexp\n)\n(\nremainder\n(* (\nexpmod\nbase\n(/\nexp\n2)\nm\n)\n(\nexpmod\nbase\n(/\nexp\n2)\nm\n))\nm\n))\n(\nelse\n(\nremainder\n(*\nbase\n(\nexpmod\nbase\n(-\nexp\n1)\nm\n))\nm\n))))\n“\nこれがどんな違いを生んでいるのかわからないよ\n”\nと\nLouis\nは言\nった。\n“\n私にはわかる\n”\nと\nEva\nが言う。\n“\n手続をそのように記述す\nることで、\nΘ(푙표푔 푛)\nのプロセスを\nΘ(푛)\nのプロセスに変えてしま\nったの。\n”\n説明せよ。\nExercise 1.27:\nFootnote 1.47\nにて並べられたカーマイケル数が実\n際にフェルマーテストを騙すか実演せよ。整数\n푛\nを取り\n푎\n푛\nが\n푎\n56","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":82},{"id":"./test/fixtures/pdf/sicp.pdf:83","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"と法\n푛\nに関して合同であるか全ての\n푎 < 푛\nに対しテストを行う手\n続を書き、与えられたカーマイケル数に対してその手続を試せ。\nExercise 1.28:\n騙されないフェルマーテストの\n1\nつの変形とし\nて\nMiller-Rabin test\n(\nMiller 1976\n;\nRabin 1980\n)\nがある。これはフェ\nルマーの小定理の代替形から始めるが、それは\n푛\nが素数でかつ\n푎\nが\n푛\n以下の任意の正の整数である時、\n푎\nの\n(푛 − 1)\n乗は法\n푛\nに関\nして\n1\nと合同であると定める。\nMiller-Rabin\nテストで数値\n푛\nの素\n数判定を行うには乱数\n푎 < 푛\nを選択し、\n푎\nの\n(푛 − 1)\n乗の\n푛\nを法\nとする剰余を\nexpmod\n手続を用いて求める。しかし、\nexpmod\n手続\n中で二乗するステップにおいて毎回、\n“\n自明でない法\n푛\nに関する\n1\nの平方根\n”\nを見つけたかチェックを行う。これは\n1\nまたは\n푛 − 1\nに\n等しくない数値でかつ、法\n푛\nに関して二乗した値の剰余が\n1\nに等\nしい数値である。そのような自明でない\n1\nの平方根が存在すれば\n푛\nが素数ではないことが証明可能である。またもし\n푛\nが素数でな\nい奇数である時、少なくとも\n푎 < 푛\nの半分においてこのような方\n法で\n푎\n푛−1\nを演算すると自明でない法\n푛\nに関する\n1\nの平方根が現\nれることが証明可能である。\n(\nこれがなぜ\nMiller-Rabin\nテストが騙\nされないかである\n)\n。\nexpmod\n手続を変更し自明でない\n1\nの平方根を\n見つけた時合図を送るようにし、それを用いて\nfermat-test\nに似\nた\nMiller-Rabin\nテストを実装せよ。既知の素数、非素数を用いて\nあなたの手続をチェックせよ。ヒント：\nexpmod\nに合図を送らせる\n簡単な方法は\n0\nを返させることである。\n1.3\n高階手続による抽象の形式化\n私達はここまでで手続が事実上、特定の値から独立した数値への複合命令\nを記述する抽象化であることを見てきました。例えば、\n(\ndefine\n(\ncube\nx\n) (*\nx\nx\nx\n))\nこれは特定の値の立方について述べているのではなく、任意の数値の立方を得\nるための手法について述べている訳です。もちろんこの手続を定義することな\nく常に以下のような式を書くことでやっていくことも可能です。\n(* 3 3 3)\n57","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":83},{"id":"./test/fixtures/pdf/sicp.pdf:84","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(*\nx\nx\nx\n)\n(*\ny\ny\ny\n)\nそして明示的に\ncube\nについて触れないことも可能でしょう。しかしこれはと\nても大きな不便を与えます。高レベルな命令の用語ではなく常に言語内にプリ\nミティブとして偶然存在するレベルの特定の命令レベルにて働かざるを得なく\nなります\n(\nこのケースでは乗算です\n)\n。私達のプログラムは立方を計算可能です\nが、私達の言語は立方のコンセプトを表現する能力が欠けているかもしれませ\nん。私達が強力なプログラミング言語から望むべき物の\n1\nつは共通のパター\nンに対し名前を付けることで抽象を構築し、その後抽象化の用語にて直接働く\n能力です。手続はこの能力を与えます。これがなぜ原始的な物を除いた全ての\nプログラミング言語にて手続を定義するメカニズムが含まれているかの理由\nです。\nそれにも関わらず数値演算ですら、もし手続のパラメータが数値のみであ\nると制約されていれば抽象化を行うには我々の能力は非常に大きく制限されて\nいると言えるでしょう。しばしば同じプログラムのパターンがいくつもの異な\nる手続にて使用されます。そのようなパターンを表現するには引数として手続\nを受け入れることができるか、手続を値として返すような手続を構築する必要\nが出てきます。手続を操作する手続は\nhigher-order procedures\n(\n高階手続\n)\nと呼\nばれます。この節では高階手続がどのように強力な抽象化メカニズムを果たし、\n言語の表現力を幅広く増大するかを示します。\n1.3.1\n引数としての手続\n次の\n3\nつの手続について考えてみて下さい。\n1\nつ目は\na\nから\nb\nの整数の合\n計を計算します。\n(\ndefine\n(\nsum-integers\na\nb\n)\n(\nif\n(>\na\nb\n)\n0\n(+\na\n(\nsum-integers\n(+\na\n1)\nb\n))))\n2\nつ目は与えられた範囲の整数の立方の合計を計算します。\n(\ndefine\n(\nsum-cubes\na\nb\n)\n(\nif\n(>\na\nb\n)\n0\n(+ (\ncube\na\n)\n58","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":84},{"id":"./test/fixtures/pdf/sicp.pdf:85","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nsum-cubes\n(+\na\n1)\nb\n))))\n3\nつ目は以下の級数の一連の項の合計を計算します。\n1\n1 ⋅ 3\n+\n1\n5 ⋅ 7\n+\n1\n9 ⋅ 11\n+ ... ,\nこれは\n휋/8\nに\n(\nとてもゆっくりと\n)\n収束します。\n49\n(\ndefine\n(\npi-sum\na\nb\n)\n(\nif\n(>\na\nb\n)\n0\n(+ (/ 1.0 (*\na\n(+\na\n2)))\n(\npi-sum\n(+\na\n4)\nb\n))))\nこれらの\n3\nつの手続は明確に共通な基礎をなすパターンを共有しています。そ\nれらはほとんどの部分が同一で、手続の名前、和を求める項を\na\nを用いて演算\nする関数、\na\nの次の値を与える関数のみが異なります。各手続を同じテンプレ\nートを用いて枠を埋めることで生成することができそうです。\n(\ndefine\n(\n⟨\nname\n⟩\na\nb\n)\n(\nif\n(>\na\nb\n)\n0\n(+ (\n⟨\nterm\n⟩\na\n)\n(\n⟨\nname\n⟩\n(\n⟨\nnext\n⟩\na\n)\nb\n))))\nこのような共通パターンの存在は便利な抽象化が表に浮かび上がるのを待\nっていることを示す強力な証拠です。実際に数学者は大昔に\nsummation of a\nseries\n(\n級数の和\n)\nの抽象化を特定し\n“\nシグマ記法\n”\nを開発しました。つまり、\n푏\n∑\n푛=푎\n푓(푛) = 푓(푎) + ... + 푓(푏),\nこのように表現します。シグマ記法の力は数学者に特定の合計のみについてで\nはなく、総和のコンセプト自身について取り扱うことを可能にしました。例え\nば特定の級数の和を求めることから独立して一般的な総和についての結果を形\n式化することを可能としたのです。\n49\nこの級数は一般に等価である形式\n휋\n4\n= 1 −\n1\n3\n+\n1\n5\n−\n1\n7\n+ ...\nにて記述される\nLeibniz\nに\nよる物です。私達はこれがある高級な数学上のトリックに使われるのを\nSection 3.5.3\nで\n見ることになります。\n59","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":85},{"id":"./test/fixtures/pdf/sicp.pdf:86","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"同様に、プログラムの設計者である私達は言語に、特定の総和を求める手\n続のみでなく、総和自身のコンセプトを表現する手続を書くことができるのに\n十分に強力になって欲しいと願うでしょう。そうすることが直ぐに私達の手続\n言語にて上記にて示された共通テンプレートを用いて、\n“\n枠\n”\nを形式パラメータ\nに変換することで可能です。\n(\ndefine\n(\nsum\nterm\na\nnext\nb\n)\n(\nif\n(>\na\nb\n)\n0\n(+ (\nterm\na\n)\n(\nsum\nterm\n(\nnext\na\n)\nnext\nb\n))))\nsum\nが引数として下限と上限の\na\nと\nb\nを手続\nterm\nと\nnext\nと一緒に取ることに\n注意して下さい。\nsum\nはこれから行うように好きな手続を使用することができ\nます。例えばそれを\n(\n引数に\n1\nを足す手続\ninc\nと共に\n)\nsum-cubes\nの定義に利用\n可能です。\n(\ndefine\n(\ninc\nn\n) (+\nn\n1))\n(\ndefine\n(\nsum-cubes\na\nb\n)\n(\nsum\ncube\na\ninc\nb\n))\nこれを用いて整数\n1\nから\n10\nの立方の和を求めることができます。\n(\nsum-cubes\n1 10)\n3025\nterm\nを求める\nidentity\nプロシジャの助けを借りて、\nsum\nを用いて\nsum-integers\nの定義ができます。\n(\ndefine\n(\nidentity\nx\n)\nx\n)\n(\ndefine\n(\nsum-integers\na\nb\n)\n(\nsum\nidentity\na\ninc\nb\n))\nこれで\n1\nから\n10\nまでの整数の和を求められます。\n(\nsum-integers\n1 10)\n55\npi-sum\nも同様に定義可能です。\n50\n50\nブロック構造\n(\nSection 1.1.8\n)\nを\npi-sum\nの中に\npi-next\nと\npi-term\nの定義を埋め込\nむために使用していることに注意して下さい。これらの手続は任意の他の手続に対し\n60","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":86},{"id":"./test/fixtures/pdf/sicp.pdf:87","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\npi-sum\na\nb\n)\n(\ndefine\n(\npi-term\nx\n)\n(/ 1.0 (*\nx\n(+\nx\n2))))\n(\ndefine\n(\npi-next\nx\n)\n(+\nx\n4))\n(\nsum\npi-term\na\npi-next\nb\n))\nこれらの手続を用いて\n휋\nの近似値を求められます。\n(* 8 (\npi-sum\n1 1000))\n3.139592655589783\nsum\nを手に入れたことで、それを構築用ブロックとしてより多くのコンセプト\nの形式化にて利用可能です。例えば関数\n푓\nの\n푎\nと\n푏\nの限度値の間の定積分は以\n下の式を用いて小さな値\n푑푥\nに対し数値的に近似可能です。\n∫\n푏\n푎\n푓  = [ 푓(푎 +\n푑푥\n2\n) + 푓(푎 + 푑푥 +\n푑푥\n2\n) + 푓(푎 + 2푑푥 +\n푑푥\n2\n) + ... ]푑푥\nこれを直接、手続として表現します。\n(\ndefine\n(\nintegral\nf\na\nb\ndx\n)\n(\ndefine\n(\nadd-dx\nx\n)\n(+\nx\ndx\n))\n(* (\nsum\nf\n(+\na\n(/\ndx\n2.0))\nadd-dx\nb\n)\ndx\n))\n(\nintegral\ncube\n0 1 0.01)\n.24998750000000042\n(\nintegral\ncube\n0 1 0.001)\n.249999875000001\n(\ncube\nの\n0\nから\n1\nの実際の定積分の値は\n1/4\nです。\n)\nExercise 1.29:\nシンプソンの公式は上記にて示された方法よりもよ\nり正確な数値積分の方法である。シンプソンの公式を用いて\n푎\nと\n有用ではなかろうためです。それらを一緒にどのように取り除くかについては\nSection\n1.3.2\nで説明します。\n61","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":87},{"id":"./test/fixtures/pdf/sicp.pdf:88","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"푏\nの間の\n푓\nの定積分は次のように近似される。\nℎ\n3\n(푦\n0\n+ 4푦\n1\n+ 2푦\n2\n+ 4푦\n3\n+ 2푦\n4\n+ ... + 2푦\n푛−2\n+ 4푦\n푛−1\n+ 푦\n푛\n),\nここで\nℎ = (푏 − 푎)/푛\n、\n푛\nは偶数、\n푦\n푘\n= 푓(푎 + 푘ℎ)\nである。\n(\n푛\nを\n増やすことで近似の精度を高めることができる\n)\n。\n푓\n,\n푎\n,\n푏\n,\n푛\nを引\n数に取りシンプソンの公式を用いて求めた定積分の値を返す手続\nを定義せよ。\nExercise 1.30:\n上の\nsum\n手続は線形再帰を生成する。手続は和の計\n算が線形で行われるよう書き直すことが可能だ。次の定義にて消\nされた表記を埋め、どのように行うのか示せ。\n(\ndefine\n(\nsum\nterm\na\nnext\nb\n)\n(\ndefine\n(\niter\na\nresult\n)\n(\nif\n⟨\n??\n⟩\n⟨\n??\n⟩\n(\niter\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\n(\niter\n⟨\n??\n⟩\n⟨\n??\n⟩\n))\nExercise 1.31:\na\nsum\n手続は高階手続として捉えられる非常に多くの数の同様\nな抽象化の最も簡単な物にすぎない。\n51\nproduct\nと呼ぶ与え\nられた範囲の点の関数値の積を返す類似の手続を書け。どの\nようにして\nproduct\nを用いて\nfactorial\nを定義するのか示\nせ。また\nproduct\nを用いて次の式を使用して\n휋\nの近似値を計\n算せよ。\n52\n휋\n4\n=\n2 ⋅ 4 ⋅ 4 ⋅ 6 ⋅ 6 ⋅ 8 ...\n3 ⋅ 3 ⋅ 5 ⋅ 5 ⋅ 7 ⋅ 7 ...\n.\n51\nExercise 1.31\nから\nExercise 1.33\nの間の目的は一見異なる操作を強固にするための適\n切な抽象化を用いることで獲得される表現力を実演することだ。しかし、集積やフィル\nタリングは洗練された考えではあるが、この時点では我々の両手が縛られているような\nものだ。私達はまだこれらの抽象化のための組み合わせの意図に適切なデータ構造を持\nっていないためである。私達は\nSection 2.2.3\nにてこれらの考えに立ち戻り、集積とフィル\nターを組み合わせるためのインターフェイスとして列をどのように使うのかを示しさら\nに一層強力な抽象化を構築する。そこではこれらの手法が実際にどのようにしてプログ\nラムを設計するのに強力で洗練されたアプローチとして役に立つのかを学ぶ。\n52\nこの式は\n17\n世紀に英国人数学者\nJohn Wallis\nにより発見されました。\n62","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":88},{"id":"./test/fixtures/pdf/sicp.pdf:89","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"b\nもしあなたの\nproduct\n手続が再帰プロセスを生成するのであ\nれば線形プロセスを生成するものを書け。もし線形プロセス\nを生成するのであれば再帰プロセスを生成するものを書け。\nExercise 1.32:\na.\nsum\nと\nproduct\n(\nExercise 1.31\n)\nは両方とも、汎用の集積関数\nを用いて項の集合を結合する\n@codeaccumulate(\n集積\n)\nと呼ば\nれるより一般的な目的の特別なケースに過ぎない。\n(\naccumulate\ncombiner\nnull-value\nterm\na\nnext\nb\n)\naccumulate\nは引数として\nsum\nと\nproduct\nと同じく項と範囲\nの指定を\n(2\nつの引数の\n)\ncombiner\n手続と\nnull-value\nを共に\n得る。\ncombiner\nはどのように現在の項が以前の項の集積と結\n合されるかを指定し、\nnull-value\nは項が尽きた時に使用す\nる基となる値を指定する。\naccumulate\nを書き\nsum\nと\nproduct\nの両者がどのように簡単な\naccumulate\nの呼び出しで定義で\nきるかを示せ。\nb.\nあなたの\naccumulate\nが再帰プロセスを生成するのなら線形\nプロセスを生成する物を書け。もし線形プロセスを生成する\nのならば再帰プロセスを生成する物を書け。\nExercise 1.33:\nより汎用的なバージョンの\naccumulate\n(\nExercise\n1.32\n)\nを結合される項の\nfilter\n(\nフィルタ\n)\nの概念を紹介することで\n得ることが可能だ。指定された条件を満たす範囲の値から導かれ\nる項のみを連結する。結果としての\nfiltered-accumulate\n抽象は\naccumulate\nと同じ引数を追加の\n1\n引数の述語と共に取り、述語\nはフィルタを指定する。手続としての\nfiltered-accumulate\nを書\nけ。以下を\nfiltered-accumulate\nを用いてどのように表現するか\nを示せ。\na\n푎\nと\n푏\nの区間の素数の二乗の和\n(\nあなたは既に\nprime?\n述語を\n書いていると前提する\n)\nb\n全ての\n푛\n未満の正の整数でかつ\n푛\nに対して互いに素\n(\nつまり\n퐺퐶퐷(푖, 푛) = 1\nとなる全ての整数\n푖 < 푛\n)\nの積\n63","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":89},{"id":"./test/fixtures/pdf/sicp.pdf:90","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.3.2\nlambda\nを用いた手続の構築\nSection 1.3.1\nに示すよう\nsum\nを使用する時、\npi-term\nや\npi-next\nのような\n自明な手続を高階手続にて引数として使うためだけに定義せねばならないのは\nひどく不恰好に見えます。\npi-next\nや\npi-term\nを定義する代わりに、\n“\n入力値に\n4\nを足す手続\n”\nや\n“\n入力値と入力値に\n2\nを足した数の積の逆数を返す手続\n”\nを直\n接指定する方法を持つほうがより便利になるでしょう。これは手続を作成する\n特別な形式\nlambda\nを紹介することで可能です。\nlambda\nを用いることで先程行\nいたかったことを以下のように記述できます。\n(\nlambda\n(\nx\n) (+\nx\n4))\nそして\n(\nlambda\n(\nx\n) (/ 1.0 (*\nx\n(+\nx\n2))))\n次に\npi-sum\n手続は補助的な手続を定義すること無しに表現が可能となります。\n(\ndefine\n(\npi-sum\na\nb\n)\n(\nsum\n(\nlambda\n(\nx\n) (/ 1.0 (*\nx\n(+\nx\n2))))\na\n(\nlambda\n(\nx\n) (+\nx\n4))\nb\n))\n同様に\nlambda\nを使用して、\nintegral\n手続を補助的な手続\nadd-dx\nを定義する\nことなく書くことが可能です。\n(\ndefine\n(\nintegral\nf\na\nb\ndx\n)\n(* (\nsum\nf\n(+\na\n(/\ndx\n2.0))\n(\nlambda\n(\nx\n) (+\nx\ndx\n))\nb\n)\ndx\n))\n一般的に、\nlambda\nは\ndefine\nと同様に手続を作成しますが、手続に対して名前\nが指定されないことが異なります。\n(\nlambda\n(\n⟨\nformal-parameters\n⟩\n)\n⟨\nbody\n⟩\n)\n結果としての手続は\ndefine\nを用いて作成した手続と同じです。ただ\n1\nつの違\nいはそれが環境においてどのような名前にも結び付けられていないことです。\n64","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":90},{"id":"./test/fixtures/pdf/sicp.pdf:91","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nplus4\nx\n) (+\nx\n4))\n上記は以下と等価です。\n(\ndefine\nplus4\n(\nlambda\n(\nx\n) (+\nx\n4)))\nlambda\n式は以下のように読むことができます。\n(\nlambda\n(\nx\n)\n(+\nx\n4))\n|\n|\n|    |\n|\nthe\nprocedure\nof\nan\nargument\nx\nthat\nadds\nx\nand\n4\n手続は\n引数\nx\nを持ち\n足す\nx\nと\n4\n任意の値として手続を持つ式と同様に、\nlambda\n式は複合式においてオペレー\nタとして使用することが可能です。例えば、\n((\nlambda\n(\nx\ny\nz\n) (+\nx\ny\n(\nsquare\nz\n)))\n1 2 3)\n12\nまたはより一般的に、私達が通常手続の名前を使用する任意の文脈において使\n用可能です。\n53\nローカル変数使用のため\nlet\nを用いる\n別の\nlambda\n使用法にはローカル変数の作成があります。形式的パラメータ\nに束縛されていないローカル変数を手続で必要とする場合は良くあります。例\nえば以下の関数を演算したいとします。\n푓(푥, 푦) = 푥(1 + 푥푦)\n2\n+ 푦(1 − 푦) + (1 + 푥푦)(1 − 푦),\nこれは以下のようにも表現できます。\n푎 = 1 + 푥푦,\n푏 = 1 − 푦,\n푓(푥, 푦) = 푥푎\n2\n+ 푦푏 + 푎푏.\n53\nLisp\nを学ぶ人にとっては\nlambda\nという名前よりは\nmake-procedure\nの様な名前を\n使用したほうがより判りやすいか、または恐しく思わせたりはしないでしょう。しかし\nこの慣習はしっかりと根付いた物です。この表記は\n휆\n-calculus(\nラムダ演算\n)\nという数理\n論理学者\nAlonzo\nChurch (1941)\nにより発表された数学上の形式主義の名から受け入れら\nれています。\nChurch\nは\n휆\n演算を関数と関数適用の概念を学ぶための厳格な基礎として\n与えるために開発しました。\n휆\n演算はプログラミング言語の意味の数学上の研究のため\nの基礎的なツールとなりました。\n65","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":91},{"id":"./test/fixtures/pdf/sicp.pdf:92","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"푓\nを求める手続を書く場合、\n푥\nと\n푦\nのみでなく中間値の名前として\n푎\nや\n푏\nをローカル変数として含みたくなるでしょう。これを実現する\n1\nつの方法とし\nて補助的な手続をローカル変数を束縛するため使用することがあります。\n(\ndefine\n(\nf\nx\ny\n)\n(\ndefine\n(\nf-helper\na\nb\n)\n(+ (*\nx\n(\nsquare\na\n))\n(*\ny\nb\n)\n(*\na\nb\n)))\n(\nf-helper\n(+ 1 (*\nx\ny\n))\n(- 1\ny\n)))\nもちろん、\nlambda\n式を用いて無名手続をローカル変数の束縛のため指定する\nことも可能です。\nf\nのボディはすると手続への単一の呼び出しになります。\n(\ndefine\n(\nf\nx\ny\n)\n((\nlambda\n(\na\nb\n)\n(+ (*\nx\n(\nsquare\na\n))\n(*\ny\nb\n)\n(*\na\nb\n)))\n(+ 1 (*\nx\ny\n))\n(- 1\ny\n)))\nこの構成はとても便利で\nlet\nと呼ばれる特別な形式がその使用をより便利に\nするために用意されています。\nlet\nを用いることで手続\nf\nは以下のようになり\nます。\n(\ndefine\n(\nf\nx\ny\n)\n(\nlet\n((\na\n(+ 1 (*\nx\ny\n)))\n(\nb\n(- 1\ny\n)))\n(+ (*\nx\n(\nsquare\na\n))\n(*\ny\nb\n)\n(*\na\nb\n))))\nlet\n式の一般的な形式は次のとおりです。\n(\nlet\n((\n⟨\n푣푎푟\n1\n⟩\n⟨\n푒푥푝\n1\n⟩\n)\n(\n⟨\n푣푎푟\n2\n⟩\n⟨\n푒푥푝\n2\n⟩\n)\n...\n(\n⟨\n푣푎푟\n푛\n⟩\n⟨\n푒푥푝\n푛\n⟩\n))\n66","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":92},{"id":"./test/fixtures/pdf/sicp.pdf:93","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"⟨\nbody\n⟩\n)\nこれは以下のように考えることが可能です。\nlet\n⟨\n푣푎푟\n1\n⟩\nhave\nthe\nvalue\n⟨\n푒푥푝\n1\n⟩\nand\n⟨\n푣푎푟\n2\n⟩\nhave\nthe\nvalue\n⟨\n푒푥푝\n2\n⟩\nand\n...\n⟨\n푣푎푟\n푛\n⟩\nhave\nthe\nvalue\n⟨\n푒푥푝\n푛\n⟩\nin\n⟨\nbody\n⟩\n(let\nは使役の意ですので、\n⟨\nbody\n⟩\nの中では\n⟨푣푎푟\n1\n⟩\nは\n⟨푒푥푝\n1\n⟩\nの値を持たせ\nる、以下繰り返しと読めます。\n)\nlet\n式の最初の部分は名前と式のペアのリストです。\nlet\nが評価される時、各\n名前は関連する式の値と関連付けされます。\nlet\nのボディはこれらのローカル\nな値に束縛された名前と共に評価されます。\nlet\n式は以下の代替文法として評\n価されるためこれが起こります。\n((\nlambda\n(\n⟨\n푣푎푟\n1\n⟩\n...\n⟨\n푣푎푟\n푛\n⟩\n)\n⟨\nbody\n⟩\n)\n⟨\n푒푥푝\n1\n⟩\n...\n⟨\n푒푥푝\n푛\n⟩\n)\nインタプリタ内にはローカル変数を提供するために新しいメカニズムが必要と\nされません。\nlet\n式は中で行われる\nlambda\n適用に対する構文糖でしかありま\nせん。\nこの等価式から\nlet\n式にて指定された変数のスコープが\nlet\nのボディであ\nることがわかります。これが以下のことを暗示します。\n•\nlet\nは変数を可能な限り使用される場所に局地的に束縛します。例えば\nもし\nx\nの値が\n5\nである時、次の式の値は\n(+ (\nlet\n((\nx\n3))\n(+\nx\n(*\nx\n10)))\nx\n)\n38\nです。ここで\nlet\nのボディの中の\nx\nは\n3\nですので\nlet\n式の値は\n33\nで\nす。一方で最も外側の\n+\nの第二引数である\nx\nは依然\n5\nです。\n•\n変数の値は\nlet\nの外側にて計算されます。これはローカル変数の値を提\n供する式がローカル変数自身と同じ名前を持っている変数に依存する場\n合に問題となります。例えば、もし\nx\nの値が\n2\nの時、次の式では\n67","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":93},{"id":"./test/fixtures/pdf/sicp.pdf:94","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\nx\n3)\n(\ny\n(+\nx\n2)))\n(*\nx\ny\n))\n式の値は\n12\nになります。\nlet\nのボディ内部では\nx\nは\n3\n、\ny\nは\n4(\n外側の\nx\n足す\n2)\nになるためです。\n時には\nlet\nと同様の効果を得るために内部定義を利用することもあります。例\nとして、上記の手続\nf\nを次のように定義することも可能でした。\n(\ndefine\n(\nf\nx\ny\n)\n(\ndefine\na\n(+ 1 (*\nx\ny\n)))\n(\ndefine\nb\n(- 1\ny\n))\n(+ (*\nx\n(\nsquare\na\n))\n(*\ny\nb\n)\n(*\na\nb\n)))\nしかしこのような状況では\nlet\nを使用し、内部定義は内部手続のみのために利\n用することを好みます。\n54\nExercise 1.34:\n以下の手続を定義したとする。\n(\ndefine\n(\nf\ng\n) (\ng\n2))\nすると以下の結果を得る。\n(\nf\nsquare\n)\n4\n(\nf\n(\nlambda\n(\nz\n) (*\nz\n(+\nz\n1))))\n6\nもし\n(\n天邪鬼にも\n)\nインタプリタに\n(f f)\nの組み合わせを評価させ\nたらどのような結果が起こるか\n?\n説明せよ。\n54\n内部定義を十分に良く理解し、プログラムが私達がそれに意図した意味を意味する\nことを確実にするには私達がこの章で紹介したよりもより複雑な評価過程のモデルを必\n要とします。しかし手続の内部定義と共にはその機微は浮かび上がりません。この問題\nについては\nSection 4.1.6\nにて評価についてより学んだ後に立ち戻ります。\n68","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":94},{"id":"./test/fixtures/pdf/sicp.pdf:95","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1.3.3\n汎用手法としての手続\nSection 1.1.4\nにて複合手続を数値演算の抽象化パターンのメカニズムとし\nて紹介し、関係する特定の数値から独立させました。\nSection 1.3.1\nの\nintegral\n手続のような高階手続ではより強力な種類の抽象化について学び始めました。\n関係する特定の関数から独立した汎用的演算手法を表現するのに利用される手\n続でした。この節では\n2\nつのより複雑な例\n—\n零と関数の不動点を見付けるため\nの汎用手法\n—\nについて議論します。そしてこれらの手法がどのように手続とし\nて直接的に表現されるのかを示します。\n半区間手法により方程式の根を求める\nhalf-interval method\n(\n半区間手法\n)\nは方程式\n푓(푥) = 0\nの根を求めるのに単\n純ながら強力なテクニックです。ここで\n푓\nは連続関数とします。この考えは\n푓(푎) < 0 < 푓(푏)\nとなる点\n푎\nと\n푏\nを与えた時、\n푓\nは最低でも\n1\nつの\n0\nを\n푎\nと\n푏\nの間に持つことになります。ゼロを特定するために\n푎\nと\n푏\nの平均\n푥\nを求め\n푓(푥)\nを計算します。もし\n푓(푥) > 0\nなら\n푓\nは\n0\nを\n푎\nと\n푥\nの間に持ちます。もし\n푓(푥) < 0\nなら\n푓\nは\n0\nを\n푥\nと\n푏\nの間に持ちます。このように繰り返すことで\n푓\nが\n0\nを持つより小さな区間を特定できます。区間が十分に小さな時点に辿りつ\nいたら処理は停止します。不確かな区間が処理の各ステップにて半分になるた\nめ、必要とされるステップ数は\nΘ(푙표푔(퐿/푇 ))\nに従い増加します。このとき\n퐿\nは元の区間の長さで\n푇\nは許容誤差\n(\n私達が\n“\n十分に小さい\n”\nと考える区間のサ\nイズ\n)\nになります。この戦略を実装した手続が以下になります。\n(\ndefine\n(\nsearch\nf\nneg-point\npos-point\n)\n(\nlet\n((\nmidpoint\n(\naverage\nneg-point\npos-point\n)))\n(\nif\n(\nclose-enough?\nneg-point\npos-point\n)\nmidpoint\n(\nlet\n((\ntest-value\n(\nf\nmidpoint\n)))\n(\ncond\n((\npositive?\ntest-value\n)\n(\nsearch\nf\nneg-point\nmidpoint\n))\n((\nnegative?\ntest-value\n)\n(\nsearch\nf\nmidpoint\npos-point\n))\n(\nelse\nmidpoint\n))))))\n最初に関数\n푓\nを値が負と正になる\n2\nつの点と共に与えられると想定します。最\n初に\n2\nつの与えられた点の中間点を求めます。次に与えられた区間が十分に小\nさいかチェックし、もしそうであれば単純に中間点を答とします。そうでなけ\n69","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":95},{"id":"./test/fixtures/pdf/sicp.pdf:96","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"れば中間点における\n푓\nの値を\ntest-value(\n試験値\n)\nとして計算します。もし試験\n値が正ならば、元の負の地点から中間点までの新しい区間にて処理を続けます。\nもし試験値が負ならば中間値から正の地点までの区間にて処理を続けます。最\n終的に試験値が\n0\nになる可能性がありますが、その場合、中間地点そのものが\n我々が探している根となります。\n終了地点が\n“\n十分に近い\n”\nか試験するためには\nSection 1.1.7\nにて平方根を求\nめるために利用した物と同様の手続が利用可能です。\n55\n(\ndefine\n(\nclose-enough?\nx\ny\n) (< (\nabs\n(-\nx\ny\n)) 0.001))\nsearch\nは直接利用するのは扱いにくいです。\n푓\nの値が必要な符号を持たない点\nを意図せず与えてしまうことが可能なためです。そのような場合では間違った\n答を得てしまいます。代わりに\nsearch\nを次の手続を経由して使用することに\nしましょう。これは終端のどちらが負の関数値を持ち、どちらが正の関数値を\n持つか検査します。そして\nsearch\n手続を適切に呼び出します。もし関数が\n2\nつの与えられた点にて同じ符号を持つ場合、半区間手法は使用できません。こ\nの場合この手続はエラーを伝えます。\n56\n(\ndefine\n(\nhalf-interval-method\nf\na\nb\n)\n(\nlet\n((\na-value\n(\nf\na\n))\n(\nb-value\n(\nf\nb\n)))\n(\ncond\n((\nand\n(\nnegative?\na-value\n) (\npositive?\nb-value\n))\n(\nsearch\nf\na\nb\n))\n((\nand\n(\nnegative?\nb-value\n) (\npositive?\na-value\n))\n(\nsearch\nf\nb\na\n))\n(\nelse\n(\nerror\n\"\nValues\nare\nnot\nof\nopposite\nsign\n\"\na\nb\n)))))\n次の例は半区間手法を使用して\n휋\nの近似を\n푠푖푛 푥 = 0\nの\n2\nと\n4\nの間の根として\n求めています。\n(\nhalf-interval-method\nsin\n2.0 4.0)\n3.14111328125\n55\n私達は\n“\n小さな\n”\n値の表現として\n0.001\nを用い、計算にて受け入れられる誤差の許容\n範囲を示しました。実際の演算における適切な許容範囲は解決すべき問題、計算機とア\nルゴリズムの制約に依存します。これはしばしばとても微妙な考慮事項であり、数値解\n析者や他の魔法使いのような人達の助けを必要とします。\n56\nこれは\nerror\nを用いて達成できます。\nerror\nは引数としていくつかの項目を受け取\nりそれらをエラーメッセージとして出力します。\n70","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":96},{"id":"./test/fixtures/pdf/sicp.pdf:97","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"また次の別の例では半区間手法を用いて方程式\n푥\n3\n− 2푥 − 3 = 0\nにおいて\n1\nと\n2\nの間で根を探しています。\n(\nhalf-interval-method\n(\nlambda\n(\nx\n) (- (*\nx\nx\nx\n) (* 2\nx\n) 3))\n1.0\n2.0)\n1.89306640625\n関数の不動点を求める\n数値\n푥\nは\n푥\nが等式\n푓(푥) = 푥\nを満たす時、関数\n푓\nの\nfixed point\n(\n不動点\n)\nと呼\nばれます。いくつかの関数\n푓\nに対し不動点を初期推測値から始めて\n푓\nを値があ\nまり変わらなくなるまで繰り返し適用することで求めることができます。\n푓(푥),\n푓(푓(푥)),\n푓(푓(푓(푥))),\n... ,\nこの考えを用いて関数と初期推定値を入力とし、関数の不動点への近似を生成\nする手続、\nfixed-point\nを開発できます。指示した許容範囲未満の差に二点が\n収まるまで関数を繰り返し適用します。\n(\ndefine\ntolerance\n0.00001)\n(\ndefine\n(\nfixed-point\nf\nfirst-guess\n)\n(\ndefine\n(\nclose-enough?\nv1\nv2\n)\n(< (\nabs\n(-\nv1\nv2\n))\ntolerance\n))\n(\ndefine\n(\ntry\nguess\n)\n(\nlet\n((\nnext\n(\nf\nguess\n)))\n(\nif\n(\nclose-enough?\nguess\nnext\n)\nnext\n(\ntry\nnext\n))))\n(\ntry\nfirst-guess\n))\n例えばこの手法をコサイン関数の不動点を近似するのに利用できます。初期推\n測値は\n1\nとします。\n57\n(\nfixed-point\ncos\n1.0)\n.7390822985224023\n57\n以下を暇な授業の間に実行してみて下さい：電卓をラジアンモードに設定し不動点\nに到達するまで\ncos\nを連打してみましょう。\n71","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":97},{"id":"./test/fixtures/pdf/sicp.pdf:98","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"同様にして、次の方程式の答を見つけられます。\n푦 = 푠푖푛 푦 + 푐표푠 푦\n:\n(\nfixed-point\n(\nlambda\n(\ny\n) (+ (\nsin\ny\n) (\ncos\ny\n))) 1.0)\n1.2587315962971173\n不動点処理は\nSection 1.1.7\nにて平方根を求めるのに使用した処理を思い出させ\nます。両者は共に結果がある判定基準を満たすまで推測値を繰り返し改善する\n考えを基にしています。実際に直ぐに平方根の計算を不動点検索として形式化\nが可能です。ある数値\n푥\nの平方根を求めるには\n푦\n2\n= 푥\nを満たす\n푦\nを探す必要\nがあります。この等式を等価な形式\n푦 = 푥/푦\nにするとその関数\n58\n푦 ↦ 푥/푦\nの\n不動点を探してることに気付きます。従って平方根を以下のように求めること\nを試すことができます。\n(\ndefine\n(\nsqrt\nx\n)\n(\nfixed-point\n(\nlambda\n(\ny\n) (/\nx\ny\n)) 1.0))\n残念ながらこの不動点検索は収束しません。初期推測値を\n푦\n1\nとします。次の\n推測値は\n푦\n2\n= 푥/푦\n1\nでさらに次は\n푦\n3\n= 푥/푦\n2\n= 푥/(푥/푦\n1\n) = 푦\n1\nです。この結\n果は\n2\nつの推測値\n푦\n1\nと\n푦\n2\nがずっと繰り返し、答が振動する無限ループです。\nそのような振動をコントロールする\n1\nつの方法は推測値が大きく変化する\nことを防ぐことです。回答は常に推測値\n푦\nと\n푥/푦\nの間にあるはずですから\n푦\nと\n푥/푦\nの両方から同じ位遠くはない地点にできるはずです。従って\n푦\nと\n푥/푦\nの平\n均を取って\n푦\nの次の推測値は\n1\n2\n(푦 + 푥/푦)\nとなります。\n(\ndefine\n(\nsqrt\nx\n)\n(\nfixed-point\n(\nlambda\n(\ny\n) (\naverage\ny\n(/\nx\ny\n))) 1.0))\n(\n푦 =\n1\n2\n(푦 + 푥/푦)\nは等式\n푦 = 푥/푦\nを単純に変形したものであることに注意して\n下さい。得るためには等式の両辺に\n푦\nを足し、\n2\nで割ります。\nl)\nこの変更により平方根手続がうまく行きます。実際に、もし定義をひも解\nいた場合、ここで生成された平方根の近似の連続は元々の\nSection 1.1.7\nの平方\n根手続が生成するものと正確に同じです。この一連の近似値の平均から回答へ\nのアプローチは、\naverage damping\n(\n平均減衰\n)\nと呼ぶテクニックであり、良く\n不動点検索の収束に対し手助けとなります。\nExercise 1.35:\n黄金比率\n휑\n(\nSection 1.2.2\n)\nは変形\n푥 ↦ 1 + 1/푥\nの不\n動点であることを示せ。この比率を用いて\n휑\nを\nfixed-point\n手続\nを用いて求めよ。\n58\n↦\n(“maps to”(\n写す\n)\nと読みます。\n)\nは数学者による\nlambda\nの記述法です。\n푦 ↦ 푥/푦\nは\n(lambda (y) (/ x y))\nを意味し、\n푦\nにおける関数の値は\n푥/푦\nということです。\n72","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":98},{"id":"./test/fixtures/pdf/sicp.pdf:99","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 1.36:\nfixed-point\nを変更し、\nExercise 1.22\nにて示され\nた\nnewline\nと\ndisplay\nプリミティブを用いて生成する一連の\n近似値を表示するようにせよ。次に\n푥\n푥\n=  1000\nの答を\n푥  ↦\n푙표푔(1000)/푙표푔(푥)\nの不動点を求める方法で求めよ。\n(Scheme\nの\nプリミティブである\nlog\n手続を利用せよ。これは自然対数を計算\nする\n)\n。平均減衰を用いる場合と用いない場合にてステップ数を比\n較せよ。\n(\nfixed-point\nを推定値\n1\nでは開始できないことに注意せ\nよ。これは\n푙표푔(1) = 0\nでの割り算を引き起すためである。\n)\nExercise 1.37:\na\n無限\ncontinued fraction\n(\n連分数\n)\nとは以下の形式の式である。\n푓 =\n푁\n1\n퐷\n1\n+\n푁\n2\n퐷\n2\n+\n푁\n3\n퐷\n3\n+...\n.\n例として、無限連分数の展開として\n푁\n푖\nと\n퐷\n푖\nの全てが\n1\nの\n場合、\n1/휑\nを生成し、この時\n휑\nは\n(\nSection 1.2.2\nで説明した\n)\n黄金比率である。無限連分数の近似を求める\n1\nつの方法と\nして与えられた項の数を越えた後、展開を切り捨てる方法\nがある。そのような切り捨て\n—\n所謂\nk-term finite continued\nfraction\n(\nk\n項有限連分数\n)—\nは以下の形式になる。\n푁\n1\n퐷\n1\n+\n푁\n2\n⋱+\n푁\n푘\n퐷\n푘\n.\nn\nと\nd\nは連分数の\n푁\n푖\n퐷\n푖\nの項を返す\n1\n引数\n(\n項の索引\n푖\n)\nの手\n続であると考える。\n(cont-frac n d k)\nを評価すると\n푘\n項有\n限連分数の値を求める手続、\ncont-frac\nを定義せよ。あなた\nの手続を以下を用いて\n1/휑\nの近似を求めることで、一連の\nk\nの値についてチェックせよ。\n(\ncont-frac\n(\nlambda\n(\ni\n) 1.0)\n(\nlambda\n(\ni\n) 1.0)\nk\n)\n小数点以下\n4\n桁の精度の近似を得るには\nk\nはどれだけの大き\nさでなければならないか\n?\n73","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":99},{"id":"./test/fixtures/pdf/sicp.pdf:100","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"b\nもしあなたの\ncont-frac\n手続が再帰プロセスを生成するのな\nらば線形プロセスを生成するものを書け。もし線形プロセス\nを生成するのであれば、再帰プロセスを生成するものを書け。\nExercise 1.38:\nIn 1737, 1737\n年にスイスの数学者、\nLeonhard Eu-\nler(\nレオンハルト・オイラー\n)\nは学術論文\nDe Fractionibus Con-\ntinuis\nを出版した。それには\n푒\nが自然対数の底である時の、\n푒 − 2\nに対する連分数展開が含まれている。この分数では\n푁\n푖\nは全て\n1\nで\nあり、\n퐷\n푖\nは数列\n1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8,\n...\nである。\nExercise\n1.37\nのあなたの\ncont-frac\n手続を用いてオイラー展開を基にし\n푒\nの近似を求めるプログラムを書け。\nExercise 1.39:\nタンジェント\n(\n正接\n)\n関数の連分数表現は\n1770\n年に\nドイツの数学者\nJ.H. Lambert (\nヨハン・ハインリッヒ・ランベル\nト\n)\nにより発表された。\n푡푎푛 푥 =\n푥\n1 −\n푥\n2\n3−\n푥\n2\n5−...\n,\nここで\n푥\nはラジアンである。ランベルトの式を基にして正接関\n数の近似値を求める手続\n(tan-cf x k)\nを定義せよ。\nk\nは\nExercise\n1.37\nと同様に求める項の数を指定する。\n1.3.4\n返り値としての手続\nここまでの一連の例は手続を引数として渡す能力が著しく私達のプログラ\nミング言語の表現力を拡張することを実演しました。返り値自体が手続である\n手続を作成することでさらに表現力を獲得することができます。\nこの考えを\nSection 1.3.3\nの終わりにて説明された不動点の例を振り返るこ\nとで説明できます。\nsquare-root\n手続の新しいバージョンを、\n√\n푥\nは\n푦 ↦ 푥\n/\n푦\n関数の不動点であるという観察結果から始めて、不動点検索の形で形式化しま\nした。次に平均減衰を用いて近似値を収束させました。平均減衰はそれ自体が\n便利な汎用技法です。即ち関数\n푓\nを与えられた時、\n푥\nにおける関数の値が\n푥\nと\n푓(푥)\nの平均だと考えます。\n平均減衰の考えを次の手続を用いて説明できます。\n(\ndefine\n(\naverage-damp\nf\n) (\nlambda\n(\nx\n) (\naverage\nx\n(\nf\nx\n))))\n74","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":100},{"id":"./test/fixtures/pdf/sicp.pdf:101","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"average-damp\nは引数として手続\nf\nを取りその値として\n(\nlambda\nで生成された\n)\n手続を返します。その手続は数値\nx\nに適用された時、\nx\nと\n(f x)\nの平均を返し\nます。例えば\naverage-damp\nを\nsquare\n手続に適用した時、生成された手続の値\nは、ある値\n푥\nにおいて\n푥\nと\n푥\n2\nの平均となります。この結果の手続に\n10\nを適用\nすれば\n10\nと\n100\nの平均として\n55\nを返します。\n59\n((\naverage-damp\nsquare\n) 10)\n55\naverage-damp\nを用いて\nsquare-root\n手続を次のように再公式化できます。\n(\ndefine\n(\nsqrt\nx\n)\n(\nfixed-point\n(\naverage-damp\n(\nlambda\n(\ny\n) (/\nx\ny\n))) 1.0))\nこの形式化が手法内においてどれだけ\n3\nつの考え、不動点検索、平均減衰、関\n数\n푦 ↦ 푥/푦\nについて明快にしているかに注目して下さい。この\nsquare-root\nの\n手法の形式化と\nSection 1.1.7\nで与えた元のバージョンの比較は示唆的です。こ\nれらの手続が同じ処理について表現していることを心に留めて下さい。そして\n同じ処理をこれらの抽象化を用いて表現した時にどれだけ明白になるのかに注\n目して下さい。一般的に処理を手続に形式化する手法はとても多くの数有りま\nす。経験の豊富なプログラマはどのように手続形式化を選ぶのか、特に明快な\n方法を知っています。そしてどこで処理の便利な要素が他のアプリケーション\nにて再使用可能な独立した要素として浮かび上がるかについて知っているので\nす。再使用の簡単な例として\n푥\nの立方根は関数\n푦 ↦ 푥/푦\n2\nの不動点であること\nに注意して下さい。従って直ぐに\nsquare-root\n手続を立方根を求める手続に汎\n化することが可能です。\n60\n(\ndefine\n(\ncube-root\nx\n)\n(\nfixed-point\n(\naverage-damp\n(\nlambda\n(\ny\n) (/\nx\n(\nsquare\ny\n))))\n1.0))\n59\nこれは組み合わせであり、かつそのオペレータもまた合成式であることに注意して\n下さい。\nExercise 1.4\nにて既にそのような合成式を形式化する能力については実演しまし\nた。しかしあれは単に簡単な例にすぎません。ここではそのような合成式に対する真の\n要求\n—\n高階手続により値として返されることで得られた手続をいつ適用するのかについ\nて学び始めます。\n60\nさらなる一般化については\nExercise 1.45\nを参照して下さい。\n75","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":101},{"id":"./test/fixtures/pdf/sicp.pdf:102","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ニュートン法\nSection 1.1.7\nにて初めて\nsquare-root\n手続を紹介した時に、これは\nNewton’s\nmethod\n(\nニュートン法\n)\nの特別な場合であると伝えました。もし\n푥 ↦ 푔(푥)\nが微\n分可能な関数である時、方程式\n푔(푥) = 0\nの答は以下の条件で関数\n푥 ↦ 푓(푥)\nの\n不動点となります。\n푓(푥) = 푥 −\n푔(푥)\n퐷푔(푥)\nそして\n퐷푔(푥)\nは\n푥\nにより微分した導関数です。ニュートン法は上で学んだ不\n動点を用いる手法で、関数\n푓\nの不動点を探すことで方程式の解の近似を求めま\nす。\n61\n多くの関数\n푔\nにおいて、また十分に良い初期推測値\n푥\nにおいてニュートン\n法は\n푔(푥) = 0\nの解に急速に収束します。\n62\nニュートン法を手続として実装するために、最初に微分の考えを表現せね\nばなりません。\n“\n微分\n”\nは平均減衰と同様にある関数を別の関数へと変形するこ\nとに注目して下さい。例えば関数\n푥 ↦ 푥\n3\nの微分は\n푥 ↦ 3푥\n2\nです。一般的に\n푔\nが関数であり\n푑푥\nが小さな値である時、\n푔\nの導関数\n퐷푔\nはその値が任意の数\n푥\nが与えられた時に\n(\n小さな値\n푑푥\nの極限において\n)\n퐷푔(푥) =\n푔(푥 + 푑푥) − 푔(푥)\n푑푥\n.\n従って微分の考えを\n(\n푑푥\nを例えば\n0.00001\nとして\n)\n手続として次のように表現\nできます。\n(\ndefine\n(\nderiv\ng\n)\n(\nlambda\n(\nx\n) (/ (- (\ng\n(+\nx\ndx\n)) (\ng\nx\n))\ndx\n)))\n次の定義と一緒に用います。\n(\ndefine\ndx\n0.00001)\naverage-damp\nと同様に、\nderiv\nは引数として手続を取り、値として手続を返す\n手続です。例えば導関数\n푥 ↦ 푥\n3\nの\n5\nにおける値\n(\n正確な値は\n75\nです\n)\nの近似\nを求めるために以下のように評価できます。\n61\n初歩的な微積分学の教科書は通常ニュートン法を近似の数列\n푥\n푛+1\n=  푥\n푛\n−\n푔(푥\n푛\n)/퐷푔(푥\n푛\n)\nを用いて説明しています。処理に関する言語を持ち不動点の考えを\n用いることで手法の説明を平易にできます。\n62\nニュートン法は常に解へと収束はしません。しかし好ましい場合においては各繰り\n返しにおいて解の近似値の精度の桁数は二倍になることが示されます。そのような場合\nではニュートン法は半区間手法よりも大変速く収束します。\n76","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":102},{"id":"./test/fixtures/pdf/sicp.pdf:103","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ncube\nx\n) (*\nx\nx\nx\n))\n((\nderiv\ncube\n) 5)\n75.00014999664018\nderiv\nの助けを借りて、ニュートン法を不動点処理として次のように表現でき\nます。\n(\ndefine\n(\nnewton-transform\ng\n)\n(\nlambda\n(\nx\n) (-\nx\n(/ (\ng\nx\n) ((\nderiv\ng\n)\nx\n)))))\n(\ndefine\n(\nnewtons-method\ng\nguess\n)\n(\nfixed-point\n(\nnewton-transform\ng\n)\nguess\n))\nnewton-transform\n手続はこの節の最初の式を表現しています。そして\nnewtons-\nmethod\nが直ぐにそれを用いて定義されています。これは初期推測値と一緒に\n手続を引数として取りその手続はゼロを見つけたい関数を計算します。例えば、\n푥\nの平方根を見つけたい時、ニュートン法を用いて関数\n푦 ↦ 푦\n2\n− 푥\nのゼロを\n初期推測値\n1\nから始めて探すことが可能です。\n63\nこれが平方根手続の別の形を与えます。\n(\ndefine\n(\nsqrt\nx\n)\n(\nnewtons-method\n(\nlambda\n(\ny\n) (- (\nsquare\ny\n)\nx\n)) 1.0))\n抽象化と一級手続\nより一般的な手法の事例として、平方根の演算の表現方法を\n2\nつ見てきま\nした。\n1\nつは不動点検索で、もう\n1\nつはニュートン法です。ニュートン法はそ\nれ自体が不動点処理として表現されているため、実際には平方根を不動点とし\nて計算する\n2\nつの方法を見た訳になります。各手法は関数と共に開始し、その\n関数のある変形の不動点を探します。この一般的な考えそれ自身を手続として\n表現できます。\n(\ndefine\n(\nfixed-point-of-transform\ng\ntransform\nguess\n)\n(\nfixed-point\n(\ntransform\ng\n)\nguess\n))\nこのとても汎用的な手続は引数としてある関数を計算する手続\ng\n、\ng\nを変形す\nる手続、初期推測値を取ります。結果としての返り値は変形された関数の不動\n点です。\n63\n平方根を探す場合、ニュートン法は任意の開始値から急速に正しい解に収束します。\n77","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":103},{"id":"./test/fixtures/pdf/sicp.pdf:104","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この抽象化を用いて、この節最初の\n(\n平均減衰バージョンの\n푦 ↦ 푥/푦\nの不\n動点を探した\n)\n平方根演算をこの汎用手法の例として変更できます。\n(\ndefine\n(\nsqrt\nx\n)\n(\nfixed-point-of-transform\n(\nlambda\n(\ny\n) (/\nx\ny\n))\naverage-damp\n1.0))\n同様にこの節の\n2\nつ目の平方根演算\n(\n푦 ↦ 푦\n2\n− 푥\nのニュートン変形の不動点を\nを探すニュートン法の例\n)\nを以下の様に表現できます。\n(\ndefine\n(\nsqrt\nx\n)\n(\nfixed-point-of-transform\n(\nlambda\n(\ny\n) (- (\nsquare\ny\n)\nx\n))\nnewton-transform\n1.0))\nSection 1.3\nでは複合手続は重大な抽象化メカニズムであるという考えから始め\nました。私達のプログラミング言語において演算の一般的な手法を明示的な要\n素として表現することを可能にするためです。ここでは高階手続がどのように\nこれらの一般的手法を操作してさらなる抽象化を作成することを可能にするの\nかについて学びます。\nプログラマとして、私達のプログラムに内在する抽象化を判別する機会を\n迅速に学ばねばなりません。そしてその上に構築し、それらを汎化してより強\n力な抽象化を作成する術を学ばねばなりません。これは常にプログラムを可能\nな限り抽象化して書かねばならないと言う訳ではありません。エキスパートプ\nログラマは彼等のタスクにとって適切な抽象化レベルの選択方法を知っていま\nす。しかし、これらの抽象化を用いて考えられるようになることが重要です。\nそうすればそれらを新しいコンテキストでも適用することに準備することがで\nきます。高階手続の有用性は、それらがここまでの抽象化を私達のプログラミ\nング言語の要素として明示的に表現することを可能にしてくれることです。そ\nうすることで抽象化は他の計算上の要素と同様に扱われることが可能となり\nます。\n通常、プログラミング言語は計算要素が取扱可能になるような方法に制約\nを課します。制約が最も少ない要素は\nfirst-class\n(\n第一級\n)\nの地位にあると言われ\nます。第一級要素の\n“\n権利と特権\n”\nのいくつかを次に示します。\n64\n•\nThey may be named by variables.\n変数により名付けることが可能\n64\nプログラミング言語の要素の第一級の地位の概念はイギリスの計算機科学者\nChristopher Strachey (1916-1975)\nによるものです。\n78","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":104},{"id":"./test/fixtures/pdf/sicp.pdf:105","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n手続に対し引数として渡すことが可能\n•\n手続の結果として返すことが可能\n•\nデータ構造に含まれることが可能\n65\nLisp\nは他の言語と異なり、手続に完全な第一級の地位を与えます。このことが\n効率の良い実装に対して課題を課しますが、結果的に表現力に得る物は莫大な\n物となります。\n66\nExercise 1.40:\nnewtons-method\n手続と共に以下の形式の式にて使\n用が可能な手続\ncubic\nを定義せよ。\n(\nnewtons-method\n(\ncubic\na\nb\nc\n) 1)\n次に三次方程式\n푥\n3\n+ 푎푥\n2\n+ 푏푥 + 푐 = 0\nの近似解を求めよ。\nExercise 1.41:\n引数が\n1\nつの手続を引数として取り、その手続を二\n回適用する手続を返す手続\ndouble\nを定義せよ。例えば\ninc\nが引数\nに\n1\nを足す手続であれば、\n(double inc)\nは\n2\nを足す手続になる。\n次の式はどんな値を返すか\n?\n(((\ndouble\n(\ndouble\ndouble\n))\ninc\n) 5)\nExercise 1.42:\n푓\nと\n푔\nが\n2\nつの\n1\n引数関数だとする。\n푔\nに\n푓\nを\ncomposition\n(\n合成\n)\nするとは関数\n푥  ↦  푓(푔(푥))\nと定義される。\n合成を実装する手続\ncompose\nを定義せよ。例えば\ninc\nが引数に\n1\nを足す手続である場合、\n((\ncompose\nsquare\ninc\n) 6)\n49\nExercise 1.43:\n푓\nが数値演算関数であり\n푛\nが正の整数である時、\n푓\nを\n푛\n回適用する、\n푥\nにおける値が\n푓(푓(... (푓(푥)) ... ))\nである関数を\n定義できる。例えば\n푓\nが関数\n푥 ↦ 푥 + 1\nである時、\n푓\nを\n푛\n回適用\nした関数は\n푥 ↦ 푥 + 푛\nとなる。もし\n푓\nが数値を二乗する操作なら\nば、\n푓\nを\n푛\n回適用した関数は引数を\n2\n푛\n乗する。入力として\n푓\nを計\n65\nこれの例は\nChapter 2\nにてデータ構造を紹介した後に学びます。\n66\n第一級手続の主な実装コストは、手続が値として返ることを可能とするために、手続\nの自由変数に対して予備の領域を、例え手続が実行中でなくとも必要とします。私達が\nSection 4.1\nにて学ぶ\nScheme\nの実装では、これらの変数は手続の環境に保存されます。\n79","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":105},{"id":"./test/fixtures/pdf/sicp.pdf:106","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"算する手続と正の整数\n푛\nを取り、\n푓\nの\n푛\n回適用を計算する手続を\n返す手続を書け。その手続は以下のように使用可能でなければな\nらない。\n((\nrepeated\nsquare\n2) 5)\n625\nヒント：\nExercise 1.42\nの\ncompose\nを使うと便利でしょう。\nExercise 1.44:\n関数の\nsmoothing\n(\n補間\n)\nという考えは信号処理にお\nいて重要な概念である。\n푓\nが関数であり\n푑푥\nがある小さな値である\n時、\n푓\nの補間とは\n푥\nにおける値が\n푓(푥 − 푑푥)\n,\n푓(푥)\n, and\n푓(푥 + 푑푥)\nの平均である関数である。入力として\n푓\nを計算する手続を取り、補\n間された\n푓\nを計算する手続を返す手続\nsmooth\nを書け。時には関\n数の補正を繰り返し\n(\nつまり補間された関数をさらに補間するこ\nとを繰り返す\n)\n、\nn-fold smoothed function\n(\nn\n次畳み込み補間関数\n)\nを得ることには価値がある。任意の与えられた関数の\nn\n次畳み込\nみ補間関数を\nExercise 1.43\nの\nsmooth\nと\nrepeated\nを用いてどのよ\nうに生成するかを示せ。\nExercise 1.45:\nSection 1.3.3\nにて平方根を求める試みにおいて単\n純に\n푦 ↦ 푥/푦\nの不動点を探すのでは収束しないのを見た。この\n問題は平均減衰にて解決できた。同じ手法が平均減衰を行った\n푦 ↦ 푥/푦\n2\nの不動点として立方根を求める場合においてもうまく行\nく。残念ながらこの処理は\n4\n乗根ではうまくいかない\n—\n単一の平\n均減衰は\n푦 ↦ 푥/푦\n3\nの不動点検索を収束させるのに十分ではない。\n一方でもし平均減衰を二回行えば\n(\nすなわち\n푦 ↦ 푥/푦\n3\n)\nの平均減\n衰の平均減衰\n)\n不動点検索は収束する。\n푛\n乗根を\n푦 ↦ 푥/푦\n푛−1\nの\n平均減衰の繰り返しを基として不動点探索して求める場合に何回\nの平均減衰が必要であるかを試行せよ。この結果を用いて\nExercise\n1.43\nの\nfixed-point\n,\naverage-damp\n,\nrepeated\n手続を用いて\n푛\n乗\n根を求める単一の手続を実装せよ。必要な数値演算はプリミティ\nブとして存在すると仮定する。\nExercise 1.46:\nこの章にて説明されたいくつかの数値解析手法は非\n常に汎用的な計算戦略であり\niterative improvement\n(\n反復改善法\n)\nとして知られている。反復改善法は何かを求めるために解の初期\n推測値から始め、推測値が十分に良いかをテストし、そうでなけれ\nば推測値を改善し、改善された推測値を新しい推測値として用い\n80","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":106},{"id":"./test/fixtures/pdf/sicp.pdf:107","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"て処理を継続する。\n2\nつの手続を引数として取る手続\niterative-\nimprove\nを書け。\n1\nつは推測値が十分に良いか判断する手続であり、\nもう\n1\nつは推測値を改善する手続である。\niterative-improve\nは\n推測値を引数として取り、推測値を十分に良くなるまで繰り返す\n手続をその値として返さなければならない。\nSection 1.1.7\nの\nsqrt\n手続と\nSection 1.3.3\nの\nfixed-point\n手続を\niterative-improve\nを\n用いて書き直せ。\n81","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":107},{"id":"./test/fixtures/pdf/sicp.pdf:108","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2\nデータを用いた抽象化の構築\n私達は今、数学上の抽象化の重要なステップに到達しました。記\n号がどんな意味を持つのか忘れるのです。\n...\n[\n数学者\n]\nに遊んでいる\n暇はありません。これらの記号を用いて実行する演算はいくらで\nもあります、これらが何を意味するのか全く考える必要無しに。\n—Hermann Weyl,\nThe Mathematical Way of Thinking\nChapter 1\nでは演算処理とプログラム設計における手続の役割について集中し\nました。私達はプリミティブなデータ\n(\n数値\n)\nとプリミティブな命令\n(\n算術演算\n)\nの使い方、組み合わせ、条件式、パラメタの使用を通して複合手続を形成する\nための手続の結合方法、\ndefine\nを用いた抽象化の方法について学びました。ま\nた手続が処理の局地展開のためのパターンとして見なされ得ることを学びまし\nた。そして手続内で具体化されたプロセスに対するいくつかの共通パターンの、\n簡単なアルゴリズム上の解析を分類し、推論し、実行しました。また高階手続\nが、一般的な演算の手段を操作し、その結果を用いて推測することを可能にす\nることにより、私達の言語の強化することも学びました。これはプログラミン\nグの本質の大部分です。\nこの章では私達はより複雑なデータについて目を向けることにします。第\n一章での全ての手続は単純な数値データを操作しましたが、単純なデータは私\n達が演算を用いて解決したいと願う多くの問題には不十分です。プログラムは\n一般的に複雑な事象をモデル化するために設計され、大抵の場合、複数の側面\n82","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":108},{"id":"./test/fixtures/pdf/sicp.pdf:109","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を持つ実世界の事象をモデル化するため、いくつかのパーツを持つ演算対象の\nオブジェクトを構築せねばなりません。従って第一章での焦点は手続を組み合\nわせることで複合手続を形成し抽象化を構築することでしたが、この章では任\n意のプログラミング言語においてもう\n1\nつの鍵となる側面に向かいます。プ\nログラミング言語がデータオブジェクトを組み合わせ\ncompound data\n(\n複合デー\nタ\n)\nを形成することにより抽象化構築が与える意味です。\n私達はなぜプログラミング言語にてデータを組合せたいのでしょうか\n?\n手\n続を組み合わせたいのと同じ理由のためです。プログラムを設計可能な概念上\nのレベルに持ち上げ、設計の部品化を進め、言語の表現力を拡張したいがため\nです。手続を定義する能力が、言語のプリミティブな命令のレベルよりもより\n高い概念のレベルにおいて処理を扱うことを可能にしてくれるのと同様に、複\n合データオブジェクトを構築できる能力は、言語のプリミティブなデータオブ\nジェクトが与えるよりもより高い概念レベルのデータを扱うことを可能にし\nます。\n分数を用いて数値演算を実行するシステム設計の課題を考えます。\n2\nつの\n分数を取りそれらの和を実行する命令\nadd-rat\nを想像します。単純なデータ\nを用いる場合、分数は\n2\nつの整数として考えられます。分子と分母です。する\nと各分数が\n2\nつの整数\n(\n分子と分母\n)\nで表現されるプログラムの設計が可能で\nす。そして\nadd-rat\nは\n2\nつの手続\n(1\nつは和の分子を求め、もう\n1\nつは分母を\n求める\n)\nにて実装されるでしょう。しかしこれは不恰好です。それではどの分\n子がどの分母に関係するのか明示的に追跡をせねばなりません。多くの分数に\n対して多くの命令を実行する目的のシステムにおいては、そのような詳細な記\n録はプログラムを大幅に散乱させるのみでなく、それらが私達の心にどんな影\n響を与えるかについは言うまでもありません。もし分子と分母をプログラムが\n分数を単一の概念上の単位として見做し静的な方法で扱えることができるペア\n—\ncompound data object\n(\n複合データオブジェクト\n)—\nに\n“\n貼り合せ\n”\nられれば\nずっと良くなることでしょう。\n複合データの使用はまたプログラムのモジュラリティ\n(\n部品化\n)\nを推進しま\nす。もし分数を直接オブジェクトそれ自身として扱うことができれば、分数を\n扱うプログラムの一部それ自体ををどのように分数を恐らく整数のペアとして\n表現するという部分の詳細から分離することができます。データオブジェクト\nがどのように表現されるかを扱うプログラムの部分を、データオブジェクトが\nどのように利用されるかを扱うプログラムの部分から分離する一般的なテクニ\nックは強力な設計手法であり\ndata abstraction\n(\nデータ抽象化\n)\nと呼ばれます。ど\nのようにデータ抽象化がプログラムの設計、保守、変更をより簡単にするかを\nこれから学びます。\n83","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":109},{"id":"./test/fixtures/pdf/sicp.pdf:110","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"複合データの使用はプログラミング言語の表現力を実際に増加させます。\n“\n一次結合\n”\n푎푥 + 푏푦\nの形式化について考えてみて下さい。\n푎\n,\n푏\n,\n푥\n, and\n푦\nを引数\nとして取り、\n푎푥 + 푏푦\nの値を返す手続を書こうと思うかもしれません。これは\n引数が数値であるならば少しも難しいとは思えません。私達は既に手続を定義\nできます。\n(\ndefine\n(\nlinear-combination\na\nb\nx\ny\n)\n(+ (*\na\nx\n) (*\nb\ny\n)))\nしかし数値のみが対象ではないと考えてみましょう。手続の項目として加算と\n乗算が定義されているならば分数、複素数、多項式、その他何でも一次結合を\n形式化できるというアイデアを表現したいとします。これを以下の形式の手続\nとして表現できるでしょう。\n(\ndefine\n(\nlinear-combination\na\nb\nx\ny\n)\n(\nadd\n(\nmul\na\nx\n) (\nmul\nb\ny\n)))\nadd\nと\nmul\nはプリミティブな手続\n+\nと\n*\nではなく、より複雑なものです。適切\nな操作を引数\na\n,\nb\n,\nx\n,\ny\nとして与えたどのような種類のデータに対しても行い\nます。キーポイントは\nlinear-combination\nが\na\n,\nb\n,\nx\n,\ny\nについて知らねばな\nらないことは手続\nadd\nとは\nmul\nが適切な操作を行うだろうことのみです。手続\nlinear-combination\nの視点からは\na\n,\nb\n,\nx\n,\ny\nが何であるかは無関係であり、そ\nれらがどのようによりプリミティブなデータを用いて表現されるのかについて\nは尚更無関係です。この同じ例がなぜプログラミング言語が複合オブジェクト\nを直接操作する能力を提供することが重要であるのかを示しています。もしこ\nれが無ければ、\nlinear-combination\nのような手続に対してその引数を\nadd\nと\nmul\nに向けてそれらの詳細な構造を知らずに渡す方法がありません。\n1\n私達はこの章を先に触れられた分数の数値演算システムを実装することで\n始めます。これが複合データとデータ抽象化の議論の背景を形作ります。複合\n手続と同様に、解決すべき主な問題は複雑さを対処するための技術としての\n抽象化でありどのようにデータ抽象化が適切な\nabstraction barriers\n(\n抽象化バリ\n1\n手続を直接操作する能力はプログラミング言語の表現力に対して類似の増強を与え\nます。例えば\nSection 1.3.1\nにおいて\nsum\n手続を紹介しましたが、これは手続\nterm\nを引数\nとして取り、ある指定した区間の\nterm\nの値の和を求めました。\nsum\nを定義するためには\nterm\nのような手続を、\nterm\nがよりプリミティブな命令にてどのように表現されている\nのかに関わらず、それ自身の要素として表現できることが重要でした。実際に、もし\n“\n手\n続\n”\nという概念が無ければ\nsum\nのような命令の定義の可能性について考えつくことすら\n疑わしいことだったでしょう。その上、加算の実行を考慮する範囲では\nterm\nがどのよう\nによりプリミティブな命令から構築され得るのかの詳細は無関係なのです。\n84","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":110},{"id":"./test/fixtures/pdf/sicp.pdf:111","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ア\n)\nを異なるプログラムの部分の間に構築することを可能にするかについて学\nびます。\n複合データを形成するための鍵はプログラミング言語はある種の\n“\n糊\n”\nを提\n供しなければならないことであり、そうすることでデータオブジェクトはより\n複雑なデータオブジェクトを形成するために組み合わせることが可能になりま\nす。多くの有力な種類の糊が存在します。実際に、全く特別ではない手続のみ\nの\n“\nデータ\n”\n操作を用いて複合データをどのように形成するかについて発見す\nるでしょう。これは第一章の終りに向かい既に希薄となっていた\n“\n手続\n”\nと\n“\nデ\nータ\n”\nの区別をよりボカすことになるでしょう。また列と木を表現するいくつ\nかの保守的な技術についても探検します。複合データを扱う場合の鍵となる考\nえの\n1\nつは\nclosure\n(\nクロージャ\n)\nの概念です\n—\nそのデータオブジェクトを組み\n合わせるのに用いる糊はプリミティブなデータオブジェクトのみではなく、複\n合データオブジェクトもまた組み合わせられなければなりません。もう\n1\nつの\n鍵となる考えは複合データオブジェクトは種々様々な方法でプログラムモジュ\nールを組み立てるための\nconventional interfaces\n(\n慣習的インターフェイス\n)\nの\n役を演じることができることです。これらのアイデアのいくつかについてはク\nロージャを用いる簡単なグラフィック言語を与えることで説明します。\n次に\nsymbolic expressions\n(\n記号表現\n)—\nその基本的な部分は任意の記号であ\nり数字のみではないデータ\n—\nを紹介することで言語の具象的な力を増補しま\nす。オブジェクトの集合を表現するための様々な代替方法について探検します。\n与えられた数値関数が多くの異なる演算処理により計算され得ると同時に、与\nえられたデータ構造が多くの方法にてより単純なオブジェクトを用いて表現さ\nれ得ること、表現の選択はデータを扱う処理が日宇町な時間と記憶域に対し重\n大な影響を与えることについて発見するでしょう。記号上の微分、集合の表現、\n情報符号化のコンテキストにてこれらの考えについて調査します。\n次にプログラムの異なる部分において異なって表現され得るデータを用い\nて処理する問題に問とりかかります。これが\ngeneric operations\n(\n総称命令\n)\nの実\n装の必要性へと導きます。総称命令は多くの異なるデータの型を扱わなければ\nなりません。総称命令の存在時における部品化の保守は単純なデータ抽象化の\nみにより構築可能な場合に比べて、より強力な抽象化バリアを、必要とします。\n具体的には\ndata-directed programming\n(\nデータ適従プログラミング\n)\nを個別のデ\nータ表現に対し分離した設計と\nadditively\nに\n(\n付加的\nに\n)(\nつまり変更無しに\n)\n組\nみ合わせることを可能にする技術として紹介します。システム設計に対するこ\nのアプローチを説明するために、この章を多項式上の記号演算の実行向けパッ\nケージを実装するために私達が学んだことを適用することで閉めます。その実\n装の中では多項式の係数は整数、分数、複素数、さらには多項式にもなりえ\n85","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":111},{"id":"./test/fixtures/pdf/sicp.pdf:112","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ます。\n2.1\nデータ抽象化のイントロダクション\nSection 1.1.8\nにおいてより複雑な手続を作成する要素として使われる手続\nは特定の命令の集合としてのみでなく、手続の抽象化としても見做されること\nを伝えました。その手続がどのように実装されたのかの詳細は抑制可能であり、\n特定の手続それ自身は相対的に同じ振舞を持つ任意の他の手続で置き換えられ\nます。言い換えれば、手続がどのように使われるかをその手続がどのようによ\nりプリミティブな手続を用いて実装されたかの詳細から分離する抽象化を作成\nできます。複合データのための類似の概念は\ndata abstraction\n(\nデータ抽象化\n)\nと\n呼ばれます。データ抽象化はどのように複合データオブジェクトが使用される\nかをどれがどのようによりプリミティブなデータオブジェクトから構築された\nのかの詳細から分離することを可能にする方法論\n(methodology,\nメソドロジ\n)\nです。\nデータ抽象化の基本的なアイデアは複合データオブジェクトを使用するた\nめのプログラムを構造化することで\n“\n抽象データ\n”\n上で操作を行うことです。そ\nれはつまり、私達のプログラムが手元でタスクを実行するためには厳密には必\n要と言えないデータに関する想定を一切持たないような方法でデータを利用し\nなければいけないということです。同時に、\n“\n具体的\n”\nなデータ表現はデータ\nを利用するプログラムとは独立に定義されます。システムにおけるこれらの\n2\nつのパーツの間のインターフェイスは手続の集合であり、\nselectors\n(\nセレクタ\n)\nと\nconstructors\n(\nコンストラクタ\n)\nと呼ばれ、抽象データを具体的な表現を用い\nて実装します。このテクニックを説明するために、分数を扱う手続の集合をど\nのように設計するかについてこれから考えます。\n2.1.1\n例\n:\n分数のための数値演算命令\n分数を用いて数値演算を行いたいとします。足し算、引き算、かけ算、割\nり算をそれらに対して行い\n2\nつの分数が等しいかテストします。\n分子と分母から分数を構築する方法を既に持っていると仮定することから\n始めましょう。分数を与えられた時にそれの分子と分母を抽出する\n(\nまたは選\n択\n(\nセレクト\n)\nする\n)\n方法を持っているとも仮定します。さらにコンストラクタ\nとセレクタが手続として存在すると仮定します。\n86","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":112},{"id":"./test/fixtures/pdf/sicp.pdf:113","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n(make-rat\n⟨푛⟩ ⟨푑⟩\n)\nは分子が整数\n⟨푛⟩\nであり、かつ分母が整数\n⟨푑⟩\nであ\nる分数を返す。\n•\n(numer\n⟨푥⟩\n)\nは分数\n⟨푥⟩\nの分子を返す。\n•\n(denom\n⟨푥⟩\n)\nは分数\n⟨푥⟩\nの分母を返す。\nここで統合のための強力な戦略、\nwishful thinking\n(\n希望的観測\n)\nを用います。私\n達はまだ分数がどのように表現されるのか、または手続\nnumer\n,\ndenom\n,\nmake-\nrat\nがどのように実装されるべきであるのかについて語っていません。そうで\nあっても、もし私達がこれら\n3\nつの手続を持っているのならば、足し算、引き\n算、かけ算、割り算、等値テストを以下の関係性を用いて行うことができるで\nしょう。\n푛\n1\n푑\n1\n+\n푛\n2\n푑\n2\n=\n푛\n1\n푑\n2\n+ 푛\n2\n푑\n1\n푑\n1\n푑\n2\n,\n푛\n1\n푑\n1\n−\n푛\n2\n푑\n2\n=\n푛\n1\n푑\n2\n− 푛\n2\n푑\n1\n푑\n1\n푑\n2\n,\n푛\n1\n푑\n1\n⋅\n푛\n2\n푑\n2\n=\n푛\n1\n푛\n2\n푑\n1\n푑\n2\n,\n푛\n1\n/푑\n1\n푛\n2\n/푑\n2\n=\n푛\n1\n푑\n2\n푑\n1\n푛\n2\n,\n푛\n1\n푑\n1\n=\n푛\n2\n푑\n2\n푖푓 푎푛푑 표푛푙푦 푖푓    푛\n1\n푑\n2\n= 푛\n2\n푑\n1\n.\nこれらのルールを手続として表現できます。\n(\ndefine\n(\nadd-rat\nx\ny\n)\n(\nmake-rat\n(+ (* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\nnumer\ny\n) (\ndenom\nx\n)))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\nsub-rat\nx\ny\n)\n(\nmake-rat\n(- (* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\nnumer\ny\n) (\ndenom\nx\n)))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\nmul-rat\nx\ny\n)\n(\nmake-rat\n(* (\nnumer\nx\n) (\nnumer\ny\n))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\ndiv-rat\nx\ny\n)\n87","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":113},{"id":"./test/fixtures/pdf/sicp.pdf:114","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nmake-rat\n(* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\ndenom\nx\n) (\nnumer\ny\n))))\n(\ndefine\n(\nequal-rat?\nx\ny\n)\n(= (* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\nnumer\ny\n) (\ndenom\nx\n))))\nこれでセレクタとコンストラクタの手続である\nnumer\n,\ndenom\n,\nmake-rat\nを\n用いて分数の操作を定義できました。必要な物は分子と分母を貼り合せて分数\nを形成する何らかの方法です。\nペア\nデータ抽象化の具体的レベルを実装できるようになるために、私達の言語\nは\npair\n(\nペア\n)\nと呼ばれる複合構造を提供します。それはプリミティブな手続\ncons\nを用いて構築できます。この手続は\n2\nつの引数を取り、\n2\nつの引数を部分\nとして持つ複合データオブジェクトを返します。ペアを与えられた時、プリミ\nティブな手続\ncar\nと\ncdr\nを用いてそれの部分を抽出することができます。\n2\n従\nって、\ncons\n,\ncar\n,\ncdr\nを以下のように使用できます。\n(\ndefine\nx\n(\ncons\n1 2))\n(\ncar\nx\n)\n1\n(\ncdr\nx\n)\n2\nペアは名前を与えることができ、プリミティブなデータオブジェクトと同様に\n扱うことができるデータオブジェクトです。さらに\ncons\nは要素がペアやその\n以外であるペアを作ることも可能です。\n(\ndefine\nx\n(\ncons\n1 2))\n(\ndefine\ny\n(\ncons\n3 4))\n(\ndefine\nz\n(\ncons\nx\ny\n))\n2\ncons\nという名前は\n“construct”\nによります。\ncar\nと\ncdr\nという名前は\nIBM 704\n上\nでのオリジナルの\nLisp\n実装に由来します。このマシンはアドレシングの仕組みとして\nメモリロケーションの\n“\nアドレス\n”\nと\n“\nデクリメント\n”\nの部分を参照可能でした。\ncar\nは\n“Contents of Address part of Register”(\nレジスタのアドレス部分の中身\n)\nを表し、\ncdr\n(“\nクダー\n”\nと読みます\n)\nは\n“Contents of Decrement part of Register.”(\nレジスタのデ\nクリメント部分の中身\n)\nを表します。\n88","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":114},{"id":"./test/fixtures/pdf/sicp.pdf:115","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncar\n(\ncar\nz\n))\n1\n(\ncar\n(\ncdr\nz\n))\n3\nSection 2.2\nにおいてペアを組み立てるこの能力が、ペアが全ての種類の複雑な\nデータ構造を作成するために汎用目的構築ブロックとして利用可能であること\nに対し、どのような意味を持つのかについて学びます。\ncons\n,\ncar\n,\ncdr\nにより\n実装された単一の複合データプリミティブペアが私達が必要とするただ\n1\nつの\n糊です。ペアから構築されたデータオブジェクトは\nlist-structured\n(\nリスト構造\n化\n)\nデータと呼ばれます。\n分数を表現する\nペアは分数システムを仕上げるための自然な方法を提供します。単純に分\n数を\n2\nつの整数、分子と分母のペアとして表現します。そして\nmake-rat\n,\nnumer\n,\ndenom\nは簡単に次のように実装することが可能です。\n3\n(\ndefine\n(\nmake-rat\nn\nd\n) (\ncons\nn\nd\n))\n(\ndefine\n(\nnumer\nx\n) (\ncar\nx\n))\n(\ndefine\n(\ndenom\nx\n) (\ncdr\nx\n))\n3\nAnother way to define the selectors and constructor is\nセレクタとコンストラクタを定義するもう\n1\nつの実装として次が上げられます。\n(\ndefine\nmake-rat\ncons\n)\n(\ndefine\nnumer\ncar\n)\n(\ndefine\ndenom\ncdr\n)\n最初の定義は名前\nmake-rat\nを式\ncons\nの値に関連付けます。それはペアを構築するプ\nリミティブな手続です。従って\nmake-rat\nと\ncons\nは同じプリミティブなコンストラクタ\nになります。\nセレクタとコンストラクタをこのように定義するのは効率が良いです。\nmake-rat\nが\ncons\nを\ncalling\n(\n呼び出す\n)\n代わりに、\nmake-rat\nが\ncons\nで\nis\n(\nある\n)\nためです。そのため\nmake-rat\nが呼ばれた時に\n2\nつでなく、\n1\nつの手続が呼ばれるだけになります。しかし一\n方で、これを行うことは手続呼出のトレースや手続呼出に対するブレイクポイントの設\n定に対するデバッグ上の手助けを無効にしてしまいます。あなたは\nmake-rat\nの呼出を見\nたくなるのであって、\ncons\nへの全ての呼出を見たい訳ではないからです。\nこの本ではこの定義スタイルを使用しないことにしました。\n89","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":115},{"id":"./test/fixtures/pdf/sicp.pdf:116","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"また演算結果を表示するために、分数を分子、スラッシュ、分母で表示するこ\nとにします。\n4\n(\ndefine\n(\nprint-rat\nx\n)\n(\nnewline\n)\n(\ndisplay\n(\nnumer\nx\n))\n(\ndisplay\n\"\n/\n\"\n)\n(\ndisplay\n(\ndenom\nx\n)))\nこれで分数手続を試すことができます。\n(\ndefine\none-half\n(\nmake-rat\n1 2))\n(\nprint-rat\none-half\n)\n1/2\n(\ndefine\none-third\n(\nmake-rat\n1 3))\n(\nprint-rat\n(\nadd-rat\none-half\none-third\n))\n5/6\n(\nprint-rat\n(\nmul-rat\none-half\none-third\n))\n1/6\n(\nprint-rat\n(\nadd-rat\none-third\none-third\n))\n6/9\n最後の例が示すとおり、私達の分数実装は分数を最も小さな項に約分しません。\nこれを\nmake-rat\nを変更することで改良できます。もし\nSection 1.2.5\nで扱った\n2\nつの整数の最大公約数を生成する\ngcd\n手続を持っていれば、\ngcd\nを用いて分子\nと分母を最小の項に、ペアを構築する前に縮小することができます。\n(\ndefine\n(\nmake-rat\nn\nd\n)\n(\nlet\n((\ng\n(\ngcd\nn\nd\n)))\n(\ncons\n(/\nn\ng\n) (/\nd\ng\n))))\nこれで次の希望した結果を得ます。\n(\nprint-rat\n(\nadd-rat\none-third\none-third\n))\n2/3\n4\ndisplay\nはデータを表示する\nScheme\nのプリミティブです。\nScheme\nのプリミティブ\nである\nnewline\nは表示を新しい行から始めます。これらの手続のどちらも意味のある値\nは返しません。そのため下記の\nprint-rat\n内での使用においては\nprint-rat\nが表示する\n物のみを示し、インタプリタが\nprint-rat\nの返り値として表示する物は示していません。\n90","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":116},{"id":"./test/fixtures/pdf/sicp.pdf:117","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この変更は\n(\nadd-rat\nや\nmul-rat\nのような\n)\n実際の命令を実装する他の手続の\n変更無しに、コンストラクタ\nmake-rat\nを変更することで達成されました。\n引数を扱えるより良い版の\nmake-rat\nを定義せよ。\nExercise 2.1:\n正\nと負の両方の\nmake-rat\nは符号の正常化を行わなければならない。\n従ってもし分数が正であれば分子と分母の両方が正であるし、も\nし分数が負であれば分子のみが負でなければならない。\n2.1.2\n抽象化バリア\nさらなる複合データとデータ抽象化の例を続ける前に、分数の例にて持ち\n上がったいくつかの問題について考えてみましょう。私達は分数操作をコンス\nトラクタ\nmake-rat\nとセレクタ\nnumer\nと\ndenom\nを用いて定義しました。一般的\nにデータ抽象化の基となる考えはデータオブジェクトの各型に対し、その型の\nデータオブジェクトの全ての操作が表される命令を用いて、命令の基本的な集\n合を判断し、そのデータを操作する時にそれらの命令のみを用いることです。\n私達は\nFigure 2.1\nにて示された分数システムの構造を想像することができ\nます。水平線は\nabstraction barriers\n(\n抽象化バリア\n)\nを表現し、システムの異な\nる\n“\nレベル\n”\nを分離します。各レベルではバリアはデータ抽象化を利用する\n(\n上\n側の\n)\nプログラムをデータ抽象化を実装する\n(\n下側の\n)\nプログラムから分離しま\nす。分数を利用するプログラムはもっぱら分数パッケージにより\n“\n公用向け\n”\nに提供された手続を用いて分数を操作します。それら手続とは\nadd-rat\n,\nsub-\nrat\n,\nmul-rat\n,\ndiv-rat\n,\nそれに\nequal-rat?\nです。これらは順に、もっぱらコン\nストラクタとセレクタである\nmake-rat\n,\nnumer\n,\ndenom\nを用いて実装されます。\nこの\n3\nつはペアを用いて実装されます。ペアがどのように実装されているかの\n詳細はペアが\ncons\n,\ncar\n,\ncdr\nの使用により操作できる限りにおいては分数パッ\nケージの他の物に取っては重要ではありません。実質的に、各レベルにおける\n手続は抽象化バリアを定義するインターフェイスであり、異なるレベルを接続\nします。\nこの単純な考えは多くの利点を持ちます。\n1\nつの利点はプログラムの保守\nと変更をより簡単にすることです。任意の複雑なデータ構造が、プログラミン\nグ言語により提供されるプリミティブなデータ構造を用いて多彩な方法で表現\nされます。もちろん、表現の選択がその上で操作を行うプログラムに影響を与\nえます。従ってもし表現がある程度後に変更された場合、全ての当該プログラ\nムはそれに応じて変更されなければなりません。この作業は大きなプログラム\nの場合においては表現上の依存が設計によりとても少ないプログラムモジュー\n91","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":117},{"id":"./test/fixtures/pdf/sicp.pdf:118","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Programs that use rational numbers\nRational numbers in problem domain\nadd-rat  sub-rat  ...\nRational numbers as numerators and denominators\nmake-rat  numer  denom\nRational numbers as pairs\ncons  car  cdr\nHowever pairs are implemented\nFigure 2.1:\n分数パッケージ内の抽象化バリア\nルに対してのみに制限されていなければ時間のかかる高コストな物に成り得\nます。\n例として、分数を最小の項へと約分する問題の解法の代替法には、分数を組み\n立てた時でなく、分数のパーツにアクセスする度に約分を実行する方法があり\nます。これは異なるコンストラクタとセレクタ手続に導きます。\n(\ndefine\n(\nmake-rat\nn\nd\n) (\ncons\nn\nd\n))\n(\ndefine\n(\nnumer\nx\n)\n(\nlet\n((\ng\n(\ngcd\n(\ncar\nx\n) (\ncdr\nx\n))))\n(/ (\ncar\nx\n)\ng\n)))\n(\ndefine\n(\ndenom\nx\n)\n(\nlet\n((\ng\n(\ngcd\n(\ncar\nx\n) (\ncdr\nx\n))))\n(/ (\ncdr\nx\n)\ng\n)))\nこの実装と依然の実装との間の違いはいつ\ngcd\nを求めるかにあります。私達の\n典型的な分数の使用においては、同じ分数の分子と分母に何度もアクセスする\n場合、分数が組み立てられる時に\ngcd\nを求めるほうが好ましいです。そうでな\nければ\ngcd\nを求めるのはアクセスする時まで待ったほうが良いかもしれませ\n92","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":118},{"id":"./test/fixtures/pdf/sicp.pdf:119","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ん。どちらの場合でも、一方の表現からもう一方の表現へと変更する場合、手\n続、\nadd-rat\n,\nsub-rat\n,\nその他は全く変更する必要がありません。\n表現上の依存対象を少ないインターフェイス手続に制約することはプログ\nラムの設計と共にそれらの変更をも手助けします。なぜなら代替的な実装を考\nえるための柔軟性を保つことを可能にするためです。私達の簡単な例で続ける\nために、私達は分数パッケージを設計中で、早期に\ngcd\nを構築時と選択時のど\nちらで実行するか決められないと想像して下さい。データ抽象化メソドロジは\nその決定をシステムの他の部分上の進行の可能性を失わせずに決定を遅らせる\n方法を与えます。\nExercise 2.2:\n平面上の線分を表現する問題について考える。各線\n分は点のペアにて表現する。始点と終点である。コンストラクタ\nmake-segment\nとセレクタ\nstart-segment\nと\nend-segment\nを定義\nせよ。それらは点を用いて線分の表現を定義する。さらに点は数値\nのペアにて表現できる。\n푥\n座標と\n푦\n座標である。それに沿ってこの\n表現を定義するコンストラクタ\nmake-point\nとセレクタ\nx-point\nを\ny-point\nを定めよ。最後に、セレクタとコンストラクタを用い\nて引数として線分を取りその中点\n(\nその座標が両端点の座標の平\n均である点\n)\nを返す手続\nmidpoint-segment\nを定義せよ。あなたの\n手続をテストするためには以下の点を表示する方法が必要だろう。\n(\ndefine\n(\nprint-point\np\n)\n(\nnewline\n)\n(\ndisplay\n\"\n(\n\"\n)\n(\ndisplay\n(\nx-point\np\n))\n(\ndisplay\n\"\n,\n\"\n)\n(\ndisplay\n(\ny-point\np\n))\n(\ndisplay\n\"\n)\n\"\n))\nExercise 2.3:\n平面上の三角のための表現を実装せよ。\n(\nヒント：\nExercise 2.2\nを利用したいだろう。\n)\nコンストラクタとセレクタを\n利用して、与えられた三角の周辺の長さと面積を求める手続を作\nれ。適切な抽象化バリアを用いてどんな表現を用いても同じ周辺\n長と面積の手続が働くよう、あなたのシステムを設計できるだろ\nうか\n?\n93","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":119},{"id":"./test/fixtures/pdf/sicp.pdf:120","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2.1.3\nデータにより何が意味されるのか\nSection 2.1.1\nにて分数実装を分数演算\nadd-rat\n,\nsub-rat\n,\nその他を\n3\nつの\n定められていない手続、\nmake-rat\n,\nnumer\n,\ndenom\nを用いて実装することから始\nめました。その時点では命令はデータオブジェクト\n—\n分子、分母と分数を用い\nて定義されると考えることができました。データオブジェクトの振舞は後者の\n3\nつの手続により指定されました。\nしかし\ndata\n(\nデータ\n)\nとは正確には何を意味するのでしょうか。\n“\n与えられた\nセレクタとコンストラクタにより実装された物全て\n”\nと言うのみでは十分では\nありません。明かに\n3\nつの手続の任意の集合全てが分数実装に対する適切な基\n準としての役割を果せる訳ではありません。もし分数\nx\nを整数のペア\nn\nと\nd\nか\nら組み立てた場合、\nx\nの\nnumer\nと\ndenom\nの抽出しそれらを割ることは、\nn\nを\nd\nで割るのと同じ結果になることを保証せねばなりません。言い替えれば、\nmake-\nrat\n,\nnumer\n,\ndenom\nは任意の整数\nn\nと零でない整数\nd\nに対しもし\nx\nが\n(make-rat\nn d)\nである時、その場合以下の条件を満たさなければなりません。\n(numer x)\n(denom x)\n=\n푛\n푑\n.\n実際にこれが\nmake-rat\n,\nnumer\n,\ndenom\nが分数表現のための適切な基準を形\n成するために満たさなければならないただ\n1\nつの条件です。一般的に、私達は\nデータをセレクタとコンストラクタのある集合と共に、これらの手続が有効な\n表現となるために満たさなければならない制約により定義されると考えること\nができます。\n5\n5\n意外にもこの考えは厳格に形式化することがとても難しいのです。そのような形式\n化を与える試みは\n2\nつあります。\n1\nつは\nC. A. R.\nHoare (1972)\nにより開拓され、\nabstract\nmodels\n(\n抽象モデル\n)\nとして知られています。\n“\n手続プラス制約\n”\nの仕様を上の分数の例内\nで概説されたように形式化します。分数表現上の条件は整数に関する事実\n(\n等値関係と\n除算\n)\nを用いて規定されています。一般的に抽象モデルは新しい種類のデータオブジェ\nクトを以前に定義されたデータオブジェクトの型を用いて定義します。従ってデータオ\nブジェクトに関する成立条件はそれらを以前に定義されたデータオブジェクトに関する\n成立条件へと還元していくことでチェックできます。もう\n1\nつの試みは\nmit\nの\nZilles\nと\nIBM\nの\nGoguen, Thatcher, Wagner, Wright\nにより紹介され\n(\nThatcher et al. 1978\nを参\n照\n)\n、またトロント大学の\nGuttag\nにより紹介されました。\n(\nGuttag 1977\nを参照\n)\n。その\n試みは\n“\n手続\n”\nを抽象代数システムの要素と見做し、その振舞は\n“\n条件\n”\nに相当する公理\nにより指定されました。そして抽象代数のテクニックを用いてデータオブジェクトに関\nする成立条件をチェックしました。両者の手法が\nLiskov and Zilles (1975)\nにより論文と\nして調査されています。\n94","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":120},{"id":"./test/fixtures/pdf/sicp.pdf:121","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この視点は分数のような\n“\n高階データオブジェクト\n”\nのみを定義するのでは\nなく、より低いレベルのオブジェクトの定義も提供することができます。私達\nが分数を定義するために使用したペアの概念について考えてみます。私達はま\nだペアとは実際には何であるのか述べていません。言語が手続\ncons\n,\ncar\n,\ncdr\nをペア上の命令として提供するとのみ説明しています。しかしこれら\n3\nつの\n命令について知らなければいけないことはもし私達が\n2\nつのオブジェクトを\ncons\nを用いて貼り合わせた時、\ncar\nと\ncdr\nを用いてそれらのオブジェクトを取\n得することができることのみです。つまり、それらの命令は任意のオブジェク\nト\nx\nと\ny\nに対し、もし\nz\nが\n(cons x y)\nであるなら\n(car z)\nは\nx\nであり、\n(cdr\nz)\nは\ny\nであるという制約を満たしています。実際に、これらの\n3\nつの手続は\n言語にプリミティブとして含まれていることについて既に述べました。しかし、\n上記の制約を満たす任意の\n3\nつの手続ならペアを実装するための基盤として使\n用することが可能です。この点は私達が\ncons\n,\ncar\n,\ncdr\nをどんなデータ構造も\n全く利用せずに、しかし手続のみを用いて実装できることにより、著しく説明\nされます。これがその定義です。\n(\ndefine\n(\ncons\nx\ny\n)\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((=\nm\n0)\nx\n)\n((=\nm\n1)\ny\n)\n(\nelse\n(\nerror\n\"\nArgument\nnot\n0\nor\n1:\nCONS\n\"\nm\n))))\ndispatch\n)\n(\ndefine\n(\ncar\nz\n) (\nz\n0))\n(\ndefine\n(\ncdr\nz\n) (\nz\n1))\nこの手続の使用はデータが何であるべきかという私達の直感的概念のような物\nには全く関係しません。それでもなお、これがペアを表現するのに有効な方法\nであると示すのに必要なこと全てはこれらの手続が上で与えられた制約を満た\nすことです。\n注意すべき微細な点は\n(cons x y)\nにより返される値は手続\n—\nすなわち内\n部で定義された手続\ndispatch\nであることです。それが\n1\nつの引数を取り\nx\nか\ny\nのどちらかを引数が\n0\nであるか\n1\nであるかに従って返します。相応して、\n(car\nz)\nは\nz\nを\n0\nに適用します。故にもし\nz\nが\n(cons x y)\nにより作られた手続であ\nるのなら、\nz\nを\n0\nに適用すれば\nx\nを返します。従って、\n(car (cons x y))\nが希\n望通りに\nx\nを返すことを示しました。同様に\n(cdr (cons x y))\nは\n(cons x y)\nの返り値としての手続を\n1\nに適用し、\ny\nを返します。従ってこのペアの手続と\nしての実装は有効な実装であり、もし私達が\ncons\n,\ncar\n,\ncdr\nのみを用いてペア\n95","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":121},{"id":"./test/fixtures/pdf/sicp.pdf:122","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"にアクセスする場合、この実装を\n“\n本物の\n”\nデータ構造を用いる実装と区別す\nることはできません。\nペアの手続による表現を提示することのポイントは私達の言語がこのよう\nに働いているということではなく\n(Scheme\nや一般的な\nLisp\nシステムは効率上\nの理由からペアを直接的に実装します\n)\n、しかしそれがこのように働くことが\nできるということです。手続による表現は曖昧ですが、ペアを表現するのに完\n璧に適切な方法です。ペアが満たすべき必要な条件を満たすからです。この例\nはまた手続をオブジェクトとして操作する能力が自動的に複合データを表現す\nる能力を提供することを実演しました。これは今は珍しく見えるかもしれませ\nんが、しかし手続によるデータの表現は私達のプログラミングレパートリの中\n心的役割を演じます。このプログラミングスタイルは時折\nmessage passing\n(\nメ\nッセージパッシング\n)\nと呼ばれ、私達はこれを\nChapter 3\nにてモデリングとシ\nミュレーションの問題を解決する時に基本的なツールとして用います。\nExercise 2.4:\nここにペアの代替的な手続上の表現がある。この表\n現に対して\n(car (cons x y))\nが任意のオブジェクト\nx\nと\ny\nに対\nして\nx\nを返すか確認せよ。\n(\ndefine\n(\ncons\nx\ny\n)\n(\nlambda\n(\nm\n) (\nm\nx\ny\n)))\n(\ndefine\n(\ncar\nz\n)\n(\nz\n(\nlambda\n(\np\nq\n)\np\n)))\n対応する\ncdr\nの定義はどうなるか\n? (\nヒント：これが正しく働くか\n確認するには\nSection 1.1.5\nの置換モデルを使用せよ\n)\nExercise 2.5:\n負ではない整数のペアを数値と数値演算命令のみを\n用いて表現できることを、もし\n푎\nと\n푏\nのペアを積\n2\n푎\n3\n푏\nの整数で\n表現すれば可能であることにより示せ。対応する手続\ncons\n,\ncar\n,\ncdr\n.\nの定義を与えよ。\nExercise 2.6:\nペアを手続として表現することが十分に驚かせるに\n値するものでない場合、手続を操作可能なある言語においては\n0\nと\n1\nを足すことを以下のように実装することで数値が無くてもや\nっていける\n(\n少なくとも負ではない整数のみを考える場合におい\nては\n)\nことを考えてみよ。\n(\ndefine\nzero\n(\nlambda\n(\nf\n) (\nlambda\n(\nx\n)\nx\n)))\n(\ndefine\n(\nadd-1\nn\n)\n(\nlambda\n(\nf\n) (\nlambda\n(\nx\n) (\nf\n((\nn\nf\n)\nx\n)))))\n96","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":122},{"id":"./test/fixtures/pdf/sicp.pdf:123","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この表現はその開発者に因んで\nChurch numerals\n(\nチャーチ数\n)\nとし\nて知られる。\nAlonzo Church\nは\n휆\n-\n演算を発明した論理学者である。\none\nと\ntwo\nを直接\n(\nzero\nと\nadd-1\nを用いずに\n)\n定義せよ。\n(\nヒント：\n加算手続の直接的な定義\n+\nを与えよ。\n(\nadd-1\nの繰り返し適用は用\nいない\n)\n2.1.4\n延長課題\n:\n区間演算\nAlyssa P. Hacker\nは人々が工学上の問題を解くのを手助けするシステムを\n設計しています。システムにおいて彼女が提供したい\n1\nつの機能は\n(\n物理機器\nの測定されたパラメータのような\n)\n不正確な量を既知の精度にて扱う能力です。\n演算がそのような近似量にて行われた時、結果が既知の精度の値になるように\nするためです。\n電気技術者達が\nAlyssa\nのシステムを電気の量を計算するために使用しま\nす。彼らは時折\n2\nつの抵抗\n푅\n1\n,\n푅\n2\nの並列に等価な抵抗値\n푅\n푝\nを次の式を用い\nて計算する必要があります。\n푅\n푝\n=\n1\n1/푅\n1\n+ 1/푅\n2\n.\n抵抗値は通常抵抗の生産者により保証されるいくらかの許容誤差未満であ\nることが知られています。例えばもしあなたが\n“10%\nの許容誤差で\n6.8Ω”\nとラベ\nリングされた抵抗を買ったとしたら、確かなのはその抵抗は\n6.8 − 0.68 = 6.12\nと\n6.8 + 0.68 = 7.48\nΩ\nの間の抵抗を持つことのみです。従って、もし\n6.8Ω\n10%\nの抵抗と並列に\n4.7Ω 5%\nの抵抗を接続した場合に、組み合わせの抵抗は\n約\n2.58Ω(2\nつの抵抗が低限である場合\n)\nから約\n2.97Ω(2\nつの抵抗が上限である\n場合\n)\nの区間になります。\nAlyssa\nのアイデアは\n“interval arithmetic”(\n区間演算\n)\nを\n“\n区間\n”(\n不正確な量\nの取り得る値の区間を表現するオブジェクト\n)\nを連結する演算命令の集合とし\nて実装することです。\n2\nつの区間の加算、減算、乗算、除算の結果はそれ自身\nが区間であり、結果の範囲を表します。\nAlyssa\nは\n2\nつの終端、下限と上限を持つ\n“\n区間\n”\nと呼ばれる抽象オブジェ\nクトの存在を仮定しました。彼女はまた区間の終端を与えられた時、データ\nコンストラクタ\nmake-interval\nを用いて区間の構築ができると仮定しました。\nAlyssa\nは最初に\n2\nつの区間を足す手続を書きました。彼女は和の最小値は\n2\nつ\nの下限の和であり、最大値は\n2\nつの上限の和になるだろうと推測しました。\n97","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":123},{"id":"./test/fixtures/pdf/sicp.pdf:124","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nadd-interval\nx\ny\n)\n(\nmake-interval\n(+ (\nlower-bound\nx\n) (\nlower-bound\ny\n))\n(+ (\nupper-bound\nx\n) (\nupper-bound\ny\n))))\nAlyssa\nはまた\n2\nつの区間の積を限界値の積の最小値と最大値を見つけることで\n算出し、そしてそれらを結果区間の限界値として用いました。\n(\nmin\nと\nmax\nは任\n意の数の引数の最小値と最大値を見つけるプリミティブです\n)\n。\n(\ndefine\n(\nmul-interval\nx\ny\n)\n(\nlet\n((\np1\n(* (\nlower-bound\nx\n) (\nlower-bound\ny\n)))\n(\np2\n(* (\nlower-bound\nx\n) (\nupper-bound\ny\n)))\n(\np3\n(* (\nupper-bound\nx\n) (\nlower-bound\ny\n)))\n(\np4\n(* (\nupper-bound\nx\n) (\nupper-bound\ny\n))))\n(\nmake-interval\n(\nmin\np1\np2\np3\np4\n)\n(\nmax\np1\np2\np3\np4\n))))\n2\nつの区間を割るために、\nAlyssa\nは一つ目に\n2\nつ目の逆数を掛けました。区間\nの逆数の限界値は上限の逆数と下限の逆数をその順で用いることに注意して下\nさい。\n(\ndefine\n(\ndiv-interval\nx\ny\n)\n(\nmul-interval\nx\n(\nmake-interval\n(/ 1.0 (\nupper-bound\ny\n))\n(/ 1.0 (\nlower-bound\ny\n)))))\nExercise 2.7:\nAlyssa\nのプログラムは未完成である。なぜなら彼女\nは区間の抽象の実装を特定していない。以下に区間のコンストラ\nクタの定義を置く。\n(\ndefine\n(\nmake-interval\na\nb\n) (\ncons\na\nb\n))\nセレクタ\nupper-bound\nと\nlower-bound\nを定義し実装を完成させよ。\nExercise 2.8:\nAlyssa\nの考えと同様の推論を用いて、\n2\nつの区間の\n差がどのように計算されるかを説明せよ。対応する減算手続\nsub-\ninterval\nを定義せよ。\nExercise 2.9:\n区間の\nwidth\n(\n幅\n)\nは上限と下限の差の半値である。幅\nは区間で指定された数値の不確かさの基準である。いくつかの数\n98","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":124},{"id":"./test/fixtures/pdf/sicp.pdf:125","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"値演算に対しては、\n2\nつの区間を結合した結果の幅は引数区間の\n幅のみによる関数である。一方で他の演算においては結合の幅は\n引数の幅の関数ではない。\n2\nつの区間の和、または差の幅は足され\nる、または引かれる区間の幅の関数であることを示せ。これが乗\n算と除算においては正しくないことを例をもって示せ。\nExercise 2.10:\nエキスパートシステムプログラマの\nBen Bitdiddle\nは\nAlyssa\nの肩越しに覗いて、区間の長さが\n0\nの時に割ったらどう\nなるのか不明だよとコメントした。\nAlyssa\nのコードを変更し、この\n条件をチェックしてもしそれが起こればエラーを返すようにせよ。\nExercise 2.11:\n通り過ぎながら\nBen\nはまた曖昧なコメントを残し\nた。\n“\n区間の終端の符号をテストすることで\nmul-interval\nを\n7\nつ\nに場合分けできる。その\n1\nつのみが\n2\nつ以上の乗算を必要とする。\n”\nこの手続を\nBen\nの提案に従い書き直せ。\nプログラムをデバッグした後で、\nAlyssa\nはユーザ候補の一人に見せた。彼は彼\n女のプログラムは間違った問題を解いていると文句を言った。彼が欲しいのは\n中央値として表現された数値と追加の許容誤差を扱えるプログラムだ。例えば\n彼は\n3.5 ± 0.15\nのような区間を扱いたく、\n[3.35, 3.65]\nではない。\nAlyssa\nは彼女\nの机に戻りこの問題を代替となるコンストラクタとセレクタを提供することで\n直した。\n(\ndefine\n(\nmake-center-width\nc\nw\n)\n(\nmake-interval\n(-\nc\nw\n) (+\nc\nw\n)))\n(\ndefine\n(\ncenter\ni\n)\n(/ (+ (\nlower-bound\ni\n) (\nupper-bound\ni\n)) 2))\n(\ndefine\n(\nwidth\ni\n)\n(/ (- (\nupper-bound\ni\n) (\nlower-bound\ni\n)) 2))\n不運なことに、\nAlyssa\nのユーザの多くはエンジニアです。実際の工学の場では\n通常、小さな不確かさを伴なう計測を伴い、区間の中央値に対する区間の幅の\n割合として測定されます。エンジニアは通常パーセンテージにて許容誤差を端\n末のパラメータ上に、以前に与えた抵抗の仕様のように指定します。\nExercise 2.12:\nコンストラクタ\nmake-center-percent\nを中央値と\nパーセンテージ許容誤差を取り望まれた区間を返すように定義せ\nよ。セレクタ\npercent\nを与えられた区間に対するパーセンテージ\n許容誤差を返すように定義することも行うこと。\ncenter\nセレクタ\nは上で見たものと同じである。\n99","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":125},{"id":"./test/fixtures/pdf/sicp.pdf:126","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.13:\n小さなパーセンテージ許容誤差の前提の下では、\n2\nつの区間の積のパーセンテージ許容誤差を因数の許容誤差を用い\nて近似するための簡単な式が存在することを示せ。全ての数値は\n正であると前提して問題を簡単にしても良い。\n大変な仕事を終え、\nAlyssa P. Hacker\nは完了したシステムを受け渡しました。\n何年か後、彼女が全てを忘れた頃に、彼女は興奮した電話を、怒ったユーザ、\nLem E. Tweakit\nから受けました。どうやら\nLem\nは並列接続の抵抗の式が\n2\nつ\nの代数的に等価な方法で書くことができることに気付いたようです。\n푅\n1\n푅\n2\n푅\n1\n+ 푅\n2\nと、\n1\n1/푅\n1\n+ 1/푅\n2\n.\n彼は以下の\n2\nつのプログラムを書きました。それぞれが並列接続の抵抗値\nを異なる式で計算します。\n(\ndefine\n(\npar1\nr1\nr2\n)\n(\ndiv-interval\n(\nmul-interval\nr1\nr2\n)\n(\nadd-interval\nr1\nr2\n)))\n(\ndefine\n(\npar2\nr1\nr2\n)\n(\nlet\n((\none\n(\nmake-interval\n1 1)))\n(\ndiv-interval\none\n(\nadd-interval\n(\ndiv-interval\none\nr1\n)\n(\ndiv-interval\none\nr2\n)))))\nLem\nは\nAlyssa\nのプログラムは\n2\nつの方法の演算にて異なる値を返すと抗\n議しました。これは深刻な苦情です。\nExercise 2.14:\nLem\nが正しいことを確認せよ。様々な数値演算にて\nシステムの挙動を調べよ。ある区間\n퐴\nと\n퐵\nを作成し、式\n퐴/퐴\nと\n퐴/퐵\nの計算においてそれらを用いよ。幅が中央値の小さなパーセ\nンテージである区間を用いることで多くの実態を掴むことができ\nるだろう。\ncenter-percent\n形式\n(\nExercise 2.12\n参照\n)\nの演算の結果を\n調査せよ。\n100","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":126},{"id":"./test/fixtures/pdf/sicp.pdf:127","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.15:\nEva Lu Ator\nはもう一人のユーザで、彼女もまた異\nなるが代数的には等価な式により異なる区間が算出されることに\n気付いた。彼女は\nAlyssa\nのシステムを用いて区間の計算をする式\nが、もし式が不確かな値を表現する変数がどれも繰り返されない\n形であれば、より厳しいエラーの限界を算出すると言う。従って\n彼女は抵抗の並列に対し、\npar2\nの方が\npar1\nより\n“\nより良い\n”\nプロ\nグラムであると述べた。彼女は正しいだろうか\n?\nそれは何故か\n?\nExercise 2.16:\n一般的に、なぜ等価な代数式が異なる答に導くのか\n説明せよ。この欠点を持たない区間演算パッケージを開発するこ\nとは可能だろうか。または不可能だろうか。\n(\n警告：この問題はと\nても難しい\n)\n2.2\n階層データと閉包性\nここまで学んだように、ペアは私達が複合データオブジェクトを構築する\nのに利用可能なプリミティブな\n“\n糊\n”\nを提供します。\nFigure 2.2\nはペア\n—\nこの場\n合は\n(cons 1 2)\nにて形成されたペアを図示する標準的な方法を示しています。\nこの\nbox-and-pointer notation\n(\n箱と点表記法\n)\nと呼ばれる表現において、各オブ\nジェクトは箱への\npointer\n(\nポインタ\n)\nとして表わされています。プリミティブオ\nブジェクトの箱はオブジェクトの表現を持っています。例えば数値の箱は数字\nを持っています。ペアの箱は実際には二重の箱で、左部分はペアの\ncar\n(\nへのポ\nインタ\n)\nを持っており、右部分は\ncdr\nを持っています。\n私達は既に\ncons\nが数値のみでなくペアもまた組み合わせられることにつ\nいて学びました。\n(\nExercise 2.2\nと\nExercise 2.3\nであなたはこの事実を用いたか、\nまたは用いざるを得なかったでしょう\n)\n。結果としてペアは全ての種類のデー\nタ構造を構築可能な普遍的な構築ブロックを提供します。\nFigure 2.3\nは数値\n1,\n2, 3, 4\nを組み合わせるためにペアを用いる\n2\nつの方法を示しています。\n要素がペアであるペアを作成する能力は表現ツールとしてのリスト構造の重\n要性の本質です。私達はこの能力を\ncons\nの\n閉包性\n(closure property)\nと呼びま\nす。一般的に、データオブジェクトを組み合わせる操作はもしその命令による\n組み合わせの結果それ自身が同じ命令を用いて組み合わせることが可能ならば\n閉包性を満たします。\n6\n閉包はどのような目的の組み合わせをも強力にする鍵\n6\nここでの\n“closure”(\n閉包\n)\nという用語の使用は抽象代数から来ており、もし操作の集\n合の要素への適用により生成される要素が再び同じ集合の要素である場合、要素の集合\n101","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":127},{"id":"./test/fixtures/pdf/sicp.pdf:128","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2\n1\nFigure 2.2:\n(cons 1 2)\nの箱とポインタ表現\n1\n4\n2  3\n3  4\n1  2\n(cons (cons 1 2)               (cons (cons 1\n      (cons 3 4))                          (cons 2 3))\n                                     4)\nFigure 2.3:\nペアを用いて\n1,2,3,4\nを組み合わせる\n2\nつの方法\nとなります。なぜなら\nhierarchical\n(\n階層\n)\n構造\n—\n複数のパーツから成る構造で\nあり、パーツ自身も複数のパーツから成るような構造を作成することが可能に\nなるためです。\nChapter 1\nの始めから、手続の取扱において閉包を本質的に利用してきまし\nた。とても簡単なプログラムを除けば全てのプログラムは組み合わせの要素は\nそれ自身もまた組み合わせであるという事実に依存しているためです。この節\nでは複合データにとっての閉包の重要性を取り上げます。ペアを使用して列と\n木を表現するための、いくつかの便利なテクニックを説明します。そして鮮烈\nが操作の下において閉じられていると呼ばれます。\nLisp\nコミュニティでは\n(\n残念なこと\nに\n)\n用語\n“closure”\nを全く関係のない概念にも使用しています。\nclosure\nとは自由変数を\n持つ手続を表現するための実装テクニックです。私達は\n“closure”\nをこの本の中では\n2\nつ\n目の意味では用いません。\n102","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":128},{"id":"./test/fixtures/pdf/sicp.pdf:129","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"な方法でクロージャを図示するグラフィック言語を提示します。\n7\n2.2.1\n列の表現\nペアを用いて構築可能な便利な構造の\n1\nつが\nsequence\n(\n列\n)—\n順に並べたデ\nータオブジェクトの集合です。もちろんペアを用いて列を表現する方法は数多\nく存在します。特に簡単な表現方法の\n1\nつを\nFigure 2.4\nに示します。列\n1, 2, 3,\n4\nがペアの連鎖として表わされています。各ペアの\ncar\nは鎖内で相対するアイ\nテムであり、各ペアの\ncdr\nは鎖内での次のペアです。最後のペアの\ncdr\nは列の\n終端をペアではないことを識別する値を指し示すことで合図します。箱とポイ\nンタの図では斜めの線にて表現され、プログラムでは変数\nnil\nの値にて示され\nます。列全体は入れ子の\ncons\n命令にて構築されます。\n(\ncons\n1\n(\ncons\n2\n(\ncons\n3\n(\ncons\n4\nnil\n))))\nそのようなペアの列は入れ子の\ncons\nにて形成され、\nlist\n(\nリスト\n)\nと呼ばれます。\nそして\nScheme\nは\nlist\nと呼ばれるプリミティブを提供しリストの構築を手助\nけします。\n8\n上の列は\n(list 1 2 3 4)\nにより生成可能です。\n(\nlist\n⟨\n푎\n1\n⟩\n⟨\n푎\n2\n⟩\n...\n⟨\n푎\n푛\n⟩\n)\n7\n組み合わせは閉包であるべきだという手段の概念は単純なアイデアです。残念なこ\nとに多くの人気の有るプログラミング言語が提供するデータの組み合わせ手法は閉包性\nを満たしませんし、閉包性の活用が面倒です。\nFortran\nや\nBASIC\nではデータ要素を組合\nせる典型的な\n1\nつの手段は配列にそれらをまとめることです。しかし配列の要素自身が\n配列である配列を形成できません。\nPascal\nと\nC\nは構造体の要素が構造体であることを認\nめます。しかしこれはプログラマが明示的にポインタを取り扱うことを要求し、構造体\nの各フィールドが事前に指定された形式の要素のみを保管できるという制約に帰着しま\nす。\nLisp\nのペアとは異なりこれらの言語は複合データを統一的な方法で扱うことを簡単\nにする組み込みの汎用目的な糊を持っていません。この制約がこの本の前書きにおける\nAlan Perlis\nのコメントの背景にあります。\n“Pascal\nにおける過剰な宣言可能なデータ構\n造は関数内にて特殊化を引き起こし、カジュアルな連携を不利にし、抑制してしまう。\n1\nつのデータ構造を操作する\n100\nの関数を持つほうが、\n10\nのデータ構造を操作する\n10\nの\n関数を持つよりも良い。\n”\n8\nこの本では\nlist\nをリスト終端マーカーにて終端化されたペアの鎖を意味するように使\n用します。一方で用語\nlist structure\n(\nリスト構造\n)\nはペアから作り上げられた任意のデー\nタ構造を参照し、ただのリストは意味しません。\n103","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":129},{"id":"./test/fixtures/pdf/sicp.pdf:130","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1\n4\n2\n3\nFigure 2.4:\nペアの鎖として表現された列\n1, 2, 3, 4\nis equivalent to\nは以下と等価です。\n(\ncons\n⟨\n푎\n1\n⟩\n(\ncons\n⟨\n푎\n2\n⟩\n(\ncons\n...\n(\ncons\n⟨\n푎\n푛\n⟩\nnil\n)\n...\n)))\nLisp\nシステムは慣習としてリストを括弧で括られた要素の列を表示することで\n表します。従って\nFigure 2.4\nのデータオブジェクトは\n(1 2 3 4)\nの様に表示さ\nれます。\n(\ndefine\none-through-four\n(\nlist\n1 2 3 4))\none-through-four\n(1 2 3 4)\n式\n(list 1 2 3 4)\nとリスト\n(1 2 3 4)\nを取り違えないよう気をつけて下さい。\nリストは式が評価された時に得られた結果です。式\n(1 2 3 4)\nを評価しようと\nする試みはインタプリタが手続\n1\nを引数\n2\n,\n3\n,\n4\nに適用しようとした時にエラ\nーを発します。\ncar\nをリスト内の最初のアイテムを選択すると考えることもでき、\ncdr\nを最\n初のアイテム以外の全てにより成り立つサブ\n(\n副\n)\nリストを選択すると考える\nことも可能です。\ncar\nと\ncdr\nの入れ子の適用はリスト内の\n2\nつ目、\n3\nつ目、そ\nしてその後に続く複数のアイテムを抽出するために利用可能です。\n9\n9\ncar\nと\ncdr\nの入れ子の適用は書くのが面倒なため\nLisp\nの各種方言はそれらに対する\n略記法を提供しています。例えば、\n(\ncadr\n⟨\n푎푟푔\n⟩\n) = (\ncar\n(\ncdr\n⟨\n푎푟푔\n⟩\n))\n104","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":130},{"id":"./test/fixtures/pdf/sicp.pdf:131","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"コンストラクタ\ncons\nは元のリストと同様のリストを作りますが、最初に追\n加のアイテムを入れます。\n(\ncar\none-through-four\n)\n1\n(\ncdr\none-through-four\n)\n(2 3 4)\n(\ncar\n(\ncdr\none-through-four\n))\n2\n(\ncons\n10\none-through-four\n)\n(10 1 2 3 4)\n(\ncons\n5\none-through-four\n)\n(5 1 2 3 4)\ncodenil\nの値はペアの鎖を終了するために使用されますが、全く要素が無い\n列\nempty list\n(\n空リスト\n)\nとして考えることもできます。\nnil\nという単語はラテン\n語の単語\nnihil\nの省略形で、\n“\n無\n”\nを意味します。\n10\nリスト命令\n複数のペアを使用して要素の列をリストのように表現することは、慣習的\nなプログラミングテクニックである連続してリストを\n“\ncdr\nで縮小する\n”\nこと\nによりリストを操作するのと同時に生じます。例えば手続\nlist-ref\nは引数と\nしてリストと数値\n푛\nを取り、リストの\n푛\n番目の項目を返します。リストの要素\nを数えるのに\n0\nから始めるのが慣習です。\nlist-ref\nを計算する方法は以下の\n通りです。\nそのような手続全ての名前は\nc\nで始まり\nr\nで終わります。それらの間の各\na\nは\ncar\n命\n令を意図し、\nd\nは\ncdr\n命令を意図し、その名前に現れた順と同じ順にて適用されます。\ncar\nと\ncdr\nの名前は存続します。なぜなら\ncadr\nのような単純な組み合わせが発音可能だ\nからです。\n10\nどれだけのエネルギーが\nLisp\n方言の標準化において文字通り意味の無い議論に浪費\nされたかについては特筆に値します。\nnil\nは普通の名前であるべきか\n?\nnil\nの値は記号で\nあるべきか\n?\nそれはリストであるべきか\n?\nそれはペアであるべきか\n? Scheme\nでは\nnil\nは\n普通の名前でありこの節では変数として扱いその値はリスト終端マーカーです。\n(\ntrue\nが\n普通の変数であり、真の値を持つのと同様です\n)\n。\nCommon Lisp\nを含む他の\nLisp\n方言は\nnil\nを特別な記号として扱います。この本の著者達は、言語の標準化における数多くの乱\n闘に耐えてきたので、この問題全体を避けたいと思います。\nSection 2.3\nにて\nquote\nを紹\n介した後には空リストに\n'()\nという名前を付け、全体的に変数\nnil\nを免除します。\n105","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":131},{"id":"./test/fixtures/pdf/sicp.pdf:132","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n푛 = 0\nの場合、\nlist-ref\nはリストの\ncar\nを返す。\n•\nそうでなければ、\nlist-ref\nはリストの\ncdr\nの\n(푛 − 1)\n番目の項目を返す。\n(\ndefine\n(\nlist-ref\nitems\nn\n)\n(\nif\n(=\nn\n0)\n(\ncar\nitems\n)\n(\nlist-ref\n(\ncdr\nitems\n) (-\nn\n1))))\n(\ndefine\nsquares\n(\nlist\n1 4 9 16 25))\n(\nlist-ref\nsquares\n3)\n16\n時折、私達はリスト全体を\ncdr\nで下ります。これを手助けするために、\nScheme\nはプリミティブな手続\nnull?\nを持っており、その引数が空リストであるかどう\nかを試験します。手続\nlength\nはリスト内の要素数を返しますが、\nnull?\nの使用\nの典型的なパターンを説明します。\n(\ndefine\n(\nlength\nitems\n)\n(\nif\n(\nnull?\nitems\n)\n0\n(+ 1 (\nlength\n(\ncdr\nitems\n)))))\n(\ndefine\nodds\n(\nlist\n1 3 5 7))\n(\nlength\nodds\n)\n4\n手続\nlength\nは単純な最近計画を実装します。集約ステップは以下の通りです。\n•\n任意のリストの\nlength\nはリストの\ncdr\nの\nlength\nに\n1\nを足した値\nこれが底となるケースに到達するまで繰り返し適用される\n•\n空リストの\nlength\nは\n0\nまた\nlength\nは反復スタイルでも計算可能です。\n(\ndefine\n(\nlength\nitems\n)\n(\ndefine\n(\nlength-iter\na\ncount\n)\n(\nif\n(\nnull?\na\n)\ncount\n(\nlength-iter\n(\ncdr\na\n) (+ 1\ncount\n))))\n(\nlength-iter\nitems\n0))\n106","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":132},{"id":"./test/fixtures/pdf/sicp.pdf:133","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"もう\n1\nつの慣習的なプログラミングテクニックは\ncdr\nを繰り返し利用しリスト\nを下る間に、答のリストを\n“\ncons\nで積み上げ\n”\nることです。これは手続\nappend\nにて利用され、\nappend\nは\n2\nつのリストを引数として取り、それらの要素を結合\nし、新しいリストを作ります。\n(\nappend\nsquares\nodds\n)\n(1 4 9 16 25 1 3 5 7)\n(\nappend\nodds\nsquares\n)\n(1 3 5 7 1 4 9 16 25)\nappend\nもまた再帰計画を用いて実装されます。リスト\nlist1\nと\nlist2\nを\nappend\nするためには以下の通りに行います。\n•\nもし\nlist1\nが空リストであれば、結果は単に\nlist2\n•\nそうでない場合、\nlist1\nの\ncdr\nと\nlist2\nを\nappend\nし、その結果の上に\nlist1\nの\ncar\nを\ncons\nする\n(\ndefine\n(\nappend\nlist1\nlist2\n)\n(\nif\n(\nnull?\nlist1\n)\nlist2\n(\ncons\n(\ncar\nlist1\n) (\nappend\n(\ncdr\nlist1\n)\nlist2\n))))\nExercise 2.17:\n与えられた\n(\n空でない\n)\nリストの最初の要素のみを\n持つリストを返す手続\nlast-pair\nを定義せよ。\n(\nlast-pair\n(\nlist\n23 72 149 34))\n(34)\nExercise 2.18:\nリストを引数として取り、同じ要素を逆順に持つリ\nストを返す手続\nreverse\nを定義せよ。\n(\nreverse\n(\nlist\n1 4 9 16 25))\n(25 16 9 4 1)\nExercise 2.19:\nSection 1.2.2\nの両替数え上げプログラムについて考\nえる。プログラムにて用いられる通貨を容易に変更できるようにな\nればとても良いだろう。そうすることで例えばイギリスのポンドの\n両替方法の数を計算できるようになるだろう。プログラムが書かれ\n107","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":133},{"id":"./test/fixtures/pdf/sicp.pdf:134","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"た時には、通貨の知識はある部分は手続\nfirst-denomination\nの中\nに、またある部分は手続\ncount-change\nの中に存在した。\n(\ncount-\nchange\nは米国の貨幣には\n5\n種類あることを知っていた\n)\n。両替を行\nうため利用される貨幣のリストが提供できるようになればより良\nくなるだろう。\ncc\nを変更することで、その\n2\nつ目の引数がどの貨幣を使用するか\nを指定する整数ではなく、使用する貨幣の値のリストとなるよう\nにしたいと考える。そして通貨の各種類を定義するリストを持つ\nことにする。\n(\ndefine\nus-coins\n(\nlist\n50 25 10 5 1))\n(\ndefine\nuk-coins\n(\nlist\n100 50 20 10 5 2 1 0.5))\n次に\ncc\nを以下のように呼び出す。\n(\ncc\n100\nus-coins\n)\n292\nこれを行うためにはプログラム\ncc\nに何らかの変更が必要だ。同じ\n形態を保つが、\n2\nつ目の引数に異なる方法でアクセスする。以下の\nようになる。\n(\ndefine\n(\ncc\namount\ncoin-values\n)\n(\ncond\n((=\namount\n0) 1)\n((\nor\n(<\namount\n0) (\nno-more?\ncoin-values\n)) 0)\n(\nelse\n(+ (\ncc\namount\n(\nexcept-first-denomination\ncoin-values\n))\n(\ncc\n(-\namount\n(\nfirst-denomination\ncoin-values\n))\ncoin-values\n)))))\nリスト構造に対するプリミティブな命令を用いて手続\nfirst-\ndenomination\n,\nexcept-first-de- nomination\n, and\nno-more?\nを\n定義せよ。リスト\ncoin-values\nの順は\ncc\nにより生成される解答に\n影響を与えるか\n?\nそれは何故か\n?\nまたは何故そうでないのか\n?\n108","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":134},{"id":"./test/fixtures/pdf/sicp.pdf:135","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.20:\n手続\n+\n,\n*\n,\nlist\nは任意の数の引数を取る。そのよう\nな手続を定義する\n1\nつの方法として\ndotted-tail notation\n(\nドット付\nき末尾記法\n)\nと共に\ndefine\nを使用することが上げられる。手続定\n義において、最後のパラメータ名の前にドットがあるパラメータ\nリストは手続が呼び出された時に、最初以下のパラメータが\n(\nもし\n存在したら\n)\n初期引数の値を通常通りに持つが、最後のパラメータ\nの値は残りの引数全てのリストとなる。例えば、以下の定義を与\nえられた時に、\n(\ndefine\n(\nf\nx\ny\n.\nz\n)\n⟨\nbody\n⟩\n)\n手続\nf\nは\n2\nつ以上の引数で呼び出すことが可能だ。もし次を評価\nすれば、\n(\nf\n1 2 3 4 5 6)\nf\nのボディでは\nx\nが\n1\n、\ny\nが\n2\n、そして\nz\nはリスト\n(3 4 5 6)\nとな\nる。以下の定義を与えられた時、\n(\ndefine\n(\ng\n.\nw\n)\n⟨\nbody\n⟩\n)\n手続\ng\nはゼロ個以上の引数にて呼び出し可能となる。次を評価す\nれば、\n(\ng\n1 2 3 4 5 6)\ng\nのボディでは\nw\nはリスト\n(1 2 3 4 5 6)\nとなる。\n11\nこの記法を用いて手続\nsame-parity\nを書け。\nsame-parity\nは\n1\nつ\nまたはそれ以上の整数を引数として取り、最初の引数と同じ偶奇\n性を持つ全ての引数のリストを返す。例えば、\n(\nsame-parity\n1 2 3 4 5 6 7)\n(1 3 5 7)\n(\nsame-parity\n2 3 4 5 6 7)\n(2 4 6)\n11\nTo define\nf\nand\ng\nusing\nlambda\nwe would write\nf\nと\ng\nを\nlambda\nを用いて定義するには、以下のように記述する。\n(\ndefine\nf\n(\nlambda\n(\nx\ny\n.\nz\n)\n⟨\nbody\n⟩\n))\n(\ndefine\ng\n(\nlambda\nw\n⟨\nbody\n⟩\n))\n109","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":135},{"id":"./test/fixtures/pdf/sicp.pdf:136","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"リストに渡る\nmap\nあるとても便利な命令は、ある変換をリストの各要素に適用し、結果のリ\nストを返します。例えば以下の手続はリストの各数値を与えられた因数で拡大\nします。\n(\ndefine\n(\nscale-list\nitems\nfactor\n)\n(\nif\n(\nnull?\nitems\n)\nnil\n(\ncons\n(* (\ncar\nitems\n)\nfactor\n)\n(\nscale-list\n(\ncdr\nitems\n)\nfactor\n))))\n(\nscale-list\n(\nlist\n1 2 3 4 5) 10)\n(10 20 30 40 50)\n私達は\nSection 1.3\nのように、この一般的な考えを抽象化し、高階手続にて表現\nされた共通なパターンとして捉えることができます。ここでの高階手続は\nmap\nと呼ばれます。\nmap\nは引数として\n1\n引数の手続とリストを取り、返り値として\nその手続をリストの各要素に適用することで得られた結果のリストを返しま\nす。\n12\n(\ndefine\n(\nmap\nproc\nitems\n)\n(\nif\n(\nnull?\nitems\n)\nnil\n(\ncons\n(\nproc\n(\ncar\nitems\n))\n(\nmap\nproc\n(\ncdr\nitems\n)))))\n(\nmap\nabs\n(\nlist\n-10 2.5 -11.6 17))\n12\nScheme\nは標準としてここで説明される物よりもより汎用的な\nmap\n手続を提供しま\nす。このより汎用的な\nmap\nは\n푛\n引数の手続を、\n푛\n個のリストと共に取り、全てのリスト\nの最初の要素を手続に適用し、次に全ての\n2\nつ目の要素を適用し、以下それを繰り返し、\n結果のリストを返します。例えば、\n(\nmap\n+ (\nlist\n1 2 3) (\nlist\n40 50 60) (\nlist\n700 800 900))\n(741 852 963)\n(\nmap\n(\nlambda\n(\nx\ny\n) (+\nx\n(* 2\ny\n)))\n(\nlist\n1 2 3)\n(\nlist\n4 5 6))\n(9 12 15)\n110","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":136},{"id":"./test/fixtures/pdf/sicp.pdf:137","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(10 2.5 11.6 17)\n(\nmap\n(\nlambda\n(\nx\n) (*\nx\nx\n)) (\nlist\n1 2 3 4))\n(1 4 9 16)\nこれで\nmap\nを用いた新しい\nscale-list\nの定義を与えられる。\n(\ndefine\n(\nscale-list\nitems\nfactor\n)\n(\nmap\n(\nlambda\n(\nx\n) (*\nx\nfactor\n))\nitems\n))\nmap\nは重要な構造です。それが共通なパターンを掴むからだけでなく、リスト\nを扱うより高いレベルの抽象化を確立させるためです。\nscale-list\nの元の定\n義ではプログラムの再帰構造はリストのエレメント毎の処理に注意を引きまし\nた。\nmap\nを用いた\nscale-list\nの定義はそのレベルの詳細を抑制し、要素のリ\nストから結果のリストへの拡大変換を強調します。\n2\nつの定義の間の違いはコ\nンピュータが異なる処理を行うことではなく\n(\n異なりますが\n)\n、私達が過程につ\nいて異って考えていることです。実際に、\nmap\nはリストの要素がどのように抽\n出され、また結合されるかの詳細からリストを変換する手続の実装を分離する\n抽象化バリアを強化することを手助けします。\nFigure 2.1\nにて示されるバリア\nのように、この抽象化は私達に列がどのように実装されるかの低レベルの詳細\nを変更する柔軟性を提供し、その上で列から列へと変換する操作の概念上のフ\nレームワークを保っている。\nSection 2.2.3\nはこのプログラムを構成するための\nフレームワークとしての列の利用を拡張している。\nExercise 2.21:\nT\n手続\nsquare-list\nは数値のリストを引数として\n取りそれらの数値の二乗のリストを返す。\n(\nsquare-list\n(\nlist\n1 2 3 4))\n(1 4 9 16)\nここに\n2\nつの異なる\nsquare-list\nがある。失なわれた式を埋める\nことで両者を完成させよ。\n(\ndefine\n(\nsquare-list\nitems\n)\n(\nif\n(\nnull?\nitems\n)\nnil\n(\ncons\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\n(\ndefine\n(\nsquare-list\nitems\n)\n(\nmap\n⟨\n??\n⟩\n⟨\n??\n⟩\n))\n111","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":137},{"id":"./test/fixtures/pdf/sicp.pdf:138","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.22:\nLouis Reasoner\nは\nExercise 2.21\nの最初の\nsquare-\nlist\n手続を書き直し、反復プロセスを展開させようと試みている。\n(\ndefine\n(\nsquare-list\nitems\n)\n(\ndefine\n(\niter\nthings\nanswer\n)\n(\nif\n(\nnull?\nthings\n)\nanswer\n(\niter\n(\ncdr\nthings\n)\n(\ncons\n(\nsquare\n(\ncar\nthings\n))\nanswer\n))))\n(\niter\nitems\nnil\n))\n残念なことに、\nsquare-list\nをこのように定義しては解答のリス\nトは希望の逆順になってしまう。何故か\n?\nLouis\nはそこで彼のバグを\ncons\nへの引数を逆順にすることで直そ\nうと試みた。\n(\ndefine\n(\nsquare-list\nitems\n)\n(\ndefine\n(\niter\nthings\nanswer\n)\n(\nif\n(\nnull?\nthings\n)\nanswer\n(\niter\n(\ncdr\nthings\n)\n(\ncons\nanswer\n(\nsquare\n(\ncar\nthings\n))))))\n(\niter\nitems\nnil\n))\nこれもまたうまく行かない。説明せよ。\nExercise 2.23:\n手続\nfor-each\nは\nmap\nに似ている。手続と要素のリ\nストを引数として取る。しかし結果のリストを形成するのではな\nく、\nfor-each\nはただ手続を左から右へと毎回各要素に適用する。\n手続を要素に適用し返された値は全く利用しない\n—\nfor-each\nは\n表示のような行動を起こす手続と共に利用される。例えば、\n(\nfor-each\n(\nlambda\n(\nx\n)\n(\nnewline\n)\n(\ndisplay\nx\n))\n(\nlist\n57 321 88))\n57\n112","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":138},{"id":"./test/fixtures/pdf/sicp.pdf:139","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(1 2)\n4\n1\n2\n3\n(3 4)\n((1 2) 3 4)\nFigure 2.5:\n(cons (list 1 2) (list 3 4))\nにより形作ら\nれた構造\n321\n88\n(\n上では示されていない\n)\nfor-each\n呼出による返り値は真のような\n不定な何かである。\nfor-each\nの実装を与えよ。\n2.2.2\n階層構造\nリストを用いた列の表現は要素が列自身である列を表現することを自然に\n一般化する。例えば以下の様に構築されたオブジェクト\n((1 2) 3 4)\nを\n(\ncons\n(\nlist\n1 2) (\nlist\n3 4))\n最初の項目はそれ自身がリスト\n(1 2)\nである、\n3\nつの項目のリストであると見\n做すことができる。実際に、インタプリタにより表示される結果の形式によ\nりこれは推奨されている。\nFigure 2.5\nがペアを用いたこの構造の表現を示して\nいる。\n要素それ自身が列である列のもう\n1\nつの考え方は木としての考え方である。列\nの要素は木の枝であり、それ自身が列である\nelements(\n複数の要素\n)\nは部分木で\nある。\nFigure 2.6\nは木として見た場合の\nFigure 2.5\nを示している。\n再帰は木構造を扱うのに自然なツールです。良く木に対する操作を枝に対する\n操作へと還元でき、それは順に枝の枝への操作へと還元され、木の葉に辿り着\n113","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":139},{"id":"./test/fixtures/pdf/sicp.pdf:140","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"((1 2) 3 4)\n(1 2)\n3 4\n1  2\nFigure 2.6:\n木として見た\nFigure 2.5\nのリスト構造\nくまで繰り返されます。例として、\nSection 2.2.1\nの\nlength\n手続を木の葉の総数\nを求める\ncount-leaves\n手続と比べてみましょう。\n(\ndefine\nx\n(\ncons\n(\nlist\n1 2) (\nlist\n3 4)))\n(\nlength\nx\n)\n3\n(\ncount-leaves\nx\n)\n4\n(\nlist\nx\nx\n)\n(((1 2) 3 4) ((1 2) 3 4))\n(\nlength\n(\nlist\nx\nx\n))\n2\n(\ncount-leaves\n(\nlist\nx\nx\n))\n8\ncount-leaves\nを実装するには\nlength\nを求める再帰計画を思い出します。\n•\nリスト\nx\nの\nlength\nは\nx\nの\ncdr\nの\nlength\nに\n1\nを足した物\n•\n空リストの\nlength\nは\n0\ncount-leaves\nも同様えす。空リストの値は同じで\n•\n空リストの\ncount-leaves\nは\n0\nしかし集約ステップにおいて、リストの\ncar\nを取り除く時、\ncar\nはそれ自身が\n後で数えねばならない木である可能性があることを計算に入れねばなりませ\nん。従って適切な集約ステップは\n•\n木\nx\nの\ncount-leaves\nは\nx\nの\ncar\nの\ncount-leaves\nと、\nx\nの\ncdr\nの\ncount-\nleaves\nの和\n114","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":140},{"id":"./test/fixtures/pdf/sicp.pdf:141","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最終的に\ncar\nを取ることにより実際の葉に届くので別の規範を必要とする。\n•\n葉の\ncount-leaves\nは\n1\n木に対する再帰手続を書くのを助けるために、\nScheme\nはプリミティブな手続\npair?\nを提供します。\npair?\nは引数がペアであるかをテストします。以下に完\n成した手続を置きます。\n13\n(\ndefine\n(\ncount-leaves\nx\n)\n(\ncond\n((\nnull?\nx\n) 0)\n((\nnot\n(\npair?\nx\n)) 1)\n(\nelse\n(+ (\ncount-leaves\n(\ncar\nx\n))\n(\ncount-leaves\n(\ncdr\nx\n))))))\nExercise 2.24:\n式\n(list 1 (list 2 (list 3 4)))\nを評価したと\nする。インタプリタの表示する結果、対応する箱と点構造、木とし\nての解釈\n(\nFigure 2.6\n相当\n)\nを示せ。\nExercise 2.25:\n以下の各リストから\n7\nを抽出する\ncar\nと\ncdr\nの組\nみ合わせを与えよ。\n(1 3 (5 7) 9)\n((7))\n(1 (2 (3 (4 (5 (6 7))))))\nExercise 2.26:\n2\nつのリスト\nx\nと\ny\nを定義したとする。\n(\ndefine\nx\n(\nlist\n1 2 3))\n(\ndefine\ny\n(\nlist\n4 5 6))\n以下の各式を評価した場合にレスポンスとしてインタプリタがど\nのような結果を表示するか\n?\n(\nappend\nx\ny\n)\n(\ncons\nx\ny\n)\n(\nlist\nx\ny\n)\n13\ncond\nの最初の\n2\nつの項の順が大事です。空リストは\nnull?\nを満たし、その上でペア\nでもありません\n115","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":141},{"id":"./test/fixtures/pdf/sicp.pdf:142","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.27:\nExercise 2.18\nの\nreverse\n手続を変更してリストを\n引数として取り、全ての要素が逆順に、さらに全てのサブリストも\n同様に逆順にされたリストをその値として返す手続\ndeep-reverse\nを作れ。例として、\n(\ndefine\nx\n(\nlist\n(\nlist\n1 2) (\nlist\n3 4)))\nx\n((1 2) (3 4))\n(\nreverse\nx\n)\n((3 4) (1 2))\n(\ndeep-reverse\nx\n)\n((4 3) (2 1))\nExercise 2.28:\nリストとして表現された木を引数に取り、その木の\n全ての葉を左から右への順で要素としたリストを返す手続\nfringe\nを書け。\n(\ndefine\nx\n(\nlist\n(\nlist\n1 2) (\nlist\n3 4)))\n(\nfringe\nx\n)\n(1 2 3 4)\n(\nfringe\n(\nlist\nx\nx\n))\n(1 2 3 4 1 2 3 4)\nExercise 2.29:\nバイナリモバイル\n(binary mobile)\n14\nは左の枝と右\nの枝の\n2\nつの枝で構成される。各枝はある長さを持つ棒であり、そ\nこから重りか別のバイナリモバイルをぶら下げる。バイナリモバ\nイルを複合データを用いて\n2\nつの枝から組み立てることで表現で\nきる。\n(\n例えば\nlist\nを用いる。\n)\n(\ndefine\n(\nmake-mobile\nleft\nright\n)\n(\nlist\nleft\nright\n))\n枝は\nlength\n(\n数値であること\n)\nと\nstructure\nから組み立てられ、\nstructure\nは数値\n(\n簡単に重りを表わす\n)\nかまたは他のモバイルで\nある。\n14\n訳注：天井から糸で釣ってあり、絶妙なバランスで揺れ、回る数々の棒のインテリ\nア。枝が必ず\n2\nつに分かれるのでバイナリ\n(\n二進\n)\nと名付けられている。\nGoogle Images\nで\nmobile\nを検索すると実物が見られる。\n116","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":142},{"id":"./test/fixtures/pdf/sicp.pdf:143","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nmake-branch\nlength\nstructure\n)\n(\nlist\nlength\nstructure\n))\na\n対応するセレクタ\nleft-branch\nを\nright-branch\nを書け。こ\nのセレクタはモバイルの複数の枝を返す。また\nbranch-\nlength\nと\nbranch-structure\nは枝のそれぞれのコンポーネ\nント\n(\n構成要素\n)\nを返す。\nb\nセレクタを用いて手続\ntotal-weight\nを定義せよ。それはモ\nバイルの総重量を返す。\nc\nモバイルは一番上の左枝にかかるトルク\n(\n回転力\n)\nが一番上\nの右の枝にかかるトルクと等しい時\n(\nこれはつまり、もし左\nの棒の長さとその棒にかかる重さを掛けた値が、相対する右\n側の積の値と同じ場合である\n)\n、かつ各部分モバイルも全て\n同様である場合に限り、\nbalanced\n(\nバランスが取れた状態\n)\nで\nあると言う。あるバイナリモバイルがバランスが取れている\nかテストする述語を設計せよ。\nd\nモバイルの表現をコンストラクタが以下になるように変更す\nると考える。\n(\ndefine\n(\nmake-mobile\nleft\nright\n) (\ncons\nleft\nright\n))\n(\ndefine\n(\nmake-branch\nlength\nstructure\n)\n(\ncons\nlength\nstructure\n))\n新しい表現へとあなたのプログラムを変更するのにどれほど\nが必要か\n?\n木に渡る\nmap\nmap\nが列を扱うのに強力な抽象化であるのと同様に、再帰を伴なう\nmap\nは\n木を扱うのに強力な抽象化です。例えば\nSection 2.2.1\nの\nscale-list\nに同類な\nscale-tree\n手続は引数として因数と葉が数値である木を取ります。これは同\nじ形の木を返しますが、各数値は因数により乗算されます。\nscale-tree\nの再帰\n計画は\ncount-leaves\nに対する物に似ています。\n(\ndefine\n(\nscale-tree\ntree\nfactor\n)\n(\ncond\n((\nnull?\ntree\n)\nnil\n)\n((\nnot\n(\npair?\ntree\n)) (*\ntree\nfactor\n))\n117","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":143},{"id":"./test/fixtures/pdf/sicp.pdf:144","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nelse\n(\ncons\n(\nscale-tree\n(\ncar\ntree\n)\nfactor\n)\n(\nscale-tree\n(\ncdr\ntree\n)\nfactor\n)))))\n(\nscale-tree\n(\nlist\n1 (\nlist\n2 (\nlist\n3 4) 5) (\nlist\n6 7)) 10)\n(10 (20 (30 40) 50) (60 70))\nscale-tree\nを実装するもう\n1\nつの方法は木を部分木の列と見做し\nmap\nを使用\nします。列全体に\nmap\nをかけ、各部分木を順に拡大し、結果のリストを返しま\nす。その木が葉である場合には単純に因数を掛けます。\n(\ndefine\n(\nscale-tree\ntree\nfactor\n)\n(\nmap\n(\nlambda\n(\nsub-tree\n)\n(\nif\n(\npair?\nsub-tree\n)\n(\nscale-tree\nsub-tree\nfactor\n)\n(*\nsub-tree\nfactor\n)))\ntree\n))\n多くの木の操作が同様な列操作と再帰の組み合わせにて実装可能です。\nExercise 2.30:\nExercise 2.21\nの\nsquare-list\nと同様の手続\nsquare-\ntree\nを定義せよ。\nsquare-tree\nは以下の振舞を行う。\n(\nsquare-tree\n(\nlist\n1\n(\nlist\n2 (\nlist\n3 4) 5)\n(\nlist\n6 7)))\n(1 (4 (9 16) 25) (36 49))\nsquare-tree\nを直接な\n(\nつまり高階関数を全く用いない\n)\n方法と\nmap\nと再帰を用いる方法の両者を定義せよ。\nExercise 2.31:\nExercise 2.30\nへの解答を抽象化し、手続\ntree-map\nを作れ。\ntree-map\nを用いて\nsquare-tree\nは以下のように定義で\nきる。\n(\ndefine\n(\nsquare-tree\ntree\n) (\ntree-map\nsquare\ntree\n))\nExercise 2.32:\n集合は識別可能な要素のリストとして表現できる。\nそして集合の全ての部分集合集合をリストのリストとして表わせ\nられる。例えば、集合が\n(1 2 3)\nである時、全ての部分集合の集\n合は\n(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))\nだ。以下の\n118","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":144},{"id":"./test/fixtures/pdf/sicp.pdf:145","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"集合の全ての部分集合の集合を生成する手続の定義を完成し、な\nぜうまくいくのかを明確に説明せよ。\n(\ndefine\n(\nsubsets\ns\n)\n(\nif\n(\nnull?\ns\n)\n(\nlist\nnil\n)\n(\nlet\n((\nrest\n(\nsubsets\n(\ncdr\ns\n))))\n(\nappend\nrest\n(\nmap\n⟨\n??\n⟩\nrest\n)))))\n2.2.3\n慣習的インターフェイスとしての列\n複合データを用いて働く場合、これまでデータ抽象化がどれだけプログラ\nムの設計をデータ表現の詳細に陥らずに行えるか、また抽象化がどれだけ代替\n的な表現方法を試みる柔軟性を保つかについて強調してきました。この節で\nはもう\n1\nつの強力なデータ構造を用いる設計原則を紹介します。\nconventional\ninterfaces\n(\n慣習的インターフェイス\n)\nの使用です。\nSection 1.3\nにおいてプログラム抽象化、高階手続としての実装がどのよう\nにして数値データを取り扱うプログラムの共通パターンを掴むことができるの\nかを学んできました。複合データを扱う類似の操作を形式化する能力は決定的\nにデータ構造を扱うスタイルに依存します。例えば次の手続について考えてみ\nて下さい。\nSection 2.2.2\nの\ncount-leaves\n手続に類似しており、木を引数として\n取り、奇数の葉の二乗の合計を求めます。\n(\ndefine\n(\nsum-odd-squares\ntree\n)\n(\ncond\n((\nnull?\ntree\n) 0)\n((\nnot\n(\npair?\ntree\n))\n(\nif\n(\nodd?\ntree\n) (\nsquare\ntree\n) 0))\n(\nelse\n(+ (\nsum-odd-squares\n(\ncar\ntree\n))\n(\nsum-odd-squares\n(\ncdr\ntree\n))))))\n表面上では、この手続は以下の物ととても異なっています。以下では全ての偶\n数のフィボナッチ数\n퐹 푖푏(푘)\nのリストを、\n푘\nが与えられた\n푛\n以下の範囲にて作\n成しています。\n(\ndefine\n(\neven-fibs\nn\n)\n(\ndefine\n(\nnext\nk\n)\n(\nif\n(>\nk\nn\n)\nnil\n119","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":145},{"id":"./test/fixtures/pdf/sicp.pdf:146","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\nf\n(\nfib\nk\n)))\n(\nif\n(\neven?\nf\n)\n(\ncons\nf\n(\nnext\n(+\nk\n1)))\n(\nnext\n(+\nk\n1))))))\n(\nnext\n0))\nこれらの\n2\nつの手続は構造的にとても異なっているという事実にも係らず、\n2\nつの計算のより抽象的な記述は大きな類似性を明らかにします。最初のプログ\nラムは\n•\n木の葉を列挙する\n•\nフィルタを通して奇数のみを選ぶ\n•\n選択された数の二乗を求める\n•\n初期値\n0\nにて\n+\nを用いて集積する。\n2\nつ目のプログラムは\n•\n0\nから\n푛\nを列挙する\n•\n各整数のフィボナッチ数を求める\n•\nフィルタを通して偶数を選択する\n•\n初期値は空リストにて\ncons\nを用いて結果を集積する\n信号処理のエンジニアはこれらの処理をステージのカスケードを通して流れ\nる信号を用いて処理するという概念的説明を自然だと思われるでしょう。各\nステージはプログラム設計の部分を\nFigure 2.7\nに示すように実装しています。\nsum-odd-squares\nでは\nenumerator\n(\nエニュメレータ\n)\nにて始めました。それは\n与えられた木の葉から成る\n“\n信号\n”\nを生成します。この信号は\nfilter\n(\nフィルタ\n)\nを通して奇数要素以外を全て取り除きます。残った信号は順に\n“\n変換器\n”\nであ\nる\nmap\nを通し、それが\nsquare\n手続を各要素に適用します。\nmap\nの出力は次\nに\naccumulator\n(\n集積機\n)\nに与えられ、それが要素を初期値\n0\nと\n+\nを用いて連結\nします。\neven-fibs\nの設計も同様です。\n残念ながら上記の\n2\nつの手続の定義はこの信号の流れの構造を提示するの\nは失敗しています。例えば\nsum-odd-squares\nを調べてみると\nenumeration(\n列\n挙\n)\nは部分的に\nnull?\nの\npair?\nのテストにて実装され、別の部分では手続の木\n再帰構造により実装されています。同様に集積は部分的にテストの中に見つか\nり、また部分的に再帰中で使用される足し算に見つかります。全体的にどちら\nの手続も信号の流れの記述内の要素に関連する明確な部分は存在しません。\n2\n120","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":146},{"id":"./test/fixtures/pdf/sicp.pdf:147","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"enumerate:\ntree leaves\nfilter:\nodd?\nmap:\nsquare\naccumulate:\n+, 0\nenumerate:\nintegers\nmap:\nfib\nfilter:\neven?\naccumulate:\ncons, ()\nFigure 2.7:\n手続\nsum-odd-squares\n(\n上\n)\nと\neven-fibs\n(\n下\n)\nの信号の流れ\nの計画が二つのプログラムの間の共通点を明かす\nつの手続は演算を異なる方法で分解し、列挙をプログラム全体に広げて\nmap,\nfilter, accumulation\nに混ぜました。もしプログラムを手続中に信号処理構造の\n宣言を作るように構成できるのであれば結果としてのコードの概念の明快さを\n増すことができるでしょう。\n列命令\nプログラムを体系化し信号伝達構造をより明確に反映する鍵はある段階の\n処理から次へと流れる\n“\n信号\n”\nに集中することです。もしこれらの信号をリスト\nとして表現するなら、各段階の処理をリスト操作を用いて実装できます。例え\nば信号伝達図の\nmap\nの段階を\nSection 2.2.1\nの\nmap\n手続を用いて実装できます。\n(\nmap\nsquare\n(\nlist\n1 2 3 4 5))\n(1 4 9 16 25)\n列をフィルタリングして与えられた述語を満足する要素のみを選択することは\n以下の様に達成できます。\n(\ndefine\n(\nfilter\npredicate\nsequence\n)\n(\ncond\n((\nnull?\nsequence\n)\nnil\n)\n((\npredicate\n(\ncar\nsequence\n))\n(\ncons\n(\ncar\nsequence\n)\n(\nfilter\npredicate\n(\ncdr\nsequence\n))))\n(\nelse\n(\nfilter\npredicate\n(\ncdr\nsequence\n)))))\n例として、\n121","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":147},{"id":"./test/fixtures/pdf/sicp.pdf:148","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nfilter\nodd?\n(\nlist\n1 2 3 4 5))\n(1 3 5)\n集積は次のように実装します。\n(\ndefine\n(\naccumulate\nop\ninitial\nsequence\n)\n(\nif\n(\nnull?\nsequence\n)\ninitial\n(\nop\n(\ncar\nsequence\n)\n(\naccumulate\nop\ninitial\n(\ncdr\nsequence\n)))))\n(\naccumulate\n+ 0 (\nlist\n1 2 3 4 5))\n15\n(\naccumulate\n* 1 (\nlist\n1 2 3 4 5))\n120\n(\naccumulate\ncons\nnil\n(\nlist\n1 2 3 4 5))\n(1 2 3 4 5)\n信号伝達図を実装するのに残っているもの全ては処理すべき要素の列を列挙す\nることです。\neven-fibs\nのためには与えられた区間の整数の列を生成しなけれ\nばならず、以下のように行うことができます。\n(\ndefine\n(\nenumerate-interval\nlow\nhigh\n)\n(\nif\n(>\nlow\nhigh\n)\nnil\n(\ncons\nlow\n(\nenumerate-interval\n(+\nlow\n1)\nhigh\n))))\n(\nenumerate-interval\n2 7)\n(2 3 4 5 6 7)\n木の葉を列挙するには、以下の様にして可能です。\n15\n(\ndefine\n(\nenumerate-tree\ntree\n)\n(\ncond\n((\nnull?\ntree\n)\nnil\n)\n((\nnot\n(\npair?\ntree\n)) (\nlist\ntree\n))\n(\nelse\n(\nappend\n(\nenumerate-tree\n(\ncar\ntree\n))\n(\nenumerate-tree\n(\ncdr\ntree\n))))))\n(\nenumerate-tree\n(\nlist\n1 (\nlist\n2 (\nlist\n3 4)) 5))\n(1 2 3 4 5)\n15\nこれは実際には\nExercise 2.28\nの\nfringe\n手続そのものです。ここではその名を変え\nて列操作手続一般に属するパーツであることを強調しています。\n122","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":148},{"id":"./test/fixtures/pdf/sicp.pdf:149","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これで\nsum-odd-squares\nと\neven-fibs\nを信号伝達図の様に再形式化すること\nができます。\nsum-odd-squares\nのためには木の葉の列を列挙し、これをフィル\nタにかけ列の奇数のみを保持し、各要素を二乗し、結果の合計を求めます。\n(\ndefine\n(\nsum-odd-squares\ntree\n)\n(\naccumulate\n+ 0 (\nmap\nsquare\n(\nfilter\nodd?\n(\nenumerate-tree\ntree\n)))))\neven-fibs\nに対しては\n0\nから\n푛\nの整数を列挙し、これらの整数のそれぞれに対\nするフィボナッチ数を生成し、結果列をフィルタにかけ偶数の要素のみを保持\nし、結果をリストの中に集積します。\n(\ndefine\n(\neven-fibs\nn\n)\n(\naccumulate\ncons\nnil\n(\nfilter\neven?\n(\nmap\nfib\n(\nenumerate-interval\n0\nn\n)))))\n列操作としての伝達プログラムの価値はこれがモジュラ形式のプログラムデザ\nインを行うことを手助けしてくれることにあります。モジュラであるとは相対\n的に独立した部品を組み立てることで構築される設計です。柔軟な形でコンポ\nーネントを接続するための慣習的なインターフェイスと共に、標準コンポーネ\nントのライブラリを提供することで、モジュラ設計を推進することができます。\nモジュラ構築は複雑性を工学的設計において複雑性をコントロールするこ\nとに対して強力な戦略です。例えば現実の信号処理アプリケーションでは、設計\n者は恒常的にフィルタと変換器の標準化されたグループから選択された要素を\n繋げることでシステムを構築します。同様に列操作は標準的プログラム要素を\n様々に組合せたライブラリを提供します。実例として私達は\nsum-odd-squares\nと\neven-fibs\nの手続の部品を用いて、フィボナッチ数の最初から\n푛 + 1\n個の二\n乗のリストを作成できます。\n(\ndefine\n(\nlist-fib-squares\nn\n)\n(\naccumulate\ncons\nnil\n(\nmap\nsquare\n(\nmap\nfib\n(\nenumerate-interval\n0\nn\n)))))\n(\nlist-fib-squares\n10)\n(0 1 1 4 9 25 64 169 441 1156 3025)\n部品を再配置し、列の奇数の二乗の積を計算するのに使うことも可能です。\n123","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":149},{"id":"./test/fixtures/pdf/sicp.pdf:150","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nproduct-of-squares-of-odd-elements\nsequence\n)\n(\naccumulate\n* 1 (\nmap\nsquare\n(\nfilter\nodd?\nsequence\n))))\n(\nproduct-of-squares-of-odd-elements\n(\nlist\n1 2 3 4 5))\n225\n慣習的なデータ処理アプリケーションを列操作を用いて説明することもできま\nす。個人の記録の列があるとし、最も高給なプログラマの給料を見つけたいと\nします。記録の給料を返すセレクタ\nsalary\nと記録がプログラマの物であるか\nを判定する述語\nprogrammer?\nがあるとします。すると以下のように書けます。\n(\ndefine\n(\nsalary-of-highest-paid-programmer\nrecords\n)\n(\naccumulate\nmax\n0 (\nmap\nsalary\n(\nfilter\nprogrammer?\nrecords\n))))\nこの例は列操作として表わすことができる広範囲な処理のヒントを与えたにす\nぎません。\n16\nここではリストとして実装された列は処理モジュールを接続することを可\n能にする慣習的インターフェイスとしての役割を行います。その上、私達が構\n造を列として統一的に表現した時、私達はプログラム中のデータ構造依存性を\n少ない数の列操作へと局所化しました。これらを変更することで、プログラム\n設計を全体的に保存したまま列の代替的表現方法を試みることができます。私\n達はこの能力を\nSection 3.5\nにて列処理パラダイムを無限列を許可するよう一般\n化する時に利用します。\nExercise 2.33:\n欠けた式を埋めて次の集積としてのいくつかの基本\n的なリスト操作命令の定義を完成させよ。\n(\ndefine\n(\nmap\np\nsequence\n)\n(\naccumulate\n(\nlambda\n(\nx\ny\n)\n⟨\n??\n⟩\n)\nnil\nsequence\n))\n(\ndefine\n(\nappend\nseq1\nseq2\n)\n(\naccumulate\ncons\n⟨\n??\n⟩\n⟨\n??\n⟩\n))\n16\nRichard\nWaters (1979)\nは伝統的な\nFrotran\nプログラムを自動的に解析し、\nmap,\nフ\nィルタ\n,\n集積を用いてそらを俯瞰するプログラムを開発しました。彼は\nFortran\nの科学サ\nブルーチンパッケージのコードの実に\n90%\nがこのパラダイムにうまくはまることを発見\nしました。\nLisp\nがプログラミング言語として成功した理由の\n1\nつにリストが順序有り集\n合を表すのに標準的な手段を提供したことがあり、そのため高階手続を用いて操作する\nことが可能になりました。プログラミング言語\nAPL\nはその力と魅力の多くを同様の選択\nのおかげで得ました。\nAPL\nでは全てのデータは配列として表現され、統一的、かつ便利\nな全ての種類の配列操作のための包括的な命令集合が存在します。\n124","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":150},{"id":"./test/fixtures/pdf/sicp.pdf:151","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nlength\nsequence\n)\n(\naccumulate\n⟨\n??\n⟩\n0\nsequence\n))\nExercise 2.34:\n푥\nの多項式を\n푥\nの与えられた値にて評価するこ\nとは集積として表すことができる。以下の多項式を良く知られ\nた\nHorner’s rule\n(\nホーナー法\n)\nと呼ばれるアルゴリズムを用いて評\n価する。\n푎\n푛\n푥\n푛\n+ 푎\n푛−1\n푥\n푛−1\n+ ... + 푎\n1\n푥 + 푎\n0\nホーナー法は上記の計算を以下のような構造にする。\n(... (푎\n푛\n푥 + 푎\n푛−1\n)푥 + ... + 푎\n1\n)푥 + 푎\n0\n.\nすなわち\n푎\n푛\nで始め、\n푥\nを掛け、\n푎\n푛−1\nを足し、\n푥\nを掛け、を\n푎\n0\nに\n到達するまで繰り返す。\n17\n以下のテンプレートを埋めホーナー法を用いて多項式を評価する\n手続を作り出せ。多項式の係数\n푎\n0\nから\n푎\n푛\nは列で用意されると想\n定せよ。\n(\ndefine\n(\nhorner-eval\nx\ncoefficient-sequence\n)\n(\naccumulate\n(\nlambda\n(\nthis-coeff\nhigher-terms\n)\n⟨\n??\n⟩\n)\n0\ncoefficient-sequence\n))\n例えば\n1 + 3푥 + 5푥\n3\n+ 푥\n5\nを\n푥 = 2\nの時の値を求める場合、次のよ\nうに評価を行う。\n(\nhorner-eval\n2 (\nlist\n1 3 0 5 0 1))\n17\nKnuth 1981\nによるとこの方法は\nW. G. Horner\nにより\n19\n世紀始めに考案された。し\nかしその手法は実際にはニュートンにより\n100\n年を越えた前に使用されていた。ホーナ\nー法は多項式を最初に\n푎\n푛\n푥\n푛\nを計算し、\n푎\n푛−1\n푥\n푛−1\nを足すを繰り返す直接的な方法より\n少ない回数の和と積を用いて評価する。実際に任意の多項式を評価するためのどんなア\nルゴリズムもホーナー法が必要な数と同じ数の和と積を使用する必要があることを証明\nすることが可能である。従ってホーナー法は多項式評価において最適なアルゴリズムで\nある。これは\n(\n和の数において\n)A. M. Ostrowski\nによる\n1954\n年の論文にて証明され、こ\nれが現代の最適アルゴリズム研究の基礎を築いた。同様の説明が積の数について\nV. Y.\nPan\nにより\n1966\n年に証明された。\nBorodin and Munro (1975)\nによる本がこれらと他の\n最適アルゴリズムについての結果について概観している。\n125","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":151},{"id":"./test/fixtures/pdf/sicp.pdf:152","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.35:\nSection 2.2.2\nの\ncount-leaves\nを集積として再定義\nせよ。\n(\ndefine\n(\ncount-leaves\nt\n)\n(\naccumulate\n⟨\n??\n⟩\n⟨\n??\n⟩\n(\nmap\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\nExercise 2.36:\n手続\naccumulate-n\nは\naccumulate\nに似ているが\n3\n番目の引数として列の列を取り、その要素の列の長さは全て一定\nである。指定された集積手続を複数の列の最初の要素、二番目の\n要素、以下繰り返し、を全て連結するため適用し、結果の列を返\nす。例えばもし\ns\nが\n4\nつの列を含む列、\n((1 2 3) (4 5 6) (7 8\n9) (10 11 12))\nである時、\n(accumulate-n + 0 s)\nの値は列\n(22\n26 30)\nにならなければならない。以下の\naccumulate-n\nの定義の\n欠けた式を補え。\n(\ndefine\n(\naccumulate-n\nop\ninit\nseqs\n)\n(\nif\n(\nnull?\n(\ncar\nseqs\n))\nnil\n(\ncons\n(\naccumulate\nop\ninit\n⟨\n??\n⟩\n)\n(\naccumulate-n\nop\ninit\n⟨\n??\n⟩\n))))\nExercise 2.37:\nベクトル\n푣 = (푣\n푖\n)\nを数値の列として表現し、行列\n푚 = (푚\n푖푗\n)\nをベクトル\n(\n行列の行\n)\nの列として表現するとする。例\nえば以下の行列は、\n⎛\n⎜\n⎜\n⎝\n1    2    3    4\n4    5    6    6\n6    7    8    9\n⎞\n⎟\n⎟\n⎠\n列\n((1 2 3 4) (4 5 6 6) (6 7 8 9))\nとして表現される。この表\n現と共に列操作を用いることで簡潔に基本的な行列とベクトルの\n操作を表現することができる。これらの操作は\n(\n行列演算のどんな\n本にも記述されている\n)\n次のものである。\n(dot-product v w)\n푟푒푡푢푟푛푠 푡ℎ푒 푠푢푚 Σ\n푖\n푣\n푖\n푤\n푖\n,\n(matrix-*-vector m v)\n푟푒푡푢푟푛푠 푡ℎ푒 푣푒푐푡표푟\nt\n,\n푤ℎ푒푟푒 푡\n푖\n= Σ\n푗\n푚\n푖푗\n푣\n푗\n,\n(matrix-*-matrix m n)\n푟푒푡푢푟푛푠 푡ℎ푒 푚푎푡푟푖푥\np\n,\n푤ℎ푒푟푒 푝\n푖푗\n= Σ\n푘\n푚\n푖푘\n푛\n푘푗\n,\n(transpose m)\n푟푒푡푢푟푛푠 푡ℎ푒 푚푎푡푟푖푥\nn\n,\n푤ℎ푒푟푒 푛\n푖푗\n= 푚\n푗푖\n.\n126","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":152},{"id":"./test/fixtures/pdf/sicp.pdf:153","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ドット積を次のように定義できる。\n18\n(\ndefine\n(\ndot-product\nv\nw\n)\n(\naccumulate\n+ 0 (\nmap\n*\nv\nw\n)))\n以下の他の行列操作を演算するための手続の欠けた式を補え。\n(\n手\n続\naccumulate-n\nは\nExercise 2.36\nで定義されている。\n)\n(\ndefine\n(\nmatrix-*-vector\nm\nv\n)\n(\nmap\n⟨\n??\n⟩\nm\n))\n(\ndefine\n(\ntranspose\nmat\n)\n(\naccumulate-n\n⟨\n??\n⟩\n⟨\n??\n⟩\nmat\n))\n(\ndefine\n(\nmatrix-*-matrix\nm\nn\n)\n(\nlet\n((\ncols\n(\ntranspose\nn\n)))\n(\nmap\n⟨\n??\n⟩\nm\n)))\nExercise 2.38:\naccumulate\n手続はまた\nfold-right\nとしても知ら\nれている。それが列の最初の要素と右側の要素全てを結合した結\n果とを結合するためである。\nfold-left\nも存在し、\nfold-right\nと\n似ているが、要素の結合を逆の向きに行う。\n(\ndefine\n(\nfold-left\nop\ninitial\nsequence\n)\n(\ndefine\n(\niter\nresult\nrest\n)\n(\nif\n(\nnull?\nrest\n)\nresult\n(\niter\n(\nop\nresult\n(\ncar\nrest\n))\n(\ncdr\nrest\n))))\n(\niter\ninitial\nsequence\n))\n以下の式の値はいくらか。\n(\nfold-right\n/ 1 (\nlist\n1 2 3))\n(\nfold-left\n/ 1 (\nlist\n1 2 3))\n(\nfold-right\nlist\nnil\n(\nlist\n1 2 3))\n(\nfold-left\nlist\nnil\n(\nlist\n1 2 3))\nop\nが\nfold-right\nと\nfold-left\nにて同じ値を任意の列に対し生成\nすることを保証するのに必要な特性を答えよ。\n18\nこの定義は\nFootnote 12\nにて説明した\nmap\nの拡張バージョンを使用する\n127","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":153},{"id":"./test/fixtures/pdf/sicp.pdf:154","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.39:\n以下の\nreverse\n(\nExercise 2.18\n)\nの\nfold-right\nと\nfold-left\n(\nExercise 2.38\n)\nを用いた定義を完成させよ。\n(\ndefine\n(\nreverse\nsequence\n)\n(\nfold-right\n(\nlambda\n(\nx\ny\n)\n⟨\n??\n⟩\n)\nnil\nsequence\n))\n(\ndefine\n(\nreverse\nsequence\n)\n(\nfold-left\n(\nlambda\n(\nx\ny\n)\n⟨\n??\n⟩\n)\nnil\nsequence\n))\n入れ子の\nmap\n列のパラダイムを拡張し、一般的に入れ子ループを用いて表現される多く\nの演算を含めてみます。\n19\n次の問題について考えてみて下さい：正の整数\n푛\nを与えられた時、異なる正の整数\n푖\nと\n푗\nの全ての順序付けペアを見つけよ。条\n件として\n1 ≤ 푗 < 푖 ≤ 푛\n、かつ\n푖 + 푗\nは素数である。例として、もし\n푛\nが\n6\nなら\nばペアは以下の通りである。\n푖\n2\n3\n4\n4\n5\n6\n6\n푗\n1\n2\n1\n3\n2\n1\n5\n푖 + 푗\n3\n5\n5\n7\n7\n7\n11\nこの演算を体系化する自然な方法は全ての順序付けられた\n푛\n以下の正の整\n数のペアを生成し、フィルタを通してその合計が素数であるもののみを選択し、\nフィルタを通った各ペア\n(푖, 푗)\nに対し三つ組\n(푖, 푗, 푖 + 푗)\nを生成することです。\nここでペアの列を生成する方法を上げます：全ての整数\n푖 ≤ 푛\nに対し、整\n数\n푗 < 푖\nを列挙し、全てのそのような\n푖\nと\n푗\nに対し、ペア\n(푖, 푗)\nを生成します。\n列操作を用いて、列\n(enumerate-interval 1 n)\nに沿って\nmap\nを行います。こ\nの列の各\n푖\nに対し、列\n(enumerate-interval 1 (- i 1))\nに沿って\nmap\nを行い\nます。この後者の列の\n푗\nに対し、ペア\n(list i j)\nを生成します。これが全ての\n푖\nに対するペアの列を与えます。全ての\n푖\nに対する全ての列を\n(\nappend\nを用い\nて集積することにより\n)\n接続することで要求されたペアの列を生成します。\n20\n19\nこの入れ子マッピングへの取り組み方は\nDavid Turner\nにより示されました。彼の言\n語である\nKRC\nと\nMiranda\nはこれらの構成概念を取り扱うための洗練された形式主義を\n与えました。この節の例\n(\nまた\nExercise 2.42\nも参照\n)\nは\nTurner 1981\nより翻案されました。\nSection 3.5.3\nではこのやり方が無限長列に対しどのように一般化されるかを学びます。\n20\nここではペアを\n2\nつの要素のリストとして表現しており、\nLisp\nのペアとしてではあ\nりません。従って\n“\nペア\n”\n(푖, 푗)\nは\n(list i j)\nであり、\n(cons i j)\nではありません。\n128","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":154},{"id":"./test/fixtures/pdf/sicp.pdf:155","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\naccumulate\nappend\nnil\n(\nmap\n(\nlambda\n(\ni\n)\n(\nmap\n(\nlambda\n(\nj\n) (\nlist\ni\nj\n))\n(\nenumerate-interval\n1 (-\ni\n1))))\n(\nenumerate-interval\n1\nn\n)))\nmap\nと集積の組み合わせを\nappend\nと共に用いるのはこの種のプログラムにお\nいてとても一般的ですので、これを分離したプログラムとして分けます。\n(\ndefine\n(\nflatmap\nproc\nseq\n)\n(\naccumulate\nappend\nnil\n(\nmap\nproc\nseq\n)))\nこれでこのペアの列をフィルタにかけ和が素数であるものを探します。フィル\nタの述語が各要素に対して呼ばれます。その引数はペアであり、ペアから整数\nを抽出せねばなりません。従って列の各要素に適用される述語は以下のように\nなります。\n(\ndefine\n(\nprime-sum?\npair\n)\n(\nprime?\n(+ (\ncar\npair\n) (\ncadr\npair\n))))\n最後に、フィルタを通ったペア全体に以下の手続を用いて\nmap\nをかけた結果\nの列を生成します。以下の手続は\n2\nつの要素のペアとそれらの和を用いて\n3\nつ\n組を構築します。\n(\ndefine\n(\nmake-pair-sum\npair\n)\n(\nlist\n(\ncar\npair\n) (\ncadr\npair\n) (+ (\ncar\npair\n) (\ncadr\npair\n))))\nこれらのステップ全てを接続すれば手続は完了です。\n(\ndefine\n(\nprime-sum-pairs\nn\n)\n(\nmap\nmake-pair-sum\n(\nfilter\nprime-sum?\n(\nflatmap\n(\nlambda\n(\ni\n)\n(\nmap\n(\nlambda\n(\nj\n) (\nlist\ni\nj\n))\n(\nenumerate-interval\n1 (-\ni\n1))))\n(\nenumerate-interval\n1\nn\n)))))\n入れ子の\nmap\nは区間を列挙するもの以外の列に対しても便利です。ある集合\n푆\nの全ての順列を生成したいとします。つまり集合内の項目の全ての並べ方です。\n例えば\n{1, 2, 3}\nの順列は\n{1, 2, 3}\n,\n{1, 3, 2}\n,\n{2, 1, 3}\n,\n{2, 3, 1}\n,\n{3, 1, 2}\n, and\n{3, 2, 1}\nです。ここに集合\n푆\nの順列を生成するための計画を上げます：\n푆\n中の\n129","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":155},{"id":"./test/fixtures/pdf/sicp.pdf:156","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"全て項目\n푥\nに対し再帰的に\n푆 − 푥\nの順列の列を生成し、\n21\n次に\n푥\nをそれぞれの\n先頭に置く。これは\n푆\nの全ての\n푥\nに対し\n푆\nの\n푥\nで始まる順列の列を生成する。\nこれらの全ての\n푥\nに対する列を接続すると\n푆\nの全ての順列が与えられる。\n22\n(\ndefine\n(\npermutations\ns\n)\n(\nif\n(\nnull?\ns\n)\n;\n集合は空か\n?\n(\nlist\nnil\n)\n;\n空集合を持つ列\n(\nflatmap\n(\nlambda\n(\nx\n)\n(\nmap\n(\nlambda\n(\np\n) (\ncons\nx\np\n))\n(\npermutations\n(\nremove\nx\ns\n))))\ns\n)))\nこの戦略がどのように\n푆\nの順列を生成する問題から\n푆\nよりもより少ない要素\nの集合の順列生成の問題へと縮小しているかに注意して下さい。境界条件に関\nしては要素無しの集合を表す空リストまで順に処理を繰り返します。空リスト\nに対して\n(list nil)\nを生成しました。これは\n1\n要素の列であり、要素無しの\n集合を表します。\npermutations\n内で利用される\nremove\n手続は与えられた式か\nら与えられた項目以外の全ての要素を返します。これは簡単なフィルタにて表\nすことができます。\n(\ndefine\n(\nremove\nitem\nsequence\n)\n(\nfilter\n(\nlambda\n(\nx\n) (\nnot\n(=\nx\nitem\n)))\nsequence\n))\nExercise 2.40:\n整数\n푛\nを与えられ、ペア\n(푖, 푗)\nを\n1 ≤ 푗 < 푖 ≤ 푛\nの\n条件で生成する手続\nunique-pairs\nを定義せよ。\nunique-pairs\nを\n用いて上で与えられた\nprime-sum-pairs\nの定義をより簡単にせよ。\nExercise 2.41:\n与えられた整数\n푛\n以下でかつ合計が与えられた整\n数\n푠\nである、全ての異なる正の整数\n푖\n,\n푗\n,\n푘\nの順序有りの\n3\nつ組を\n求める手続を書け。\nExercise 2.42:\n21\n集合\n푆 − 푥\nは\n푆\nの全ての要素から\n푥\nを除いた集合\n22\nScheme\nのコードではセミコロンは\ncomments\n(\nコメント\n)\nを書く場合に利用されます。\nセミコロンから始まり行末までの全てはインタプリタに無視されます。この本ではあま\nり多くのコメントを使用していません。私達はプログラムに対し説明的な名前を付ける\nことでそれ自身がドキュメントであるかのように作るよう努力しています。\n130","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":156},{"id":"./test/fixtures/pdf/sicp.pdf:157","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 2.8:\n8\nクイーンパズルの解の一例\n“8\nクイーンパズル\n”\nは\n8\nつのクイーンをチェス盤の上に、どのク\nイーンも他のクイーンを取ることができないようにするにはどの\nように置くかを尋ねる。\n(\nこれはつまりどの\n2\nつのクイーンも同じ\n列、行、または斜めの線上に有ってはならないということである\n)\n。\n考えられる解の\n1\nつを\nFigure 2.8\nに示す。このパズルを解く\n1\nつの\n方法は盤上に渡って各列にクイーンを置く。\n푘 − 1\n個のクイーンを\n置いたら\n푘\n番目のクイーンは既に盤上に置いてあるどのクイーン\nも取れない場所に置かなければならない。この取り組み方を再帰\n的に形式化できる：盤上の最初の\n푘 − 1\n列内の\n푘 − 1\n個のクイーン\nの可能な置き方全ての列を既に生成したと想定する。これら全て\nの方法に対し拡張した位置の拡張集合を\n푘\n番目の列の各行にクイ\nーンを置くことで生成する。次にこれらをフィルタにかけて\n푘\n番\n目の列のクイーンが他のクイーンを考慮しても安全な位置のみを\n保持する。これは\n푘\n個のクイーンを最初の\n푘\n列内に置く全ての方\n法を生成する。この過程を繰り返すことで\n1\nつの解答のみでなく、\nこのパズルの全ての解答を生成できる。\nこの解法を手続\nqueens\nとして実装した。\n푛\n個のクイーンを\n푛 × 푛\nのチェス盤上に置く問題に対する全ての解の列を返す。\nqueens\nは\n内部手続\nqueen-cols\nを持ち、それは盤の最初の\n푘\n列中にクイー\nンを置く全ての方法の列を返す。\n131","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":157},{"id":"./test/fixtures/pdf/sicp.pdf:158","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nqueens\nboard-size\n)\n(\ndefine\n(\nqueen-cols\nk\n)\n(\nif\n(=\nk\n0)\n(\nlist\nempty-board\n)\n(\nfilter\n(\nlambda\n(\npositions\n) (\nsafe?\nk\npositions\n))\n(\nflatmap\n(\nlambda\n(\nrest-of-queens\n)\n(\nmap\n(\nlambda\n(\nnew-row\n)\n(\nadjoin-position\nnew-row\nk\nrest-of-queens\n))\n(\nenumerate-interval\n1\nboard-size\n)))\n(\nqueen-cols\n(-\nk\n1))))))\n(\nqueen-cols\nboard-size\n))\nこの手続の中で、\nrest-of-queens\nは最初の\n푘 − 1\n列内に\n푘 − 1\n個\nのクイーンを置く方法であり、\nnew-row\nは\nk\n番目の列に対してクイ\nーンを置くように提案された行である。盤上の位置の集合に対す\nる表現を、新しい列の位置を位置の集合に付け足す手続\nadjoin-\nposition\nと位置の空集合を表す\nempty-board\nを含めて実装する\nことでプログラムを完成させよ。あなたは\nk\n番目の列にあるクイ\nーンが他に対して安全であるかどうかを位置の集合に対して決定\nする\nsafe?\nもまた書かなければならない。\n(\n新しいクイーンが安全\nであるかどうかのみをチェックする必要であることに注意するこ\nと\n—\n他のクイーンは既にお互いに安全であることが保証されてい\nる\n)\n。\nLouis Reasoner\nは\nExercise 2.42\nを行うことで酷い時間を過してい\nる。彼の\nqueens\n手続は\nExercise 2.43:\n動いているように見える。\nしかし実行がとても遅い。\n(Louis\nは\n6 × 6\nの場合でさえそれを解く\nのにかかる長い時間を待つことができなかった\n)\n。\nLouis\nが\nEva Lu\nAtor\nに助けを求めた時、彼女は\nLouis\nが\nflatmap\n内の入れ子のマ\nッピングの順を交換してしまったことを指摘した。以下のように\n書いていた。\n(\nflatmap\n(\nlambda\n(\nnew-row\n)\n132","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":158},{"id":"./test/fixtures/pdf/sicp.pdf:159","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nmap\n(\nlambda\n(\nrest-of-queens\n)\n(\nadjoin-position\nnew-row\nk\nrest-of-queens\n))\n(\nqueen-cols\n(-\nk\n1))))\n(\nenumerate-interval\n1\nboard-size\n))\nこの交換がなぜプログラムの実行を遅くするのか説明せよ。\nLouis\nのプログラムが\n8\nクイーンパズルを解くのにどれだけの時間がか\nかるか推察せよ。\nExercise 2.42\nのプログラムが同じパズルを解く\nのに必要な時間が\n푇\nであるとの前提で行え。\n2.2.4\n例\n:\nピクチャー言語\nこの節では絵を描く簡単な言語をお見せします。これがデータ抽象と閉包\nの力を図示し、また高階手続を本質的な方法で利用します。この言語は\nFigure\n2.9\nのようなパターンを試験することを簡単にするように設計されております。\nこの図は要素が移動し、縮小しを繰り返しながら組み立てられています。\n23\nこ\nの言語内では、組み立てられるデータオブジェクトはリスト構造ではなく手続\nとして表現されます。閉包の特性を見たす\ncons\nが簡単に自由に複雑なリスト\n構造を構築できるように、この言語内の命令もまた閉包の特性を満たし、簡単\nに自由に複雑なパターンを構築できます。\nこの本のピクチャー言語\nSection 1.1\nでプログラミングの学習を始めたとき、言語のプリミティブ、そ\nの組み合わせの手段、抽象化の手段に集中することが言語の説明の重要性だと\n強調しました。ここではその枠組みに従います。\nこのピクチャー言語の優雅さの部分は要素の種類が\npainter\n(\nペインタ\n)\nと呼ば\nれるものたった\n1\nつしかないことです。ペインタは指定された平行四辺形の枠\nの中にイメージを移動し、拡大縮小して描きます。例えば\nwave\nと呼ぶペイン\nタがありそれは\nFigure 2.10\nに見られるような粗野な線の絵を描きます。実際\nの絵の下腿はフレームに依存します\n—\nFigure 2.10\nの\n4\nつの絵全ては同じ\nwave\nペインタにより生成されていますが、\n4\nつの異なるフレームを考慮していま\n23\nピクチャー言語は\nPeter Henderson\nが作成した言語を基にしており、この言語は\nM.C. Escher\nの木版画\n“Square Limit”(\nHenderson 1982\n参照\n)\nのようなイメージを構築\nするために作成されました。その木版画は繰り返しサイズが変更されたパターンが組込\nまれており、この節の\nsquare-limit\n手続を用いて描かれた配置と似ております。\n133","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":159},{"id":"./test/fixtures/pdf/sicp.pdf:160","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 2.9:\nピクチャー言語を用いて生成したデザイン\nす。ペインタはこれよりもより複雑にすることが可能です。\nrogers\nと呼ばれ\nるプリミティブなペインタは\nmit\nの創始者である\nWilliam Barton Rogers\nの\n絵を\nFigure 2.11\nに示されるように描きます。\n24\nFigure 2.11\nの\n4\nつのイメージ\n24\nWilliam Barton Rogers (1804-1882)\nは\nmit\nの創始者であり、かつ初代学長です。地\n質学者であり、才能溢れる教師である彼は\nWilliam and Mary College\nと\nUniversity of\nVirginia\nにて教鞭を取りました。\n1859\n年に彼はボストンへ移りそこでより研究に打ち込\nみ、\n“\n技術専門の研究所\n”\nを設立する計画を進めました。またマサチューセッツ州の最初\nのガスメータの州検査官も務めました。\nmit\nが\n1861\n年に創設された時、\nRogers\nは最初の学長に選ばれました。\nRogers\nは\n“useful\nlearning”(\n実用的学習\n)\nの活用を信奉しました。これは当時の大学教育からは異なるもの\nでした。彼に依れば古典の過度の強調が\n“\nより幅広く、高く、より現実的な教育と自然科\n学、及び社会科学の前に立ち塞がっている\n”\nと書いています。同様に彼の教育は職業専門\n学校の狭い教育からも異なるものになろうとしていました。\n実利的であることと科学実務者の間の区別を強制する世界は全く無益だ。\n現代の経験全てがその完全な無益さを示している。\nRogers\nは\nmit\nの学長を健康上の理由で辞任する\n1870\n年まで務めました。\n1878\n年に二\n代目の\nmit\n学長\nJohn Runkle\nは\n1873\n年からの大不況によりもたらされた財政危機のプ\nレッシャーと\nHarvard\nによる\nmit\nの買収の試みに対する抵抗の緊張により辞任しまし\nた。\nRoger\nは学長のオフィスを支えるため\n1881\n年まで戻りました。\n134","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":160},{"id":"./test/fixtures/pdf/sicp.pdf:161","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 2.10:\nwave\nにより生成されたイメージ\nは\nFigure 2.10\nの\nwave\nのイメージと同じ\n4\nつのフレームを考慮して描かれてい\nます。\nイメージを結合するには与えられたペインタから新しいペインタを構築する\nRogers\nは\n1882\n年、\nmit\nの大学院の卒業試験に取り組む最中に倒れ、亡くなられまし\nた。\nRunkle\nが\nRoger\nの最後の言葉を同年に送られた弔事から引用しています。\n“\n本日ここに立ち本校とは何であるかを考えると\n...\n科学の始まりを思い受\nかべます。\n150\n年前に\nStephen Hales\nは灯用のガスを主題にした小論文を\n発表しました。その中で彼は彼の研究が\n128\nグレインの瀝青炭\n– ” “\n瀝青\n炭\n”\nこれが地上での彼の最後の言葉でした。ここで彼は体を前に曲げ、彼\nの前のテーブルの上にある端書を確認するようでいて、そしてゆっくりと\n直立した体制を取り戻し、両腕を上げ、そして彼の地上の労働と業績の場\n面から\n“\n死の明日\n”\nへと形を変えたのです。そこでは人生の謎は解決され、\n肉体から解放された魂は新しく、未だ測りしれない無限の未来の謎を熟考\nすることに終りの無い充足を見つけるのです。\nFrancis A. Walker(\nmit\nの三代目の学長\n)\nの言葉では\n彼自身が負うた彼の人生全ては最も誠実で雄々しく、そして彼は騎士が心\nから望んだかのごとく、仕事中に、その役職のまま、公務の行いの最中に\n亡くなった。\n135","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":161},{"id":"./test/fixtures/pdf/sicp.pdf:162","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 2.11:\nWilliam Barton Rogers\nのイメージ\n種々の命令を使用します。例えば\nbeside\n命令は\n2\nつのペインタを取り新しい\n最初のペインタのイメージをフレームの左半分に、\n2\nつ目のペインタのイメー\nジをフレームの右半分に描く複合ペインタを生成します。同様に\nbelow\nは\n2\nつ\nのペインタを取り、\n1\nつ目のペインタのイメージを\n2\nつ目のペインタのイメー\nジの下に描きます。いくつかの命令は単一のペインタを変換し新しいペインタ\nを生成します。例えば\nflip-vert\nはペインタを取りそのイメージを上下逆さに\n描くペインタを生成し、\nflip-horiz\nは元のペインタのイメージを左右逆に描\nくペインタを生成します。\nFigure 2.12\nは\nwave4\nを呼んだペインタの描画を見せており、これは\nwave\nで\n始め\n2\n段階を経て構築されています。\n(\ndefine\nwave2\n(\nbeside\nwave\n(\nflip-vert\nwave\n)))\n(\ndefine\nwave4\n(\nbelow\nwave2\nwave2\n))\n複雑なイメージをこの様式で構築する場合はペインタが言語の接続手段の下で\n閉じているという事実を利用しています。\n2\nつのペインタの\nbeside\nや\nbelow\nはそれ自身がペインタです。従ってそれをより複雑なペインタを作るための要\n素として使用できます。\ncons\nを用いてリスト構造を構築するのと同様に、結合\n手段の下のデータの閉包はほんのわずかな命令を用いて複雑な構造を作成する\n能力にとって重大です。\n136","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":162},{"id":"./test/fixtures/pdf/sicp.pdf:163","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 2.12:\nFigure 2.10\nの\nwave\nペインタから始めて複雑な図を作\n成する\nペインタを結合できれば直ぐに、ペインタを接続する典型的なパターンを\n抽象化できるようになりたいと願うでしょう。ペインタ操作を\nScheme\nの手続\nとして実装することにします。それは私達がピクチャー言語内のメカニズム\nとして専用の抽象化を必要としないことを意味します。接続の手段が普通の\nScheme\nの手続ですから、手続の範囲で行えるペインタの操作を用いて、何で\nもできる能力が自動的に得られます。例えば\nwave4\n内のパターンを抽象化でき\nます。\n(\ndefine\n(\nflipped-pairs\npainter\n)\n(\nlet\n((\npainter2\n(\nbeside\npainter\n(\nflip-vert\npainter\n))))\n(\nbelow\npainter2\npainter2\n)))\nそして\nwave4\nをこのパターンのインスタンスとして定義します。\n(\ndefine\nwave4\n(\nflipped-pairs\nwave\n))\nまた再帰命令を定義することも可能です。以下はペインタを分割し、\nFigure\n2.13\nに示すように右へ向けて枝分かれします。\n(\ndefine\n(\nright-split\npainter\nn\n)\n(\nif\n(=\nn\n0)\npainter\n(\nlet\n((\nsmaller\n(\nright-split\npainter\n(-\nn\n1))))\n(\nbeside\npainter\n(\nbelow\nsmaller\nsmaller\n)))))\n右に向けてと同じように上方向にも枝分かれすることでバランスの取れたパ\nターンを生成することも可能です。\n(\n課題\nExercise 2.44\nと図\nFigure 2.13\nと\nFigure\n2.14\nを参照して下さい\n)\n。\n137","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":163},{"id":"./test/fixtures/pdf/sicp.pdf:164","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"right-split\nidentity\nright-split\nright-split \nn\nright-split\ncorner-split\nup-\nsplit\nn\n--1\nup-\nsplit\nright-split\nidentity\nn\n--1\nn\n--1\nn\n--1\nn\n--1\ncorner-split \nn\nn\n--1\nn\n--1\nFigure 2.13:\nright-split\nと\ncorner-split\nの再帰計画\n(\ndefine\n(\ncorner-split\npainter\nn\n)\n(\nif\n(=\nn\n0)\npainter\n(\nlet\n((\nup\n(\nup-split\npainter\n(-\nn\n1)))\n(\nright\n(\nright-split\npainter\n(-\nn\n1))))\n(\nlet\n((\ntop-left\n(\nbeside\nup\nup\n))\n(\nbottom-right\n(\nbelow\nright\nright\n))\n(\ncorner\n(\ncorner-split\npainter\n(-\nn\n1))))\n(\nbeside\n(\nbelow\npainter\ntop-left\n)\n(\nbelow\nbottom-right\ncorner\n))))))\ncorner-split\nの\n4\nつのコピーを置くことで\nsquare-limit\nと呼ばれるパター\nンを獲得することができ、\nwave\nと\nrogers\nに対する適用が\nFigure 2.9\nに示され\nます。\n(\ndefine\n(\nsquare-limit\npainter\nn\n)\n(\nlet\n((\nquarter\n(\ncorner-split\npainter\nn\n)))\n(\nlet\n((\nhalf\n(\nbeside\n(\nflip-horiz\nquarter\n)\nquarter\n)))\n138","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":164},{"id":"./test/fixtures/pdf/sicp.pdf:165","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbelow\n(\nflip-vert\nhalf\n)\nhalf\n))))\nExercise 2.44:\ncorner-split\nにて使用された手続\nup-split\nを定\n義せよ。\nright-split\nに似ているが、\nbelow\nと\nbeside\nの役割を入\nれ替える。\n高階命令\nペインタ命令のパターンを抽象化するのに加えて、より高いレベルのペイ\nンタ命令接続の抽象化パターンについて取り組むことができます。それはペイ\nンタ命令を操作を行うための要素\n—\nペインタ命令を引数として取り新しいペ\nインタ命令を作成する手続と見做し、そしてこれらの要素のための組み合わせ\nの手段の記述が可能だということです。\n例として、\nflipped-pairs\nと\nsquare-limit\nはペインタのイメージを四角\nのパターン内にて\n4\nつのコピーをそれぞれが準備します。それらはどのような\n位置と向きに置くかということのみにおいて異なります。このペインタ接続の\nパターンを抽象化する\n1\nつの方法は以下のプロシジャを用いて、\n4\nつの\n1\n引数\nペインタ命令を取り与えられたペインタをそれら\n4\nつの命令で変換する命令を\n生成し、結果を四角の中に配置します。\ntl\n,\ntr\n,\nbl\n, and\nbr\nは左上、右上、左下、\n右下のコピーに対応する変換です。\n(\ndefine\n(\nsquare-of-four\ntl\ntr\nbl\nbr\n)\n(\nlambda\n(\npainter\n)\n(\nlet\n((\ntop\n(\nbeside\n(\ntl\npainter\n) (\ntr\npainter\n)))\n(\nbottom\n(\nbeside\n(\nbl\npainter\n) (\nbr\npainter\n))))\n(\nbelow\nbottom\ntop\n))))\nすると\nflipped-pairs\nは\nsquare-of-four\nを以下のように用いて定義可能で\nす。\n25\n(\ndefine\n(\nflipped-pairs\npainter\n)\n(\nlet\n((\ncombine4\n(\nsquare-of-four\nidentity\nflip-vert\n25\n同等に、こうも書けます。\n(\ndefine\nflipped-pairs\n(\nsquare-of-four\nidentity\nflip-vert\nidentity\nflip-vert\n))\n139","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":165},{"id":"./test/fixtures/pdf/sicp.pdf:166","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(right-split wave 4)\n(right-split rogers 4)\n(corner-split wave 4)\n(corner-split rogers 4)\nFigure 2.14:\nペインタ\nwave\nと\nrogers\nに適用された再帰命\n令\nright-split\nと\ncorner-split\n。\n4\nつの図\ncorner-split\nを\n組み合わせることで\nFigure 2.9\nで示された対照的な\nsquare-\nlimit\nのデザインを生成する。\n140","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":166},{"id":"./test/fixtures/pdf/sicp.pdf:167","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"identity\nflip-vert\n)))\n(\ncombine4\npainter\n)))\nそして\nsquare-limit\nは以下の様に表現可能です。\n26\n(\ndefine\n(\nsquare-limit\npainter\nn\n)\n(\nlet\n((\ncombine4\n(\nsquare-of-four\nflip-horiz\nidentity\nrotate180\nflip-vert\n)))\n(\ncombine4\n(\ncorner-split\npainter\nn\n))))\nExercise 2.45:\nright-split\nと\nup-split\nは一般的な分割命令のイ\nンスタンスだと言うことができる。手続\nsplit\nを以下の式を評価\nする場合に、\n(\ndefine\nright-split\n(\nsplit\nbeside\nbelow\n))\n(\ndefine\nup-split\n(\nsplit\nbelow\nbeside\n))\n既に定義住みのものと全く同じ振舞を行う手続\nright-split\nと\nup-split\nを生成するよう定義せよ。\nフレーム\nペインタとどのように実装しその接続手段を示す前に、始めにフレームに\nついて考えなければなりません。フレームは\n3\nつのベクトル\n—\n始点ベクトルと\n2\nつの辺ベクトルで説明できます。始点ベクトルは平面上においてある絶対的\nな始点からフレームの始点までのオフセットを指定します。そして辺ベクトル\nは始点から角までのオフセットを指定します。もし\n2\nつの辺が垂直であればフ\nレームは長方形になります。それ以外ではフレームはより一般的な平行四辺形\nになります。\nFigure 2.15\nはフレームとその対応するベクトルを示します。データ抽象化\nに従い、まだフレームがどのように表現されるかについては、\n3\nつのベクトル\nを取りフレームを生成するコンストラクタ\nmake-frame\nと関連する\n3\nつのセレ\nクタ\norigin-frame\n,\nedge1-frame\n,\nedge2-frame\nが存在すること以外を特定す\nる必要がありません。\n(\nExercise 2.47\nを参照して下さい\n)\n。\n26\nRotate180\nはペインタを\n180\n度回転します\n(\nExercise 2.50\n参照\n)\n。\nrotate180\nの代わり\nに\n(compose flip-vert flip-horiz)\nと言うこともできます。\ncompose\n手続は\nExercise\n1.42\nから使用しました。\n141","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":167},{"id":"./test/fixtures/pdf/sicp.pdf:168","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"frame\nedge1\nvector\nframe\nedge2\nvector\nframe\norigin\nvector\n(0, 0) point on \ndisplay screen\nFigure 2.15:\n3\nつのベクトル\n—\n始点と\n2\nつの辺により記述\nされたフレーム\n私達は単位正方形\n(0 ≤ 푥, 푦 ≤ 1)\n内の座標をイメージを指定するのに用いるこ\nとにします。各フレームは、フレームに適合するようにイメージの移動と拡大\n縮小をするのに使われる\nframe coordinate map\n(\nフレーム座標マップ\n)\nに関連付\nけられます。マップは単位正方形をベクトル\n푣 = (푥, 푦)\nを次のベクトルの和に\nマッピングすることで変換します。\n푂푟푖푔푖푛(퐹 푟푎푚푒) + 푥 ⋅ 퐸푑푔푒\n1\n(퐹 푟푎푚푒) + 푦 ⋅ 퐸푑푔푒\n2\n(퐹 푟푎푚푒).\n例えば、\n(0, 0)\nはフレームの始点に、\n(1, 1)\nは対角線上に始点の反対の頂点へ、\nそして\n(0.5, 0.5)\nはフレームの中心点にマッピングされます。フレーム座標マ\nップは以下の手続により作成できます。\n27\n(\ndefine\n(\nframe-coord-map\nframe\n)\n(\nlambda\n(\nv\n)\n(\nadd-vect\n27\nframe-coord-map\nはこの先の\nExercise 2.46\nにて説明されるベクトル操作を用います。\nここでは何らかのベクトルの表現を用いて実装済みと仮定します。データ抽象化のおか\nげでこのベクトルの表現がどんなものかは、ベクトル操作が正しく振る舞われる限りに\nおいて問題にはなりません。\n142","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":168},{"id":"./test/fixtures/pdf/sicp.pdf:169","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\norigin-frame\nframe\n)\n(\nadd-vect\n(\nscale-vect\n(\nxcor-vect\nv\n)\n(\nedge1-frame\nframe\n))\n(\nscale-vect\n(\nycor-vect\nv\n)\n(\nedge2-frame\nframe\n))))))\nframe-coord-map\nをフレームに適用すると、ベクトルを取りベクトルを返す手\n続を返すことに注意して下さい。もし引数ベクトルが単位正方形の中なら、結\n果のベクトルはフレームの範囲内になります。例として、\n((\nframe-coord-map\na-frame\n) (\nmake-vect\n0 0))\nは以下のベクトルと同じものを返します。\n(\norigin-frame\na-frame\n)\nExercise 2.46:\n始点からある点へと走る\n2\n次元ベクトル\n푣\nは\n푥\n-\n座\n標と\n푦\n-\n座標から成るペアにより表現できる。ベクトルに対するデ\nータ抽象をコンストラクタ\nmake-vect\nと関連するセレクタ\nxcor-\nvect\nと\nycor-vect\nを与えることにより実装せよ。セレクタとコン\nストラクタを用いてベクトルの足し算、引き算、スカラによる乗\n算を求める操作を実行する手続\nadd-vect\n,\nsub-vect\n,\nscale-vect\nを実装せよ。\n(푥\n1\n, 푦\n1\n) + (푥\n2\n, 푦\n2\n) = (푥\n1\n+ 푥\n2\n, 푦\n1\n+ 푦\n2\n),\n(푥\n1\n, 푦\n1\n) − (푥\n2\n, 푦\n2\n) = (푥\n1\n− 푥\n2\n, 푦\n1\n− 푦\n2\n),\n푠 ⋅ (푥, 푦) = (푠푥, 푠푦).\nExercise 2.47:\nここに\n2\nつの有り得そうなフレームのコンストラク\nタがある\n(\ndefine\n(\nmake-frame\norigin\nedge1\nedge2\n)\n(\nlist\norigin\nedge1\nedge2\n))\n(\ndefine\n(\nmake-frame\norigin\nedge1\nedge2\n)\n(\ncons\norigin\n(\ncons\nedge1\nedge2\n)))\n各コンストラクタに適切な、フレームに対応する実装を生成する\nセレクタを提供せよ。\n143","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":169},{"id":"./test/fixtures/pdf/sicp.pdf:170","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ペインタ\nペインタはフレームを引数として与え、特定のイメージをフレームにはま\nるように移動、拡大縮小して描く手続として表現される。すなわちもし\np\nがペ\nインタで\nf\nがフレームである場合、\nf\nを引数として\np\nを呼び出すことで\nf\nの中\nに\np\nのイメージを生成する。\nプリミティブなペインタがどのように実装されているかの詳細は特定のグ\nラフィックシステムの特質と描画されるイメージのタイプに依存します。例え\nばスクリーン上の\n2\nつの指定された点の間に線を引く手続\ndraw-line\nがあると\n想定します。すると線分のリストから線を引くためのペインタ、例えば\nFigure\n2.10\nの\nwave\nペインタのようなものを以下のように作ることができます。\n28\n(\ndefine\n(\nsegments->painter\nsegment-list\n)\n(\nlambda\n(\nframe\n)\n(\nfor-each\n(\nlambda\n(\nsegment\n)\n(\ndraw-line\n((\nframe-coord-map\nframe\n)\n(\nstart-segment\nsegment\n))\n((\nframe-coord-map\nframe\n)\n(\nend-segment\nsegment\n))))\nsegment-list\n)))\n線分は単位正方形に対しての座標を用いて与えられます。リスト中の各線分に\n対してペインタは線分の終端をフレーム座標マップを用いて変換し、変換後の\n点の間に線を引きます。\n手続としてペインタを表現することは強力な抽象化バリアをピクチャーラ\nンゲージの中に確立します。私達は全ての種類のプリミティブなペインタを\n種々のグラフィック機能の基盤の上に作り、混ぜることができます。それらの\n実装の詳細は問題ではありません。フレームを引数として取りフレームに適切\nなサイズにスケールして何かを描く任意の手続がペインタの役を演じることが\nできます。\n29\n28\nSegments->painter\nは線分の表現に下記の\nExercise 2.48\nで説明されたものを使って\nいます。また\nExercise 2.23\nで説明された\nfor-each\nを使っています。\n29\n例えば\nFigure 2.11\nの\nrogers\nペインタはグレーレベルのイメージから構築されてい\nます。与えられたフレームの中の各点に対し\nrogers\nペインタはイメージ中のマッピング\nされる位置をフレーム座標マップの下に決定し、適切に影を付けます。異なるタイプの\nペインタを許可することで、\nSection 2.1.3\nで議論された分数表現は適切な条件を満たせ\n144","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":170},{"id":"./test/fixtures/pdf/sicp.pdf:171","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.48:\n平面上で方向を持つ線分はベクトルのペア\n—\n原点\nから線分の始点へと向かうベクトルと原点から線分の終点へと向\nかうベクトルとして表現可能だ。\nExercise 2.46\nのベクトル表現を\n用いて、コンストラクタ\nmake-segment\nとセレクタ\nstart-segment\nと\nend-segment\nを持つ線分表現を定義せよ。\nExercise 2.49:\nsegments->painter\nを用いて以下のプリミティブ\nなペインタを定義せよ。\na\n指定したフレームの外枠を描くペインタ\nb\nフレームの反対の角を繋いで\n“X”\nを描くペインタ\nc\nフレームの辺の中点を結んでダイヤモンドの形を描くペ\nインタ\nd\nwave\nペインタ\n変形とペインタの組み合わせ\nペインタに対する操作\n(\n例えば\nflip-vert\nや\nbeside\n)\nはフレーム引数に由\n来するフレームに対して元のペインタを実行するペインタを作成することで働\nいています。従って例えば\nflip-vert\nは引っくり返す場合にもそれがどのよう\nに描かれるのかは知る必要がありません\n—\nただフレームをどのように引っく\nり返すのか知る必要があるのみです。逆転したペインタはただ元のペインタを\n用いますが、フレームは逆転されているのです。\nペインタ操作は\ntransform-painter\n手続を基にしており、それはペインタ\nとどのようにフレームを変換するかの情報を引数に取り、新しいペインタを生\n成します。変換されたペインタはフレーム上にて呼ばれた時に、フレームを\n変換して基のペインタを変換済みのフレーム上で呼び出します。\ntransform-\npainter\nに対する引数は新しいフレームの角を指定する\n(\nベクトルとして表現\nされる\n)\n複数の点です。フレームにマッピングされる時、最初の点は新しいフ\nレームの始点を指定し、他の\n2\nつのは辺ベクトルの終点を指定します。従って、\n単位正方形内の引数は元のフレームの中に含まれるフレームを指定します。\nば全く任意でかまわないという抽象データの考えからより大きな利点を得ています。こ\nこではペインタは指定されたフレーム内に何かを描くのであれば全くどのように実装さ\nれても構わないという事実を用いています。\nSection 2.1.3\nはまたペアがどのように手続\nとして実装され得るかということも示しました。ペインタはデータに対する手続表現の\n二つ目の例です。\n145","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":171},{"id":"./test/fixtures/pdf/sicp.pdf:172","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ntransform-painter\npainter\norigin\ncorner1\ncorner2\n)\n(\nlambda\n(\nframe\n)\n(\nlet\n((\nm\n(\nframe-coord-map\nframe\n)))\n(\nlet\n((\nnew-origin\n(\nm\norigin\n)))\n(\npainter\n(\nmake-frame\nnew-origin\n(\nsub-vect\n(\nm\ncorner1\n)\nnew-origin\n)\n(\nsub-vect\n(\nm\ncorner2\n)\nnew-origin\n)))))))\n次はどのようにペインタのイメージを縦方向に逆向きにするかです。\n(\ndefine\n(\nflip-vert\npainter\n)\n(\ntransform-painter\npainter\n(\nmake-vect\n0.0 1.0)\n; new\norigin\n(\nmake-vect\n1.0 1.0)\n; new end of\nedge1\n(\nmake-vect\n0.0 0.0)))\n; new end of\nedge2\ntransform-painter\nを用いることで簡単に新しい変換を定義することができま\nす。右上\n4\n分の\n1\nのフレームは次のようにして与えられます。\n(\ndefine\n(\nshrink-to-upper-right\npainter\n)\n(\ntransform-painter\npainter\n(\nmake-vect\n0.5 0.5)\n(\nmake-vect\n1.0 0.5) (\nmake-vect\n0.5 1.0)))\n他の変換はイメージを時計回りの逆に\n90\n度回転したり、\n30\n(\ndefine\n(\nrotate90\npainter\n)\n(\ntransform-painter\npainter\n(\nmake-vect\n1.0 0.0)\n(\nmake-vect\n1.0 1.0)\n(\nmake-vect\n0.0 0.0)))\nイメージをフレームの中心に向けて潰したりします。\n31\n(\ndefine\n(\nsquash-inwards\npainter\n)\n30\nrotate90\nは四角形のフレームに対してのみの純粋な回転です。イメージもまた拡大\n縮小して回転したフレームに合わせられるためです。\n31\nFigure 2.10\nと\nFigure 2.11\n内のひし形のイメージは\nsquash-inwards\nを\nwave\nと\nrogers\nに適用することで作成されました。\n146","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":172},{"id":"./test/fixtures/pdf/sicp.pdf:173","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ntransform-painter\npainter\n(\nmake-vect\n0.0 0.0)\n(\nmake-vect\n0.65 0.35)\n(\nmake-vect\n0.35 0.65)))\nフレーム変換は\n2\nつ以上のペインタを接続する手段を定義するための鍵でもあ\nります。例えば\nbeside\n手続は\n2\nつのペインタを取りそれらを引数のフレーム\nの左半分と右半分にそれぞれ描画するように変換する新しい複合ペインタを生\n成します。複合ペインタがフレームを与えられ時、\n1\nつ目の変換済みペインタ\nを呼びフレームの左半分に描き、次に二つ目の変換済みペインタを呼びフレー\nムの右半分を描きます。\n(\ndefine\n(\nbeside\npainter1\npainter2\n)\n(\nlet\n((\nsplit-point\n(\nmake-vect\n0.5 0.0)))\n(\nlet\n((\npaint-left\n(\ntransform-painter\npainter1\n(\nmake-vect\n0.0 0.0)\nsplit-point\n(\nmake-vect\n0.0 1.0)))\n(\npaint-right\n(\ntransform-painter\npainter2\nsplit-point\n(\nmake-vect\n1.0 0.0)\n(\nmake-vect\n0.5 1.0))))\n(\nlambda\n(\nframe\n)\n(\npaint-left\nframe\n)\n(\npaint-right\nframe\n)))))\nペインタのデータ抽象化と、特にペインタの手続としての表現がどのように\nbeside\nの実装を簡単にしているのか注目して下さい。\nbeside\n手続はコンポー\nネントのペイントの詳細について各ペインタが指定されたフレームに何かを描\nくこと以外は一切知る必要がありません。\nExercise 2.50:\nペインタを水平方向に引っくり返す変換\nflip-\nhoriz\nを定義せよ。またペインタを時計と逆回りに\n180\n度と\n270\n度回す変換を定義せよ。\n147","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":173},{"id":"./test/fixtures/pdf/sicp.pdf:174","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.51:\nペインタに対する\nbelow\n命令を定義せよ。\nbelow\nは\n2\nつのペインタを引数に取る。結果のペインタはフレームを与え\nられ、\n1\nつ目のペインタにてフレームの底部を描き、\n2\nつ目のペイ\nンタにて上部を描く。\nbelow\nを\n2\nつの異なる方法で定義せよ。\n1\nつ\nは上で与えた\nbeside\nと同様な方法で、\n2\nつ目は\nbeside\nと適切な\n(\nExercise 2.50\nの\n)\n回転命令を利用せよ。\n堅牢な設計のための言語のレベル\nピクチャー言語は私達が紹介した手続とデータにようる抽象化についての\n重要なアイデアのいくつかを訓練しました。基本的なデータ抽象化であるペイ\nンタは手続表現を用いて実装され言語に異なる基礎的な描画能力を統一した方\n法で扱うことを可能にしました。接続手段は閉包の性質を満たし簡単に複雑な\n設計を組み上げることを可能にしました。最後に、抽象化手続に対する全ての\nツールはペインタに対する接続手段の抽象化にとって有効でした。\n私達はまた言語とプログラム設計に関する素晴しい考えを垣間見ることが\nできました。これは\nstratified design\n(\n階層化設計\n)\nの方法で、複雑なシステムは\n一連の言語を用いて記述される一連のレベルとして構造化されるべきであると\nいう概念です。各レベルはパーツをパーツを接続して構築され、それらは次の\nレベルではプリミティブとして参照されます。そして各レベルで構築されたパ\nーツは次のレベルにてプリミティブとして使用されます。階層化された設計の\n各レベルで使用される言語はプリミティブ、接続手段、そしてそのレベルの詳\n細さに適切な抽象化手段を持っています。\n階層化された設計は複雑なシステムの設計において普及しています。例え\nば計算機設計では抵抗とトランジスタは接続され\n(\nそしてアナログ回路言語を\n用いて記述され\n)AND\nゲートや\nOR\nゲートのようなパーツを生じ、それらがデ\nジタル回路の言語のプリミティブを形成します。\n32\nこのようなパーツはプロセ\nッサ、バス構造、メモリシステムを構築するために接続され、それらはコンピ\nュータを形成するために接続され、コンピュータアーキテクチャに相応しい言\n語を用います。コンピュータは分散システムを形成するために接続され、ネッ\nトワーク相互接続その他を記述するに適切な言語を用います。\n階層化の簡単な例として、ピクチャー言語はプリミティブな要素\n(\nプリミテ\nィブペインタ\n)\nを用い、それらは点と線を指定し\nsegments->painter\nのための\n線分のリストを提供したり、\nrogers\nのようなペインタに対するシェーディン\nグの詳細を提供したりする言語を用いて作成されました。私達のピクチャー言\n32\nSection 3.3.4\nがそのような言語について記述します。\n148","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":174},{"id":"./test/fixtures/pdf/sicp.pdf:175","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"語の説明の大部分がこれらのプリミティブを接続し\nbeside\nや\nbelow\nのような\n幾何学的なコンバイナ\n(\n結合器\n)\nに充てられました。私達はまたより高階なレベ\nルにおいて\nbeside\nと\nbelow\nをプリミティブとして見做し\nsquare-of-four\nの\nような命令を持つ言語において幾何学的結合器を接続する共通のパターンを獲\n得することに努めました。\n階層化設計はプログラムを\nrobust\n(\n堅牢\n)\nにすることを手助けします。それ\nはつまりプログラムにおける仕様上の小さな変更が相応した小さな変更を要求\nすることを意味します。例えば\nFigure 2.9\nで示された\nwave\nのイメージを変更し\nたいとします。\nwave\n要素の詳細な表現を変更する最も低レベルで行うことも\n可能ですが、中間のレベルにおいて\ncorner-split\nが\nwave\nをどのように複製す\nるかについて行うことも可能ですし、最高レベルにおいて\nsquare-limit\nがど\nのように角の\n4\nつのコピーを配置するかについて変更することも可能です。一\n般的に階層設計の各レベルは異なる語彙をシステムの特徴を表すのに提供しま\nす。そして異なる種類の変更方法をも提供します。\nExercise 2.52:\nFigure 2.9\nの\nwave\nの\nsquare-limit\nに、上で説明され\nた各レベルで働くことで変更を加えよ。より詳細には、\na\nExercise 2.49\nのプリミティブな\nwave\nペインタにいくつか線\n分を加えよ。\n(\n例えば笑顔を追加せよ\n)\nb\ncorner-split\nにより構築されるパターンを変更せよ\n(\n例え\nば\nup-split\nや\nright-split\nのイメージを\n2\nつでなく\n1\nつに\nせよ\n)\nc\nsquare-of-four\nを用いる\nsquare-limit\nのバージョンを変\n更し角を異なるパターンで組み立てるようにせよ。\n(\n例えば\n正方形の各角にて\nMr. Rogers\nをそれぞれ外に向けよ\n)\n2.3\n記号データ\n私達がここまで使用した全ての複合データオブジェクトは最終的には数値\nから構築されていました。この節では任意のシンボル\n(\n記号\n)\nをデータとして用\nいる能力を紹介することで、言語の表現力を拡張します。\n149","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":175},{"id":"./test/fixtures/pdf/sicp.pdf:176","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2.3.1\nクォート\nもし記号を用いて複合データを形成できれば以下のようなリストを持つこ\nとができます。\n(\na\nb\nc\nd\n)\n(23 45 17)\n((\nNorah\n12) (\nMolly\n9) (\nAnna\n7) (\nLauren\n6) (\nCharlotte\n4))\n記号を含むリストは言語の式と全く同じように見えます。\n(* (+ 23 45)\n(+\nx\n9))\n(\ndefine\n(\nfact\nn\n)\n(\nif\n(=\nn\n1) 1 (*\nn\n(\nfact\n(-\nn\n1)))))\n記号を扱う目的のためには言語に新しい要素を必要とします。データオブジェ\nクトを\nquote\n(\n引用\n)\nする能力です。例えばリスト\n(a b)\nを構築したいとします。\n私達はこれを\n(list a b)\nを用いては達成できません。なぜならこの式は\na\nと\nb\nの値からリストを構築する式であり、記号それ自体ではないからです。この\n問題は自然言語の文脈では良く知られていて、単語と文が意味上の要素として\n見做されているか、または文字列\n(\n文法上の要素\n)\nとして見做されているかの場\n合が有り得ます。自然言語での共通な慣例は単語や文が文字通りに扱われるこ\nとを示すためにクォーテーションマークを用いることです。例えば\n“John”\nの\n最初の文字は明らかに\n“J”\nです。もし私達が誰かに\n“\n貴方の名前を大きな声で\n言って\n”\nと伝えれば、その人の名前を聞くことを期待します。しかしもし誰か\nに\n“ ‘\n貴方の名前\n’\nと大きな声で言って\n”\nと伝えれば\n“\n貴方の名前\n”\nという語を聞\nくことを期待するでしょう。私達がクォーテーションマークを入れ子にするこ\nとを第三者が何を言うだろうかを説明するために強制されていることに注意し\nて下さい。\n33\n33\n言語の中でクォーテーションを許可することが簡単な語で言語について推論する能\n力を与えると共に大きな破壊をもたらしています。それが等値な物は等値な物と置換で\nきるという概念を破壊するためです。例えば\n1\n足す\n2\nは\n3\nですが\n“3”\nという語は\n“1\n足す\n2”\nという語句ではありません。クォーテーションは他の表現を操作する表現を構築する\n手段を提供するため強力です。\n(\nChapter 4\nでインタプリタを書く時に学びます\n)\n。しかし\n言語の中で、同じ言語の他の文について話す文を許すことは\n“\n等値な物は等値な物と交換\nできる\n”\nが何を意味すべきかという任意の一貫性を保守することをとても難しくします。\n例えばもし私達が宵の明星が明けの明星と同じであることを知っている場合、\n“\n宵の明星\nは金星\n”\nという文から\n“\n明けの明星は金星\n”\nであることを推論できます。しかし\n“John\nは\n150","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":176},{"id":"./test/fixtures/pdf/sicp.pdf:177","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"データオブジェクトとして扱われるべきであり、式として評価されるべき\nではないリストとシンボルを区別するために、これと同じ習慣に従うことがで\nきます。しかしクォートする形式は自然言語のそれとは異なり、クォーテーシ\nョンマーク\n(\n伝統的にシングルクォートの記号\n'\n)\nはクォートされるべきオブジ\nェクトの先頭にのみ置かれます。\nScheme\nの文法でこの様に逃れられるのはオ\nブジェクトを区切るのに空白と括弧を信頼することができるためです。従って\nシングルクォート文字の意味は次のオブジェクトをクォートすることになりま\nす。\n34\nこれでシンボルとその値を区別することが可能です。\n(\ndefine\na\n1)\n(\ndefine\nb\n2)\n(\nlist\na\nb\n)\n(1 2)\n(\nlist\n'a\n'b\n)\n(a b)\n(\nlist\n'a\nb\n)\n(a 2)\nクォーテーションはまた慣習的なリストに対する印字された表現を用いて複合\nオブジェクトの入力も可能にします。\n35\n宵の明星が金星であることを知っている\n”\nを与えられても\n“John\nは明けの明星が金星で\nあることを知っている\n”\nとは推論することはできません。\n34\nシングルクォートは表示される文字列を囲むのに使用してきたダブルクォートとは\n異なります。シングルクォートがリストやシンボルを示すのに対し、ダブルクォートは\n文字列と共にのみ利用されます。この本では文字列の使用方法は表示されるための項目\nとしてのみです。\n35\n厳密には私達のクォーテーションマークの使用方法は言語における全ての複合式は\n括弧で区切られリストのように見えるという全体のルールを破ります。この整合性に対\nしては特別な形式\nquote\nを紹介することで回復することが可能です。これはクォーテー\nションマークと同じ目的を演じます。従って\n'a\nの代わりに\n(quote a)\nと入力できますし、\n'(a b c)\nの代わりに\n(quote (a b c))\nと入力できます。これはインタプリタは正確に\nはどのように働くかということです。クォーテーションマークは単一文字による省略形\nに過ぎず次の完全な式を\nquote\nでラッピングすることで\n(quote\n⟨\nexpression\n⟩\n)\nを形成\nします。これは重要なことです。なぜならインタプリタに読まれる任意の式がデータオ\nブジェクトとして扱うことができるという原則を保持するからです。例えば\n(car '(a b\nc))\nという式は\n(car (quote (a b c)))\nと同じで、\n(list 'car (list 'quote '(a b\nc)))\nを評価することで構築できます。\n151","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":177},{"id":"./test/fixtures/pdf/sicp.pdf:178","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncar\n'\n(\na\nb\nc\n))\na\n(\ncdr\n'\n(\na\nb\nc\n))\n(b c)\nこれを守ることで、空リストを\n'()\nを評価して得ることができます。従って、変\n数\nnil\nの使用を止められます。\n記号を操作するのに使われるもう\n1\nつ追加のプリミティブとして\neq?\nがあ\nります。これは\n2\nつのシンボルを引数として取りそれらが同じであるかテスト\nします。\n36\neq?\nを用いることで\nmemq\nと呼ばれる便利な手続を実装できます。こ\nれは\n2\nつの引数、シンボルとリストを取ります。もしシンボルがリストに含ま\nれていない場合\n(\nつまりリスト中のどの項目にも\neq?\nでない場合\n)\nmemq\nは\nfalse\nを返します。そうでなければリスト中のそのシンボルが最初に出現する場所か\nらのサブリストを返します。\n(\ndefine\n(\nmemq\nitem\nx\n)\n(\ncond\n((\nnull?\nx\n)\nfalse\n)\n((\neq?\nitem\n(\ncar\nx\n))\nx\n)\n(\nelse\n(\nmemq\nitem\n(\ncdr\nx\n)))))\n例えば、次の式の値は\n(\nmemq\n'apple\n'\n(\npear\nbanana\nprune\n))\nfalse\nになります。そして次の式の値は\n(\nmemq\n'apple\n'\n(\nx\n(\napple\nsauce\n)\ny\napple\npear\n))\n(apple pear)\nです。\nExercise 2.53:\n以下の式のそれぞれを評価した応答としてインタプ\nリタは何を表示するか\n?\n(\nlist\n'a\n'b\n'c\n)\n(\nlist\n(\nlist\n'george\n))\n(\ncdr\n'\n((\nx1\nx2\n) (\ny1\ny2\n)))\n(\ncadr\n'\n((\nx1\nx2\n) (\ny1\ny2\n)))\n36\n2\nつのシンボルが同じ文字で同じ順に構成されている場合にそれらが\n“\n同じ\n”\nである\nと考えることができます。そのような定義はまだ私達が解決するには準備の足りない深\nい問題を回避しています。プログラミング言語における\n“\n同一性\n”\nの意味です。私達はこ\nの問題に\nChapter 3\n(\nSection 3.1.3\n)\nにて戻ります。\n152","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":178},{"id":"./test/fixtures/pdf/sicp.pdf:179","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\npair?\n(\ncar\n'\n(\na\nshort\nlist\n)))\n(\nmemq\n'red\n'\n((\nred\nshoes\n) (\nblue\nsocks\n)))\n(\nmemq\n'red\n'\n(\nred\nshoes\nblue\nsocks\n))\nExercise 2.54:\n2\nつのリストはそれぞれが同じ要素を同じ順で持っ\nている場合に\nequal?\nと言える。例えば\n(\nequal?\n'\n(\nthis\nis\na\nlist\n)\n'\n(\nthis\nis\na\nlist\n))\nは真であるが\n(\nequal?\n'\n(\nthis\nis\na\nlist\n)\n'\n(\nthis\n(\nis\na\n)\nlist\n))\nは偽である。具体的には基本となる\neq?\nの記号の等価性を再帰的\nに用いて\nequal?\nを定義できる。\na\nと\nb\nが\nequal?\nであるとはそれ\nらが両方とも記号である場合、かつ記号が\neq?\nである場合、または\n両方ともリストであり\n(car a)\nが\n(car b)\nに\nequal?\nであり、か\nつ\n(cdr a)\nが\n(cdr b)\nに\nequal?\nであるような場合である。この\n考えを用いて\nequal?\nを手続として実装せよ。\n37\nExercise 2.55:\nEva Lu Ator\nはインタプリタに次の式を入力した。\n(\ncar\n''abracadabra\n)\n驚いたことにインタプリタは\nquote\nを応答として表示した。説明\nせよ。\n2.3.2\n例\n:\n記号微分\n記号操作の説明として、及びより一層のデータ抽象の説明として、代数式\nの記号微分を行う手続の設計について考えてみましょう。手続は引数として代\n数式と変数を取り変数に対する式の導関数を返すことにします。例えば手続に\n対する引数が\n푎푥\n2\n+ 푏푥 + 푐\nと\n푥\nの時、手続は\n2푎푥 + 푏\nを返さなければいけま\nせん。記号微分は\nLisp\nにとって歴史的に特別な意味があります。記号操作の\n37\n実際には、プログラマは\nequal?\nを数値と同じくシンボルを含むリストの比較に用い\nる。数値は記号とは認識されない。数の上で等しい二つの数値\n(\n=\nでテストした場合の様\nに\n)\nが\neq?\nでもそうであるかという問題は高度に実装依存である。\nequal?\nの\n(Scheme\nに\nプリミティブとして提供されているような\n)\nより良い定義でも、もし\na\nと\nb\nが数値である\nなら、それらが数値として等しい場合に\nequal?\nであると明記するだろう。\n153","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":179},{"id":"./test/fixtures/pdf/sicp.pdf:180","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ためのコンピュータ言語の開発の裏にこれがその動機の一例として存在しまし\nた。さらにこれが現在増大する応用数学者及び科学者に用いられている記号数\n理の成果のための強力なシステムの開発へと導く一連の研究の始まりに跡を残\nしました。\n記号微分プログラムの開発においても\nSection 2.1.1\nの分数システムの開発\nと同じデータ抽象化の戦略に従います。最初に\n“sums,” “products,” “variables”\nのような抽象オブジェクトを操作する微分アルゴリズムを定義します。これら\nがどのように表現されているのかについて心配することありません。後程、表\n現上の問題については解決しましょう。\n抽象データを用いた微分プログラム\n問題を簡単にするために、二引数の足し算とかけ算の命令のみから構築さ\nれる式のみを扱うとても簡単な記号微分プログラムについて考えましょう。任\n意のそのような式の微分は以下の簡約ルールを適用することで実行されます。\n푑푐\n푑푥\n= 0,\n푓표푟 푐 푎 푐표푛푠푡푎푛푡 표푟 푎 푣푎푟푖푎푏푙푒 푑푖푓푓푒푟푒푛푡 푓푟표푚 푥,\n푑푥\n푑푥\n= 1,\n푑 (푢 + 푣 )\n푑푥\n=\n푑푢\n푑푥\n+\n푑푣\n푑푥\n,\n푑 (푢푣 )\n푑푥\n= 푢\n푑푣\n푑푥\n+ 푣\n푑푢\n푑푥\n.\n後者の\n2\nつのルールは自然に再帰的であることに注意して下さい。つまり和の\n導関数を得るためには最初に項の導関数を求めそれらを足す必要があります。\n各項は順に分解が必要な式に成り得ます。順により小さな部分へと分解してい\nくことはやがて定数か、その導関数が\n0\nか\n1\nのどちらかになる変数になります。\nこれらのルールを手続で具体化するために、分数実装の設計で行ったよう\nに少し希望的観測に耽ります。もし代数式を表現するための手段があるのなら\n式が和か積か定数であるかを判別することができるはずです。式のパーツを抽\n出することができるはずです。例えば足し算に対して加数\n(\n第一項\n)\nと被加数\n(\n第二項\n)\nを抽出できるはずです。またパーツから式を構築することもできるは\nずです。既に以下のセレクタ、コンストラクタ、述語を実装するための手続を\n持っていると仮定しましょう。\n154","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":180},{"id":"./test/fixtures/pdf/sicp.pdf:181","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nvariable?\ne\n)\ne\nは変数であるか\n?\n(\nsame-variable?\nv1\nv2\n)    v1\nと\nv2\nは同じ変数であるか\n?\n(\nsum?\ne\n)\ne\nは和か\n?\n(\naddend\ne\n)\n和\ne\nの加数\n.\n(\naugend\ne\n)\n和\ne\nの被加数\n.\n(\nmake-sum\na1\na2\n)\na1\nと\na2\nの和を構築する\n(\nproduct?\ne\n)\ne\nは積か\n?\n(\nmultiplier\ne\n)\n積\ne\nの乗数\n(\nmultiplicand\ne\n)\n積\ne\nの被乗数\n(\nmake-product\nm1\nm2\n)\nm1\nと\nm2\nの積を構築する\nこれらと数値であるかを判断するプリミティブな述語\nnumber?\nを用いて、以下\nの手続の様に微分のルールを表現できます。\n(\ndefine\n(\nderiv\nexp\nvar\n)\n(\ncond\n((\nnumber?\nexp\n) 0)\n((\nvariable?\nexp\n) (\nif\n(\nsame-variable?\nexp\nvar\n) 1 0))\n((\nsum?\nexp\n) (\nmake-sum\n(\nderiv\n(\naddend\nexp\n)\nvar\n)\n(\nderiv\n(\naugend\nexp\n)\nvar\n)))\n((\nproduct?\nexp\n)\n(\nmake-sum\n(\nmake-product\n(\nmultiplier\nexp\n)\n(\nderiv\n(\nmultiplicand\nexp\n)\nvar\n))\n(\nmake-product\n(\nderiv\n(\nmultiplier\nexp\n)\nvar\n)\n(\nmultiplicand\nexp\n))))\n(\nelse\n(\nerror\n\"\nunknown\nexpression\ntype\n:\nDERIV\n\"\nexp\n))))\nこの\nderiv\n手続は完全な微分アルゴリズムに立脚しています。代数データの項\nにより表現されているため、適切なセレクタとコンストラクタを設計する限り\nにおいて、どのように代数式を表現しても動きます。この条件の部分が次に解\n決すべき問題です。\n代数式を表現する\n代数式を表現するリスト構造を使用する手法は数多く想像できます。例え\nば通常の代数記法を真似する記号のリストを用い、\n푎푥 + 푏\nをリスト\n(a * x\n+ b)\nの様に表現することもできるでしょう。しかし特に直接的な\n1\nつの選択\n155","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":181},{"id":"./test/fixtures/pdf/sicp.pdf:182","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"は\nLisp\nが複合式に用いるのと同じく括弧で括った接頭辞記述法です。つまり\n푎푥 + 푏\nは\n(+ (* a x) b)\nと表現されます。従って微分問題に対するデータ表\n現は以下のとおりです。\n•\n変数はシンボルである。プリミティブな述語\nsymbol?\nで判別される。\n(\ndefine\n(\nvariable?\nx\n) (\nsymbol?\nx\n))\n•\n2\nつの変数はそれらを表現するシンボルが\neq?\nである時同じだ。\n(\ndefine\n(\nsame-variable?\nv1\nv2\n)\n(\nand\n(\nvariable?\nv1\n) (\nvariable?\nv2\n) (\neq?\nv1\nv2\n)))\n•\n和と積はリストとして構築される。\n(\ndefine\n(\nmake-sum\na1\na2\n) (\nlist\n'\n+\na1\na2\n))\n(\ndefine\n(\nmake-product\nm1\nm2\n) (\nlist\n'*\nm1\nm2\n))\n•\n和は最初の要素がシンボル\n+\nのリストだ。\n(\ndefine\n(\nsum?\nx\n) (\nand\n(\npair?\nx\n) (\neq?\n(\ncar\nx\n)\n'\n+)))\n•\n加数は和のリストの二つ目の項だ。\n(\ndefine\n(\naddend\ns\n) (\ncadr\ns\n))\n•\n被加数は和のリストの三つめの項だ。\n(\ndefine\n(\naugend\ns\n) (\ncaddr\ns\n))\n•\n積は最初の要素がシンボル\n*\nのリストだ。\n(\ndefine\n(\nproduct?\nx\n) (\nand\n(\npair?\nx\n) (\neq?\n(\ncar\nx\n)\n'*\n)))\n•\n乗数は積のリストの二つ目の項だ。\n(\ndefine\n(\nmultiplier\np\n) (\ncadr\np\n))\n•\n被乗数は積のリストの三つめの項だ。\n(\ndefine\n(\nmultiplicand\np\n) (\ncaddr\np\n))\n156","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":182},{"id":"./test/fixtures/pdf/sicp.pdf:183","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"従って記号微分プログラムを得るためには、これらを\nderiv\nにより組込まれた\nアルゴリズムを用いて組み立てることのみが必要でです。いくつかの例とその\n振舞を見てみましょう。\n(\nderiv\n'\n(+\nx\n3)\n'x\n)\n(+ 1 0)\n(\nderiv\n'\n(*\nx\ny\n)\n'x\n)\n(+ (* x 0) (* 1 y))\n(\nderiv\n'\n(* (*\nx\ny\n) (+\nx\n3))\n'x\n)\n(+ (* (* x y) (+ 1 0))\n(* (+ (* x 0) (* 1 y))\n(+ x 3)))\nプログラムは正しい解答を生成します。しかし、それらは簡略化されていま\nせん。\n푑 (푥푦)\n푑푥\n= 푥 ⋅ 0 + 1 ⋅ 푦,\nしかし私達はこのプログラムに\n푥 ⋅ 0 = 0\n,\n1 ⋅ 푦 = 푦\n,\n0 + 푦 = 푦\nを理解して欲し\nいと望みます。二つ目の例の解答は単純に\ny\nとなるべきです。三つめの例が示\nすように、これは式が複雑な場合には深刻な問題となります。\nこの困難は分数実装において出くわしたものととても似ています。最も単\n純な形式に解答を約分していませんでした。分数を約分するためには実装のコ\nンストラクタとセレクタのみを変更する必要がありました。ここでも同様の戦\n略を受け入れることができます。\nderiv\nには全く変更は加えません。その代わ\nりに\nmake-sum\nを変更し両方の加数が数値である場合、\nmake-sum\nはそれらを足\nしてその和を返します。また加数の\n1\nつが\n0\nならば\nmake-sum\nはもう一方の加\n数を返します。\n(\ndefine\n(\nmake-sum\na1\na2\n)\n(\ncond\n((=\nnumber?\na1\n0)\na2\n)\n((=\nnumber?\na2\n0)\na1\n)\n((\nand\n(\nnumber?\na1\n) (\nnumber?\na2\n))\n(+\na1\na2\n))\n(\nelse\n(\nlist\n'\n+\na1\na2\n))))\nこれには手続\n=number?\nを用いました。式が与えられた数値と等しいかチェッ\nクします。\n(\ndefine\n(=\nnumber?\nexp\nnum\n) (\nand\n(\nnumber?\nexp\n) (=\nexp\nnum\n)))\n157","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":183},{"id":"./test/fixtures/pdf/sicp.pdf:184","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"同様に\nmake-product\nを変更し任意の項に\n0\nを掛ければ\n0\n、任意の項に\n1\nを掛\nければそれ自身にするルールを構築します。\n(\ndefine\n(\nmake-product\nm1\nm2\n)\n(\ncond\n((\nor\n(=\nnumber?\nm1\n0) (=\nnumber?\nm2\n0)) 0)\n((=\nnumber?\nm1\n1)\nm2\n)\n((=\nnumber?\nm2\n1)\nm1\n)\n((\nand\n(\nnumber?\nm1\n) (\nnumber?\nm2\n)) (*\nm1\nm2\n))\n(\nelse\n(\nlist\n'*\nm1\nm2\n))))\nこれがこのバージョンが先程の\n3\nつの例でどのように動くかです\n(\nderiv\n'\n(+\nx\n3)\n'x\n)\n1\n(\nderiv\n'\n(*\nx\ny\n)\n'x\n)\ny\n(\nderiv\n'\n(* (*\nx\ny\n) (+\nx\n3))\n'x\n)\n(+ (* x y) (* y (+ x 3)))\nこれはとても改善が見られますが、三つめの例は式を\n“\n最も単純\n”\nだと同意を得\nられる形式に変形するプログラムを得るまでには今だ長い道程があることを示\nします。代数の簡約の問題は複雑です。他の理由の中でも、ある目的にとって\n最も単純な形式が他の目的にとってはそうではないことが有り得るためです。\nExercise 2.56:\nより多くの種類の式を扱うために基本的な微分をど\nのように拡張すべきか示せ。例として、以下の微分ルールを実装\nせよ。\n푑 (푢\n푛\n)\n푑푥\n= 푛푢\n푛−1\n푑푢\n푑푥\nderiv\nプログラムに新しい節を追加し、適切な手続\nexponentiation?\n,\nbase\n,\nexponent\n,\nmake-exponentiation\nを定義せよ。\n(\nシンボル\n**\nを指数演算の表記に用いても良い\n)\n。任意の数の\n0\n乗は\n1\nであり、\n任意の数の\n1\n乗はそれ自身であるというルールを構築せよ。\nExercise 2.57:\n微分プログラムを拡張し、\n(2\n以上の\n)\n任意の数の項\nの和と積を扱えるようにせよ。すると上の最後の例は以下のよう\nに表現できる。\n(\nderiv\n'\n(*\nx\ny\n(+\nx\n3))\n'x\n)\n158","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":184},{"id":"./test/fixtures/pdf/sicp.pdf:185","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この問題を和と積の表現のみを変更することで行え。\nderiv\n手続\nには全く変更を加えない。例えば和の\naddend\n(\n加数\n)\nは最初の項に\nなり、\naugend\n(\n被加数\n)\nは残りの項の和となるであろう。\nExercise 2.58:\n微分プログラムを変更し通常の数学の記法を扱える\nようにしたいとする。\n+\nと\n*\nは接中辞となり接頭辞演算子ではなく\nなる。微分プログラムは抽象データを用いて定義されているので、\nもっぱら微分プログラムが操作する代数式を表現する述語、セレ\nクタ、コンストラクタを変更することで式の異なる表現を対応す\nるように変更することができる。\na\n(x + (3 * (x + (y + 2))))\nの様な接中辞で表される代数式\nを微分することをどのように行うのか示せ。作業を簡単にす\nるために\n+\nと\n*\nは常に\n2\nつの引数を取り式は完全に括弧で括\nられていると仮定せよ。\nb\n(x + 3 * (x + y + 2))\nのような標準的な代数記法を認める\nことで問題は大幅に難しくなる。これは必要の無い括弧を省\n略し、乗算は加算の前に行われると仮定している。私達の微\n分プログラムがそれでも働くこの記法に対する適切な述語、\nセレクタ、コンストラクタを設計できるだろうか\n?\n2.3.3\n例\n:\n集合を表現する\n以前の例において\n2\nつ種類の複合データオブジェクトの表現を構築しまし\nた。分数と代数式です。これらの例の\n1\nつでは組立時と選択時のどちらかで式\nを単純化\n(\n簡約化\n)\nを行うか選択肢がありました。しかしそれ以外ではリストを\n用いたこれらの構造に対する表現の選択肢は直接的なものでした。私達が集合\nの表現に向かう時、表現の選択肢はあまり明白ではありません。本当に数多く\nの可能な表現が存在し、それらはお互いからいくつかの点において著しく異な\nります。\n非公式には集合は異なる要素の単純な集まりです。より正確な定義を与える\nために私達はデータ抽象の手法を用いることができます。それは\n“\n集合\n”\nを集合\n上で用いられる操作を特定することで定義することです。これらは\nunion-set\n,\nintersection-set\n,\nelement-of-set?\n,\nadjoin-set\nです。\nelement-of-set?\nは\n与えられた要素が集合のメンバーであるかを判定する述語です。\nadjoin-set\nはオブジェクトと集合を引数として取り、元の集合の要素と挿入された要素を\nも含む集合を返します。\nunion-set\nはどちらかの引数に現れる全ての要素含む\n159","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":185},{"id":"./test/fixtures/pdf/sicp.pdf:186","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"集合である、\n2\nつの集合の和集合を計算します。\nintersection-set\nは両方の\n引数の中に現れる要素のみを含む、\n2\nつの集合の共通集合を計算します。デー\nタ抽象の視点から見れば、私達は上で与えられた解釈と一致する方法であれば、\nこれらの命令を実装するどんな表現を設計することも自由です。\n38\n順序無しリストとしての集合\n集合を表現するための\n1\nつの方法は、どの要素も一度より多くは現れない\n要素のリストとします。空集合は空リストとして表現されます。この表現で\nは\nelement-of-set?\nは\nSection 2.3.1\nの手続\nmemq\nと似ています。\neq?\nの代わり\nに\nequal?\nを用いているので集合要素はシンボルである必要はありません。\n(\ndefine\n(\nelement-of-set?\nx\nset\n)\n(\ncond\n((\nnull?\nset\n)\nfalse\n)\n((\nequal?\nx\n(\ncar\nset\n))\ntrue\n)\n(\nelse\n(\nelement-of-set?\nx\n(\ncdr\nset\n)))))\nこれを用いて\nadjoin-set\nを書けます。\nadjoin\nされるオブジェクトが既に集合\nに存在する場合、単に元の集合を返します。そうでなければ\ncons\nを用いてオ\nブジェクトを集合を表すリストに追加します。\n(\ndefine\n(\nadjoin-set\nx\nset\n)\n(\nif\n(\nelement-of-set?\nx\nset\n)\nset\n(\ncons\nx\nset\n)))\nintersection-set\nに対して再帰の戦略を使用できます。もし\nset2\nと\nset1\nの\ncdr\nの共通集合の求める方がわかれば、これに\nset1\nの\ncar\nを含めるかどうか\n決定することのみが必要です。しかしこれは\n(car set1)\nが\nset2\nにも存在す\nるかに依存します。以下に結果の手続を示します。\n38\nもしより正式でありたければ、\n“\n上で与えられた解釈と一致する\n”\nの部分を、命令群\nが以下のようなルールの集合を満たすと指定することができます。\n任意の集合\nS\nと任意のオブジェクト\nx\nに対し、\n(element-of-set? x (adjoin-set x S))\nは真\n(\n非公式には\n“\nオブジェクトを集合に\nadjoin\nすればそのオブジェクトを含む集合を\n生成する\n”)\n任意の集合\nS\nと\nT\nと任意のオブジェクト\nx\nに対し、\n(element-of-set? x (union-set S\nT))\nは\n(or (element-of-set? x S) (element-of-set? x T))\nに等しい\n(\n非公式には\n“\n(union S T)\nの要素は\nS\nまたは\nT\nに存在する要素\n”)\n任意のオブジェクト\nx\nに対し\n(element-of-set? x '())\nは偽\n(\n非公式には\n“\nどのオブジ\nェクトも空集合の要素ではない\n”)\n160","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":186},{"id":"./test/fixtures/pdf/sicp.pdf:187","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nintersection-set\nset1\nset2\n)\n(\ncond\n((\nor\n(\nnull?\nset1\n) (\nnull?\nset2\n))\n'\n())\n((\nelement-of-set?\n(\ncar\nset1\n)\nset2\n)\n(\ncons\n(\ncar\nset1\n)\n(\nintersection-set\n(\ncdr\nset1\n)\nset2\n)))\n(\nelse\n(\nintersection-set\n(\ncdr\nset1\n)\nset2\n))))\n表現の設計において、私達が考慮しなければならない問題の\n1\nつは効率です。集\n合操作により必要とされるステップ数を考えて下さい。それら全てが\nelement-\nof-set?\nを使用するので、この命令のスピードは総じて集合実装の効率上に主\n要な影響を与えます。ここで、あるオブジェクトが集合の要素であるかをチ\nェックするために、\nelement-of-set?\nは集合全体をスキャンしなければならな\nいかもしれません。\n(\n最悪の場合、そのオブジェクトがその集合の中に存在し\nないことが分かるかもしれません\n)\n。それ故にもしその集合が\n푛\n要素を持つ場\n合、\nelement-of-set?\nは最大\n푛\nステップかかるかもしれません。従って必要と\nされるステップ数は\nΘ(푛)\nで増加します。\nadjoin-set\nにより必要とされるス\nテップ数は、それがこの命令を用いるので、これもまた\nΘ(푛)\nで増加します。\nintersection-set\nは、\nset1\nの各要素に対し\nelement-of-set?\nのチェックを行\nうため、必要とされるステップ数は関係する集合のサイズの積か、またはサイ\nズ\n푛\nの\n2\nつの集合に対し\nΘ(푛\n2\n)\nで増加します。\nunion-set\nに対しても同じこ\nとが言えます。\nExercise 2.59:\n集合の順序無しリスト表現に対する\nunion-set\n命\n令を実装せよ。\nExercise 2.60:\n集合は重複無しのリストとして表現されると指示し\nた。ここで重複を許可すると仮定してみる。例として集合\n{1, 2, 3}\nはリスト\n(2 3 2 1 3 2 2)\nとして表現できるだろう。この表\n現上で操作を行う手続\nelement-of-set?\n,\nadjoin-set\n,\nunion-set\n,\nintersection-set\nを設計せよ。それぞれの効率は対応する重複\n無し表現に対する手続に比べてどれ程だろうか\n?\n重複無しの集合\nに優先してこの表現を用いるだろうアプリケーションはあるだろ\nうか\n?\n順序有りリストとしての集合\n私達の集合操作を高速化するための\n1\nつの方法として表現を変更すること\nで集合要素を昇順に並べる方法があります。これを行うには\n2\nつのオブジェク\n161","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":187},{"id":"./test/fixtures/pdf/sicp.pdf:188","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"トを比較する何らかの方法が必要です。それによりどちらが大きいを言うこと\nができます。例えばシンボルを辞書順で比較したり、オブジェクトに一意の番\n号を付けその後要素を対応する番号で比較するための何らかの方法について同\n意できるでしょう。議論を単純にするため私達は集合要素が数値である場合の\nみについて考えます。それにより要素を\n>\nと\n<\nを用いて比較することができま\nす。数値の集合をその要素を昇順に並べることで表現しましょう。上の最初の\n表現は集合\n{1, 3, 6, 10}\nを要素を任意の順で並べることで表現できる一方で、\n新しい表現はリスト\n(1 3 6 10)\nのみを許します。\n順序付けの\n1\nつの利点は\nelement-of-set?\nにて現れます。項目の存在をチ\nェックする場合において、集合全体をスキャンする必要がありません。もし探\nしている項目よりも大きな要素に出会ったならばその集合にこの項目が無いこ\nとがわかります。\n(\ndefine\n(\nelement-of-set?\nx\nset\n)\n(\ncond\n((\nnull?\nset\n)\nfalse\n)\n((=\nx\n(\ncar\nset\n))\ntrue\n)\n((<\nx\n(\ncar\nset\n))\nfalse\n)\n(\nelse\n(\nelement-of-set?\nx\n(\ncdr\nset\n)))))\nこれがどれだけのステップを割引くでしょうか\n?\n最悪の場合、探している項目\nは集合の中で一番大きい物かもしれません。その場合ステップ数は順序無し表\n現と同じです。しかし一方でもし多くの異なるサイズの項目を探している場合、\n時々はリストの先頭近くの点で検索を停止することができることを期待できま\nす。そして他の場合にはやはりリストのほとんどを試験しなければいけません。\n平均では集合の項目数の半分近くを試験しなければいけないことが期待できる\nはずです。従って必要とされる平均のステップ数は約\n푛/2\nになります。これは\nそれでも\nΘ(푛)\nで増加しますが、以前の実装に対して平均的にはステップ数に\nおいて半分に節約します。\nintersection-set\nではより目覚ましい高速化を得ます。順序無し表現では\nこの命令は\nΘ(푛\n2\n)\nステップを必要としました。\nset1\nの各要素に対して\nset2\nの\n完全なスキャンを実行していたためです。しかし順序有り表現ではより賢い方\n法を用いることができます。二つの集合の最初の要素\nx1\nと\nx2\nを比較すること\nで始め、もし\nx1\nと\nx2\nが等しい場合にはそれらは共通集合の要素です。そして\n共通集合の残りは\n2\nつの集合の\ncdr\nの共通集合です。そうでなく\nx1\nが\nx2\nより\n小さい場合を考えます。\nx2\nは\nset2\nの最小の要素ですから直ぐに\nx1\nは\nset2\nの\nどこにも現れず、従って共通集合には有り得ません。従って共通集合は\nset2\nと\nset1\nの\ncdr\nの共通集合に等しいとなります。同様にもし\nx2\nが\nx1\nより小さ\n162","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":188},{"id":"./test/fixtures/pdf/sicp.pdf:189","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"い場合、共通集合は\nset1\nと\nset2\nの\ncdr\nの共通集合にて与えられます。以下に\n手続を与えます。\n(\ndefine\n(\nintersection-set\nset1\nset2\n)\n(\nif\n(\nor\n(\nnull?\nset1\n) (\nnull?\nset2\n))\n'\n()\n(\nlet\n((\nx1\n(\ncar\nset1\n)) (\nx2\n(\ncar\nset2\n)))\n(\ncond\n((=\nx1\nx2\n)\n(\ncons\nx1\n(\nintersection-set\n(\ncdr\nset1\n)\n(\ncdr\nset2\n))))\n((<\nx1\nx2\n)\n(\nintersection-set\n(\ncdr\nset1\n)\nset2\n))\n((<\nx2\nx1\n)\n(\nintersection-set\nset1\n(\ncdr\nset2\n)))))))\nこの処理により必要とされるステップ数を推定するために、各ステップにて共\n通集合問題は縮小され、\nset1\nか\nset2\n、又はその両方の最初の要素を削除する\nことで、より小さな集合の共通部分を求める問題になっていることに注意して\n下さい。従って必要とされるステップ数は最大でも\nset1\nと\nset2\nのサイズの合\n計であり、順序無し表現におけるサイズの積とはなりません。これは\nΘ(푛\n2\n)\nで\nなく、\nΘ(푛)\nで増加するため、例え中程度のサイズの集合に対してでも考慮に\n値する高速化です。\nExercise 2.61:\n順序有り表現を用いた\nadjoin-set\nの実装を与えよ。\nelement-of-set?\nとの類似点にて、どのように順序の利点を用い\nて順序無し表現に対し平均で約半分のステップを必要とする手続\nを生成するかを示せ。\nExercise 2.62:\n順序付きリストとして表現された集合に対する\nunion-set\nの実装を\nΘ(푛)\nの範囲で行え。\n二分木としての集合\n集合要素を木の形式にて準備することで順序有りリスト表現よりも良く\n行なうことができます。木の各ノードはそのノードにおける\n“\nエントリ\n”\nと\n呼ばれる集合の\n1\nつの要素と他の\n2\nつの\n(\n空にも有り得る\n)\nノードへのリン\nクを持ちます。\n“\n左\n”\nのリンクはそのノードよりも小さな値を差し、\n“\n右\n”\nのリ\nンクはそのノードの値より大きな値のノードを差します。\nFigure 2.16\nは集合\n{1, 3, 5, 7, 9, 11}\nを表現するいくつかの木を示しています。\n163","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":189},{"id":"./test/fixtures/pdf/sicp.pdf:190","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"7\n3\n5\n3  9   1  7\n93\n1\n11  5  9\n1   7  11\n11\n5\nFigure 2.16:\n集合\n{1, 3, 5, 7, 9, 11}\nを表現するさまざまな\n二分木\n木表現の優位点は次のとおりです。ある数値\n푥\nがある集合に含まれているかど\nうかをチェックしたいと想定します。\n푥\nをトップノードのエントリと比較する\nことから始めます。もし\n푥\nがこれよりも小さければ、左の部分木のみを探索す\nれば良いことがわかります。もし\n푥\nが大きければ、右の部分木のみを探索す\nる必要があります。ここで、木が\n“\nバランスが取れた\n”\n状態であるとは各部分\n木のサイズが元の約半分であるということです。従って一度のステップにおい\nてサイズ\n푛\nの木の探索問題を、サイズ\n푛/2\nの木の探索問題に縮小したことに\nなります。各ステップにより木の探索に必要なステップは半分になるのでサイ\nズ\n푛\nの木の探索に必要なステップ数は\nΘ(푙표푔 푛)\nで増加することが期待されま\nす。\n39\n大きな集合に対しては以前の表現に比べこれは著しい高速化になるでし\nょう。\n木はリストを用いて表現できます。各ノードは\n3\nつの項目のリストになり\nます。ノードのエントリ、左部分木、右部分木です。左、または右部分木が空\nリストの場合はそこに接続された部分木が存在しないことを示します。この表\n現を以下の手続にて説明できます。\n40\n(\ndefine\n(\nentry\ntree\n) (\ncar\ntree\n))\n39\nSection 1.2.4\nの高速指数アルゴリズムや\nSection 1.2.4\nの半区間検索手法で学んだよう\nに各ステップにて問題のサイズを半分にすることは対数増加の特徴的な性質です。\n40\n私達は集合を木を用いて表現しており、そして木はリストを用いています\n—\n事実上、\nデータ抽象化がデータ抽象化の上に構築されています。手続\nentry\n,\nleft-branch\n,\nright-\nbranch\n,\nmake-tree\nを私達がそのような木をリスト構造を用いて表現することを望んだ\n特定の方法から\n“\n二分木\n”\nの抽象化を分離する方法として見做すことができます。\n164","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":190},{"id":"./test/fixtures/pdf/sicp.pdf:191","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nleft-branch\ntree\n) (\ncadr\ntree\n))\n(\ndefine\n(\nright-branch\ntree\n) (\ncaddr\ntree\n))\n(\ndefine\n(\nmake-tree\nentry\nleft\nright\n)\n(\nlist\nentry\nleft\nright\n))\nこれで\nelement-of-set?\n手続を上で説明された戦略を用いて書くことができ\nます。\n(\ndefine\n(\nelement-of-set?\nx\nset\n)\n(\ncond\n((\nnull?\nset\n)\nfalse\n)\n((=\nx\n(\nentry\nset\n))\ntrue\n)\n((<\nx\n(\nentry\nset\n))\n(\nelement-of-set?\nx\n(\nleft-branch\nset\n)))\n((>\nx\n(\nentry\nset\n))\n(\nelement-of-set?\nx\n(\nright-branch\nset\n)))))\n集合に項目を付加することは同様に実装され、そしてまた\nΘ(푙표푔 푛)\nステップ\nを必要とします。項目\nx\nを付加するためには、\nx\nをノードのエントリと比較し\nx\nが右か左のどちらの枝に追加されるべきを判断し、\nx\nを適切な枝に追加し、こ\nの新しく構築された枝を元のエントリともう一方の枝と共に接続します。もし\nx\nを空の木に付加するよう求められたらエントリに\nx\nを持ち、右と左の枝は空\nである木を生成します。以下がこの手続です。\n(\ndefine\n(\nadjoin-set\nx\nset\n)\n(\ncond\n((\nnull?\nset\n) (\nmake-tree\nx\n'\n()\n'\n()))\n((=\nx\n(\nentry\nset\n))\nset\n)\n((<\nx\n(\nentry\nset\n))\n(\nmake-tree\n(\nentry\nset\n)\n(\nadjoin-set\nx\n(\nleft-branch\nset\n))\n(\nright-branch\nset\n)))\n((>\nx\n(\nentry\nset\n))\n(\nmake-tree\n(\nentry\nset\n) (\nleft-branch\nset\n)\n(\nadjoin-set\nx\n(\nright-branch\nset\n))))))\n上の木の検索は対数ステップで実行可能であるとの主張は木は\n“\nバランスが取\nれている\n”\nという前提に依存しています。すなわち、全ての木の左と右の部分\n木は大体同じ要素の数を持っているため、各部分木はその親の約半分の要素持\nっていることになります。しかしどのようにすれば私達が構築した木がバラン\nスが取れていると確信することができるのでしょうか。例えもしバランスの取\n165","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":191},{"id":"./test/fixtures/pdf/sicp.pdf:192","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1\n2\n3\n4\n5\n6\n7\nFigure 2.17:\n1\nから\n7\nまで順に\nadjoin\nすることで生成した不\n均衡な木\nれた木で開始したとしても、\nadjoin-set\nにて要素を足していけばバランスが\n取れていない結果を生み出します。新しく付加される要素の位置は集合に既に\n存在する項目とどのように比較されるかに依存するために、もし要素を\n“\nラン\nダム\n”\nに追加すればその木が平均ではバランスが取れることが予想できます。\nしかしこれは保証されません。例えばもし空集合から始めて数値を\n1\nから\n7\nま\nで順番に追加していけば\nFigure 2.17\nで示されるとてもアンバランスな木になっ\nてしまいます。この木では全ての左の部分木は空であり、単純な順序有りリス\nトに対する優位点が存在しません。この問題を解く\n1\nつの方法として任意の木\nをバランスの取れた木に同じ要素を用いて変換する操作を定義することが上げ\nられます。そうすれば数回毎の\nadjoin-set\nの後にこの変換を実行することで\n集合のバランスを保つことができます。この問題を解く他の方法もまた存在し\nますが、その多くは検索と挿入の両方が\nΘ(푙표푔 푛)\nステップで行える新しいデ\nータ構造を設計することを含みます。\n41\nExercise 2.63:\n以下の\n2\nつの手続はそれぞれ二分木をリストに変換\nする。\n(\ndefine\n(\ntree->list-1\ntree\n)\n(\nif\n(\nnull?\ntree\n)\n41\nそのような構造の例には\nB-trees\n(\nB\n木\n)\nや\nred-black trees\n(\n赤黒木\n)\nがあります。この\n問題にささげられた巨大な文献が存在します。\nCormen et al. 1990\nを参照して下さい。\n166","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":192},{"id":"./test/fixtures/pdf/sicp.pdf:193","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"'\n()\n(\nappend\n(\ntree->list-1\n(\nleft-branch\ntree\n))\n(\ncons\n(\nentry\ntree\n)\n(\ntree->list-1\n(\nright-branch\ntree\n))))))\n(\ndefine\n(\ntree->list-2\ntree\n)\n(\ndefine\n(\ncopy-to-list\ntree\nresult-list\n)\n(\nif\n(\nnull?\ntree\n)\nresult-list\n(\ncopy-to-list\n(\nleft-branch\ntree\n)\n(\ncons\n(\nentry\ntree\n)\n(\ncopy-to-list\n(\nright-branch\ntree\n)\nresult-list\n)))))\n(\ncopy-to-list\ntree\n'\n()))\na\n2\nつの手続は全ての木に対して同じ結果を生成するか\n?\nもし\nそうでなければどのように結果は異なるか\n?\nFigure 2.16\nの木\nに対して\n2\nつの手続はどんなリストを生成するか\n?\nb\n2\nつの手続は\n푛\n要素のバランスの取れた木をリストに変換す\nるのに同じステップ数増加のオーダであるか\n?\nもしそうでな\nければどちらがより遅く増加するか\n?\nExercise 2.64:\n以下の手続\nlist->tree\nは順序有りリストをバラン\nスの取れた木に変換する。ヘルパ手続\npartial-tree\nは引数として\n整数\n푛\nと少なくとも\n푛\n要素のリストを取り、リストの最初の\n푛\n要\n素を含むバランスの取れた木を生成する。\npartial-tree\nの結果と\nして返されるのは\n(\ncons\nで構築された\n)\nペアであり、\ncar\nが構築さ\nれた木で\ncdr\nが木に含まれなかった要素のリストである、\n(\ndefine\n(\nlist->tree\nelements\n)\n(\ncar\n(\npartial-tree\nelements\n(\nlength\nelements\n))))\n(\ndefine\n(\npartial-tree\nelts\nn\n)\n(\nif\n(=\nn\n0)\n(\ncons\n'\n()\nelts\n)\n(\nlet\n((\nleft-size\n(\nquotient\n(-\nn\n1) 2)))\n(\nlet\n((\nleft-result\n167","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":193},{"id":"./test/fixtures/pdf/sicp.pdf:194","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\npartial-tree\nelts\nleft-size\n)))\n(\nlet\n((\nleft-tree\n(\ncar\nleft-result\n))\n(\nnon-left-elts\n(\ncdr\nleft-result\n))\n(\nright-size\n(-\nn\n(+\nleft-size\n1))))\n(\nlet\n((\nthis-entry\n(\ncar\nnon-left-elts\n))\n(\nright-result\n(\npartial-tree\n(\ncdr\nnon-left-elts\n)\nright-size\n)))\n(\nlet\n((\nright-tree\n(\ncar\nright-result\n))\n(\nremaining-elts\n(\ncdr\nright-result\n)))\n(\ncons\n(\nmake-tree\nthis-entry\nleft-tree\nright-tree\n)\nremaining-elts\n))))))))\na\nできるだけ明確に\npartial-tree\nがどのように働くのか文章\nで答えよ。リスト\n(1 3 5 7 9 11)\nに対し\nlist->tree\nによ\nり生成される木を描け。\nb\nlist->tree\nが\n푛\n要素のリストを変換するのに必要とされる\nステップ数の増加んオーダはいくらか\n?\nExercise 2.65:\nExercise 2.63\nと\nExercise 2.64\nの結果を用いて\n(\nバラ\nンスの取れた\n)\n二分木として実装された集合の\nΘ(푛)\nにおける実装\nを与えよ。\n42\n集合と情報検索\nリストを集合を表現するのに使用する選択肢について調べ、データオブジ\nェクトに対する表現の選択がどのようにそのデータを使用するプログラムのパ\nフォーマンスに大きな影響を与えるかについて学びました。集合に専念するも\nう\n1\nつの理由としてここで議論されたテクニックが情報検索を含むアプリケー\nションにおいて何度も何度も現われることが上げられます。\n42\nExercise 2.63\nから\nExercise 2.65\nは\nPaul Hilfinger\nによるものである。\n168","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":194},{"id":"./test/fixtures/pdf/sicp.pdf:195","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"企業が持つ個人情報や会計システムの取引等、大量の個人レコードを持つ\nデータベースについて考えてみて下さい。典型的なデータ管理システムはレコ\nードの中のデータへのアクセスや変更に多大な時間を過ごします。従ってレコ\nードにアクセスする効率的な手法を必要とします。これは各レコードの一部に\n識別子である\nkey\n(\nキー\n)\nとしての役割を果たさせることで行われます。キーは\nレコードを一意に識別する任意の物でかまいません。個人情報に対しては従業\n員番号であったりします。会計システムにおいては取引番号であったりします。\nキーが何であれレコードをデータ構造として定義する時、与えられたレコード\nに関連するキーを取得する\nkey\nセレクタ手続を含まなければなりません。\nさて、データベースをレコードの集合として表現します。与えられたキー\nでレコードを指し示すためには手続\nlookup\nを用い、引数としてキーとデータ\nベースを取り、そのキーを持つレコードを返すか、そのようなレコードが無け\nれば\nfalse\nを返します。例えばもしレコードの集合が順序無しリストで実装さ\nれていれば、以下を用いることができます。\n(\ndefine\n(\nlookup\ngiven-key\nset-of-records\n)\n(\ncond\n((\nnull?\nset-of-records\n)\nfalse\n)\n((\nequal?\ngiven-key\n(\nkey\n(\ncar\nset-of-records\n)))\n(\ncar\nset-of-records\n))\n(\nelse\n(\nlookup\ngiven-key\n(\ncdr\nset-of-records\n)))))\nもちろん、巨大な集合を表現するのには順序無しリストよりもより良い方法が\n存在します。レコードが\n“\nランダムアクセス\n”\nされる情報検索システムは一般\n的に木をベースにした手法で実装されます。以前に議論された二分木のような\n物です。そのようなシステムを設計する場合、データ抽象化の方法論はとても\n大きな手助けになります。設計者は順序無しリストの様な、簡単で直接的な表\n現を用いて初期実装を作成することができます。これは最終的なシステムには\n相応しくありません。しかし、\n“quick and dirty”(\n迅速だが汚い\n)\nデータベース\nを残りのシステムをテストするために提供する目的には便利でしょう。後でデ\nータ表現はより洗練された物に変更することが可能です。もしデータベースが\n抽象セレクタとコンストラクタによりアクセスされるのならば、この表現上の\n変更は残りのシステムに対し何の変更も要求しません。\nExercise 2.66:\nレコードの集合が二分木として構造化され、キーの\n数値で順序付けられている場合の\nlookup\n手続を実装せよ。\n169","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":195},{"id":"./test/fixtures/pdf/sicp.pdf:196","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2.3.4\n例\n:\nハフマン符号化木\nこの節では集合と木を操作するためのリスト構造とデータ抽象化の使用の\nための練習を提供します。アプリケーションの狙いは\n1\nと\n0\nの\n(\nビットの\n)\n列と\nしてのデータを表現するための手法です。例えば\nASCII\n標準コードはコンピュ\nータ内にて各文字を\n7\nビットの列に符号化してテキストを表現するのに利用さ\nれます。\n7\nビットを用いることは\n2\n7\n、または\n128\nの異なる文字を区別すること\nができます。一般的に、もし\n푛\n個の異なる記号を区別したい場合、記号当たり\nに\n푙표푔\n2\n푛\nビットの使用が必要となります。もし全てのメッセージが\n8\nつのシン\nボル、\nA, B, C, D, E, F, G, H\nで作られている場合、一文字当たり\n3\nビットの\nコードを選択することができます。以下に例を上げます。\nA 000    C 010    E 100    G 110\nB 001    D 011    F 101    H 111\nこの符号を用いて、以下のメッセージは\nBACADAEAFABBAAAGAH\n54\nビットの列として符号化されます。\n001000010000011000100000101000001001000000000110000111\nASCII\nや上記の\nA\nから\nH\nの符号は\nfixed-length\n(\n固定長\n)\n符号として知られてい\nます。それらがメッセージの各記号を同じ数のビットを用いて表現するためで\nす。時には\nvariable-length\n(\n可変長\n)\n符号を使用することが有利な場合もありま\nす。異なるシンボルが異なる数のビットで表現され得るものです。例えばモー\nルス符号はアルファベットの各文字に対して同じ数の点と長音を用いはしませ\nん。具体的には\nE\nは最も頻繁に現われる文字ですので単一のドットで表現され\nます。一般的にはもしメッセージにおいてある記号がとても良く現れ、ある記\n号はとても稀に現れる場合、短い符号を頻出のシンボルに割り振ることでデー\nタをより効率的に\n(\nつまりメッセージ当たりでより少ないビット数で\n)\n符号化\nすることができます。\nA 0\nC 1010    E 1100    G 1110\nB 100    D 1011    F 1101    H 1111\nこの符号では上の同じメッセージが以下の列として符号化されます。\n170","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":196},{"id":"./test/fixtures/pdf/sicp.pdf:197","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"100010100101101100011010100100000111001111\nこの列は\n42\nビットですから上で示した固定長符号に比べ記憶域において\n20%\n以上節約できています。\n可変長符号を用いる上での難点の\n1\nつとして\n0\nと\n1\nの列を読んでいる時に\nいつシンボルの終わりに辿り着いたか知ることが上げられます。モールス符号\nはこの問題を各文字に対するトンとツーの列の後に特別な\nseparator code\n(\n分離\n符号\n)(\nこの場合には一息置くこと\n)\nを用いることで解決しました。他の解法とし\nてはどの任意のシンボルに対する完全な符号も他のシンボルの符号の始め\n(\nま\nたは\nprefix\n(\n接頭辞\n))\nではない様に符号を設計するという物があります。このよ\nうな符号は\nprefix code\n(\n接頭符号\n)\nと呼ばれます。上の例では\nA\nは\n0\nで符号化さ\nれ\nB\nは\n100\nで符号化されるので、他のどのシンボルも\n0\n、または\n100\nで始まる\n符号を持つことができません。\n一般的に、もし符号化対象のメッセージ中のシンボルの相対頻度の利点を\n得られる可変長接頭符号を用いれば著しい倹約を達成することができます。こ\nれを行うための\n1\nつの特定な理論体系としてその発見者\nDavid Huffman\nに因\nんでハフマン符号と呼ばれる手法があります。ハフマン符号は葉が符号化され\nた記号である二分木として表現することができます。木の葉でないノードのそ\nれぞれにはそのノードの下に位置する葉の中のシンボル全てを含む集合があり\nます。加えて各葉のシンボルには重み\n(\n相対的な頻度\n)\nが割り振られており、葉\nでないノードのそれぞれはその下に位置する葉の重み全ての合計である重みを\n持っています。重みはエンコード、またはデコード処理では利用されません。\n以下では重みがどのように木の構築を手助けするかについて学びます。\nFigure 2.18\nは上で与えられた\nA\nから\nH\n符号に対するハフマン木を示して\nいます。葉の重みはこの木が\nA\nは相対頻度\n8\n、\nB\nは相対頻度\n3\n、他の文字は相\n対頻度\n1\nで現われるメッセージに対し設計されたことを示しています。\nハフマン木を与えられることで、任意のシンボルの符号を木の根から始めてそ\nのシンボルを持つ葉に辿り着くまで降りていくことで見つけることができま\nす。左の枝に降りる度に符号に\n0\nを追加し、右の枝に降りる度に\n1\nを追加しま\nす。\n(\nどの枝を降りるかはどの枝がそのシンボルに対する葉を含むか、つまり\nその集合にシンボルを含むかをテストして判断することで決定します\n)\n。例え\nば\nFigure 2.18\nの木の根から始めて\nD\nに対する葉に辿り付くには右の枝を選択\nし、次に左の枝、次に右の枝、次に右の枝を辿ります。従って\nD\nに対する符号\nは\n1011\nになります。\nビット列をハフマン木を用いて複合するには、根から始めてビット列の一\n連の\n0\nと\n1\nを用いて左か右の枝を下りるのか決定します。葉に着く度に、メッ\nセージの新しいシンボルを生成し、その時点で木の根から再開し次のシンボル\n171","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":197},{"id":"./test/fixtures/pdf/sicp.pdf:198","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"{A B C D E F G H} 17\n{B C D E F G H} 9\nA 8\n{B C D} 5\n{C D} 2\nD 1C 1\nB 3\n{E F G H} 4\n{G H} 2\n{E F} 2\nE 1\nF 1\nH 1G 1\nFigure 2.18:\nハフマン符号化木\nを見つけます。例えば上記の木と列\n10001010\nを与えられたとします。根から\n始めて右の枝へと下ります。\n(\n列の最初のビットが\n1\nだからです\n)\n。次に左の枝\nを下ります。\n(2\nつ目のビットが\n0\nだからです\n)\n。次に左の枝を下ります。\n(3\nつ\n目のビットもまた\n0\nだからです\n)\n。この様にして\nB\nに対する葉に辿り着くので\n複合されたメッセージの最初のシンボルは\nB\nです。ここでまた根から再開し、\n次のビットが\n0\nなので左に移動します。これにより\nA\nの葉に辿り着きます。そ\nしてまた根から残りの列\n1010\nと共に再開し、右、左、右左と動き\nC\nに辿り着\nきます。従ってメッセージ全体は\nBAC\nです。\nハフマン木の生成\nシンボルの\n“\nアルファベット\n”\nとそれらに対応する頻度を与えられた時、ど\nのように\n“\n最高の\n”\n符号を構築できるでしょうか\n? (\n言い替えれば、どの木がメ\nッセージを最も少ないビット数で符号化するでしょうか\n?)\n。ハフマンはこれを\n行うアルゴリズムを与え、結果の符号が相対的なシンボルの頻度と符号が構築\nされた時の頻度が合致した場合に、実際にメッセージに対する最良の可変長符\n号であることを示しました。このハフマン符号の最適性についてはここでは証\n明しません。しかしハフマン木がどのように構築されるかについては示します。\n172","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":198},{"id":"./test/fixtures/pdf/sicp.pdf:199","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"43\nハフマン木を生成するためのアルゴリズムはとても簡単です。その考えは\n木を再配置することで最も低い頻度のシンボルが根から最も遠く現れるように\nします。シンボルと頻度を含む葉のノードの集合と共に符号が構築される初期\nデータにより決定されるに従うまず重みが最低の\n2\nつの葉を見つけ、それらを\nマージしてこの\n2\nつのノードを左と右の枝に持つノードを生成します。新しい\nノードの重みは\n2\nつの重みの和です。元の集合から\n2\nつの葉を削除しそれらを\nこの新しいノードで置き換えます。この処理を続けます。各ステップにて最も\n小さな重みを持つ\n2\nつのノードをマージし、集合から削除し、これらの\n2\nつを\n左と右の枝に持つノードで置き換えします。処理は\n1\nつのノードのみが残った\n時に停止し、それが木全体の根になります。以下に\nFigure 2.18\nのハフマン木が\nどのように生成されるかを示します。\nInitial\nleaves   {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}\nMerge    {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}\nMerge    {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}\nMerge    {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}\nMerge    {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}\nMerge    {(A 8) ({B C D} 5) ({E F G H} 4)}\nMerge    {(A 8) ({B C D E F G H} 9)}\nFinal    {({A B C D E F G H} 17)}\nmerge\nこのアルゴリズムは常に同じ木を特定しません。各ステップにおいて重みが最\n小のノードのペアが一意となるとは限らないためです。またどの\n2\nつのノード\nがマージされるかの順も決定しません。\n(\nつまりどれが右になり、どれが左にな\nるのかはわかりません\n)\n。\nハフマン木の表現\n以下ではハフマン木を用いてメッセージの符号化・複合化を行い、かつ上\nで概説したアルゴリズムに基づきハフマン木を作成します。木はどのように表\n現されるかの議論から始めます。\n43\nハフマン符号の数学上の特性についての議論に対しては\nHamming 1980\nを参照して\n下さい。\n173","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":199},{"id":"./test/fixtures/pdf/sicp.pdf:200","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"木の葉はシンボル\nleaf\n、葉に対するシンボル、そして重みから構成される\nリストにて表現されます。\n(\ndefine\n(\nmake-leaf\nsymbol\nweight\n)\n(\nlist\n'leaf\nsymbol\nweight\n))\n(\ndefine\n(\nleaf?\nobject\n)\n(\neq?\n(\ncar\nobject\n)\n'leaf\n))\n(\ndefine\n(\nsymbol-leaf\nx\n) (\ncadr\nx\n))\n(\ndefine\n(\nweight-leaf\nx\n) (\ncaddr\nx\n))\n一般的な木は左側の枝、右側の枝、シンボルの集合、そして重みのリストになり\nます。シンボルの集合は単純にシンボルのリストとなり、より洗練された集合\nの表現を用いはしません。\n2\nつのノードをマージして木を作る時、木の重みを\n各ノードの重みの和として取得し、シンボルの集合は各ノードのシンボルの集\n合の和集合とします。シンボルの集合はリストとして表現されていますので和\n集合は\nSection 2.2.1\nで定義した\nappend\n手続を用いて形成することができます。\n(\ndefine\n(\nmake-code-tree\nleft\nright\n)\n(\nlist\nleft\nright\n(\nappend\n(\nsymbols\nleft\n)\n(\nsymbols\nright\n))\n(+ (\nweight\nleft\n)\n(\nweight\nright\n))))\nもしこのように木を作るのなら以下のようなセレクタを持つことになります。\n(\ndefine\n(\nleft-branch\ntree\n) (\ncar\ntree\n))\n(\ndefine\n(\nright-branch\ntree\n) (\ncadr\ntree\n))\n(\ndefine\n(\nsymbols\ntree\n)\n(\nif\n(\nleaf?\ntree\n)\n(\nlist\n(\nsymbol-leaf\ntree\n))\n(\ncaddr\ntree\n)))\n(\ndefine\n(\nweight\ntree\n)\n(\nif\n(\nleaf?\ntree\n)\n(\nweight-leaf\ntree\n)\n(\ncadddr\ntree\n)))\n174","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":200},{"id":"./test/fixtures/pdf/sicp.pdf:201","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"手続\nsymbols\nと\nweight\nはそれらが葉と一般的な木のどちらと共に呼ばれたか\nにより少々異なったことをしなければなりません。これらは\ngeneric procedures\n(\nジェネリック手続\n：二種類以上のデータを扱える手続\n)\nの簡単なサンプルであ\nり、\nSection 2.4\nと\nSection 2.5\nにてより多くのことについて述べます。\n複合化手続\n以下の手続は複合化アルゴリズムを実装します。\n0\nと\n1\nのリストをハフマ\nン木と共に引数として取ります。\n(\ndefine\n(\ndecode\nbits\ntree\n)\n(\ndefine\n(\ndecode-1\nbits\ncurrent-branch\n)\n(\nif\n(\nnull?\nbits\n)\n'\n()\n(\nlet\n((\nnext-branch\n(\nchoose-branch\n(\ncar\nbits\n)\ncurrent-branch\n)))\n(\nif\n(\nleaf?\nnext-branch\n)\n(\ncons\n(\nsymbol-leaf\nnext-branch\n)\n(\ndecode-1\n(\ncdr\nbits\n)\ntree\n))\n(\ndecode-1\n(\ncdr\nbits\n)\nnext-branch\n)))))\n(\ndecode-1\nbits\ntree\n))\n(\ndefine\n(\nchoose-branch\nbit\nbranch\n)\n(\ncond\n((=\nbit\n0) (\nleft-branch\nbranch\n))\n((=\nbit\n1) (\nright-branch\nbranch\n))\n(\nelse\n(\nerror\n\"\nbad\nbit\n:\nCHOOSE-BRANCH\n\"\nbit\n))))\n手続\ndecode-1\nは\n2\nつの引数を取ります。残りのビット列のリストと木におけ\nる現在の位置です。木を\n“\n下り\n”\n続けるためリストの中の次のビットが\n0\nであ\nるか\n1\nであるかに従って左、または右の枝を選択します。\n(\nこれは手続\nchoose-\nbranch\nと共に行われます\n)\n。葉に辿りついた時、その葉のシンボルをメッセー\nジの次のシンボルとして、残りのメッセージを木の根から再開して複合した結\n果の頭に\ncons\nすることで返します。\nchoose-branch\nの最終条項のエラーチェ\nックに注目して下さい。もし手続が\n0\nまたは\n1\n以外の物を入力データに見つけ\nた場合にエラーを発します。\n175","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":201},{"id":"./test/fixtures/pdf/sicp.pdf:202","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"重み付き要素の集合\n私達の木の表現において、各葉ではないノードは簡単にリストとして表現\nしたシンボルの集合を持ちます。しかし上で議論した木の生成アルゴリズムは\nまた葉と木の集合に対しても働き、\n2\nつの最小の項目のマージを続けなければ\nなりません。集合の中の最も小さな項目を繰り返し見つけなければなりません\nから、このような集合に対しては順序有りの表現を用いると便利です。\n葉と木の集合を重みの昇順で配置した要素のリストとして表現することに\nします。以下の集合を構築するための\nadjoin-set\n手続は\nExercise 2.61\nにて説\n明したものと似ています。しかし項目はその重みにて比較され、集合に追加さ\nれる要素はその中に既に存在はしないとします。\n(\ndefine\n(\nadjoin-set\nx\nset\n)\n(\ncond\n((\nnull?\nset\n) (\nlist\nx\n))\n((< (\nweight\nx\n) (\nweight\n(\ncar\nset\n)))\n(\ncons\nx\nset\n))\n(\nelse\n(\ncons\n(\ncar\nset\n)\n(\nadjoin-set\nx\n(\ncdr\nset\n))))))\n以下の手続は\n((A 4) (B 2) (C 1) (D 1))\nの様なシンボルと頻度のペアのリ\nストを取り、葉の初期順序有り集合を構築し、ハフマンアルゴリズムに従いマ\nージできるよう準備します。\n(\ndefine\n(\nmake-leaf-set\npairs\n)\n(\nif\n(\nnull?\npairs\n)\n'\n()\n(\nlet\n((\npair\n(\ncar\npairs\n)))\n(\nadjoin-set\n(\nmake-leaf\n(\ncar\npair\n)\n; symbol\n(\ncadr\npair\n))\n; frequency\n(\nmake-leaf-set\n(\ncdr\npairs\n))))))\nExercise 2.67:\n符号化木とサンプルのメッセージを定義する。\n(\ndefine\nsample-tree\n(\nmake-code-tree\n(\nmake-leaf\n'A\n4)\n(\nmake-code-tree\n(\nmake-leaf\n'B\n2)\n(\nmake-code-tree\n(\nmake-leaf\n'D\n1)\n(\nmake-leaf\n'C\n1)))))\n176","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":202},{"id":"./test/fixtures/pdf/sicp.pdf:203","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\nsample-message\n'\n(0 1 1 0 0 1 0 1 0 1 1 1 0))\ndecode\n手続を用いてメッセージを複合し結果を与えよ。\nExercise 2.68:\nencode\n手続は引数としてメッセージと木を取り、符\n号化されメッセージを与えるビットのリストを生成する。\n(\ndefine\n(\nencode\nmessage\ntree\n)\n(\nif\n(\nnull?\nmessage\n)\n'\n()\n(\nappend\n(\nencode-symbol\n(\ncar\nmessage\n)\ntree\n)\n(\nencode\n(\ncdr\nmessage\n)\ntree\n))))\nencode-symbol\nはあなたが書かねばならぬ手続である。与えられ\nた木に従って与えられたシンボルの符号化を行いビットのリスト\nを返す。\nencode-symbol\nをもしシンボルがその木に存在しない場\n合にエラーを発するように設計せよ。あなたの手続を\nExercise 2.67\nで得られた結果とサンプルの木で符号化することでテストし、元\nのサンプルメッセージと同じであるか確認せよ。\nExercise 2.69:\n以下の手続はその引数としてシンボルと頻度のペア\nのリストを取り\n(\nどのシンボルも\n1\nつより多くのペアには存在しな\nい\n)\n、ハフマンアルゴリズムに従いハフマン符号化木を生成する。\n(\ndefine\n(\ngenerate-huffman-tree\npairs\n)\n(\nsuccessive-merge\n(\nmake-leaf-set\npairs\n)))\nmake-leaf-set\nは上で与えられた手続でペアのリストを葉の順序\n有り集合へと変換する。\nsuccessive-merge\nはあなたが書かなけれ\nばならぬ手続である。\nmake-code-tree\nを用いて集合の重みが最小\nの要素を残り要素が\n1\nつになるまで繰り返しマージせよ。残った\n一要素こそが望まれたハフマン木である。\n(\nこの手続は少しトリッ\nキーであるがそんなに複雑ではない。もしあなたが自分の設計が\n複雑だと思うなら、ほとんど確実に何かを間違えている。順序有\nりの集合表現を用いているという事実から著しい利点を得ること\nができる。\n)\nExercise 2.70:\n以下の\n8\nつのシンボルによるアルファベット\n(\n文字\n体系\n)\nと関連する頻度は効率的に\n1950\n年代のロックの歌を符号化\nするために設計された。\n(“\nアルファベット\n”\nの\n“\nシンボル\n”\nは単体\nの文字である必要は無いことに注意せよ。\n)\n177","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":203},{"id":"./test/fixtures/pdf/sicp.pdf:204","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"A    2   GET 2   SHA 3   WAH 1\nBOOM 1   JOB 2   NA 16   YIP 9\ngenerate-huffman-tree\n(\nExercise 2.69\n参照\n)\nを用いて対応するハ\nフマン木を生成し、\nencode\n(\nExercise 2.68\n参照\n)\nを用いて以下のメ\nッセージを符号化せよ。\nGet a job\nSha na na na na na na na na\nGet a job\nSha na na na na na na na na\nWah yip yip yip yip yip yip yip yip yip\nSha boom\n符号化には何ビットが必要であるか\n?\nこの歌をもし固定長符号を\n8\nつシンボルによるアルファベットに用いた時、最小で何ビットが\n必要であるか\n?\nExercise 2.71:\n푛\n個のシンボルのアルファベットに対するハ\nフマン木を持っているとする。各シンボルに関連する頻度は\n1, 2, 4, ... , 2\n푛−1\nだとしよう。\n푛 = 5\n、\n푛 = 10\nの場合の木をスケッ\nチせよ。そのような\n(\n任意の\n푛\nに対する\n)\n木において、最も頻度の\n高いシンボルを符号化するには何ビットが必要であるか\n?\n最も頻\n度の低いシンボルに対してはいくらか\n?\nExercise 2.72:\nあなたが\nExercise 2.68\nにて設計した符号化手続につ\nいて考える。シンボルを符号化するのに必要なステップ数の増加\nのオーダーはいくらか\n?\n各ノードに辿りついた時にシンボルリス\nトを検索するのに必要なステップ数を含めることを確認するよう\nに。この質問の一般的な解答は難しい。\n푛\n個のシンボルの相対頻\n度が\nExercise 2.71\nで説明された特別な場合について考えよ。そし\nてアルファベットにおける最大頻度と最小頻度のシンボルを符号\n化するのに必要なステップ数の\n(\n푛\nの関数としての\n)\n増加のオーダ\nーを与えよ。\n2.4\n抽象データの多重表現\nここまでデータ抽象化について紹介してきました。これはプログラムが操\n作するデータオブジェクトの実装における選択に独立して多くのプログラムが\n178","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":204},{"id":"./test/fixtures/pdf/sicp.pdf:205","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"指定され得る様な方法でシステムを構造化するメソドロジ\n(\n方法論\n)\nでした。例\nえば\nSection 2.1.1\nにてどのように分数を用いるプログラムの設計タスクを、複\n雑なデータを構築するためのコンピュータ言語のプリミティブなメカニズムを\n用いて分数を実装するタスクから分離するのかについて学びました。鍵となる\n考えは抽象化バリアを建てること\n—\n分数の使用法をそれらの根底にあるリス\nト構造を用いた表現から分離することでした。同様の抽象化バリアは分数演算\n(\nadd-rat\n,\nsub-rat\n,\nmul-rat\n,\ndiv-rat\n)\nを実行する手続の詳細を分数を用いる\n“\nより高いレベル\n”\nの手続から分離します。結果のプログラムは\nFigure 2.1\nで示\nされる構造を持ちます。\nこれらのデータ抽象化バリアは複雑さをコントロールする強力なツールで\nす。基礎をなすデータオブジェクトの表現を分離することで、大きなプログラ\nムを設計するタスクを小さなタスクに分割し別々に実行することを可能にしま\nす。しかしこの種のデータ抽象化はまだ十分に強力ではありません。データオ\nブジェクトに対して\n“\n基礎をなす表現\n”\nについて話すことが常に意味があると\nは限らないためです。\n一例として、あるデータオブジェクトに対しては便利な表現が\n1\nつよりも\n多くあるかもしれません。そして私達はシステムを複数の表現を扱えるように\n設計したいと願うでしょう。簡単な例を得るために、複素数が\n2\nつのほとんど\n同様な方法で表現されるとしましょう。\n(\n実数と虚数から成る\n)\n直行形式と\n(\n大\nきさと角度から成る\n)\n極形式です。ある時は直行形式がより適切で、ある時に\nは極形式がより適切になります。実際に複素数が両者の方法にて表現され、複\n素数を操作する手続がどちらの表現でも働くことができるシステムを考えるこ\nとは完全に適切であろうと思われます。\nより重要なこととして、プログラミングシステムは時折、長期間に渡り多\nくの人々が働くことにより設計されるため、長い間仕様変更にさらされます。\nそのような環境では、データ表現の選択を前もって同意することが誰にとって\nも可能ということは単純に有り得ません。そのため使用から表現を分離するデ\nータ抽象化バリアに加えて、お互いから異なる設計の選択を分離し、単一のプ\nログラム内にて異なる選択の共存を許す抽象化バリアを必要とします。さらに、\n巨大なプログラムは時折、以前から存在する独立して設計されたモジュールを\n組み合わせることで作成されるため、プログラマにモジュールを\nadditively\n(\n付\n加的\n)\nに組み合わせて巨大なシステムにすることを許可するための約束事が必\n要です。それはつまりこれらのモジュールを再設計、または再実装する必要が\n無いようにするためです。\nこの節ではプログラムの異なるパーツにより異なる方法で表現され得るデ\nータをどのように処理するかについて学びます。これは\ngeneric procedures\n(\nジ\n179","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":205},{"id":"./test/fixtures/pdf/sicp.pdf:206","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"add-complex  sub-complex  mul-complex  div-complex\nPrograms that use complex numbers\nComplex-arithmetic package\nRectangular\nrepresentation\nPolar\nrepresentation\nList structure and primitive machine arithmetic\nFigure 2.19:\n複素数システムのデータ抽象化バリア\nェネリック手続\n)—\n二種類以上の方法で表現され得るデータを処理可能な手続\nの構築が必要となります。ジェネリック手続を構築する主なテクニックは\ntype\ntags\n(\nタイプタグ\n)\nを持つデータオブジェクトを利用して処理することになりま\nす。それはつまりデータオブジェクト自身がどのように処理されるべきである\nかについての情報を明示的に含むことです。また\ndata-directed\n(\nデータ適従\n)\nプ\nログラミングについても議論します。これは強力、かつ便利なジェネリック命\n令を用いて付加的にシステムを組み立てる実装戦略です。\n簡単な複素数の例から始めます。どのようにタイプタグとデータに従うス\nタイルが抽象的な\n“\n複素数\n”\nデータオブジェクトの概念を維持しながら複素数\nの直交形式と極形式の表現を分けて設計を行うことを可能にしているかについ\nて学びます。私達はこれを、複素数に対する数値演算手続\n(\nadd-complex\n,\nsub-\ncomplex\n,\nmul-complex\n,\ndiv-complex\n)\nを、複素数がどのように表現されるのか\nから独立して複素数の部分にアクセスするジェネリックなセレクタを用いて定\n義することで達成します。結果としての複素数システムは\nFigure 2.19\nに示され\nるとおり、\n2\nつの異なる種類の抽象化バリアを含みます。\n“\n水平方向\n”\nの抽象化\nバリアは\nFigure 2.1\nと同じ役割を演じます。それらは\n“\n高レベル\n”\nの命令を\n“\n低\nレベル\n”\nの表現から分離します。それに加えて\n“\n垂直方向\n”\nのバリアが存在し、\n代替的な表現を分離して設計しインストールする能力を与えます。\nSection 2.5\nにてどのようにタイプタグとデータ適従スタイルを用いてジェネリ\nックな数値演算パッケージを開発するかについて示します。これは全ての種類\nの\n“\n数値\n”\nを操作するのに用いることができる手続\n(\nadd\n,\nmul\n,\nその他\n)\nを提供し\n180","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":206},{"id":"./test/fixtures/pdf/sicp.pdf:207","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ます。\nSection 2.5.3\nではどのようにして記号代数を実行するジェネリックな数\n値演算をシステム内にて用いるかについて示します。\n2.4.1\n複素数のための表現\nジェネリックな命令を用いる単純な代わりに非現実的なプログラムの例と\nして複素数上で数値演算命令を実行するシステムを開発します。順序有りペ\nアとしての複素数に対する\n2\nつのもっともらしい表現について議論すること\nから始めます。直行形式\n(\n実数部と虚数部\n)\nと極形式\n(\n大きさと角度\n)\nです。\n44\nSection 2.4.2\nがどのようにして両方の表現がタイプタグとジェネリック命令の\n使用を通して単一のシステム内にて共存できるように作成され得るのかについ\nてを示します。\n分数と同様に、複素数は自然に順序有りペアとして表現されます。複素数\nの集合は\n2\nつの直行する軸を持つ二次元空間として考えることができます。こ\nの視点から複素数\n푧 = 푥 + 푖푦\n(\nここで\n푖\n2\n= −1\n)\nはその平面中の実数座標が\n푥\nかつ、虚数座標が\n푦\nの点として考えることが可能です。複素数の和はこの表現\nにおいて座標の和と還元できます。\nReal-part\n(푧\n1\n+ 푧\n2\n)  =\nReal-part\n(푧\n1\n)  +\nReal-part\n(푧\n2\n),\nImaginary-part\n(푧\n1\n+ 푧\n2\n)  =\nImaginary-part\n(푧\n1\n)  +\nImaginary-part\n(푧\n2\n).\n複素数をかけ算する場合、複素数を大きさと角度\n(\nFigure 2.20\n内の\n푟\nと\n퐴\n)\nと\nしての極形式の表現を用いて考える方がより自然です。\n2\nつの複素数の積は一\n方の複素数をもう一方の長さで延し次にもう一方の角度の分、回転することで\n得られるベクトルになります。\nMagnitude\n(푧\n1\n⋅ 푧\n2\n)  =\nMagnitude\n(푧\n1\n)  ⋅\nMagnitude\n(푧\n2\n),\nAngle\n(푧\n1\n⋅ 푧\n2\n)  =\nAngle\n(푧\n1\n)  +\nAngle\n(푧\n2\n).\n大きさ\n(푧\n1\n⋅ 푧\n2\n)  =\n大きさ\n(푧\n1\n)  ⋅\n大きさ\n(푧\n2\n),\n角度\n(푧\n1\n⋅ 푧\n2\n)  =\n角度\n(푧\n1\n)  +\n角度\n(푧\n2\n).\n従って複素数には\n2\nつの異なる表現が存在し、それぞれは異なる操作に適して\nいます。けれども、複素数を用いるプログラムを書いている誰かさんの視点か\n44\n実際の計算システムにおいては直行形式のほうが極形式よりも多くの場合には好ま\nれます。直行形式と極形式の間の変換における丸め誤差のためです。これがなぜ複素数\nシステムのサンプルが非現実的であるかの理由です。それにもかかわらず、この例はジ\nェネリック命令を用いたシステムの設計の明確な説明を提供し、またこの章の中で後に\n開発されるより実質的なシステムに対する良い導入部であります。\n181","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":207},{"id":"./test/fixtures/pdf/sicp.pdf:208","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Imaginary\nReal\nz = x + iy = re\niA\nA\ny\nx\nr\nFigure 2.20:\n平面上の点としての複素数\nらは、データ抽象化の主義が複素数を操作するための全ての命令はどの表現が\nコンピュータにより用いられるかに係らず存在するべきだと提案します。例え\nば直行形式にて指定される複素数の大きさを求められることはしばしば便利で\nあります。同様に極形式にて指定される複素数の実数部を決定できることも時\n折便利であります。\nそのようなシステムを設計するために、\nSection 2.1.1\nにて分数パッケージ\nの設計において従ったのと同じデータ抽象化戦略に従えます。複素数上の命令\nが\n4\nつのセレクタを使用して実装されると想定します。\nreal-part\n,\nimag-part\n,\nmagnitude\n,\nangle\nです。また複素数を構築する\n2\nつの手続を持っているとも\n想定します。\nmake-from-real-imag\nは指定された実数部と虚数部を持つ複素数\nを返し、\nmake-from-mag-ang\nは指定された大きさと角度を持つ複素数を返しま\nす。これらの手続は任意の複素数に対し同じ特性を持ちます。\n(\nmake-from-real-imag\n(\nreal-part\nz\n) (\nimag-part\nz\n))\nと\n(\nmake-from-mag-ang\n(\nmagnitude\nz\n) (\nangle\nz\n))\nproduce complex numbers that are equal to\nz\n.\nの両方が\nz\nに等しい複素数を生成します。\nこれらのコンストラクタとセレクタを用いて、\nSection 2.1.1\nで分数に対して\n行ったのと全く同様に、コンストラクタとセレクタにて指定された\n“\n抽象デー\n182","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":208},{"id":"./test/fixtures/pdf/sicp.pdf:209","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"タ\n”\nを用いて複素数上での数値演算を実装可能です。前述の式にて示されたよ\nうに、複素数の和と差は実数部と虚数部を用いることで、また複素数の積と商\nは大きさと角度を用いることで実装できます。\n(\ndefine\n(\nadd-complex\nz1\nz2\n)\n(\nmake-from-real-imag\n(+ (\nreal-part\nz1\n) (\nreal-part\nz2\n))\n(+ (\nimag-part\nz1\n) (\nimag-part\nz2\n))))\n(\ndefine\n(\nsub-complex\nz1\nz2\n)\n(\nmake-from-real-imag\n(- (\nreal-part\nz1\n) (\nreal-part\nz2\n))\n(- (\nimag-part\nz1\n) (\nimag-part\nz2\n))))\n(\ndefine\n(\nmul-complex\nz1\nz2\n)\n(\nmake-from-mag-ang\n(* (\nmagnitude\nz1\n) (\nmagnitude\nz2\n))\n(+ (\nangle\nz1\n) (\nangle\nz2\n))))\n(\ndefine\n(\ndiv-complex\nz1\nz2\n)\n(\nmake-from-mag-ang\n(/ (\nmagnitude\nz1\n) (\nmagnitude\nz2\n))\n(- (\nangle\nz1\n) (\nangle\nz2\n))))\n複素数パッケージを完了させるためには表現を選択し、コンストラクタとセレ\nクタをプリミティブな数値とリスト構造を用いて実装しなければなりません。\nこれを行うために\n2\nつ明らかな方法があります。\n“\n直行形式\n”\nの複素数はペア\n(\n実数部\n,\n虚数部\n)\nとして表現し、また極形式はペア\n(\n大きさ\n,\n角度\n)\nにて表現し\nます。どちらを選択するべきでしょうか\n?\n異なる選択を具体的にするために、二人のプログラマ、\nBen Bitdiddle\nと\nAlyssa P. Hacker\nがいると想像して下さい。二人は複素数システムのための表\n現を独立して設計します。\nBen\nは複素数を直行形式にて表現することを選択し\nました。この選択により現状として複素数を与えられた実数部と虚数部から構\n築するため、実数部と虚数部を複素数から選択するのは直接的です。大きさと\n角度を求めるためには、または複素数を与えられた大きさと角度から構築する\nために彼は三角法の関係を用いました。\n푥 = 푟 푐표푠 퐴,\n푟 =\n√\n푥\n2\n+ 푦\n2\n,\n푦 = 푟 푠푖푛 퐴,\n퐴 = 푎푟푐푡푎푛(푦, 푥),\nこれは実数部と虚数部\n(푥, 푦)\nを大きさと角度\n(푟, 퐴)\nへと関係づけます。\n45\nBen\nの表現は従って以下のセレクタとコンストラクタにより与えられます。\n45\nここで参照されたアークタンジェント関数は、\nScheme\nの\natan\n手続にて計算されま\n183","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":209},{"id":"./test/fixtures/pdf/sicp.pdf:210","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nreal-part\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nimag-part\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmagnitude\nz\n)\n(\nsqrt\n(+ (\nsquare\n(\nreal-part\nz\n))\n(\nsquare\n(\nimag-part\nz\n)))))\n(\ndefine\n(\nangle\nz\n)\n(\natan\n(\nimag-part\nz\n) (\nreal-part\nz\n)))\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n) (\ncons\nx\ny\n))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n)\n(\ncons\n(*\nr\n(\ncos\na\n)) (*\nr\n(\nsin\na\n))))\n一方、\nAlyssa\nは複素数を極形式にて表現することを選択しました。彼女にとっ\nては大きさと角度を選択するのは直接的です。しかし実数部と虚数部を得るた\nめには三角法の関係を用いねばなりません。\nAlyssa\nの表現は次のとおりです。\n(\ndefine\n(\nreal-part\nz\n) (* (\nmagnitude\nz\n) (\ncos\n(\nangle\nz\n))))\n(\ndefine\n(\nimag-part\nz\n) (* (\nmagnitude\nz\n) (\nsin\n(\nangle\nz\n))))\n(\ndefine\n(\nmagnitude\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nangle\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n(\ncons\n(\nsqrt\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\natan\ny\nx\n)))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n) (\ncons\nr\na\n))\nThe discipline of data abstraction ensures that the same implementation of\nadd-\ncomplex\n,\nsub-complex\n,\nmul-complex\n, and\ndiv-complex\nwill work with either\nBen’s representation or Alyssa’s representation.\nデータ抽象化の規律は\nadd-complex\n,\nsub-complex\n,\nmul-complex\n,\ndiv-\ncomplex\nの同じ実装が\nBen\nの表現と\nAlyssa\nの表現のどちらに対してもうま\nくいくことを保証します。\n2.4.2\nタグ付きデータ\nデータ抽象化を考え方の\n1\nつは\n“\n最小責務の原則\n”\nの適用としてです。\nSection 2.4.1\nの複素数システムの実装において、私達は\nBen\nの直行形式表現と\nすが、\n2\nつの引数\n푦\nと\n푥\nを取りタンジェントが\n푦/푥\nとなる角度を返すように定義されま\nした。引数の符号が角度の象限を決定します。\n184","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":210},{"id":"./test/fixtures/pdf/sicp.pdf:211","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Alyssa\nの極形式表現のどちらも使用することができました。セレクタとコンス\nトラクタにより形成された抽象化バリアが最後の可能な瞬間にデータオブジェ\nクトに対する具体的な表現の選択に従うことを可能にしています。従ってシス\nテム設計において最高の柔軟性を維持することができるのです。\n最小責務の原則はさらにもっと高みへと到達することができます。もし私\n達が望めば、セレクタとコンストラクタを設計した\n“\n後\n”\nにさえ表現の多義性\nを維持することが可能です。そして\nBen\nの表現\n“\nと\n”Alyssa\nの表現の両方の使\n用を選択できます。もし両方の表現が単一のシステムに含まれる場合、極形式\nのデータを直行形式のデータから識別するための何らかの方法が必要になりま\nす。そうでなけば、例えばペア\n(3, 4)\nの大きさを求めるよう尋ねられた場合に\n(\n数値を直行形式だと考えて\n)5\nと答えるべきか\n(\n数値が極形式であると考えて\n)3\nと答えるべきであるのか分かりません。この識別を直接的な方法で達成するた\nめに\ntype tag\n(\nタイプタグ\n)—\nrectangular\nまたは\npolar\nのシンボル\n—\nを各複素\n数の部分として導入します。すると複素数を操作せねばならない時にタグを用\nいてどちらのセレクタを適用するべきか決定することができます。\nタグ付きデータを操作するためにデータオブジェクトからタグと\n(\n複素数\nの場合には極形式、または直行形式の\n)\n実際のコンテンツを抽出する手続\ntype-\ntag\nと\ncontents\nを持つと想定します。またタグとコンテンツを取りタグ付き\nデータオブジェクトを生成する手続\nattach-tag\nを仮定します。これを実装す\nる直接的な方法は普通のリスト構造を用いることです。\n(\ndefine\n(\nattach-tag\ntype-tag\ncontents\n)\n(\ncons\ntype-tag\ncontents\n))\n(\ndefine\n(\ntype-tag\ndatum\n)\n(\nif\n(\npair?\ndatum\n)\n(\ncar\ndatum\n)\n(\nerror\n\"\nBad\ntagged\ndatum\n:\nTYPE-TAG\n\"\ndatum\n)))\n(\ndefine\n(\ncontents\ndatum\n)\n(\nif\n(\npair?\ndatum\n)\n(\ncdr\ndatum\n)\n(\nerror\n\"\nBad\ntagged\ndatum\n:\nCONTENTS\n\"\ndatum\n)))\nこれら手続を用いて述語\nrectangular?\nと\npolar?\nを定義し、直行形式と極形\n式のそれぞれを認識することができます。\n(\ndefine\n(\nrectangular?\nz\n) (\neq?\n(\ntype-tag\nz\n)\n'rectangular\n))\n(\ndefine\n(\npolar?\nz\n) (\neq?\n(\ntype-tag\nz\n)\n'polar\n))\n185","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":211},{"id":"./test/fixtures/pdf/sicp.pdf:212","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"タイプタグを用いて\nBen\nと\nAlyssa\nはこれで彼等のコードを変更し\n2\nつの異な\nる表現が同じシステム内にて共存させることができるようになりました。\nBen\nが複素数を構築する度に彼は直行形式であるとタグを付けます。\nAlyssa\nが複素\n数を構築する度に、彼女はそれを極形式であるとタグを付けます。加えて、\nBen\nと\nAlyssa\nは手続の名前が衝突しないように確認しなければなりません。これ\nを行う\n1\nつの方法として\nBen\nは彼の各表現手続に接尾辞\nrectangular\nを追加\nし、\nAlyssa\nは彼女の手続に対し\npolar\nを付け加えます。以下は\nBen\nの\nSection\n2.4.1\nから改正した直行形式表現です。\n(\ndefine\n(\nreal-part-rectangular\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nimag-part-rectangular\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmagnitude-rectangular\nz\n)\n(\nsqrt\n(+ (\nsquare\n(\nreal-part-rectangular\nz\n))\n(\nsquare\n(\nimag-part-rectangular\nz\n)))))\n(\ndefine\n(\nangle-rectangular\nz\n)\n(\natan\n(\nimag-part-rectangular\nz\n)\n(\nreal-part-rectangular\nz\n)))\n(\ndefine\n(\nmake-from-real-imag-rectangular\nx\ny\n)\n(\nattach-tag\n'rectangular\n(\ncons\nx\ny\n)))\n(\ndefine\n(\nmake-from-mag-ang-rectangular\nr\na\n)\n(\nattach-tag\n'rectangular\n(\ncons\n(*\nr\n(\ncos\na\n)) (*\nr\n(\nsin\na\n)))))\nそして以下は\nAlyssa\nの改訂版極形式表現です。\n(\ndefine\n(\nreal-part-polar\nz\n)\n(* (\nmagnitude-polar\nz\n) (\ncos\n(\nangle-polar\nz\n))))\n(\ndefine\n(\nimag-part-polar\nz\n)\n(* (\nmagnitude-polar\nz\n) (\nsin\n(\nangle-polar\nz\n))))\n(\ndefine\n(\nmagnitude-polar\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nangle-polar\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmake-from-real-imag-polar\nx\ny\n)\n(\nattach-tag\n'polar\n(\ncons\n(\nsqrt\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\natan\ny\nx\n))))\n(\ndefine\n(\nmake-from-mag-ang-polar\nr\na\n)\n(\nattach-tag\n'polar\n(\ncons\nr\na\n)))\n186","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":212},{"id":"./test/fixtures/pdf/sicp.pdf:213","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"各ジェネリックなセレクタは引数のタグをチェックし、そのタイプのデータを\n扱うのに適切な手続を呼び出す様に実装されます。例として、複素数の実数\n部を得る場合、\nreal-part\nはタグを確かめ\nBen\nの\nreal-part-rectangular\nか\nAlyssa\nの\nreal-part-polar\nのどちらを使うのかを決定します。どちらの場合\nでも\ncontents\nを用いて生のタグの無いデータを抽出し直交形式、または極形\n式の手続を必要に応じて呼び出します。\n(\ndefine\n(\nreal-part\nz\n)\n(\ncond\n((\nrectangular?\nz\n)\n(\nreal-part-rectangular\n(\ncontents\nz\n)))\n((\npolar?\nz\n)\n(\nreal-part-polar\n(\ncontents\nz\n)))\n(\nelse\n(\nerror\n\"\nUnknown\ntype\n:\nREAL-PART\n\"\nz\n))))\n(\ndefine\n(\nimag-part\nz\n)\n(\ncond\n((\nrectangular?\nz\n)\n(\nimag-part-rectangular\n(\ncontents\nz\n)))\n((\npolar?\nz\n)\n(\nimag-part-polar\n(\ncontents\nz\n)))\n(\nelse\n(\nerror\n\"\nUnknown\ntype\n:\nIMAG-PART\n\"\nz\n))))\n(\ndefine\n(\nmagnitude\nz\n)\n(\ncond\n((\nrectangular?\nz\n)\n(\nmagnitude-rectangular\n(\ncontents\nz\n)))\n((\npolar?\nz\n)\n(\nmagnitude-polar\n(\ncontents\nz\n)))\n(\nelse\n(\nerror\n\"\nUnknown\ntype\n:\nMAGNITUDE\n\"\nz\n))))\n(\ndefine\n(\nangle\nz\n)\n(\ncond\n((\nrectangular?\nz\n)\n(\nangle-rectangular\n(\ncontents\nz\n)))\n((\npolar?\nz\n)\n(\nangle-polar\n(\ncontents\nz\n)))\n(\nelse\n(\nerror\n\"\nUnknown\ntype\n:\nANGLE\n\"\nz\n))))\n複素数演算命令を実装するためには\nSection 2.4.1\nから同じ手続\nadd-complex\n,\nsub-complex\n,\nmul-complex\n,\ndiv-complex\nを使うことができます。なぜならそ\nれらが呼び出すセレクタはジェネリックであるためどちらの表現に対しても働\n187","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":213},{"id":"./test/fixtures/pdf/sicp.pdf:214","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"くからです。例として手続\nadd-complex\nは今でも以下のとおりです。\n(\ndefine\n(\nadd-complex\nz1\nz2\n)\n(\nmake-from-real-imag\n(+ (\nreal-part\nz1\n) (\nreal-part\nz2\n))\n(+ (\nimag-part\nz1\n) (\nimag-part\nz2\n))))\n最後に、複素数を\nBen\nの表現と\nAlyssa\nの表現のどちらを利用して構築するの\nか決定しなければなりません。妥当な選択として実数部と虚数部がある場合に\nは直行形式を用い、大きさと角度がある場合には極形式を用いて構築します。\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n(\nmake-from-real-imag-rectangular\nx\ny\n))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n)\n(\nmake-from-mag-ang-polar\nr\na\n))\n結果としての複素数システムは\nFigure 2.21\nにて表される構造を持ちます。シス\nテムは\n3\nつの関連する独立した部分に分離されます。複素数演算命令、\nAlyssa\nの極形式実装、そして\nBen\nの直行形式実装です。極形式と直行形式の実装は\nBen\nと\nAlyssa\nが別々に働きながら書かれることが可能でした。そして両者が\n抽象コンストラクタ、セレクタのインターフェイスを用いながら複素数演算手\n続を実装する第三者のプログラマにより基礎を成す表現として利用されること\nが可能です。\n各データオブジェクトはその型にてタグ付けられているので、セレクタはデー\nタに対しジェネリックな方法で操作します。これは各セレクタがそれが適用さ\nれる個々のデータの型に従う振舞を持つように定義されているということで\nす。分けられた表現を結び付けるための一般的なメカニズムについて注意して\n下さい。与えられた表現実装\n(\n例えば\nAlyssa\nの極形式パッケージ\n)\nの中では複\n素数は型の無いペア\n(\n大きさ\n,\n角度\n)\nです。ジェネリックなセレクタが極形式の\n型\n(\nタイプ\n)\nの複素数を操作する時、タグを取り中身を\nAlyssa\nのコードに渡し\nます。反対に\nAlyssa\nが通常の使用のために数値を構築する時、彼女が型でタ\nグを付けることでより高いレベルの手続により適切に認識されることができま\nす。データオブジェクトがあるレベルから別のレベルへと渡されるに従い、こ\nのタグの取り付けと除去の規律が重要な組織的戦略となります。\nSection 2.5\nに\nてこれについて学びます。\n2.4.3\nデータ適従プログラミングと付加性\nデータの型をチェックし適切な手続を呼ぶ一般的な戦略は\ndispatching on\ntype\n(\nタイプ別処理\n)\nと呼ばれる。これはシステム設計においてモジュール方\n188","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":214},{"id":"./test/fixtures/pdf/sicp.pdf:215","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"add-complex  sub-complex  mul-complex  div-complex\nPrograms that use complex numbers\nComplex-arithmetic package\nRectangular\nrepresentation\nPolar\nrepresentation\nList structure and primitive machine arithmetic\nreal-part\nimag-part\nmagnitude\nangle\nFigure 2.21:\nジェネリックな複素数演算システムの構造\n式を得るための強力な戦略です。一方で\nSection 2.4.2\nのような呼出の実装は\n2\nつの明らかな弱点が存在します。\n1\nつはジェネリックインターフェイス手続\n(\nreal-part\n,\nimag-part\n,\nmagnitude\n,\nangle\n)\nは全ての異なる表現について知っ\nていなければなりません。例えば複素数に対する新しい表現を複素数システム\nに組み入れたいとしましょう。この新しい表現を型にて識別し、次に全てのジ\nェネリックインターフェイス手続に新しい型をチェックする条項を追加し、そ\nの表現に対する適切なセレクタを適用する必要が出てくるでしょう。\nもう\n1\nつのこのテクニックの弱点は例え個々の表現が別々に設計できたと\nしても、システム全体の中でどの\n2\nつの手続も同じ名前を持たないことを保証\nせねばなりません。これがなぜ\nBen\nと\nAlyssa\nが\nSection 2.4.1\nの彼等の元の手\n続の名前を変更しなければいけないかの理由でした。\n両者の弱点の根底にある問題はジェネリックインターフェイスを実装する\nためのテクニックが\nadditive\n(\n付加的\n)\nでないことです。ジェネリックセレクタ\n手続を実装する人はこれらの手続を新しい表現がインストールされる度に変更\nせねばならず、また個々の表現を接続する人々は名前衝突が起こらぬ様に彼等\nのコードを変更せねばなりません。これらのケースのそれぞれでコードに対し\nて加えられなければならない変更は簡単ですが、それでも必ず行わねばならず、\n不自由さと障害の原因となります。これは複素数システムに対しては現時点で\nはあまり大きな問題ではありません。しかしただ\n2\nつではなく数百もの異なる\n189","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":215},{"id":"./test/fixtures/pdf/sicp.pdf:216","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"real-part\nimag-part\nmagnitude\nangle\nreal-part-polar\nimag-part-polar\nmagnitude-polar\nangle-polar\nreal-part-rectangular\nimag-part-rectangular\nmagnitude-rectangular\nangle-rectangular\nTypes\nPolar\nRectangular\nOperations\nFigure 2.22:\n複素数システムの命令表\n表現が複素数に対して存在すると仮定してみて下さい。その上どのプログラマ\nも全てのインターフェイス手続や全ての表現について知らないと想定してみて\n下さい。問題は現実的であり大規模なデータベース管理システムのようなプロ\nグラムでは必ず解決される必要があります。\n私達に必要なものはより一層のシステム設計のモジュール化のための手段\nです。これは\ndata-directed programming\n(\nデータ適従プログラミング\n)\nとして知\nられるプログラミングテクニックにより提供されます。データ適従プログラミ\nングがどのように働くかを理解するためには、異なる型の集合に対して共通な\nジェネリックな命令の集合を扱う度に、実際に予想される命令を\n1\nつの軸に、\n予想される型をもう一方の軸に持つ二次元の表に取り組み、その観察結果から\n始めます。表の項目には与えられた各引数の型に対する各命令を実装する手続\nです。前の章にて開発された複素数システムでは命令の名前、データタイプ、\n実際の手続の間の対応はジェネリックなインターフェイス手続の種々の条件節\nの間に広がっています。しかし同じ情報が\nFigure 2.22\nの中に示されるように\n1\nつのテーブルの中に組込まれることができたはずです。\nデータ適従プログラミングはそのようなテーブルと直接連携するためのプ\nログラム設計のテクニックです。以前は私達は複素数演算コードをそれぞれが\n明示的に型に従う呼び出しを行う手続の集合としての\n2\nつの表現パッケージと\n接続するメカニズムを実装しました。ここではインターフェイスを命令の名前\nと引数タイプの組み合わせをテーブルの中から調べ適用すべき正しい手続を見\nつける単一の手続として実装します。そして次にその手続を引数の中身に対し\nて適用します。これを行なえば、システムに対して新しい表現パッケージの追\n加するために既存の手続に何の変更を行う必要もありません。必要なのは表に\n新しい項目を追加することです。\n190","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":216},{"id":"./test/fixtures/pdf/sicp.pdf:217","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この計画を実装するために、\n2\nつの手続\nput\nと\nget\nを命令と型のテーブルを操\n作するために持っていると仮定します。\n•\n(put\n⟨\nop\n⟩ ⟨\ntype\n⟩ ⟨\nitem\n⟩\n)\ninstalls the\n⟨\nitem\n⟩\nin the table, indexed by the\n⟨\nop\n⟩\nand the\n⟨\ntype\n⟩\n.\n•\n(get\n⟨\nop\n⟩ ⟨\ntype\n⟩\n)\nlooks up the\n⟨\nop\n⟩\n,\n⟨\ntype\n⟩\nentry in the table and returns\nthe item found there. If no item is found,\nget\nreturns false.\n•\n(put\n⟨\nop\n⟩ ⟨\ntype\n⟩ ⟨\nitem\n⟩\n)\nは\n⟨\nitem\n⟩\nをテーブルに挿入し、\n⟨\nop\n⟩\nと\n⟨\ntype\n⟩\nで索引付けられる\n•\n(get\n⟨\nop\n⟩ ⟨\ntype\n⟩\n)\nは\n⟨\nop\n⟩\n,\n⟨\ntype\n⟩\nの項目をテーブルから探し見つかった\n項目を返す。もし見つからない場合には\nget\nは\nfalse\nを返す\n今のところは\nput\nと\nget\nが私達の言語に含まれていると仮定しましょう。\nChapter 3\n(\nSection 3.3.3\n)\nにおいてこれらと他のテーブル操作の命令をどのよ\nうに実装するかについて学びます。\nここからはデータ適従プログラミングが複素数システムにおいてどのよう\nに使用できるかについて示します。直行形式表現を開発した\nBen\nは彼が元々行\nったとおりにコードを実装しました。彼は手続の集合、つまりは\npackage\n(\nパッ\nケージ\n)\nを定義し、システムにどのように直行形式の数値を取り扱うかを教え\nるテーブルに項目を追加することで、パッケージをシステムの残りに対して接\n続します。これは以下の手続を呼び出すことにより達成されます。\n(\ndefine\n(\ninstall-rectangular-package\n)\n;; internal procedures\n(\ndefine\n(\nreal-part\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nimag-part\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n) (\ncons\nx\ny\n))\n(\ndefine\n(\nmagnitude\nz\n)\n(\nsqrt\n(+ (\nsquare\n(\nreal-part\nz\n))\n(\nsquare\n(\nimag-part\nz\n)))))\n(\ndefine\n(\nangle\nz\n)\n(\natan\n(\nimag-part\nz\n) (\nreal-part\nz\n)))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n)\n(\ncons\n(*\nr\n(\ncos\na\n)) (*\nr\n(\nsin\na\n))))\n;; interface to the rest of the system\n(\ndefine\n(\ntag\nx\n) (\nattach-tag\n'rectangular\nx\n))\n191","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":217},{"id":"./test/fixtures/pdf/sicp.pdf:218","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nput\n'real-part\n'\n(\nrectangular\n)\nreal-part\n)\n(\nput\n'imag-part\n'\n(\nrectangular\n)\nimag-part\n)\n(\nput\n'magnitude\n'\n(\nrectangular\n)\nmagnitude\n)\n(\nput\n'angle\n'\n(\nrectangular\n)\nangle\n)\n(\nput\n'make-from-real-imag\n'rectangular\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nmake-from-real-imag\nx\ny\n))))\n(\nput\n'make-from-mag-ang\n'rectangular\n(\nlambda\n(\nr\na\n) (\ntag\n(\nmake-from-mag-ang\nr\na\n))))\n'done\n)\nこの中の内部手続は\nBen\nが\nSection 2.4.1\nにて分離を行った時に彼が書いたもの\nと同じ手続であることに注意して下さい。これらをシステムの残りに接続する\nためには全く変更が必要がありません。さらに、これらの手続の定義はインス\nトールを行う手続の内部であるため、\nBen\nは直行形式パッケージの外部の他の\n手続に対して名前の衝突が起こることを全く心配する必要がありません。これ\nらをシステムの残りに対し接続するために、\nBen\nは彼の\nreal-part\n手続を命令\n名\nreal-part\nと型\n(rectangular)\nの元にインストールしました。そして他の\nセレクタに対しても同様に行いました。\n46\nこのインターフェイスはまた外部シ\nステムにより利用されるコンストラクタも定義します。\n47\nこれらは\nBen\nの内部\n定義コンストラクタと全く同じです。ただしタグを付加することが異なります。\nAlyassa\nの極形式パッケージも同様です。\n(\ndefine\n(\ninstall-polar-package\n)\n;; internal procedures\n(\ndefine\n(\nmagnitude\nz\n) (\ncar\nz\n))\n(\ndefine\n(\nangle\nz\n) (\ncdr\nz\n))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n) (\ncons\nr\na\n))\n(\ndefine\n(\nreal-part\nz\n)\n(* (\nmagnitude\nz\n) (\ncos\n(\nangle\nz\n))))\n(\ndefine\n(\nimag-part\nz\n)\n(* (\nmagnitude\nz\n) (\nsin\n(\nangle\nz\n))))\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n46\n私達はシンボル\nrectangular\nではなくリスト\n(rectangular)\nを用いました。全てが\n同じ型ではない複数の引数を伴なう命令の可能性を考慮するためです。\n47\nコンストラクタがその下にインストールされる型はリストである必要がありません。\nなぜならコンストラクタは常にある特定の型のオブジェクトを作成するために使用され\nるためです。\n192","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":218},{"id":"./test/fixtures/pdf/sicp.pdf:219","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncons\n(\nsqrt\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\natan\ny\nx\n)))\n;; interface to the rest of the system\n(\ndefine\n(\ntag\nx\n) (\nattach-tag\n'polar\nx\n))\n(\nput\n'real-part\n'\n(\npolar\n)\nreal-part\n)\n(\nput\n'imag-part\n'\n(\npolar\n)\nimag-part\n)\n(\nput\n'magnitude\n'\n(\npolar\n)\nmagnitude\n)\n(\nput\n'angle\n'\n(\npolar\n)\nangle\n)\n(\nput\n'make-from-real-imag\n'polar\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nmake-from-real-imag\nx\ny\n))))\n(\nput\n'make-from-mag-ang\n'polar\n(\nlambda\n(\nr\na\n) (\ntag\n(\nmake-from-mag-ang\nr\na\n))))\n'done\n)\nBen\nと\nAlyssa\nの両者が今でも御互いに同じ名前\n(\n例えば\nreal-part\n)\nにて定義\nされた彼等の元々の手続を使用してようとも、これらの定義は今では異なる手\n続の内部定義\n(\nSection 1.1.8\n参照\n)\nです。従って名前の衝突は起こりません。\n複素数演算のセレクタは\napply-generic\nと呼ばれる普遍的な\n“operation”\n手続を用いてテーブルにアクセスします。これはジェネリックな命令を引数に\n対して適用します。\napply-generic\nは命令の名前と引数の型の下に表を調べ結\n果としての手続が存在すれば適用します。\n48\n(\ndefine\n(\napply-generic\nop\n.\nargs\n)\n(\nlet\n((\ntype-tags\n(\nmap\ntype-tag\nargs\n)))\n(\nlet\n((\nproc\n(\nget\nop\ntype-tags\n)))\n(\nif\nproc\n(\napply\nproc\n(\nmap\ncontents\nargs\n))\n(\nerror\n48\napply-generic\nは\nExercise 2.20\nで説明したドット付き末尾記法を用います。異なるジ\nェネリック命令は異なる数の引数を取る場合が考えられるためです。\napply-generic\nで\nは\nop\nがその値として\napply-generic\nの第一引数を持ち、\nargs\nはその値として残りの引\n数のリストを持ちます。\napply-generic\nはまたプリミティブな手続\napply\nを用います。これは\n2\nつの引数、手\n続とリストを取ります。\napply\nはリストの要素を引数として手続を適用します。例えば、\n(\napply\n+ (\nlist\n1 2 3 4))\nは\n10\nを返します。\n193","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":219},{"id":"./test/fixtures/pdf/sicp.pdf:220","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"\"\nNo\nmethod\nfor\nthese\ntypes\n:\nAPPLY-GENERIC\n\"\n(\nlist\nop\ntype-tags\n))))))\napply-generic\nを用いることで、私達のジェネリックなセレクタを以下のよう\nに定義することができます。\n(\ndefine\n(\nreal-part\nz\n) (\napply-generic\n'real-part\nz\n))\n(\ndefine\n(\nimag-part\nz\n) (\napply-generic\n'imag-part\nz\n))\n(\ndefine\n(\nmagnitude\nz\n) (\napply-generic\n'magnitude\nz\n))\n(\ndefine\n(\nangle\nz\n) (\napply-generic\n'angle\nz\n))\nもし新しい表現がシステムに追加されたとしてもこれらが全く変更されないこ\nとに注意して下さい。\nまたテーブルからコンストラクタを抽出することもできます。コンストラ\nクタはパッケージの外部プログラムにより使用でき、実数部と虚数部か大きさ\nと角度から複素数を作ります。\nSection 2.4.2\nにあるとおり、実数部と虚数部が\nある場合には直交形式で構築し、大きさと角度がある場合には極形式にて構築\nします。\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n((\nget\n'make-from-real-imag\n'rectangular\n)\nx\ny\n))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n)\n((\nget\n'make-from-mag-ang\n'polar\n)\nr\na\n))\nExercise 2.73:\nSection 2.3.2\nは記号微分を行うプログラムについて\n説明した。\n(\ndefine\n(\nderiv\nexp\nvar\n)\n(\ncond\n((\nnumber?\nexp\n) 0)\n((\nvariable?\nexp\n)\n(\nif\n(\nsame-variable?\nexp\nvar\n) 1 0))\n((\nsum?\nexp\n)\n(\nmake-sum\n(\nderiv\n(\naddend\nexp\n)\nvar\n)\n(\nderiv\n(\naugend\nexp\n)\nvar\n)))\n((\nproduct?\nexp\n)\n(\nmake-sum\n(\nmake-product\n(\nmultiplier\nexp\n)\n(\nderiv\n(\nmultiplicand\nexp\n)\nvar\n))\n(\nmake-product\n194","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":220},{"id":"./test/fixtures/pdf/sicp.pdf:221","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nderiv\n(\nmultiplier\nexp\n)\nvar\n)\n(\nmultiplicand\nexp\n))))\n⟨\nmore rules can be added here\n⟩\n(\nelse\n(\nerror\n\"\nunknown\nexpression\ntype\n:\nDERIV\n\"\nexp\n))))\nこのプログラムを微分する式のタイプにより呼出を行っていると\n解釈することもできる。このシチュエーションではデータの\n“\nタイ\nプタグ\n”\nが代数演算子の記号\n(\n例えば\n+\n)\nであり実行される命令は\nderiv\nである。このプログラムを基本の微分手続を書き直すこと\nでデータ適従プログラミングスタイルに変換することができる。\n(\ndefine\n(\nderiv\nexp\nvar\n)\n(\ncond\n((\nnumber?\nexp\n) 0)\n((\nvariable?\nexp\n)\n(\nif\n(\nsame-variable?\nexp\nvar\n) 1 0))\n(\nelse\n((\nget\n'deriv\n(\noperator\nexp\n))\n(\noperands\nexp\n)\nvar\n))))\n(\ndefine\n(\noperator\nexp\n) (\ncar\nexp\n))\n(\ndefine\n(\noperands\nexp\n) (\ncdr\nexp\n))\na\n上で何が行われたのか説明せよ。なぜ手続\nnumber?\nと\nvariable?\nをデータ適従呼出に吸収することができないのか\n?\nb\n和と積の微分のための手続とそれらを上記のプログラムで使\n用されたテーブルにインストールする補助コードを書け。\nc\n貴方の好きな追加の微分ルール、例えば指数に対する物\n(\nExercise 2.56\n)\nを選択し、このデータ適従システムにインス\nトールせよ。\nd\nこの単純な代数操作において、式の型はそれを一緒に束縛す\nる代数演算子である。しかし手続を逆の向きに索引付けし\nderiv\nの呼出行を以下のようにした場合、\n((\nget\n(\noperator\nexp\n)\n'deriv\n) (\noperands\nexp\n)\nvar\n)\n微分システムへの対応する変更は何が必要か\n?\nExercise 2.74:\nInsatiable Enterprises, Inc.(\n強欲エンタープライズ\n社\n)\nは高いレベルで非集中化された数多くの独立事業所を世界中に\n195","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":221},{"id":"./test/fixtures/pdf/sicp.pdf:222","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"抱える複合企業である。社のコンピュータ施設は接続されたばか\nりであるが、賢いネットワーク接続計画を用いてネットワーク全\n体がどのユーザに対しても\n1\n台のコンピュータとして現れる。強\n欲社の社長は初めてネットワークの機能を用いて事業所ファイル\nから管理者情報を取得しようと試みたが、全ての事業所ファイル\nは\nScheme\nのデータ構造として実装されているのにも係らず、使\n用されている個々のデータ構造は事業所の間で異なっていること\nに狼狽した。事業所長の会議が大急ぎで開催され既存の事業所の\n自立性を保ちつつ本社の要求を満足できるファイル統合の戦略を\n探すことになった。\nそのような戦略がデータ適従戦略を用いてどのように実装できる\nか示せ。例として各事業所の職員記録は単一のファイルから成る\n従業員の名前をキーにしたレコードの集合であると想定せよ。集\n合の構造は事業所毎に変わる。さらに各従業員のレコードはそれ\n自身が集合\n(\n事業所毎で異なる構造\n)\nであり\naddress\nと\nsalary\nの\nような識別子の下で鍵付けられた情報を含んでいる。具体的には\na\n本社のために指定された従業員のレコードを指定された職員\n記録ファイルから取得する\nget-record\n手続を実装せよ。手\n続は任意の事業所のファイルに適用できなければならない。\n個々の事業所のファイルがどのように構造化されねばならな\nいか説明せよ。具体的にはどんな型の情報が提供されねばな\nらないか\nb\n本社のために任意の事業所の職員記録ファイルから与えられ\nた職員記録から給与情報を返す\nget-salary\n手続を実装せよ。\n記録はこの操作が動くようどのように構造化されねばならな\nいか\n?\nc\n本社のために\nfind-employee-record\n手続を実装せよ。これ\nは全ての事業所のファイルに対し与えられた従業員のレコー\nドを探し、レコードを返さねばならない。この手続が引数と\nして従業員の名前と全ての事業所のファイルのリストを与え\nられると仮定せよ。\nd\n強欲社が新しい会社を吸収した時、どんな変更が新しい職員\n情報を中央システムに受け入れるために必要であるか\n?\n196","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":222},{"id":"./test/fixtures/pdf/sicp.pdf:223","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"メッセージパッシング\nデータ適従プログラミングの鍵となる考えはプログラム中のジェネリック\nな命令を\nFigure 2.22\nの様な命令と型のテーブルを明示的に処理することで扱\nうことです。\nSection 2.4.2\nで用いたプログラミングスタイル要求された型に基\nく呼出を各命令がそれ自身の呼出の世話を行うことで組織化しました。実際に\nこれは命令と型のテーブルを、テーブルの行を表す各ジェネリックな操作手続\nを用いて行に分解します。\n代替的な実装戦略はテーブルを列に分解し、データ型に基き呼び出しを行\nう\n“\n知的な命令\n”\nを用いる代わりに、命令名に基づき呼び出しを行う\n“\n知的な\nデータオブジェクト\n”\nを用いて動かすものです。直行形式の複素数の様なデー\nタオブジェクトが入力として必要な命令名を取り指定された命令を実行する\nように準備を行うことで行うことができます。そのような規律の下では\nmake-\nfrom-real-imag\nは以下のように書くことができます。\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n(\ndefine\n(\ndispatch\nop\n)\n(\ncond\n((\neq?\nop\n'real-part\n)\nx\n)\n((\neq?\nop\n'imag-part\n)\ny\n)\n((\neq?\nop\n'magnitude\n)\n(\nsqrt\n(+ (\nsquare\nx\n) (\nsquare\ny\n))))\n((\neq?\nop\n'angle\n) (\natan\ny\nx\n))\n(\nelse\n(\nerror\n\"\nUnknown\nop\n:\nMAKE-FROM-REAL-IMAG\n\"\nop\n))))\ndispatch\n)\n対応する\napply-generic\n手続はジェネリックな命令を引数に適用しますが、こ\nこでは単純に命令の名前をデータオブジェクトに与えオブジェクトに仕事を行\nわせます。\n49\n(\ndefine\n(\napply-generic\nop\narg\n) (\narg\nop\n))\nmake-from-real-imag\nにより返される値は手続\n—\n内部手続\ndispatch\nのである\nことに注意して下さい。これが\napply-generic\nが命令に実行を要求した時に起\n動される手続です。\nこのプログラミングスタイルは\nmessage passing\n(\nメッセージパッシング\n)\nと\n呼ばれます。その名前はデータオブジェクトが要求された命令の名前を\n“\nメッ\n49\nこの構造の\n1\nつの制約は一引数のジェネリック手続のみを許容することです。\n197","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":223},{"id":"./test/fixtures/pdf/sicp.pdf:224","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"セージ\n”\nとして受け取った要素であるというイメージから来ています。私達\nは既にメッセージパッシングの例を\nSection 2.1.3\nにて見ています。その時は\ncons\n,\ncar\n,\ncdr\nがデータオブジェクト無し、手続のみでどのように定義され得\nるかを学びました。ここではメッセージパッシングは数学上のトリックではな\nくジェネリック命令を用いてシステムを構造化するのに便利なテクニックであ\nることを学びます。この章の残りではメッセージパッシングではなくデータ適\n従プログラミングの使用を続け、全般的な数値演算操作について議論します。\nそしてそれがシミュレーションプログラムの構造化に対して強力なツールに成\nり得ることを学びます。\nExercise 2.75:\nコンストラクタ\nmake-from-mag-ang\nをメッセージ\nパッシングスタイルにて実装せよ。この手続は上で与えられた\nmake-from-real-imag\nと同様でなければならない。\nExercise 2.76:\nジェネリックな命令を用いた巨大システムが発展す\nるにつれ、新しい型のデータオブジェクトや命令が必要となるか\nもしれない。\n3\nつの戦略\n—\nジェネリック命令の明示的呼出、デー\nタ適従スタイル、メッセージパッシング\n—\nのそれぞれに対して新\nしい型や命令を追加するために必要なシステムに対する変更につ\nいて説明せよ。どの構造化が新しい型が良く追加されるシステム\nに対して最も適切であるか\n?\nどれが新しい命令が良く追加されね\nばならぬシステムに対して最も適切であるか\n?\n2.5\nジェネリック命令を持つシステム\n前の節ではデータオブジェクトが\n2\nつ以上の方法で表現されるシステムを\nどのように設計するかについて学んだ。鍵となる考えはデータ操作を指定する\nコードをいくつかの表現に対しジェネリックなインターフェイス手続を用いて\nリンクすることでした。ここではこれと同じ考えを異なる表現上のジェネリッ\nクな命令の定義のみでなく、異なる種類の引数上のジェネリックな命令を定義\nするためにどのように用いるかについて学びます。私達は既にいくつかの数値\n演算命令の異なるパッケージを見てきました。言語内に構築されたプリミティ\nブ数値演算\n(\n+\n,\n-\n,\n*\n,\n/\n)\n、\nSection 2.1.1\nの分数演算\n(\nadd-rat\n,\nsub-rat\n,\nmul-rat\n,\ndiv-rat\n)\n、\nSection 2.4.3\nで実装した複素数演算です。ここではデータ適従のテ\nクニックを用いて私達がこれまでに構築した全ての数値演算パッケージを内蔵\nする数値演算のパッケージを構築します。\n198","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":224},{"id":"./test/fixtures/pdf/sicp.pdf:225","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"add  sub  mul  div\nadd-complex\nmul-complex\nsub-complex\ndiv-complex\nPrograms that use numbers\nGeneric arithmetic package\nComplex arithmetic\nRectangular\nPolar\nsub-rat\ndiv-rat\nadd-rat\nmul-rat\nRational\narithmetic\nOrdinary\narithmetic\nList structure and primitive machine arithmetic\n+ -- \n*\n/\nFigure 2.23:\nジェネリックな数値演算システム\nFigure 2.23\nは私達が構築するシステムの構造を示しています。抽象化バリアに\n注目して下さい。\n“\n数値\n”\nを扱う第三者の視点からはそこにあるのはどの種類の\n数値が提供されても単一の手続\nadd\nです。\nadd\nはジェネリックインターフェイ\nスの部分で別々の実数演算、分数演算、複素数演算のパッケージに、数値を使\n用するプログラムから統一的なアクセスを可能にします。\n(\n複素数の様な\n)\n任意\nの個別数値演算パッケージはそれ自身が\n(\n直行形式と極形式の様な\n)\n異なる表\n現のために設計されたパッケージを結合する\n(\nadd-complex\nの様な\n)\nジェネリ\nックな手続を通してアクセスできます。さらに、システムの構造は付加的なた\nめ個々の数値演算パッケージは別々に設計することが可能で、それらを結合し\nてジェネリックな数値演算システムを生成できます。\n2.5.1\nジェネリックな数値演算命令\nジェネリックな数値演算命令の設計タスクはジェネリックな複素数命令を\n設計するのと同様です。例えば、実数上での通常の加算のプリミティブ\n+\n、分\n数上の\nadd-rat\nや複素数上の\nadd-complex\nのように振る舞うジェネリックな\n加算手続\nadd\nを持ちたいとします。\nadd\nと他のジェネリックな数値演算命令\n199","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":225},{"id":"./test/fixtures/pdf/sicp.pdf:226","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を\nSection 2.4.3\nにて複素数に対するジェネリックなセレクタを実装するのに用\nいたのと同じ戦略に従うことで実装することが可能です。全ての種類の数値に\nタイプタグをアタッチすることでジェネリック手続にその引数のデータタイプ\nに従って適切なパッケージを呼び出す理由とします。\nジェネリックな数値演算は以下のように定義されます。\n(\ndefine\n(\nadd\nx\ny\n) (\napply-generic\n'add\nx\ny\n))\n(\ndefine\n(\nsub\nx\ny\n) (\napply-generic\n'sub\nx\ny\n))\n(\ndefine\n(\nmul\nx\ny\n) (\napply-generic\n'mul\nx\ny\n))\n(\ndefine\n(\ndiv\nx\ny\n) (\napply-generic\n'div\nx\ny\n))\nordinary\n(\n通常の\n)\n数値を扱うためのパッケージをインストールすることで始め\nます。これは私達の言語のプリミティブな数値のことです。これらにシンボル\nscheme-number\nでタグを付けます。このパッケージ内の数値演算命令はプリミ\nティブな数値演算手続です。\n(\nそのためタグの無い数値を扱うために拡張手続\nを定義する必要はありません\n)\n。これらの命令はそれぞれが\n2\nつの引数を取る\nためリスト\n(scheme-number scheme-number)\nを鍵にしてテーブルにインスト\nールされます。\n(\ndefine\n(\ninstall-scheme-number-package\n)\n(\ndefine\n(\ntag\nx\n) (\nattach-tag\n'scheme-number\nx\n))\n(\nput\n'add\n'\n(\nscheme-number\nscheme-number\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(+\nx\ny\n))))\n(\nput\n'sub\n'\n(\nscheme-number\nscheme-number\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(-\nx\ny\n))))\n(\nput\n'mul\n'\n(\nscheme-number\nscheme-number\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(*\nx\ny\n))))\n(\nput\n'div\n'\n(\nscheme-number\nscheme-number\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(/\nx\ny\n))))\n(\nput\n'make\n'scheme-number\n(\nlambda\n(\nx\n) (\ntag\nx\n)))\n'done\n)\nscheme-number\nパッケージのユーザは\n(\nタグ付きの\n)\n普通の数値を手続を用い\nて作成します。\n(\ndefine\n(\nmake-scheme-number\nn\n)\n((\nget\n'make\n'scheme-number\n)\nn\n))\nさてこのジェネリック数値演算システムのフレームワークが準備できたので\n新しい種類の数値も容易に含めることができます。ここに分数演算を実行する\n200","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":226},{"id":"./test/fixtures/pdf/sicp.pdf:227","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"パッケージがあります。付加的あることの利点として\nSection 2.1.1\nの分数コー\nドをパッケージ内の内部手続として変更無しに利用できることに注目して下\nさい。\n(\ndefine\n(\ninstall-rational-package\n)\n;; internal procedures\n(\ndefine\n(\nnumer\nx\n) (\ncar\nx\n))\n(\ndefine\n(\ndenom\nx\n) (\ncdr\nx\n))\n(\ndefine\n(\nmake-rat\nn\nd\n)\n(\nlet\n((\ng\n(\ngcd\nn\nd\n)))\n(\ncons\n(/\nn\ng\n) (/\nd\ng\n))))\n(\ndefine\n(\nadd-rat\nx\ny\n)\n(\nmake-rat\n(+ (* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\nnumer\ny\n) (\ndenom\nx\n)))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\nsub-rat\nx\ny\n)\n(\nmake-rat\n(- (* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\nnumer\ny\n) (\ndenom\nx\n)))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\nmul-rat\nx\ny\n)\n(\nmake-rat\n(* (\nnumer\nx\n) (\nnumer\ny\n))\n(* (\ndenom\nx\n) (\ndenom\ny\n))))\n(\ndefine\n(\ndiv-rat\nx\ny\n)\n(\nmake-rat\n(* (\nnumer\nx\n) (\ndenom\ny\n))\n(* (\ndenom\nx\n) (\nnumer\ny\n))))\n;; interface to rest of the system\n(\ndefine\n(\ntag\nx\n) (\nattach-tag\n'rational\nx\n))\n(\nput\n'add\n'\n(\nrational\nrational\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nadd-rat\nx\ny\n))))\n(\nput\n'sub\n'\n(\nrational\nrational\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nsub-rat\nx\ny\n))))\n(\nput\n'mul\n'\n(\nrational\nrational\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nmul-rat\nx\ny\n))))\n(\nput\n'div\n'\n(\nrational\nrational\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(\ndiv-rat\nx\ny\n))))\n(\nput\n'make\n'rational\n(\nlambda\n(\nn\nd\n) (\ntag\n(\nmake-rat\nn\nd\n))))\n201","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":227},{"id":"./test/fixtures/pdf/sicp.pdf:228","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"'done\n)\n(\ndefine\n(\nmake-rational\nn\nd\n)\n((\nget\n'make\n'rational\n)\nn\nd\n))\n複素数を扱うために同様のパッケージをタグ\ncomplex\nを用いてインストール\nできます。パッケージを作る際に、直行形式と極形式のパッケージにて定義さ\nれた\nmake-from-real-imag\nと\nmake-from-mag-ang\nの命令をテーブルから抽出\nします。付加性が内部命令として同じ\nSection 2.4.1\nの手続\nadd-complex\n,\nsub-\ncomplex\n,\nmul-complex\n,\ndiv-complex\nを使用することを可能にします。\n(\ndefine\n(\ninstall-complex-package\n)\n;; imported procedures from rectangular and polar packages\n(\ndefine\n(\nmake-from-real-imag\nx\ny\n)\n((\nget\n'make-from-real-imag\n'rectangular\n)\nx\ny\n))\n(\ndefine\n(\nmake-from-mag-ang\nr\na\n)\n((\nget\n'make-from-mag-ang\n'polar\n)\nr\na\n))\n;; internal procedures\n(\ndefine\n(\nadd-complex\nz1\nz2\n)\n(\nmake-from-real-imag\n(+ (\nreal-part\nz1\n) (\nreal-part\nz2\n))\n(+ (\nimag-part\nz1\n) (\nimag-part\nz2\n))))\n(\ndefine\n(\nsub-complex\nz1\nz2\n)\n(\nmake-from-real-imag\n(- (\nreal-part\nz1\n) (\nreal-part\nz2\n))\n(- (\nimag-part\nz1\n) (\nimag-part\nz2\n))))\n(\ndefine\n(\nmul-complex\nz1\nz2\n)\n(\nmake-from-mag-ang\n(* (\nmagnitude\nz1\n) (\nmagnitude\nz2\n))\n(+ (\nangle\nz1\n) (\nangle\nz2\n))))\n(\ndefine\n(\ndiv-complex\nz1\nz2\n)\n(\nmake-from-mag-ang\n(/ (\nmagnitude\nz1\n) (\nmagnitude\nz2\n))\n(- (\nangle\nz1\n) (\nangle\nz2\n))))\n;; interface to rest of the system\n(\ndefine\n(\ntag\nz\n) (\nattach-tag\n'complex\nz\n))\n(\nput\n'add\n'\n(\ncomplex\ncomplex\n)\n(\nlambda\n(\nz1\nz2\n) (\ntag\n(\nadd-complex\nz1\nz2\n))))\n(\nput\n'sub\n'\n(\ncomplex\ncomplex\n)\n(\nlambda\n(\nz1\nz2\n) (\ntag\n(\nsub-complex\nz1\nz2\n))))\n(\nput\n'mul\n'\n(\ncomplex\ncomplex\n)\n(\nlambda\n(\nz1\nz2\n) (\ntag\n(\nmul-complex\nz1\nz2\n))))\n202","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":228},{"id":"./test/fixtures/pdf/sicp.pdf:229","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"3  4\ncomplex  rectangular\nFigure 2.24:\n直行形式による\n3 + 4푖\nの表現\n(\nput\n'div\n'\n(\ncomplex\ncomplex\n)\n(\nlambda\n(\nz1\nz2\n) (\ntag\n(\ndiv-complex\nz1\nz2\n))))\n(\nput\n'make-from-real-imag\n'complex\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nmake-from-real-imag\nx\ny\n))))\n(\nput\n'make-from-mag-ang\n'complex\n(\nlambda\n(\nr\na\n) (\ntag\n(\nmake-from-mag-ang\nr\na\n))))\n'done\n)\n複素数パッケージの外側のプログラムは複素数を実数部と虚数部からでも大き\nさと角度からでも構築することができます。元は直行形式と極形式のパッケー\nジ内にて定義された内在する手続がどのように複素数パッケージにエクスポー\nトされているか、そしてそこからどのようにして外部の世界へとエクスポート\nされているかについて注意して下さい。\n(\ndefine\n(\nmake-complex-from-real-imag\nx\ny\n)\n((\nget\n'make-from-real-imag\n'complex\n)\nx\ny\n))\n(\ndefine\n(\nmake-complex-from-mag-ang\nr\na\n)\n((\nget\n'make-from-mag-ang\n'complex\n)\nr\na\n))\nここで私達が行ったのは\n2\nつのレベルのタグシステムです。典型的な複素数、\n直交形式で\n3 + 4푖\nのような物は\nFigure 2.24\nで示されるように表現されます。外\n型のタグ\n(\ncomplex\n)\nは数値を複素数パッケージへと導きます。複素数パッケー\nジに入れば、次のタグ\n(\nrectangular\n)\nが数値を直行形式パッケージへと導きま\nす。巨大で複雑なシステムでは多くのレベルが存在するかもしれず、それぞれ\nはジェネリックな命令を用いて次へと接続されます。データオブジェクトが\n“\n下方\n”\nへ渡されるにつれ、適切なパッケージへ導く外側のタグは\n(\ncontents\nを\n適用することで\n)\n取り去られ、次のレベルのタグ\n(\nもし存在すれば\n)\nがさらなる\n呼出のために使用されるため見えるようになります。\n上記のパッケージでは、\nadd-rat\n,\nadd-complex\n,\nそれに他の数値演算手続を全\n203","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":229},{"id":"./test/fixtures/pdf/sicp.pdf:230","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"く元々書かれた状態で利用しました。しかし、これらの定義が異なるインスト\nール手続の内部となれば直ぐに、お互いから識別可能である名前にする必要は\n無くなります。単純に両者のパッケージにて\nadd\n,\nsub\n,\nmul\n,\ndiv\nと名付けるこ\nとが可能になります。\nExercise 2.77:\nLouis Reasoner\nは\nz\nが\nFigure 2.24\nで示されるオブジ\nェクトである場合に式\n(magnitude z)\nを評価しようとした。驚い\nたことに、答の\n5\nの代わりに彼が受け取ったのは\napply-generic\nからのエラーメッセージで、型\n(complex)\n上に\nmagnitude\n命令の\n手段が存在しないと言う。彼はこの応答を\nAlyssa P. Hacker\nに見\nせた所、彼女は\n“\n問題は複素数セレクタが\ncomplex\nの数値に対し\nて定義されていない、\npolar\nと\nrectangular\nの数値に対してのみ\n行われている。これを動かすためにしなければならないことは以\n下を\ncomplex\nパッケージに追加することだ。\n”\nと述べた。\n(\nput\n'real-part\n'\n(\ncomplex\n)\nreal-part\n)\n(\nput\n'imag-part\n'\n(\ncomplex\n)\nimag-part\n)\n(\nput\n'magnitude\n'\n(\ncomplex\n)\nmagnitude\n)\n(\nput\n'angle\n'\n(\ncomplex\n)\nangle\n)\nこれでなぜ動くのか詳細を説明せよ。例として式\n(magnitude z)\nを\nz\nが\nFigure 2.24\nにて示されるデータオブジェクトの場合に評\n価する時、呼び出される全ての手続をトレースせよ具体的には、\napply-generic\nは何回起動されるか\n?\nどの手続が各ケースに対し\nて呼び出されるか\n?\nExercise 2.78:\nscheme-number\nパッケージの内部手続は本質的にプ\nリミティブな手続\n+\n,\n-\n,\nその他の呼出し以上の物ではない。言語の\nプリミティブを直接使用することはできない。私達のタイプタグ\nシステムが各データオブジェクトに対し型付けられていることを\n要件とするためである。しかし実際には全ての\nLisp\n実装は型シス\nテムを持っており、内部にて使用している。\nsymbol?\nや\nnumber?\nの\nようなプリミティブな述語はデータオブジェクトが特定の型を持\nつか決定する。\nSection 2.4.2\nの\ntype-tag\n,\ncontents\n, and\nattach-\ntag\nの定義を変更し私達のジェネリックシステムが\nScheme\nの内部\n型システムの利点を得るようにせよ。これは言い替えれば、シス\nテムは以前と同じように動作する必要があるが、ただし普通の数\n値はその\ncar\nがシンボル\nscheme-number\nであるペアでなく、単純\nに\nScheme\nの数値として表現されるようにせよ。\n204","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":230},{"id":"./test/fixtures/pdf/sicp.pdf:231","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.79:\n2\nつの数値の等値関係をテストするジェネリックな\n等値の述語\nequ?\nを定義し、ジェネリック数値演算パッケージにイ\nンストールせよ。この命令は通常の数値、分数、複素数に対しても\n働くこと。\nExercise 2.80:\n引数が\n0\nであるかテストするジェネリックな述語\n=zero?\nを定義しジェネリック数値演算パッケージにインストール\nせよ。この命令は通常の数値、分数、複素数に対しても働くこと。\n2.5.2\n異なる型のデータを組み合わす\n通常の数値、複素数、分数、そして開発するだろう任意の他の型の数値を\n包括する統一数値演算システムをどのように定義するかについて学びました。\nしかし私達は重要な問題を無視してきました。今まで私達が定義した命令は異\nなるデータの型を完全に独立しているとして扱ってきました。従って追加すべ\nき分かれたパッケージが、例えば\n2\nつの普通の数値や\n2\nつの複素数が存在しま\nす。私達がまだ考慮していないことは型の境界を渡る命令を定義することには\n意義があるという事実です。例えば複素数と実数の加算です。私達はこれまで\nプログラムの間にバリアを築くために大きな努力をしてきました。それが分離\nして開発、理解されることを可能にするためでした。私達は型を渡る命令をあ\nる程度注意深くコントロールされた手段にて導入したいと思います。そうする\nことで私達のモジュール境界を重大な侵害が起こらないようにそれらをサポー\nトすることができるようにです。\nクロスタイプ\n(\n型を渡る\n)\n命令を扱う\n1\nつの方法は命令が有効な型の可能\nな組み合わせそれぞれに対して異なる手続を設計することです。例えば複素\n数パッケージを拡張し、それが複素数と実数の加算を提供し、タグ\n(complex\nscheme-number)\nを用いてテーブルにインストールするようにします。\n50\n;; to be included in the complex package\n(\ndefine\n(\nadd-complex-to-schemenum\nz\nx\n)\n(\nmake-from-real-imag\n(+ (\nreal-part\nz\n)\nx\n) (\nimag-part\nz\n)))\n(\nput\n'add\n'\n(\ncomplex\nscheme-number\n)\n(\nlambda\n(\nz\nx\n) (\ntag\n(\nadd-complex-to-schemenum\nz\nx\n))))\n50\n私達はまたほとんど同一の手続を型\n(scheme-number complex)\nを扱うために提供し\nなければなりません。\n205","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":231},{"id":"./test/fixtures/pdf/sicp.pdf:232","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"このテクニックはうまく行きますが、面倒です。このようなシステムでは新し\nい型を導入するコストはその型のための手続のパッケージを構築するだけでな\nく、クロスタイプの命令を実装する手続の構築とインストールに及びます。こ\nれは簡単にその型自身の命令を定義するために必要なものよりより多くのコー\nドとなるでしょう。この手法はまた分かれたパッケージを付加的に接続する能\n力を弱めたり、最低でも個々のパッケージの実装者が他のパッケージの考慮を\nしなければならない範囲を制約する能力をダメにしてしまいます。例えば、上\nの例では複素数と実数上の混合命令の扱いが複素数パッケージの責任となるの\nは妥当に見えます。しかし分数と複素数の接続においては複素数パッケージで\n行われるかもしれないし、分数パッケージかもしれないし、これらの\n2\nつのパ\nッケージから抽出した命令を用いる何らかの第三者パッケージかもしれませ\nん。パッケージ間の区分上における整合性のポリシーの形式化が、多くのパッ\nケージと多くのクロスタイプ命令を伴なうシステム設計において計り知れなく\nなってしまいます。\n型の強制\n完全に依存しない型達上にて振る舞う完全に依存しない命令群が一般的な\n状況においては明示的にクロスタイプ命令を実装することは、面倒かもしれま\nせんが、人が望む最高の物かもしれません。幸運なことに私達は通常、私達の\n型システム内の潜在的に存在するだろう付加的な構造の利点を用いることによ\nりより良く行うことが可能です。時折、異なるデータの型は完全には独立して\nおらず、ある型のオブジェクトが他の型であるように見られる場合が複数存在\nするでしょう。この過程は\ncoercion\n(\n強制\n)\nと呼ばれます。例えばもし私達が算\n術上、実数と複素数を合成するよう求められた場合に、私達は実数を虚数部が\n0\nの複素数だと見做すことができます。これはこの問題を\n2\nつの複素数の合成\nへと変換し、複素数パッケージにより通常の方法にて取り扱うことが可能にな\nります。\n一般的に、ある型のオブジェクトを等価な他の型のオブジェクトに変換す\nる強制手続を設計することでこの考えを実装することができます。以下は典型\n的な強制手続です。これは与えられた普通の数値\n(\n実数\n)\nを実数部とゼロである\n虚数部を持つ複素数に変換します。\n(\ndefine\n(\nscheme-number->complex\nn\n)\n(\nmake-complex-from-real-imag\n(\ncontents\nn\n) 0))\nこれらの強制手続を\n2\nつの型の名前により索引付けした特別な強制テーブルに\nインストールします。\n206","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":232},{"id":"./test/fixtures/pdf/sicp.pdf:233","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nput-coercion\n'scheme-number\n'complex\nscheme-number->complex\n)\n(\nこのテーブルを操作するために手続\nput-coercion\nと\nget-coercion\nが存在す\nると仮定します\n)\n。一般にこのテーブルの枠のいくつかは空になります。全て\nの型の任意のデータオブジェクトを全ての他の型へと強制することは一般には\n不可能です。例えば任意の複素数を実数に強制することはできません。そのた\nめ普遍的な\ncomplex->scheme-number\n手続はテーブルに含まれることはありま\nせん。\n強制テーブルが準備されれば、\nSection 2.4.3\nの\napply-generic\n手続を変更\nすることで統一的な作法で強制を取り扱うことができます。命令を適用するよ\nう求められた時、最初にその命令が引数の型に対して定義されているかどうか\nを以前と同様にチェックします。もしそうであれば命令と型のテーブルで見つ\nかった手続を呼び出します。そうでなければ強制を試みます。単純化のために、\n2\nつの引数を伴う場合のみについて考えることにします。\n51\n強制テーブルをチ\nェックし、最初の型のオブジェクトが\n2\nつ目の型に強制できるか確認します。\nもしそうであれば、最初の引数を強制し、命令の試行を再び行います。もし最\n初の型のオブジェクトが一般に\n2\nつ目の型に強制できない場合、逆に\n2\nつ目の\n引数を\n1\nつ目の引数の型に強制できるか試します。最後にどちらの型も他方の\n型に強制できない場合、諦めます。以下がこの手続です。\n(\ndefine\n(\napply-generic\nop\n.\nargs\n)\n(\nlet\n((\ntype-tags\n(\nmap\ntype-tag\nargs\n)))\n(\nlet\n((\nproc\n(\nget\nop\ntype-tags\n)))\n(\nif\nproc\n(\napply\nproc\n(\nmap\ncontents\nargs\n))\n(\nif\n(= (\nlength\nargs\n) 2)\n(\nlet\n((\ntype1\n(\ncar\ntype-tags\n))\n(\ntype2\n(\ncadr\ntype-tags\n))\n(\na1\n(\ncar\nargs\n))\n(\na2\n(\ncadr\nargs\n)))\n(\nlet\n((\nt1->t2\n(\nget-coercion\ntype1\ntype2\n))\n(\nt2->t1\n(\nget-coercion\ntype2\ntype1\n)))\n(\ncond\n(\nt1->t2\n(\napply-generic\nop\n(\nt1->t2\na1\n)\na2\n))\n(\nt2->t1\n(\napply-generic\nop\na1\n(\nt2->t1\na2\n)))\n51\n一般化については\nExercise 2.82\nを参照して下さい。\n207","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":233},{"id":"./test/fixtures/pdf/sicp.pdf:234","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nelse\n(\nerror\n\"\nNo\nmethod\nfor\nthese\ntypes\n\"\n(\nlist\nop\ntype-tags\n))))))\n(\nerror\n\"\nNo\nmethod\nfor\nthese\ntypes\n\"\n(\nlist\nop\ntype-tags\n)))))))\nこの強制スキームは上で概説された様に明示的なクロスタイプ命令の定義手法\n上に多くの利点を持ちます。私達は依然、型に関係する強制手続を書かねばな\nりませんが\n(\n푛\n個の型のシステムに対し場合により\n푛\n2\nの手続\n)\n、全ての型の集\n合と各ジェネリック命令に対し異なる手続を書くのでなく、型のペア\n1\n組につ\nき\n1\nつの手続を書くだけで済みます。\n52\nここで私達が信頼しているものはタイ\nプ間の適切な変換は型それ自身のみに依存し、適用される命令には依存しない\nという事実です。\n一方で、私達の強制スキームが十分に汎用ではないアプリケーションが存\n在するかもしれません。たとえ合成されるオブジェクトの両方ともが他方に変\n換できないとしても両者を第三の型に変換することで命令を実行することが\n可能になるかもしれません。そのような複雑さに対処するため、そしてそれで\nもプログラムのモジュール方式を維持するために、通常はより一層タイプ間の\n関係の構造の利点を得るシステムを構築することが、次で議論するように必要\nです。\n型の階層\n上で展開された強制スキームは型のペアの間の自然な関係の存在に当てに\nしていました。より\n“\n一般的な\n”\n構造が、異なる型のお互いへの関係の仕方には\n良く存在します。例えば、私達が整数、分数、実数、複素数を扱う一般的な数\n値演算システムを構築していると仮定します。そのようなシステムにおいては\n整数を特別な種類の分数として見做すことはとても自然です。分数は同様に特\n別な種類の実数であり、実数は同様に特別な種類の複素数であります。私達が\n実際に手にしている物は\nhierarchy of types\n(\n型の階層\n)\n呼ばれるもので、その中\nでは例えば整数は分数の\nsubtype\n(\nサブタイプ\n)\nです\n(\nすなわち分数に適用できる\n任意の命令は自動的に整数に適用できます\n)\n。逆に分数は整数の\nsupertype\n(\nスー\n52\nもし私達が賢いならば普通は\n푛\n2\nよりも少ない強制手続で済みます。例えばもし型\n1\nから型\n2\nへの変換方法と型\n2\nから型\n3\nへの変換方法を知っている場合、この知識を用い\nて型\n1\nから型\n3\nへ変換することができます。これはシステムに新しい型を追加する時に\n明示的に提供せねばならない強制手続の数を劇的に減らします。もしシステムに必要な\nだけの洗練を組み入れたいのなら、システムにタイプ間の\n“\nグラフ\n”\nを検索させて自動的\nに明示的に提供された物から推論可能な強制手続を生成させることが可能です。\n208","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":234},{"id":"./test/fixtures/pdf/sicp.pdf:235","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"complex\nreal\nrational\ninteger\nFigure 2.25:\n型の塔\nパータイプ\n、親の型\n)\nと呼びます。今手にした階層はとても単純な種類で、各\n型はたかだか\n1\nつのスーパータイプを持ち、たかだか\n1\nつのサブタイプを持ち\nます。そのような構造は\ntower\n(\nタワー\n、塔\n)\nと呼ばれ\nFigure 2.25\nで示されます。\nもしタワー構造を持つ場合、階層に新しい型を追加する問題を著しく単純化で\nきます。新しい型がどのようにその上のスーパータイプの隣に組込まれるか、\nそしてどのようにその型がその下の型に対してスーパータイプであるかを指定\nするだけです。例えばもし複素数に対して整数を追加したい場合、明示的に特\n別な強制手続\ninteger->complex\nを定義する必要はありません。その代わりに\n整数がどのように分数に変換できるか、分数がどのように実数に変換できるか、\n実数がどのように複素数に変換できるかを定義します。そうしたらシステムに\n整数を複素数に変換することをこれらのステップを通して変換することを許可\nし、次に\n2\nつの複素数を加算します。\napply-generic\n手続を以下のように再設計することもできます。各型に対\nして\nraise\n手続を与える必要があります。これはある型のオブジェクトをタワ\nーにおいて\n1\nレベル上げます。そうすればシステムが異なる型のオブジェクト\n上にて操作する必要がある時、全てのオブジェクトがタワー内にて同じレベル\nになるまで連続して上げることができます\n(\nExercise 2.83\nと\nExercise 2.84\nがそ\nのような戦略の実装の詳細について考察しています\n)\n。\nタワーの別の利点には全ての型がスーパータイプ上に定義された全ての命\n令を\n“\n継承\n”\nする概念を簡単に実装できることが上げられます。例えばもし整\n数の実数部を求めるための特別な手続を提供しない場合、それにもかかわらず\n整数は複素数のサブタイプであるという事実のおかげで、整数のための\nreal-\npart\nが定義されることが期待できます。タワーでは\napply-generic\nを変更す\nるという統一的な方法でこの様なことが起こるよう準備することが可能です。\n209","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":235},{"id":"./test/fixtures/pdf/sicp.pdf:236","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"もし必要な命令が与えられたオブジェクトの型のために直接定義されていない\n場合、オブジェクトをそのスーパータイプに上げることで再試行できます。従\nってタワーを這い上がりながら望まれた命令が実行可能になるまで引数を変換\nするか、頂上まで辿りついてそこで諦めることができます。\n別のより一般的な階層に比べた場合、もう\n1\nつタワーの利点はデータオブ\nジェクトをより簡単な表現へ\n“\n下げる\n”\n簡単な方法を提供することです。例え\nば\n2 + 3푖\nを\n4 − 3푖\nに足した場合、その答は複素数\n6 + 0푖\nよりも整数\n6\nで得る\nほうがより良いと言えるでしょう。\nExercise 2.85\nはそのようなレベルを下げる\n命令の実装について議論します。\n(\nこの仕掛けには\n6 + 0푖\nのような階層のレベ\nルを下げられるオブジェクトを\n6 + 2푖\nのような下げられないオブジェクトか\nら見分ける一般的な方法が必要です\n)\n。\n階層の不十分さ\nもしシステムのデータの型が自然にタワーに配置できる場合、ここまで見\nてきた通りに、異なる型上のジェネリック命令の取扱の問題を著しく単純化で\nきます。残念なことに、これは普通の場合ではありません。\nFigure 2.26\nは雑多\nな型のより複雑な配置を図示しています。この図は幾何学的図形の異なる型の\n間の関係を見せています。一般的に\n1\nつの型が複数のサブタイプを持つことが\nわかります。例えば三角形と四角形は共に多角形のサブタイプです。加えてあ\nる型は複数のスーパータイプを持つことがあり得ます。例えば二等辺直角三角\n形は二等辺三角形、または直角三角形と見做すことができます。この複数スー\nパータイプ問題は特に困難で、階層内において型を\n“\n上げる\n”\n単一の方法が存\n在しません。オブジェクトに命令を適用するため\n“\n正しい\n”\nスーパータイプを\n求めることは\napply-generic\nの様な手続に不可欠な型ネットワーク全体を通\nしての多大な検索を巻き起す可能性があります。一般的にある型に対して複数\nのサブタイプが存在するので値に対し型階層を\n“\n下げる\n”\n強制にも同様の問題\nが存在します。巨大システムの設計におけるモジュール化方式をそれでも維持\nしながら多くの数の相互に関係する型の取り扱うことはとても難しく、現在の\n多くの研究領域です。\n53\n53\n第一版でも存在したこの文は\n12\n年前と同じく今も変わりません。実用的で汎用的な\n異なる型の要素間の関係の表現するフレームワーク\n(\n哲学者が\n“\nオントロジー\n”(\n存在論\n)\nと呼ぶもの\n)\nを開発することは不可能に見えるほど難しいことです。\n10\n年前に存在した\n混乱と現在に存在する混乱との間の違いは、種々の不適切な存在論上の理論が、相応し\nて不適切なプログラミング言語に過剰に組込まれていることです。例えばオブジェクト\n指向言語の複雑性の多くは\n—\nそして現在のオブジェクト指向言語間の微妙で混乱させる\n違いは\n—\n相互に関係する型上のジェネリック命令の扱いを中心とします。\nChapter 3\nで\n210","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":236},{"id":"./test/fixtures/pdf/sicp.pdf:237","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"polygon\nquadrilateral\nkite\ntrapezoid\nparallelogram\nrectangle   rhombus\nsquare\ntriangle\nisosceles\ntriangle\nright\ntriangle\nisosceles\nright triangle\nequilateral\ntriangle\nFigure 2.26:\n幾何学的図形の型の間の関係\nExercise 2.81:\nLouis Reasoner\nは\napply-generic\nが引数に対しそ\nれらが既に同じ型であってもお互いの型に強制を試行することに\n気付いた。そのため彼は強制テーブルに各型の引数をそれら自身\nの型に\ncoerce\n(\n強制\n)\nするための手続を追加する必要があるのでは\nないかと\n“reason”(\n推論\n)\nした。\n(\ndefine\n(\nscheme-number->scheme-number\nn\n)\nn\n)\n(\ndefine\n(\ncomplex->complex\nz\n)\nz\n)\n(\nput-coercion\n'scheme-number\n'scheme-number\nscheme-number->scheme-number\n)\nの私達自身による計算オブジェクトの議論はこれらの問題を完全に避けます。オブジェ\nクト指向言語に親しみのある読者は\nChapter 3\nにおいてローカルの状態について多くの\n触れるべきことが存在すると気付くでしょう。しかし私達は\n“\nクラス\n”\nや\n“\n継承\n”\nについ\nてさえ述べることはしません。実際に私達はこれらの問題が知識表現上の成果の利用と\n自動的な推論無しにコンピュータ言語設計のみで適切に解決されることは無いと疑って\nいます。\n211","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":237},{"id":"./test/fixtures/pdf/sicp.pdf:238","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nput-coercion\n'complex\n'complex\ncomplex->complex\n)\na\nLouis\nの強制手続がインストールされると\napply-generic\nが\n命令に対する\n2\nつの引数の型が\nscheme-number\n、または\n2\nつ\nの引数の型が\ncomplex\nでありそれらの型に対する命令がテー\nブルに存在しない場合何が起こるだろうか\n?\n例えばジェネリ\nックな指数関数命令を定義したとしよう。\n(\ndefine\n(\nexp\nx\ny\n) (\napply-generic\n'exp\nx\ny\n))\nそして\nScheme-number\nパッケージの指数関数に対する手続\nを追加したとする。ただし他の型に関しては全て行わない。\n;; following added to Scheme-number package\n(\nput\n'exp\n'\n(\nscheme-number\nscheme-number\n)\n(\nlambda\n(\nx\ny\n) (\ntag\n(\nexpt\nx\ny\n))))\n; using primitive\nexpt\n2\nつの複素数引数により\nexp\nを呼び出した場合、何が起こる\nだろうか\n?\nb\n同じ型の引数に伴なう強制に関して何かが行われるべきかに\nついて\nLouis\nは正しいだろうか\n?\nそれとも\napply-generic\nは\nそのままで正しく動作するだろうか\n?\nc\napply-generic\nを変更し\n2\nつの引数が同じ型である場合に強\n制を試行しないようにせよ。\nExercise 2.82:\napply-generic\nを複数引数の全体的な場合に強制を\n扱わせるような一般化を行わせるにはどのように行うかを示せ。\n1\nつの戦略として全ての引数を最初の引数の型に強制するよう試行\nし、次に\n2\nつ目、以降繰り返しが上げられる。この戦略\n(\nと上で与\nえられた\n2\n引数版が同様に\n)\n全体には不十分である例を示せ。\n(\nヒ\nント：テーブルにいくつか適切な型が混ざった命令が存在し、そ\nれが試行されない場合について考えよ。\n)\nExercise 2.83:\nFigure 2.25\nで示される型のタワーを取り扱うジェ\nネリックな数値演算システムの設計を行っているとする。整数、分\n数、実数、複素数に対応する。各型\n(\n複素数を除く\n)\nに対してその\n型のオブジェクトをタワー内にて\n1\nレベル上げる手続を設計せよ。\n212","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":238},{"id":"./test/fixtures/pdf/sicp.pdf:239","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\n複素数を除く\n)\n各型に対し動作するジェネリックな\nraise\n命令を\nどのようにインストールするか示せ。\nExercise 2.84:\nExercise 2.83\nの\nraise\n命令を用いて\napply-generic\n手続を変更し、複数の引数が一連の\n“\n上げる\n”\n動作を行うことによ\nりこの節で語られた様に同じ型を持つようにせよ。\n2\nつの型のど\nちらがタワー内にてより高いレベルであるかテストする手段を開\n発する必要がある。これを残りのシステムと\n“\n互換性\n”\nを保ち、タ\nワーに新しいレベルを追加する場合にも問題が無いような手段で\n行え。\nExercise 2.85:\nこの節では可能な限りタワー内の型レベルを下げる\nことによりデータオブジェクトの\n“\n単純化\n”\nを行う手段について説\n明した。\nExercise 2.83\nに記述されたタワーに対しこれを達成する\n手続\ndrop\nを設計せよ。いくつかの一般的な方法の中から決定する\n鍵は、オブジェクトを下げることができるかどうかである。例えば\n複素数\n1.5 + 0푖\nは\nreal\n(\n実数\n)\nである限り下げられ、複素数\n1 + 0푖\nは\ninteger\n(\n整数\n)\nである限り下げることができ、複素数\n2 + 3푖\nは\n下げることが絶対にできない。以下に、あるオブジェクトが下げ\nることができるか決定する計画を示す。オブジェクトをタワー内\nにて\n“\n押し下げる\n”\nジェネリックな命令\nproject\n(\n射影\n)\nを定義する\nことから始める。例えば複素数の射影は虚数部を捨てることにな\nる。すると数値は\nproject\nした結果を元の型に\nraise\n(\n上げ\n)\nた時\nに開始した時点と同じ値になれば\ndrop\n(\n落とす\n)\nことができること\nになる。可能な場合にオブジェクトを落とす手続\ndrop\nを書くこと\nで、この考えをどのように実装するか詳細に示せ。色々な射影命令\nを設計し、ジェネリックな命令として\nproject\nをシステム内にイ\nンストールする必要がある。\n54\nまた\nExercise 2.79\nで説明した等値\n関係のジェネリックな述語を利用する必要もある。最後に\ndrop\nを\n用いて\nExercise 2.84\nの\napply-generic\nを書き直し解答を\n“\n単純化\n”\nする。\nExercise 2.86:\n実数部、虚数部、大きさ、角度が通常の数値、分数、\nまたはシステムに追加したくなるかもしれない数のどれかを用い\nることができる複素数を扱えるようにしたいとする。これを達成\n54\n実数は引数に最も近い整数を返すプリミティブ\nround\nを用いて整数に射影すること\nができる。\n213","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":239},{"id":"./test/fixtures/pdf/sicp.pdf:240","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"するために必要なシステムに対する変更を説明し、実装せよ。普\n通の数と分数に対してジェネリックな\nsine\nや\ncosine\nのような命\n令を定義する必要が出てくるであろう。\n2.5.3\n例\n:\n記号代数\n記号代数表現の操作は巨大なスケールのシステムの設計において起こり得\nる最も困難な問題の多くを説明する複雑な処理です。代数表現は一般的に階層\n構造であると見ることができ、演算子の木がオペランドに適用されます。代数\n表現を定数と変数のようなプリミティブなオブジェクトの集合から始めて、こ\nれらを加算や乗算のような代数演算子を用いて接続することで構築することが\nできます。他の言語と同様に、複合オブジェクトに簡単な用語で参照すること\nを可能にするための抽象化を形式化します。典型的な記号代数における抽象化\nは線形結合、多項式、有理関数、三角関数のような考えです。これらを式の処\n理を方向付けするのによく便利である複合\n“\n型\n”\nと見做すことができます。例\nえば私達は以下の式を\n푥\n2\n푠푖푛(푦\n2\n+ 1) + 푥 푐표푠 2푦 + 푐표푠(푦\n3\n− 2푦\n2\n)\n係数を伴なう\n푥\nの多項式と係数が整数である\n푦\nの三角関数として記述するこ\nとができます。\n私達は完全な代数操作システムをここで開発しようとはしません。そのよ\nうなシステムは非常に複雑なプログラムであり、深い代数学の知識と洗練され\nたアルゴリズムを具体化する必要があります。私達が行うのは代数操作の単純\nだが重要な部分について考えること、つまり多項式の演算です。そのようなシ\nステムの設計者が直面する決定すべきことや、この試みのまとめを手助けする\nために抽象データやジェネリックな命令をどのようにして適用するかのような\n事柄について説明します。\n多項式の計算\n多項式上の数値演算を実行するシステムの設計における最初のタスクは\n多項式とは何かを決定することです。多項式は通常いくつかの変数\n(\n多項式\nの\nindeterminates\n(\n不定元\n))\nに関連して定義されます。簡単にするために多項式\nはただ\n1\nつの不定元\n(\nunivariate polynomials\n(\n一変数多項式\n))\nに制約します。\n55\n55\n一方で係数は別の変数にてそれ自身が多項式であることを許可します。これにより\n本質的に完全に多変量システムと同じ表現力を得ますが、強制においてこの先で記述さ\n214","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":240},{"id":"./test/fixtures/pdf/sicp.pdf:241","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"多項式とは項の和であり、各項は係数、不定元の累乗数、または係数と不定元\nの累乗数の積であると定義します。係数は多項式の不定元に依存しない代数表\n現であると定義します。例えば、\n5푥\n2\n+ 3푥 + 7\nは簡単な\n푥\nの多項式であり、\n(푦\n2\n+ 1)푥\n3\n+ (2푦)푥 + 1\nは係数が\n푦\nの多項式である\n푥\nの多項式です。\n既にいくつかの困難な問題を回避しています。これらの多項式の最初の物\nは多項式\n5푦\n2\n+ 3푦 + 7\nと同じかそれとも異なるでしょうか\n?\n妥当な答は\n“\n多項\n式を純粋に数学の関数であると考えれば答は\nYES\nです。しかしもし多項式を\n文法上の形式であると考えれば答は\nNO\nです\n”\nとなるでしょう。\n2\nつ目の多項\n式は代数学的に係数が\n푥\nの多項式である\n푦\nの多項式に等価です。私達のシス\nテムはこれを認識するべきでしょうか\n?\nさらに他にも多項式を表現する方法は\n存在します\n—\n例えば因数の積としてや\n(1\n変数多項式に対しては\n)\n累乗根の集\n合として、また指定した点の集合における多項式の値の列挙として。\n56\nこれら\nの問題を私達の数値演算操作システムにおいて、根底にある数学上の意味でな\nく、\n“\n多項式\n”\nが特定の文法形式であることを決定することでうまく行うことが\nできます。\nさて、多項式上で数値演算を行なうことについてどのように進めるか考え\nねばなりません。この簡単なシステムでは加算と乗算についてのみしか考えま\nせん。さらに接続される\n2\nつの多項式は同じ不定元を持たなければならないと\nします。\n私達のシステムの設計はデータ抽象化にて馴染のある規律に従うことで取\nり組みます。多項式を\npoly\nと呼ぶ新しいデータ構造を用いて表現します。\npoly\nは変数と項の係数により構成されます。\npoly\nからそれらの部分を抽出するセレ\nクタ\nvariable\nと\nterm-list\nと与えられた変数と項のリストから\npoly\nを組み\n上げるコンストラクタ\nmake-poly\nが既にあると仮定します。変数はただのシン\nれる問題が発生します。\n56\n1\n変数多項式に対しては与えられた点の集合における多項式の値を与えることは特に\n良い表現に成り得ます。これは多項式数値演算をとても簡単にすることができます。例\nとしてこの方法で表現された\n2\nつの多項式の和を求めるには相対する点の多項式の当た\nいを足すだけで済みます。より親しみ易い表現に戻すには\n푛 + 1\n個の点における多項式\nの値を与えられた場合に\n푛\n次の多項式の係数を取り戻すラグランジュ補完公式を用いる\nことができます。\n215","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":241},{"id":"./test/fixtures/pdf/sicp.pdf:242","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ボルであり\nSection 2.3.2\nの\nsame-variable?\n手続を用いて変数の比較が可能で\nす。以下の手続は\npoly\nの加算と乗算を定義します。\n(\ndefine\n(\nadd-poly\np1\np2\n)\n(\nif\n(\nsame-variable?\n(\nvariable\np1\n) (\nvariable\np2\n))\n(\nmake-poly\n(\nvariable\np1\n)\n(\nadd-terms\n(\nterm-list\np1\n)\n(\nterm-list\np2\n)))\n(\nerror\n\"\nPolys\nnot\nin\nsame\nvar\n:\nADD-POLY\n\"\n(\nlist\np1\np2\n))))\n(\ndefine\n(\nmul-poly\np1\np2\n)\n(\nif\n(\nsame-variable?\n(\nvariable\np1\n) (\nvariable\np2\n))\n(\nmake-poly\n(\nvariable\np1\n)\n(\nmul-terms\n(\nterm-list\np1\n)\n(\nterm-list\np2\n)))\n(\nerror\n\"\nPolys\nnot\nin\nsame\nvar\n:\nMUL-POLY\n\"\n(\nlist\np1\np2\n))))\n多項式を私達の数値演算システムに組込むためにはそれらをタイプタグと共に\n提供する必要があります。タグ\npolynomial\nを用いることにし、タグ付き多項\n式上の適切な命令を命令テーブルにインストールします。\nSection 2.5.1\nと同様\nに、多項式パッケージに対するインストール手続に私達の全てのコードを組み\n込んでしまうことにします。\n(\ndefine\n(\ninstall-polynomial-package\n)\n;;\n内部手続\n;; poly\nの表現\n(\ndefine\n(\nmake-poly\nvariable\nterm-list\n)\n(\ncons\nvariable\nterm-list\n))\n(\ndefine\n(\nvariable\np\n) (\ncar\np\n))\n(\ndefine\n(\nterm-list\np\n) (\ncdr\np\n))\n⟨\nprocedures same-variable?and variable? from section 2.3.2\n⟩\n;;\n項と項のリストの表現\n⟨\nprocedures adjoin-term\n...\ncoeff from text below\n⟩\n(\ndefine\n(\nadd-poly\np1\np2\n)\n...\n)\n216","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":242},{"id":"./test/fixtures/pdf/sicp.pdf:243","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"⟨\nadd-poly\nで使用される手続\n⟩\n(\ndefine\n(\nmul-poly\np1\np2\n)\n...\n)\n⟨\nmul-poly\nで使用される手続\n⟩\n;;\nシステムの残りへのインターフェイス\n(\ndefine\n(\ntag\np\n) (\nattach-tag\n'polynomial\np\n))\n(\nput\n'add\n'\n(\npolynomial\npolynomial\n)\n(\nlambda\n(\np1\np2\n) (\ntag\n(\nadd-poly\np1\np2\n))))\n(\nput\n'mul\n'\n(\npolynomial\npolynomial\n)\n(\nlambda\n(\np1\np2\n) (\ntag\n(\nmul-poly\np1\np2\n))))\n(\nput\n'make\n'polynomial\n(\nlambda\n(\nvar\nterms\n)\n(\ntag\n(\nmake-poly\nvar\nterms\n))))\n'done\n)\n多項式の加算は項別に実行されます。同じ次数の項\n(\nつまり同じ指数の不定元\n)\nが合成されねばなりません。これは係数は加数の係数の合計である同じ次数の\n新しい項を形成することにより行われます。ある加数の項の同じ次数の項がも\nう一方に無い場合には単純に構築される和の多項式に積み上げられます。\n項のリストを操作するために、空の項リストを返すコンストラクタ\nthe-\nempty-termlist\nと新しい項を項リストに挿入するコンストラクタ\nadjoin-\nterm\nを既に持っていると仮定します。また与えられた項リストが空であるか\n判断する述語\nempty-termlist?\nと項リストから最大次数の項を抽出するセレ\nクタ\nfirst-term\n、最大次数の項を除く全てを返すセレクタ\nrest-terms\nもまた\n持っていると仮定します。項を操作するために、与えられた次数と係数から項\nを構築するコンストラクタ\nmake-term\nと項の次数と係数をそれぞれ返すセレ\nクタ\norder\nと\ncoeff\nを既に持っていると仮定します。これらの命令は項と項の\nリストの両方を実際の表現については分離して考えられるデータ抽象として捉\nえることを許します。\n以下は\n2\nつの多項式の和のために項リストを構築する手続です。\n57\n(\ndefine\n(\nadd-terms\nL1\nL2\n)\n(\ncond\n((\nempty-termlist?\nL1\n)\nL2\n)\n((\nempty-termlist?\nL2\n)\nL1\n)\n57\nこの命令は\nExercise 2.62\nにて開発した\nunion-set\n命令にとても似ています。実際に\nもし多項式の項を不定元の指数に従い並べた集合だと考えるなら、和のために項リスト\nを生成するプログラムは\nunion-set\nとほとんど同じです。\n217","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":243},{"id":"./test/fixtures/pdf/sicp.pdf:244","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nelse\n(\nlet\n((\nt1\n(\nfirst-term\nL1\n))\n(\nt2\n(\nfirst-term\nL2\n)))\n(\ncond\n((> (\norder\nt1\n) (\norder\nt2\n))\n(\nadjoin-term\nt1\n(\nadd-terms\n(\nrest-terms\nL1\n)\nL2\n)))\n((< (\norder\nt1\n) (\norder\nt2\n))\n(\nadjoin-term\nt2\n(\nadd-terms\nL1\n(\nrest-terms\nL2\n))))\n(\nelse\n(\nadjoin-term\n(\nmake-term\n(\norder\nt1\n)\n(\nadd\n(\ncoeff\nt1\n) (\ncoeff\nt2\n)))\n(\nadd-terms\n(\nrest-terms\nL1\n)\n(\nrest-terms\nL2\n)))))))))\nここで注意すべき最も重要な点はジェネリックな加算手続\nadd\nを用いて合成さ\nれる\n2\nつの項の係数を一緒に足したことです。これは以下で見るように強力な\n帰結です。\n2\nつの項リストを乗算するために最初のリストの各項をもう一方のリスト\nの全ての項で乗算するのに繰り返し\nmul-term-by-all-terms\nを使用ます。\nmul-\nterm-by-all-terms\nは与えられた項を全ての与えられた項リストの項で乗算し\nます。結果の項リスト\n(\n最初のリストの各項に対して\n1\nつ\n)\nは合計に積み上げら\nれます。\n2\nつの項の乗算は次数が乗数の次数の和で係数が乗数の係数の積とな\nる項を形成します。\n(\ndefine\n(\nmul-terms\nL1\nL2\n)\n(\nif\n(\nempty-termlist?\nL1\n)\n(\nthe-empty-termlist\n)\n(\nadd-terms\n(\nmul-term-by-all-terms\n(\nfirst-term\nL1\n)\nL2\n)\n(\nmul-terms\n(\nrest-terms\nL1\n)\nL2\n))))\n(\ndefine\n(\nmul-term-by-all-terms\nt1\nL\n)\n(\nif\n(\nempty-termlist?\nL\n)\n(\nthe-empty-termlist\n)\n(\nlet\n((\nt2\n(\nfirst-term\nL\n)))\n(\nadjoin-term\n(\nmake-term\n(+ (\norder\nt1\n) (\norder\nt2\n))\n218","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":244},{"id":"./test/fixtures/pdf/sicp.pdf:245","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nmul\n(\ncoeff\nt1\n) (\ncoeff\nt2\n)))\n(\nmul-term-by-all-terms\nt1\n(\nrest-terms\nL\n))))))\nこれが本当に多項式の和と積のためにあるもの全てです。ジェネリック手続\nadd\nと\nmul\nを用いて項を操作するため、多項式パッケージはジェネリック数値\n演算パッケージにより知られている任意の型の係数を自動的に取り扱うことが\n可能であることに注意して下さい。もし\nSection 2.5.2\nで議論されたような強制\nメカニズムを含めていた場合、型の異なる係数の多項式上でも命令を取り扱う\nことが自動的にできます。\n[3푥\n2\n+ (2 + 3푖)푥 + 7] ⋅ [푥\n4\n+\n2\n3\n푥\n2\n+ (5 + 3푖)].\n多項式の加算と乗算の手続、\nadd-poly\nと\nmul-poly\nをジェネリックな数値\n演算システムに型\npolynomial\nのための命令\nadd\nと\nmul\nとしてインストールし\nたため、私達のシステムはまた自動的に以下のような多項式操作を取り扱うこ\nとが可能です。\n[(푦 + 1)푥\n2\n+ (푦\n2\n+ 1)푥 + (푦 − 1)] ⋅ [(푦 − 2)푥 + (푦\n3\n+ 7)].\nその理由はシステムが係数を合成しようと試す時、\nadd\nと\nmul\nを通して呼\n出を行うためです。係数はそれ自身\n(\n푦\nの\n)\n多項式ですから、これらは\nadd-poly\nと\nmul-poly\nを用いて合成されます。結果は\n“\nデータ適従再帰\n”\nのような物で、\n例えば\nmul-poly\nの呼出は係数の乗算のために\nmul-poly\nの再帰呼出に帰着し\nます。もし係数の係数がそれ自身多項式\n(\n多項式を\n3\n変数で表現した場合\n)\nの\n場合、データ適従はシステムがまた別のレベルの再帰呼出に従うことを保証し\nます。そしてデータの構造が指示するだけのより多くのレベルについてもまた\n同様です。\n58\n項リストの表現\nようやく項リストに対する良い表現を実装する仕事に直面せねばなりませ\nん。項リストは実際には項の次数をキーにした係数の集合です。従って\nSection\n58\nこれを完全に順調に行うには私達のジェネリック数値演算システムに\n“\n数値\n”\nを次数が\n0\nで係数がその数である多項式であると見做すことで多項式に強制する能力も追加する\n必要があります。これは以下のような式に対して実行を行いたい場合に必要です。\n[푥\n2\n+ (푦 + 1)푥 + 5] + [푥\n2\n+ 2푥 + 1],\nこれは係数\n푦 + 1\nを係数\n2\nに対し足す必要があります。\n219","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":245},{"id":"./test/fixtures/pdf/sicp.pdf:246","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2.3.3\nにて議論したような任意の集合表現の手法がこのタスクに適用可能です。\n一方で手続\nadd-terms\nと\nmul-terms\nは常に高い次数から低い次数へと連続し\nて項リストを常にアクセスします。従って何らかの順序付きリスト表現を用い\nることにしましょう。\n項リストを表現するリストをどのように構造化するべきでしょうか。\n1\nつ\nの考慮点は私達が操作しようとする多項式の\n“\n濃度\n”\nです。多項式は多くの次\n数に関して\n0\nでない係数を持つ場合\ndense\n(\n密\n)\nと呼ばれます。もし多くの\n0\nの\n項を持つ場合には\nsparse\n(\n疎\n)\nと呼ばれます。例えば、\n퐴 ∶\n푥\n5\n+ 2푥\n4\n+ 3푥\n2\n− 2푥 − 5\nis a dense polynomial, whereas\nは密多項式です。\n퐵 ∶\n푥\n100\n+ 2푥\n2\n+ 1\nは疎です。\n密多項式の項リストは係数のリストとして最も効率良く表現されます。例\nえば上の\n퐴\nは\n(1 2 0 3 -2 -5)\nとしてうまく表わされます。この表現の項の\n次数はその項の係数で始まるサブリストの長さから\n1\nを引いた数です。\n59\nこ\nれは\n퐵\nのような疎多項式には酷い表現に成り得ます。少なく孤立した非ゼロ\nな項により中断される巨大なゼロのリストになるでしょう。疎多項式のより適\n切な項リストの表現は各項が項の次数とその次数に対する係数を含むリストで\nある非ゼロ項のリストです。そのような仕組みでは多項式\n퐵\nは効率的に\n((100\n1) (2 2) (0 1))\nとして表現されます。多くの多項式操作が疎多項式上にて実\n行されるため、私達はこちらの手法を用います。項リストは項のリストとして\n表現され高次から低次の項へと並べられます。これを決定すれば項と項リスト\nに対するセレクタとコンストラクタの実装は簡単です。\n60\n(\ndefine\n(\nadjoin-term\nterm\nterm-list\n)\n(\nif\n(=\nzero?\n(\ncoeff\nterm\n))\n59\nこれらの多項式の例では\nExercise 2.78\nで提案された型メカニズムを用いてジェネリ\nック数値演算システムを実装したと前提しています。従って普通の数値の係数は数値そ\nれ自身で表現され、\ncar\nがシンボル\nscheme-number\nのペアではありません。\n60\n項リストが順序有りだと想定していますが、\nadjoin-term\nを単純に新しい項を既存\nの項リスト上に\ncons\nするように実装しました。\nadjoin-term\nを用いる\n(\nadd-terms\nのよ\nうな\n)\n手続が常にリスト内の物より高次な項と共にそれを呼ぶことを保証するならばこ\nのままにしておくことができます。もしそのような保証を行うことが望ましくなかった\nならば\nadjoin-term\nを集合の順序付きリスト表現のための\nadjoin-set\n(\nExercise 2.61\n)\nと同様に実装しておくべきだったでしょう。\n220","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":246},{"id":"./test/fixtures/pdf/sicp.pdf:247","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"term-list\n(\ncons\nterm\nterm-list\n)))\n(\ndefine\n(\nthe-empty-termlist\n)\n'\n())\n(\ndefine\n(\nfirst-term\nterm-list\n) (\ncar\nterm-list\n))\n(\ndefine\n(\nrest-terms\nterm-list\n) (\ncdr\nterm-list\n))\n(\ndefine\n(\nempty-termlist?\nterm-list\n) (\nnull?\nterm-list\n))\n(\ndefine\n(\nmake-term\norder\ncoeff\n) (\nlist\norder\ncoeff\n))\n(\ndefine\n(\norder\nterm\n) (\ncar\nterm\n))\n(\ndefine\n(\ncoeff\nterm\n) (\ncadr\nterm\n))\n=zero?\nは\nExercise 2.80\nで定義されています。\n(\n下の\nExercise 2.87\nも参照して下\nさい\n)\n。\n多項式パッケージのユーザは\n(\nタグ付き\n)\n多項式を以下の手続で作成します。\n(\ndefine\n(\nmake-polynomial\nvar\nterms\n)\n((\nget\n'make\n'polynomial\n)\nvar\nterms\n))\nExercise 2.87:\n対抗式に対する\n=zero?\nをジェネリック数値演算パ\nッケージにインストールせよ。これは\nadjoin-term\nに係数それ自\n身が多項式である多項式に対して動作を可能にする。\nExercise 2.88:\n多項式システムを拡張し多項式の減算を含めよ。\n(\nヒ\nント：ジェネリックな単項算術否定演算子を定義することが手助\nけとなるだろう。\n)\nExercise 2.89:\n密多項式に対して適切だと上で説明された項リスト\n表現を実装する手続を定義せよ。\nExercise 2.90:\n疎と密、両方の多項式に対して効率の良い多項式シ\nステムを得たいとする。これを行う\n1\nつの方法は両方の種類の項\nリスト表現をシステム内にて許可することである。状況は\nSection\n2.4\nの複素数の例と同様で、そこでは直行形式と極形式の両表現を\n許可した。これを行うため、異なる型の項リストを識別し、項リス\nト上の命令をジェネリックにせねばならない。多項式システムを\nこの汎化を行うために再設計せよ。これは局所的な変更ではなく\n大域的な変更になる。\n221","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":247},{"id":"./test/fixtures/pdf/sicp.pdf:248","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.91:\n1\n変数多項式は別の\n1\n変数多項式により割ることが\nでき、多項式の商と多項式の剰余を算出する。例えば、\n푥\n5\n− 1\n푥\n2\n− 1\n= 푥\n3\n+ 푥,\nremainder\n푥 − 1.\n除算は長除法を通して行うことができる。これは被除数の最高次\nの項を除数の最高次の項で割る。結果は商の最初の項である。次\nに結果に除数を掛け、被除数からその結果を引く。そして残りの\n答を再帰的に差を除数で割ることにより求める。除数の次数が被\n除数の次数を越えた時に停止し、その時の被除数を剰余であると\n宣言する。またもし被除数がゼロになった場合には商と剰余の両\n者をゼロとして返す。\nadd-poly\nと\nmul-poly\nのモデルの上に\ndiv-poly\n手続を設計する\nことが可能だ。この手続は\n2\nつの多項式が同じ変数を持つかチェ\nックする。そうであれば\ndiv-poly\nは変数を取り去りその問題を\ndiv-terms\nに渡す。\ndiv-terms\nは除算命令を項リスト上にて実行\nする。\ndiv-poly\nは最終的に変数を再度\ndiv-terms\nの結果に取り付\nける。除算の商と剰余の両者を求める\ndiv-terms\nを設計すること\nは便利だ。\ndiv-terms\nは\n2\nつの項リストを引数として取り商の項\nリストと剰余の項リストのリストを返す。\n以下の\ndiv-terms\nの定義を欠けた式を埋めることにより完成させ\nよ。これを用いて\ndiv-poly\nを実装せよ。\ndiv-poly\nは\n2\nつの多項\n式を引数として取り商と剰余の多項式のリストを返す。\n(\ndefine\n(\ndiv-terms\nL1\nL2\n)\n(\nif\n(\nempty-termlist?\nL1\n)\n(\nlist\n(\nthe-empty-termlist\n) (\nthe-empty-termlist\n))\n(\nlet\n((\nt1\n(\nfirst-term\nL1\n))\n(\nt2\n(\nfirst-term\nL2\n)))\n(\nif\n(> (\norder\nt2\n) (\norder\nt1\n))\n(\nlist\n(\nthe-empty-termlist\n)\nL1\n)\n(\nlet\n((\nnew-c\n(\ndiv\n(\ncoeff\nt1\n) (\ncoeff\nt2\n)))\n(\nnew-o\n(- (\norder\nt1\n) (\norder\nt2\n))))\n(\nlet\n((\nrest-of-result\n⟨\ncompute rest of result recursively\n⟩\n))\n⟨\nform complete result\n⟩\n))))))\n222","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":248},{"id":"./test/fixtures/pdf/sicp.pdf:249","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"記号代数の型の階層\n私達の多項式システムはある型\n(polynomials)\nのオブジェクトがどのよう\nにして事実上多くの異なる型のオブジェクトをその部分として持つ複雑なオブ\nジェクトになり得るのかについて説明しました。これはジェネリックな命令を\n定義する場合の実際の困難さは何も引き起していません。複合型の部分の必要\nな操作を実行するために適切なジェネリック命令をインストールすることのみ\nが必要です。実際に多項式がある種の\n“\n再帰的データ抽象化\n”\nを形成し、多項式\nのその部分においてそれ自身が多項式である場合があることを学びました。私\n達のジェネリック命令とデータ適従プログラミングスタイルはこの複雑さを大\nした問題無しに扱うことができます。\n一方で多項式代数はデータ型が自然にタワーに配置できないシステムです。\n例えば係数が\n푦\nの多項式である\n푥\nの多項式を持つことができます。また係数が\n푥\nの多項式である\n푦\nの多項式を持つことも可能です。これらの型のどちらもも\nう一方の\n“\n上\n”\nには自然には成り得ません。その上各集合から両者の要素を足\nす必要は良くあります。これを行う方法はいくつか存在します。\n1\nつの可能性\nとしてはある多項式をもう一方の多項式の型に項の展開と再配置を行うことで\n両者の多項式が同じ主な変数を持つように変換する方法が考えられます。この\n上に変数で順序付けるタワーの様な構造を強制することで、常に任意の多項式\nを最優先の変数が主で低優先度の変数が係数に埋め込まれた\n“\n基底形式\n”\nに変\n換することができます。この戦略はとても良く行きます。ただし変換が多項式\nを不必要に展開するかもしれないため、読み難くそして恐らく非効率にしてし\nまいます。タワーの戦略は全くこの領域では全く自然ではありません。または\nユーザが新しい型を古い型を用いて種々の接続形式にて動的に創作する領域、\n例えば三角関数、羃級数、積分等の任意の領域には自然ではないでしょう。\n強制をコントロールすることが巨大スケールの代数操作システムの設計に\nおいて深刻な問題であることは驚くべきことではありません。そのようなシス\nテムの多くの複雑性は様々な型の間の関係性に携わっています。私達はまだ完\n全には強制を理解していないと言うことは本当に公正でしょう。実際に私達は\nまだデータ型の概念を完全には理解していません。それでもなお、私達が知っ\nていることは強力な構造化とモジュラー方式の原則を伴ない巨大システムの設\n計の支援を与えてくれます。\nExercise 2.92:\n変数の順序付けを強要することで多項式パッケージ\nを拡張し多項式の加算と乗算が異なる変数の多項式に対しても働\nくようにせよ。\n(\nこれは簡単ではない\n!)\n223","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":249},{"id":"./test/fixtures/pdf/sicp.pdf:250","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"延長課題\n:\n分数関数\n私達のジェネリック数値演算システムを拡張し\nrational functions\n(\n分数関\n数\n)\nを含むようにすることができます。分子と分母が多項式である以下の様な\n“\n分数\n”\nが存在します。\n푥 + 1\n푥\n3\n− 1\n.\nシステムは分数関数の加算、減算、乗算、除算をできなければなりません。\nそして以下の様な計算を行うために、\n푥 + 1\n푥\n3\n− 1\n+\n푥\n푥\n2\n− 1\n=\n푥\n3\n+ 2푥\n2\n+ 3푥 + 1\n푥\n4\n+ 푥\n3\n− 푥 − 1\n.\n(\nここでは加算は共通因数を取り除くことで簡約されています。通常の\n“\nた\nすき掛け\n”\nなら\n5\n次多項式分の\n4\n次多項式の分数を生成しているでしょう。\n)\n私達の分数演算パッケージを変更することでジェネリック命令を用いるよ\nうにすると分数を最小の項に簡約する問題を除いて望むことができます。\nExercise 2.93:\n分数演算パッケージを変更しジェネリック命令を使\n用するようにせよ。ただし\nmake-rat\nを変更し分数を最小の項に簡\n約することは試行しないようにせよ。あなたのシステムを\nmake-\nrational\nを\n2\nつの多項式上にて呼び出し分数関数を生成すること\nでテストせよ。\n(\ndefine\np1\n(\nmake-polynomial\n'x\n'\n((2 1)(0 1))))\n(\ndefine\np2\n(\nmake-polynomial\n'x\n'\n((3 1)(0 1))))\n(\ndefine\nrf\n(\nmake-rational\np2\np1\n))\nここで\nrf\nを自身に\nadd\nを用いて足せ。この加算手続が分数を最小\n項に簡約しないことを確認するだろう。\n多項式の分数を整数で用いたのと同じ考えを用いて最小の項に簡約すること\nができます。\nmake-rat\nを変更し分子と分母の両方を最大公約数で割ります。\n“Greatest Common Denominator” (GCD:\n最大公約数\n)\nの概念は多項式に対し\nても意味を成します。実際に\n2\nつの多項式の\ngcd\nを整数に対して働く、基本的\nに同じユークリッドのアルゴリズムを用いて求めることができます。\n61\n整数版\nは以下のとおりです。\n61\nユークリッドのアルゴリズムが多項式に対して働くという事実は代数学において多\n項式が\nEuclidean ring\n(\nユークリッド環\n)\nと呼ばれるある種の代数の定義域を形成すると\n述べることにより形式化されます。ユークリッド環とは加算、減算、そして可換な乗算\n224","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":250},{"id":"./test/fixtures/pdf/sicp.pdf:251","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ngcd\na\nb\n)\n(\nif\n(=\nb\n0)\na\n(\ngcd\nb\n(\nremainder\na\nb\n))))\nこれを用いて、項リスト上で働く\ngcd\n命令を定義するための明かな変更を行う\nことができます。\n(\ndefine\n(\ngcd-terms\na\nb\n)\n(\nif\n(\nempty-termlist?\nb\n)\na\n(\ngcd-terms\nb\n(\nremainder-terms\na\nb\n))))\nここで\nremainder-terms\nは\nExercise 2.91\nで実装された項リストの除算命令\ndiv-terms\nにより返されるリストの剰余部を取り出します。\nExercise 2.94:\ndiv-terms\nを用いて手続\nremainder-terms\nを実装\nし、それを用いて\ngcd-terms\nを上記のように定義せよ。次に\n2\nつ\nの多項式の多項式\ngcd\nを求める手続\ngcd-poly\nを書け。\n(\nこの手続\nは\n2\nつの多項式が同じ変数でなければエラーを発しなければなら\nない\n)\n。多項式に対しては\ngcd-poly\nを簡約し、通常の数値に対し\nては通常の\ngcd\nに簡約するジェネリック命令\ngreatest-common-\ndivisor\nをシステムにインストールせよ。テストとして以下を\n試せ。\n(\ndefine\np1\n(\nmake-polynomial\n'x\n'\n((4 1) (3 -1) (2 -2) (1 2))))\n(\ndefine\np2\n(\nmake-polynomial\n'x\n'\n((3 1) (1 -1))))\n(\ngreatest-common-divisor\np1\np2\n)\n次にその結果を手でチェックせよ。\nを許す定義域であり、環の各元\n푥\nに対する正の整数の\n“\n大きさ\n”\n푚(푥)\nの割り当て方法と\nそれに対する性質として任意の非ゼロな\n푥\nと\n푦\nに対し\n푚(푥푦) ≥ 푚(푥)\nであると共に、与\nえられた任意の\n푥\nと\n푦\nに対し\n푦 = 푞푥 + 푟\nとなる\n푞\nが存在し、\n푟 = 0\nまたは\n푚(푟) < 푚(푥)\nであることが言えます。抽象化の視点からこれがユークリッドのアルゴリズムがうまく\n行くのに必要な条件です。整数の定義域に対して、整数の大きさ\n푚\nはその整数の絶対値\nです。多項式の定義域においては多項式の大きさはその次数です。\n225","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":251},{"id":"./test/fixtures/pdf/sicp.pdf:252","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 2.95:\n以下の多項式\n푃\n1\n,\n푃\n2\n,\n푃\n3\nを定義せよ。\n푃\n1\n∶    푥\n2\n− 2푥 + 1,\n푃\n2\n∶    11푥\n2\n+ 7,\n푃\n3\n∶    13푥 + 5.\n次に\n푃\n1\nと\n푃\n2\nの積\n푄\n1\n、\n푃\n1\nと\n푃\n3\nの積\n푄\n2\nを定義し、\ngreatest-\ncommon-divisor\n(\nExercise 2.94\n)\nを用いて\n푄\n1\nと\n푄\n2\nの\ngcd\nを求め\nよ。答が\n푃\n1\nと同じにならないことに注意せよ。これが非整数命令\nの演算が\ngcd\nに伴なう困難さを生じさせることの例を示している。\n62\n何が起こったのか正しく理解するため、\ngcd\nを求める間\ngcd-\nterms\nをトレースするかこの除算を手で試行してみよ。\nExercise 2.95\nで示された問題を以下に示す\n(\n整数係数の多項式の場合のみ実際\nには動作する\n)\ngcd\nアルゴリズムの変更を用いることで解決することができま\nす。\ngcd\nの演算中の一切の多項式の除算の前に、被除数を一切の分数が除算処\n理の間に現れないよう保証するために選ばれた整数定数因数を掛けます。答は\n従って実際の\ngcd\nより整数定数因数の分異なります。しかしこれは分数関数を\n最小の項に簡約する場合には問題になりません。\ngcd\nは分子と分母の両方をを\n割るために利用されるため、整数定数因数は相殺されます。\nより正確に述べれば、もし\n푃\nと\n푄\nが多項式である場合、\n푂\n1\nを\n푃\nの次数\nとし\n(\nつまり\n푃\nの最大項の次数とし\n)\n、\n푂\n2\nを\n푄\nの次数とします。\n푐\nを\n푄\nの\n第一の係数とします。すると\n푃\nを\nintegerizing factor\n(\n整数化因数\n)\n푐\n1+푂\n1\n−푂\n2\nで掛けると、結果の多項式は\ndiv-terms\nアルゴリズムを用いて一切の分数を\n生じずに\n푄\nで割ることができます。被除数をこの定数で乗算した後に割る\n命令は時々\n푃\nの\n푄\nによる\npseudodivision\n(\n擬除算\n)\nと呼ばれます。除算の剰余\nは\npseudoremainder\n(\n擬剰余\n)\nと呼ばれます。\nExercise 2.96:\na\n手続\npseudoremainder-terms\nを実装せよ。これは\nremainder-\nterms\nと同様であるが\ndiv-terms\nを呼ぶ前に被除数を上で説\n明した整数化因数で掛ける。\ngcd-terms\nを変更し\npseudoremainder-\nterms\nを用いるようにし、\ngreatest-common-divisor\nが整数\n係数の答を\nExercise 2.95\nの例にて生ずることを確認せよ。\n62\nmit\nScheme\nの様な実装ではこの問題は\n푄\n1\nと\n푄\n2\nの実際の約数を分数係数を伴なっ\nて生成します。多くの\nScheme\nシステムでは整数の除算が精度に限界のある少数を生成\nするため、正しい約数を得るのに失敗します。\n226","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":252},{"id":"./test/fixtures/pdf/sicp.pdf:253","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"b\ngcd\nはこれで整数係数を得る。しかしそれらは\n푃\n1\nの物より\nも大きい。\ngcd-terms\nを変更し解の係数から全ての係数をそ\nれらの\n(\n整数\n)\nの最大公約数により割ることで共通因数を取\nり除くようにせよ。\n従って、以下に分数関数をどのようにして規約分数に簡約するかを説明します。\n•\nExercise 2.96\nの\ngcd-terms\nの版を用いて、分子と分母の\ngcd\nを求める\n•\ngcd\nを得たら分子と分母の両方に同じ整数化因数を\ngcd\nで割る前に掛け\nることで\ngcd\nによる除算が非整数な係数を生じないようにする。因数と\nして\ngcd\nの最初の係数を\n1 + 푂\n1\n− 푂\n2\n乗した物を用いることができ、こ\nの時\n푂\n2\nは\ngcd\nの次数であり、\n푂\n1\nは分子と分母の最大次数である。こ\nうすることで分子と分母を\ngcd\nで割っても分数を生じない。\n•\nこの操作の結果は分子と分母が整数係数になる。係数は通常とても巨大\nになる。理由の全ては整数化因数のせいだ。そのため最終ステップは分\n子と分母の全ての係数の\n(\n整数の\n)\n最大公約数を求めてこの約数で割るこ\nとで冗長な因数をを取り除くことである。\nExercise 2.97:\na\nこのアルゴリズムを、\n2\nつの項リスト\nn\nと\nd\nを引数として取\nり上で説明されたアルゴリズムにて\nn\nと\nd\nを最小の項に簡約\nしたリスト\nnn\nと\ndd\nを返す手続\nreduce-terms\nとして実装せ\nよ。また\nadd-poly\nと同様に\n2\nつの多項式が同じ変数を持つ\nかチェックする手続\nreduce-poly\nも書け。もしそうである場\n合\nreduce-poly\nは変数を取り去り問題を\nreduce-terms\nに渡\nす。そして\nreduce-terms\nにより与えられた\n2\nつの項リスト\nに再び変数を取り付ける。\nb\n元の\nmake-rat\nが整数に対して行ったことを行う\nreduce-\nterms\nと同様の手続を定義せよ。\n(\ndefine\n(\nreduce-integers\nn\nd\n)\n(\nlet\n((\ng\n(\ngcd\nn\nd\n))) (\nlist\n(/\nn\ng\n) (/\nd\ng\n))))\n次に\nreduce\nをジェネリック命令として定義する。これは\napply-generic\nを呼び、\n(\npolynomial\n型引数に対しては\n)\nreduce-\npoly\nを呼び出し、\n(\nscheme-number\n型引数に対しては\n)\nreduce-\nintegers\nを呼び出す。これで\nmake-rat\nに与えられた分子と\n227","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":253},{"id":"./test/fixtures/pdf/sicp.pdf:254","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"分母を接続して分数を形成する前に\nreduce\nを呼ばせること\nで、簡単に分数数値演算パッケージに分数を最小の項に約分\nさせることができる。\n(\ndefine\np1\n(\nmake-polynomial\n'x\n'\n((1 1) (0  1))))\n(\ndefine\np2\n(\nmake-polynomial\n'x\n'\n((3 1) (0 -1))))\n(\ndefine\np3\n(\nmake-polynomial\n'x\n'\n((1 1))))\n(\ndefine\np4\n(\nmake-polynomial\n'x\n'\n((2 1) (0 -1))))\n(\ndefine\nrf1\n(\nmake-rational\np1\np2\n))\n(\ndefine\nrf2\n(\nmake-rational\np3\np4\n))\n(\nadd\nrf1\nrf2\n)\n正しい答を得るかどうか、正しく最小の項に簡約されるかど\nうか確認せよ。\ngcd\nの計算は分数関数の操作を行うどんなシステムにおいても心臓部に存在し\nます。上で用いられたアルゴリズムは数学的には簡単ですが非常に遅いです。。\n遅さの原因の一部は除算命令の大きな値であり、他には擬除算により生じる非\n常に大きな中間時の係数のためとなります。代数操作システムの活発な開発領\n域の\n1\nつは多項式の\ngcd\nを求めるより良いアルゴリズムの設計です。\n63\n63\n多項式の\ngcd\nを求めるための\n1\nつの著しく効率が良く洗練された手法は\nRichard\nZippel (1979)\nにより発見されました。この手法は\nChapter 1\nにて議論した素数性の高速\nなテストと同様の乱選アルゴリズムです。\nZippel\nの本\n(\nZippel 1993\n)\nはこの手法を多項\n式の\ngcd\nを求める他の方法と共に解説しています。\n228","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":254},{"id":"./test/fixtures/pdf/sicp.pdf:255","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"3\nモジュール方式、オブジェクト、状態\n푀휖휏훼훽  ́훼휆휆표휈\ǹ훼휈훼휋훼 ́휐휖휏훼휄\n(\n例え変化している間も、それは静止していた\n)\n—Heraclitus\nPlus ça change, plus c’est la même chose.\n(\nより多くが変化する程、より同じであり続ける\n)\n—Alphonse Karr\nここまでの章はプログラムが作成される基礎的な要素を紹介しました。どのよ\nうにしてプリミティブな手続とプリミティブなデータが接続され複合要素を構\n築するかについて学び、また抽象化が巨大システムの複雑さに立ち向かうこと\nを手助けする核心であることを学習しました。しかしこれらのツールはプログ\nラムを設計するのに十分ではありません。効果的なプログラム統合はプログラ\nム設計全体の形式化をガイドすることが可能な組織的原則を必要とします。具\n体的には巨大システムの構造化を手助けする戦略が必要で、それによりそれら\nが\nmodular\n(\nモジュラ\n)\n化されるよう、つまり\n“\n自然に\n”\n分離して開発と保守が\n可能な論理的部品に分割されるようにします。\n物理システムをモデル化したプログラムの構築に特に適切な\n1\nつの強力な\n設計戦略はプログラムの構造をモデル化されるシステムの構造を元にすること\nです。システムの各オブジェクトに対して対応する演算オブジェクトを構築し\n229","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":255},{"id":"./test/fixtures/pdf/sicp.pdf:256","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ます。各システムのアクションに対しては演算モデル内の記号操作を定義しま\nす。この戦略を用いる見込は新しいオブジェクトやアクションを供給するため\nにモデルを拡張することはプログラムに対する戦略上の変更を必要としないこ\nとです。それらのオブジェクト、またはアクションの新しい記号上の類似物の\n追加のみ変更が必要です。システムの組織化にて成功しているのなら、新しい\n機能の追加や古い物のデバッグにおいてはシステムの特定の部分上のみで働く\n必要があります。\nすると大体の場合、巨大プログラムを体系化する方法はモデル化されるシ\nステムの私達の認知により指示されます。この章では\n2\nつの大きく異なるシス\nテム構造の\n“\n世界観\n”\nから浮かび上がる\n2\nつの顕著な体系化戦略について調査\nします。最初の体系化戦略は\nobjects\n(\nオブジェクト\n)\nに集中し、巨大システムを\nその振舞が時間と共に変化する区別可能なオブジェクトの集合だと見ます。代\n替となる体系化戦略はシステム内を流れる情報の\nstreams\n(\nストリーム\n)\nに集中\nします。これは電子技術者の信号処理システムの視点と同じです。\nオブジェクトベースとストリーム処理の両方のアプローチは共にプログラ\nミングにおける重大な言語上の問題を浮かび上がらせます。オブジェクトでは\n演算オブジェクトがどのように変化可能で、それでもその同一性を維持できる\nかについて関心を持たなければなりません。このことがより機械的な、しかし\n論理的に扱い難い演算の\nenvironment model\n(\n環境モデル\n)\nのために、私達の古\nい演算の置換モデル\n(\nSection 1.1.5\n)\nを諦めさせることになります。オブジェク\nト、変化、同一性の取扱の難しさは私達の計算モデル内で時間に取り組むため\nの必要性の基本的な結論です。これらの問題はプログラムの並行実行を許可す\nる場合にさらに大きくなります。ストリームの取り組みは私達のモデル内でシ\nミュレートされた時間を計算機の中で評価の間に発生したイベントの順から分\n断した時に最も全体に利用可能です。\ndelayed evaluation\n(\n遅延評価\n)\nとして知ら\nれるテクニックを用いてこれを達成します。\n3.1\n代入と局所状態\n私達は通常世界を独立したオブジェクトが占める物として見なします。各\nオブジェクトは時間に伴ない変化する状態を持ちます。オブジェクトはその過\n去にその振舞が影響される時、\n“\n状態を持つ\n”\nと呼びます。例えば銀行講座は預\n金と引き出しの取引の記録に依存する\n“\n私は\n$100\n引き出せるか\n?”\nという質問\nの答に状態を持ちます。オブジェクトの状態を\n1\nつ以上の\nstate variables\n(\n状態\n変数\n)\nと見做すことができ、それらの間にオブジェクトの現在の振舞を決定す\n230","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":256},{"id":"./test/fixtures/pdf/sicp.pdf:257","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"るための歴史についての十分な情報を保存します。簡単な銀行システムでは口\n座の状態を口座の取引履歴全体を記憶するのではなく、現在の差引残高と見做\nすことができるでしょう。\n多くのオブジェクトから成るシステムではオブジェクトが完全に独立して\nいることは稀です。あるオブジェクトの状態変数を他のオブジェクトのそれに\n連結する相互作用を通して各オブジェクトが他の状態に影響を与えることがあ\nるでしょう。実際に、システムが分離したオブジェクトから成るという見方は、\nシステムの状態変数が密結合されたサブシステムが、他のサブシステムとは疎\n結合であるというグループに分けられる時最も便利です。\nこのシステムの見方はシステムの演算モデルの体系化に対する強力なフレ\nームワークに成ります。そのようなモデルをモジュール化するためにはシステ\nム内の実際のオブジェクトをモデル化する計算オブジェクトに分離せねばなり\nません。各計算オブジェクトは実際のオブジェクトの状態を説明するそれ自身\nの\nlocal state variables\n(\nローカル状態変数\n)\nを持たねばなりません。モデル化さ\nれるシステム内のオブジェクトの状態は経時変化するため、計算オブジェクト\nに相対する状態変数も変化しなければなりません。もし私達がシステム内の時\nの流れを計算機内で経過する時でモデル化することを選択するのならば、振舞\nがプログラムが実行するにつれ変化する計算オブジェクトを構築する手段を\n持たねばなりません。具体的には、もし状態変数をプログラミング言語内の通\n常の記号名にてモデル化を行いたいのならば、その言語は名前に関連する値を\n変化することができる\nassignment operator\n(\n代入演算子\n)\nを提供せねばなりま\nせん。\n3.1.1\n局所状態変数\n時間的に変化する状態を伴なう計算オブジェクトを持つことにより何を\n意味するのかを説明するために、銀行口座からお金を引き出す状況をモデル\n化してみましょう。これを引数として引き出される\namount\n(\n金額\n)\nを取る手続\nwithdraw\nを用いて行います。もし口座の中に引き出しを受け入れるのに十分\nなお金があるのならば、\nwithdraw\nは引き出しの後に残る差引残高を返さねば\nなりません。そうでなければ、\nwithdraw\nは\nInsufficient funds\n(\n資金不足\n)\nという\nメッセージを返します。例えば口座を\n$100\nで始めた場合、\nwithdraw\nを用いて\n以下の一連の応答を受け取るはずです。\n(\nwithdraw\n25)\n75\n(\nwithdraw\n25)\n231","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":257},{"id":"./test/fixtures/pdf/sicp.pdf:258","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"50\n(\nwithdraw\n60)\n\"Insufficient funds\"\n(\nwithdraw\n15)\n35\n式\n(withdraw 25)\nが\n2\n度評価され異なる値を返していることに注目して下さ\nい。これは手続にとって新しい種類の振舞です。今までは全ての手続は数学上\nの関数を計算する仕様だと見做すことができました。手続の呼出は与えられた\n引数に適用された関数の値を計算しました。そして同じ手続に同じ引数を与え\nば場合の\n2\n度の呼出は常に同じ結果を生じました。\n1\nwithdraw\nを実装するために、口座の差引残高を示す変数\nbalance\nを用\nい、\nbalance\nにアクセスする手続\nwithdraw\nを定義します。\nwithdraw\n手続は\nbalance\nが少なくとも要求された\namount\nと同じ大きさであるかをチェック\nします。もしそうであれば\nwithdraw\nは\nbalance\nを\namount\n分減らし、新しい\nbalance\nの値を返します。そうでなければ\nwithdraw\nは残高不足のメッセージ\nを返します。以下に\nbalance\nと\nwithdraw\nの定義を示します。\n(\ndefine\nbalance\n100)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\nbalance\nを減らすのは次の式により行われます。\n(\nset!\nbalance\n(-\nbalance\namount\n))\nこれは\nset!\nという特別形式を用いています。その文法は次のとおりです。\n(\nset!\n⟨\nname\n⟩\n⟨\nnew-value\n⟩\n)\nここでは\n⟨\nname\n⟩\nはシンボルであり、\n⟨\nnew-value\n⟩\nは任意の式です。\nset!\nは\n⟨\nname\n⟩\nを変更し、その値が\n⟨\nnew-value\n⟩\nを評価して得られた結果にします。こ\n1\n実際にはこれは全く正しい訳ではありません。例の\n1\nつは\nSection 1.2.6\nの乱数生成で\nす。別の例は\nSection 2.4.3\nで紹介した命令\n-\n型テーブルにに従って生じます。同じ引数を\n伴なう\nget\nの二度の呼出の値は間に入る\nput\nに依存します。一方で、代入を紹介するま\nではそのような手続を自分達で作る方法は無かった訳です。\n232","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":258},{"id":"./test/fixtures/pdf/sicp.pdf:259","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"の場合では\nbalance\nを変更することでその新しい値が\nbalance\nの以前の値か\nら\namount\nを引いた結果になります。\n2\nwithdraw\nはまた\nbegin\nという特別形式も使用しており、これは\n2\nつの式を\nif\nのテストが真の場合に評価されるようにします。最初に\nbalance\nを減らし、\n次に\nbalance\nの値を返します。一般的に以下の式を評価すると\n(\nbegin\n⟨\n푒푥푝\n1\n⟩\n⟨\n푒푥푝\n2\n⟩\n...\n⟨\n푒푥푝\n푘\n⟩\n)\n⟨푒푥푝\n1\n⟩\nから\n⟨푒푥푝\n푘\n⟩\nまでの式は続けて評価され最後の式\n⟨푒푥푝\n푘\n⟩\nが\nbegin\nの形\n式全体の値として返ります。\n3\nwithdraw\nは望んだ通りに働きますが、変数\nbalance\nが問題を表します。上\nで指定されたように、\nbalance\nはグローバル環境にて定義された名前であり自\n由に検査や変更のために任意の手続からアクセスすることができます。どうに\nかして\nbalance\nを\nwithdraw\nの内在にすることで\nwithdraw\nのみが\nbalance\nに\n直接アクセスでき、他の手続のどれもが\nbalance\nには間接的に\n(\nwithdraw\nの呼\n出を通して\n)\nアクセスするようにできればともて良くなるでしょう。こうする\nことが口座の状態を追跡するため\nbalance\nが\nwithdraw\nにより利用される局所\n状態変数であるという概念をより正確にモデル化します。\n定義を以下のように書き直すことで\nbalance\nを\nwithdraw\nに内在させるこ\nとができます。\n(\ndefine\nnew-withdraw\n(\nlet\n((\nbalance\n100))\n(\nlambda\n(\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))))\n2\nset!\n式の値は実装依存です。\nset!\nはその効果のためのみに用いられ、その値のために\n用いられてはなりません。\nその名前\nset!\nは\nScheme\nで用いられる名前付けの慣習が反映されています。変数の値\nを変更する命令\n(\nまたは\nSection 3.3\nで学ぶデータ構造を変える物\n)\nは感嘆符\n(\nビックリマ\nーク\n)\nで終わる名前を与えられます。これは述語をクエスチョンマークで終わる名前で指\n定するのと同様です。\n3\n私達は既に\nbegin\nを暗黙的にプログラムの中で使用しています。\nScheme\nでは手続の\nボディは連続する式となるからです。また\ncond\n式の各節の\n⟨\nconsequent\n⟩\nの部分は単一\nの式でなく一連の式にすることができます。\n233","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":259},{"id":"./test/fixtures/pdf/sicp.pdf:260","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ここで起こなったのは\nlet\nを用いて初期値\n100\nに束縛されたローカル変数\nbalance\nを持つ環境を設置しました。この局所環境の中では\nlambda\nを用いて\namount\nを引数に取り以前の\nwithdraw\n手続と同様に振る舞う手続を作成してい\nます。この手続\n—\nlet\n式の評価の結果として返される物\n—\nは\nnew-withdraw\nで\nあり正確に\nwithdraw\nと同じ振舞をしますが、その変数\nbalance\nは他のどの手\n続からもアクセスできません。\n4\nset!\nをローカル変数と組み合わせることはローカルな状態を持つ計算オブ\nジェクトを構築するのに用いる一般的なプログラミングテクニックです。残念\nなことに、このテクニックを用いることは深刻な問題をもたらします。私達が\n最初に手続を紹介した時、評価の置換モデル\n(\nSection 1.1.5\n)\nも手続の適用が何\nを意味するのかの解釈を説明するために提供しました。手続の適用は手続のボ\nディを、形式パラメータをそれらの値で置換して評価することだと解釈される\nべきだと述べました。問題は言語に代入を紹介すると直ぐに置換は最早手続\nの適用モデルとして適切ではなくなります\n(\nなぜそうなのかについては\nSection\n3.1.3\nで学びます\n)\n。結果として技術的に今の時点ではなぜ\nnew-withdraw\n手続が\n上で主張された通りに振る舞うのか理解する手立てがありません。本当に\nnew-\nwithdraw\nの様な手続を理解するためには、手続適用の新しいモデルの開発を\n必要とします。\nSection 3.2\nにおいてそのようなモデルを\nset!\nとローカル変数\nの説明と共に紹介します。しかし最初に\nnew-withdraw\nにより設定される主題\n上のいくつかの変化について調査することにします。\n以下の手続\nmake-withdraw\nは\n“\n引き出し処理\n”\nを作成します。\nmake-withdraw\nの形式パラメータ\nbalance\nは口座の初期残高を指定します。\n5\n(\ndefine\n(\nmake-withdraw\nbalance\n)\n(\nlambda\n(\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\n4\nプログラミング言語の専門語において変数\nbalance\nは手続\nnew-withdraw\nにカプセ\nル化されたと言います。カプセル化は\nhiding principle\n(\n隠蔽原則\n)\nとして知られる一般的\nなシステム設計の原則を反映しています。隠蔽原則とはシステムの部分をお互いから守\nることでよりモジュール化の推進と頑強なシステムを作成することができるということ\nです。それはつまり情報へのアクセスを\n“\n知ることを必要とする\n”\nシステムの部分ににも\n与えることによります。\n5\n上の\nnew-withdraw\nとは逆に、\nbalance\nをローカル変数にするために\nlet\nを使用する\n必要がありません。形式パラメータは既にローカル変数であるためです。\nSection 3.2\nの\n環境の評価モデルの議論の後にこのことはより明白になります。\n(\nExercise 3.10\nも参照し\nて下さい\n)\n234","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":260},{"id":"./test/fixtures/pdf/sicp.pdf:261","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"balance\n)\n\"\nInsufficient\nfunds\n\"\n)))\nmake-withdraw\nは以下のように\n2\nつのオブジェクト\nW1\nと\nW2\nを作るのに使用で\nきます。\n(\ndefine\nW1\n(\nmake-withdraw\n100))\n(\ndefine\nW2\n(\nmake-withdraw\n100))\n(\nW1\n50)\n50\n(\nW2\n70)\n30\n(\nW2\n40)\n\"Insufficient funds\"\n(\nW1\n40)\n10\nW1\nと\nW2\nが完全独立したオブジェクトであり、各々がそれ自身のローカル状態\n変数\nbalance\nを持っていることを観察して下さい。ある口座からの引き出しは\n別の口座には影響しません。\n引き出し同様に預け入れを扱うオブジェクトを作ることもできます。従っ\nて簡単な銀行口座を表現可能です。以下が指定した初期残高を持つ\n“\n銀行口座\nオブジェクト\n”\nを返す手続です。\n(\ndefine\n(\nmake-account\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n)\nwithdraw\n)\n((\neq?\nm\n'deposit\n)\ndeposit\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\n235","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":261},{"id":"./test/fixtures/pdf/sicp.pdf:262","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"m\n))))\ndispatch\n)\n各\nmake-account\nの呼出はローカル状態変数\nbalance\nを持つ環境を構築しま\nす。この環境の中で\nmake-account\nは\nbalance\nにアクセスする手続\ndeposit\nと\nwithdraw\nを定義します。また追加の手続\ndispatch\nは\n“\nメッセージ\n”\nを入力と\nして取り\n2\nつのローカル手続の内\n1\nつを返します。\ndispatch\n手続それ自身が\n銀行口座オブジェクトを表現する値として返されます。これはまさに\nSection\n2.4.3\nで学んだ\nmessage-passing\n(\nメッセージパッシング\n)\nプログラミングスタイ\nルです。ただしここではそれをローカル変数を変更する能力と合わせて用いて\nいます。\nmake-account\nは以下のように使用できます。\n(\ndefine\nacc\n(\nmake-account\n100))\n((\nacc\n'withdraw\n) 50)\n50\n((\nacc\n'withdraw\n) 60)\n\"Insufficient funds\"\n((\nacc\n'deposit\n) 40)\n90\n((\nacc\n'withdraw\n) 60)\n30\n各\nacc\nの呼出は局所的に定義された\ndeposit\nか\nwithdraw\n手続を返し、指定さ\nれた\namount\nに適用されます。\nmake-withdraw\nを用いる場合でしたので、別の\n呼出し、\n(\ndefine\nacc2\n(\nmake-account\n100))\nは完全に分離された口座オブジェクトを生成し、それ自身のローカルな\nbalance\nを持ちます。\nExercise 3.1:\naccumulator\nは\n1\nつの数値引数を持ち繰り返し呼ば\nれる手続で、引数を合計に蓄積する。呼び出される度に現在の累積\n和を返す。アキュムレータ\n(\n累算器\n)\nを返す手続\nmake-accumulator\nを書け。アキュムレータはそれぞれが独立した合計を持つ。\nmake-\naccumulator\nへの入力は累計の初期値を指定する。例えば、\n(\ndefine\nA\n(\nmake-accumulator\n5))\n(\nA\n10)\n236","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":262},{"id":"./test/fixtures/pdf/sicp.pdf:263","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"15\n(\nA\n10)\n25\nExercise 3.2:\nソフトウェアテストアプリケーションでは演算処理\nの間に与えらえれた手続が何度呼ばれたかを数えられると便利で\nある。\n1\n引数手続\nf\nを入力として取る手続\nmake-monitored\nを書け。\nmake-monitored\nの返す結果は第三の手続\n(\nmf\nとしよう\n)\nは内部カ\nウンタを保持することで何回呼出されたかを追跡する。もし\nmf\nへ\nの入力が特別なシンボル\nhow-many-calls?\nであるなら、\nmf\nはカウ\nンタの値を返す。入力が特別なシンボル\nreset-count\nであるなら\nmf\nはカウンタをゼロにリセットする。任意の他の入力に対しては\nmf\nはその入力上の\nf\n呼出の結果を返しカウンタを\n1\n増やす。例え\nば監視版の\nsqrt\n手続を作ることができるだろう。\n(\ndefine\ns\n(\nmake-monitored\nsqrt\n))\n(\ns\n100)\n10\n(\ns\n'how-many-calls?\n)\n1\nExercise 3.3:\nmake-account\n手続を変更しパスワードで守られた口\n座を作成するようにせよ。即ち\nmake-account\nはシンボルを追加引\n数として以下のように取得する。\n(\ndefine\nacc\n(\nmake-account\n100\n'secret-password\n))\n結果の口座オブジェクトはリクエストをアカウント作成時のパス\nワードが付随する場合のみ処理を行いその他の場合には間違いだ\nと返す。\n((\nacc\n'secret-password\n'withdraw\n) 40)\n60\n((\nacc\n'some-other-password\n'deposit\n) 50)\n\"Incorrect password\"\nExercise 3.4:\nExercise 3.3\nの\nmake-account\n手続に別のローカル状\n態変数を追加することで変更し、口座が\n7\n回連続間違ったパスワ\nードでアクセスされた場合に手続\ncall-the-cops\n(\n警察を呼ぶ\n)\nを\n実行するようにせよ。\n237","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":263},{"id":"./test/fixtures/pdf/sicp.pdf:264","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"3.1.2\n代入導入の利点\n私達が学ぶに従い、代入を私達のプログラミング言語に導入したことは難\nしい概念上の問題の藪の中へと導きます。それでもなおシステムをローカルな\n状態を持つオブジェクトの集合として見ることはモジュラな設計を維持する為\nの強力なテクニックです。簡単な例として、呼ばれる度に無作為な\n(\nランダム\nな\n)\n整数を返す手続\nrand\nの設計について考えてみて下さい。\n“\nランダムに選択\n”\nが何を意味するのかは全くわかりません。恐らく私達が\n欲しい物は\nrand\nへの連続した呼出が統計上の性質として均一な分散を持つ一\n連の数値を生じて欲しいのでしょう。ここでは適切な数列を生成する手法につ\nいては議論しません。そうでなく、数値\n푥\n1\nを与えて開始した場合に以下の数列\nを生成する性質を持つ手続\nrand-update\nを既に持っていると想定しましょう。\n푥\n2\n= (\nrand-update\n푥\n1\n)\n푥\n3\n= (\nrand-update\n푥\n2\n)\nすると数列\n푥\n1\n,\n푥\n2\n,\n푥\n3\n,\n...\nは望まれた統計的性質特性を持つでしょう。\n6\nrand\nをある固定値\nrandom-init\nで初期化されるローカル状態変数\nx\nを持\nつ手続として実装できます。\nrand\nへの各呼出は現在の\nx\nの値の\nrand-update\nを演算し、これを乱数として返し、また同時にこの値を\nx\nの新しい値として格\n納します。\n(\ndefine\nrand\n(\nlet\n((\nx\nrandom-init\n))\n(\nlambda\n()\n(\nset!\nx\n(\nrand-update\nx\n))\nx\n)))\nもちろん、代入を用いずに単純に\nrand-update\nを直接呼ぶことで同じ乱数列を\n生成することも可能でしたでしょう。しかし、これは私達のプログラムの乱数\n6\nrand-update\nを実装する\n1\nつの一般的な方法は\n푥\nは\n푎푥 + 푏\nmodulo\n푚\nに更新される\nとする、この時\n푎\n,\n푏\n,\n푚\nは適切に選択された整数であるというルールを用いることです。\nKnuth 1981\nの\n3\n章は広範囲に及ぶ乱数列を生成するためのテクニックの議論を含んでお\nり、またそれらの統計的性質を規定しています。\nrand-update\n手続が数学上の関数を計\n算していることに注意して下さい。同じ入力を\n2\n回与えられれば同じ出力を生成します。\n従って\nrand-update\nにより生成される数列は\n“\nランダム\n”\nが数列のどの数値も以前の数\n値に関係が無いと主張するのであれば、明らかに\n“\nランダム\n”\nではありません。\n“\n真の無\n作為性\n(\nランダムネス\n)”\nと上手く決定された計算で生成されるがそれでも適切な統計上\n特性を持つ\npseudo-random\n(\n擬似乱数\n)\n列の間の関係は数学と哲学の難しい問題を巻き込\nむ複雑な質問です。\nKolmogorov, Solomonoff,\nそれに\nChaitin\nはこれらの問題の解明に\nおいて大きな進展を上げました。これに関する議論は\nChaitin 1975\nに見つかります。\n238","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":264},{"id":"./test/fixtures/pdf/sicp.pdf:265","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を用いる任意の部分が明示的に\nx\nの現在の値を\nrand-update\nの引数として渡\nすために記憶せねばならないことを意味することになります。これがどれだけ\n不快であるかを気付くために、乱数を\nMonte Carlo simulation\n(\nモンテカルロ\nシミュレーション\n)\nと呼ばれるテクニックを実装するために乱数を用いる場合\nについて考えてみましょう。\nモンテカルロ法は巨大集合から無作為にサンプル試行を選択することと、\nその次にそれらの試行上の結果の集計から推測された確率を基準にして演繹を\n行うことから成り立ちます。例えば\n휋\nを\n6/휋\n2\nは\n2\nつの無作為に選択された整\n数に公約数が無い場合の確率であるという事実を用いて近似値を求められま\nす。言い換えると、\n2\nつの整数の最大公約数が\n1\nになる場合ということです。\n7\n휋\nの近似値を求めるためには数多くの試行を行います。各試行において\n2\nつの\n整数を無作為に選択し、それらの\ngcd\nが\n1\nであるかをテストします。テストを\nパスした回数の割合は\n6/휋\n2\nの近似値を与えてくれます。この値から\n휋\nの近似\n値を得ます。\nプログラムの心臓部は手続\nmonte-carlo\nです。これは試行回数と引数が無\nく実行される度に真偽値を返す手続として表される試行を引数として取りま\nす。\nmonte-carlo\nは試行を指定された回数実行し、試行が真と判定された割合\nを表す数値を返します。\n(\ndefine\n(\nestimate-pi\ntrials\n)\n(\nsqrt\n(/ 6 (\nmonte-carlo\ntrials\ncesaro-test\n))))\n(\ndefine\n(\ncesaro-test\n)\n(= (\ngcd\n(\nrand\n) (\nrand\n)) 1))\n(\ndefine\n(\nmonte-carlo\ntrials\nexperiment\n)\n(\ndefine\n(\niter\ntrials-remaining\ntrials-passed\n)\n(\ncond\n((=\ntrials-remaining\n0)\n(/\ntrials-passed\ntrials\n))\n((\nexperiment\n)\n(\niter\n(-\ntrials-remaining\n1)\n(+\ntrials-passed\n1)))\n(\nelse\n(\niter\n(-\ntrials-remaining\n1)\ntrials-passed\n))))\n7\nこの定理は\nE. Cesàro\nによるものです。その議論と証明については\nKnuth 1981\nの節\n4.5.2\nを参照して下さい。\n239","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":265},{"id":"./test/fixtures/pdf/sicp.pdf:266","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\niter\ntrials\n0))\nさて同じ計算を\nrand\nの代わりに\nrand-update\nを用いてやってみましょう。局\n所状態をモデル化するために代入を用いない場合に続行を強制される手法です。\n(\ndefine\n(\nestimate-pi\ntrials\n)\n(\nsqrt\n(/ 6 (\nrandom-gcd-test\ntrials\nrandom-init\n))))\n(\ndefine\n(\nrandom-gcd-test\ntrials\ninitial-x\n)\n(\ndefine\n(\niter\ntrials-remaining\ntrials-passed\nx\n)\n(\nlet\n((\nx1\n(\nrand-update\nx\n)))\n(\nlet\n((\nx2\n(\nrand-update\nx1\n)))\n(\ncond\n((=\ntrials-remaining\n0)\n(/\ntrials-passed\ntrials\n))\n((= (\ngcd\nx1\nx2\n) 1)\n(\niter\n(-\ntrials-remaining\n1)\n(+\ntrials-passed\n1)\nx2\n))\n(\nelse\n(\niter\n(-\ntrials-remaining\n1)\ntrials-passed\nx2\n))))))\n(\niter\ntrials\n0\ninitial-x\n))\nプログラムは今も単純ではありますが、いくつかモジュール方式に対する苦痛\nを伴なう侵害行為があります。\nrand\nを用いる最初の版ではモンテカルロ法を\n直接、引数として任意の\nexperiment\n手続を取る全体的な\nmonte-carlo\n手続に\nて表すことができました。乱数生成に対する状態変数の無い\n2\nつ目の版では\nrandom-gcd-test\nが明示的に乱数\nx1\nと\nx2\nを管理し、\nx2\nを繰り返しのループを\n通して\nrand-update\nに対する新しい入力としてリサイクルしなければなりま\nせん。この明示的な乱数の取扱はテスト結果の蓄積構造と私達の試行が\n2\nつの\n乱数を利用するという事実を一緒に密に結合します。例え他のモンテカルロの\n試行が\n1\nつや\n3\nつの乱数を使うにしてもです。トップレベルの手続\nestimate-\npi\nですら乱数の初期値を提供することに関心を持たねばなりません。乱数生成\n器の内部がプログラムの他の部分に漏れ出すことはモンテカルロの考えを分離\nし他のタスクに適用することを難しくします。プログラムの最初の版では代入\nが乱数生成器の状態を\nrand\n手続の中にカプセル化しているため乱数生成器の\n詳細はプログラムの他の部分からの独立を維持しています。\nモンテカルロの例にて説明された一般的な事象は以下のとおりです。複雑\n240","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":266},{"id":"./test/fixtures/pdf/sicp.pdf:267","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"なプロセスの一部の視点からは他の部分は時間に従い変化するように見えま\nす。それらは時間と共に変化するローカルな状態を隠しています。もしこの分\n解を反映する構造を持つ計算機プログラムを書きたいのならば、振舞が時間と\n共に変換する\n(\n銀行口座と乱数生成器の様な\n)\n計算オブジェクトを作成します。\n私達は状態をローカル状態変数を用いてモデル化し、状態の変化をそれらの変\n数への代入にてモデル化します。\nこの議論を次のよう述べることで結論付けることは魅力的です。曰く、代\n入と状態を局所変数に隠す技術を紹介することで、追加のパラメータを渡すこ\nとで全ての状態が明示的に操作されなければならない場合よりも、よりモジュ\nール化を行う方法でシステムの構造化を行えます、と。残念ながらこれから学\nぶように、このお話はそんなに簡単ではありません。\nExercise 3.5:\nMonte Carlo integration\n(\nモンテカルロ積分\n)\nはモン\nテカルロ・シミュレーションを用いて定積分を推測する手法だ。\n述語\n푃 (푥, 푦)\nで記述される空間の領域の面積を計算する場合につ\nいて考えてみる。述語\n푃 (푥, 푦)\nは点\n(푥, 푦)\nが領域の中であれば真\nであり、そうでなければ偽である。例えば中心\n(5, 7)\n、半径\n3\nの円\nに含まれる領域は\n(푥 − 5)\n2\n+ (푦 − 7)\n2\n≤ 3\n2\nであるかテストする述\n語にて記述される。そのよう述語で記述された領域の面積を推測\nするためにその領域を含む長方形を選択することから始める。例\nとして対角線上の角を\n(2, 4)\nと\n(8, 10)\nに持つ長方形は先程の円を\n含む。期待される積分はその領域が位置する長方形の一部の面積\nだ。長方形の中の点\n(푥, 푦)\nを不作為に選択し、各点に対し\n푃 (푥, 푦)\nをテストしその点が元の領域の中であるかどうかを決定すること\nで積分を推定することができる。もしこの試行を数多くの点で行\nえば領域の中に落ちる点の割合は長方形の内のその領域の割合の\n推定値を与えるはずだ。従ってこの割合に長方形全体の面積を掛\nけることで積分の推定値を生成可能である。\nモンテカルロ積分を手続\nestimate-integral\nとして実装せよ。こ\nれは引数として述語\nP\n、長方形の上下界として\nx1\n,\nx2\n,\ny1\n,\ny2\n、そ\nして推定値を生成するため実行する試行回数を取る。手続は上で\n휋\nを推測するために使用した\nmonte-carlo\n手続を同じく使用せね\nばならない。\nestimate-integral\nを用いて\n휋\nの推測値を単位円の\n面積を測ることで求めよ。\n与えられた値域から不作為に選択された数値を返す手続を持つ\nことが便利であると発見するかもしれない。以下の\nrandom-in-\n241","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":267},{"id":"./test/fixtures/pdf/sicp.pdf:268","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"range\n手続はこれを\nSection 1.2.6\nで使用した\nrandom\n手続を用いて\n実装する。これは入力より小さな非負数を返す。\n8\n(\ndefine\n(\nrandom-in-range\nlow\nhigh\n)\n(\nlet\n((\nrange\n(-\nhigh\nlow\n)))\n(+\nlow\n(\nrandom\nrange\n))))\nExercise 3.6:\n乱数生成器を与えられた値から始まる列を生成する\nためリセットすることができれば便利である。シンボル\ngenerate\nまたはシンボル\nreset\nのどちらかを引数として呼び出す新し\nい\nrand\n手続を設計せよ。これは次のように振る舞う。\n(rand\n'generate)\nは新しい乱数を生成する。\n((rand  'reset)\n⟨\nnew-\nvalue\n⟩\n)\nは内部の状態変数を指定された\n⟨\nnew-value\n⟩\nでリセッ\nトする。従って状態をリセットすることで繰り返し可能な列の生\n成が行える。これは乱数を用いるプログラムのテストやデバッグ\nにおいてとても役に立つ。\n3.1.3\n代入導入のコスト\nここまで見てきたとおり、\nset!\n命令はローカルな状態を持つオブジェクト\nのモデル化を可能にします。しかしこの利点は犠牲を伴ないます。私達のプロ\nグラミング言語は\nSection 1.1.5\nで紹介した手続適用の置換モデルを用いて説明\nすることができません。加えて、プログラミング言語の間にオブジェクトと代\n入を取り扱うための適切なフレームワークとなる\n“\n良い\n”\n数学上の特性を伴な\nう簡単なモデルが存在しません。\n代入を使わない限り、同じ引数を伴なう同じ手続の二度の評価は同じ結果\nを生じ、手続は数学上の関数の計算と見ることができます。私達がこの本の最\n初の二章を通じて行ってきたような代入を使用しないプログラミングは、それ\n故に\nfunctional programming\n(\n関数型プログラミング\n)\nとして知られています。\n代入が問題をどのように困難にするかを理解するために、\nSection 3.1.1\nの\nmake-withdraw\n手続を残額が十分であるかのチェックを行わない様に単純化し\nた版について考えます。\n(\ndefine\n(\nmake-simplified-withdraw\nbalance\n)\n8\nmit\nScheme\nはそのような手続を提供します。もし\nrandom\nが\n(\nSection 1.2.6\nでの様\nに\n)\n整数を渡されれば、整数を返します。しかし\n(\nこの課題のように\n)\n少数を渡された場\n合には少数を返します。\n242","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":268},{"id":"./test/fixtures/pdf/sicp.pdf:269","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlambda\n(\namount\n)\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n))\n(\ndefine\nW\n(\nmake-simplified-withdraw\n25))\n(\nW\n20)\n5\n(\nW\n10)\n-5\nこの手続と以下の\nset!\nを使用しない\nmake-decrementer\n手続とを比べてみて\n下さい。\n(\ndefine\n(\nmake-decrementer\nbalance\n)\n(\nlambda\n(\namount\n)\n(-\nbalance\namount\n)))\nmake-decrementer\nは指定された残高\nbalance\nからその入力を引きます。しか\nし連続した呼び出しにおいて\nmake-simplified-withdraw\nのような累積効果は\nありません。\n(\ndefine\nD\n(\nmake-decrementer\n25))\n(\nD\n20)\n5\n(\nD\n10)\n15\nmake-decrementer\nがどのように働くかの説明には置換モデルを使用できます。\n例えば以下の式の評価を解析してみましょう。\n((\nmake-decrementer\n25) 20)\n最初に結合のオペレータを\nmake-decrementer\nのボディの\nbalance\nを\n25\nと置\nき換えることにより簡約します。式は以下のようになります。\n((\nlambda\n(\namount\n) (- 25\namount\n)) 20)\nlambda\n式のボディにある\namount\nを\n20\nと置き換えることでオペレータを適用\nします。\n(- 25 20)\n243","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":269},{"id":"./test/fixtures/pdf/sicp.pdf:270","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最終的な答は\n5\nです。\nしかしもし\nmake-simplified-withdraw\nに対しても同様の置換分析を試み\nれば何が起こるか観察してみて下さい。\n((\nmake-simplified-withdraw\n25) 20)\n最初に\nmake-simplified-withdraw\nのボディにある\nbalance\nを\n25\nに置き換え\nることでオペレータを簡約します。これにより式は以下のようになります。\n9\n((\nlambda\n(\namount\n) (\nset!\nbalance\n(- 25\namount\n)) 25) 20)\nここで\nlambda\n式のボディの中の\namount\nを\n20\nに置き換えてオペレータを適用\nします。\n(\nset!\nbalance\n(- 25 20)) 25\nもし置換モデルに執着するのであれば、手続の適用の意味は最初に\nbalance\nを\n5\nに設定し、次に式の値として\n25\nを返すと言わざるを得ません。これは\n間違った答を得ます。正しい答を得るためには、どうにかして最初の位置の\nbalance\n(\nset!\nの効果以前\n)\nを\n2\nつ目の\nbalance\n(\nset!\nの効果の後\n)\nから区別せ\nねばなりません。そして置換モデルはこれを行うことができません。\nここでの問題は置換は詰まるところ、私達の言語のシンボルが本質的に値\nの名前であるという概念に基いています。しかし\nset!\nと変数の値が変更でき\nるという考えを紹介してから直ぐに、変数は最早単純な名前ではあり得ません。\n今では変数はどうにかして値が格納できる場所を参照し、その場所に格納され\nた値は変更することが可能です。\nSection 3.2\nにて、環境がどのようにしてこの\n“\n場所\n”\nの役割を演じるのかについて学びます。\n同一性と変更\nここで表出した問題は特定の演算モデルが単に崩壊したよりもずっと深淵\nです。私達の計算モデルに変更を紹介して直ぐに、以前は簡単であった多くの\n概念が難問と化します。\n2\nつの物が\n“\n同じ\n”\nであるという観念について考えてみ\nましょう。\nmake-decrementer\nを同じ引数を与えて二度呼び二つの手続を作成したと\nします。\n9\nset!\n式に存在する\nbalance\nは置き換えません。なぜなら\nset!\n内の\n⟨\nname\n⟩\nは評価\nされないからです。もしこれを置き換えれば\n(set! 25 (- 25 amount))\nを得ることにな\nりますが、これは意味がありません。\n244","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":270},{"id":"./test/fixtures/pdf/sicp.pdf:271","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\nD1\n(\nmake-decrementer\n25))\n(\ndefine\nD2\n(\nmake-decrementer\n25))\nD1\nと\nD2\nは同じでしょうか\n?\n無難な答は\nYES\nです。\nD1\nと\nD2\nは同じ計算上の振\n舞を持ち、それぞれが入力から\n25\nを引く手続です。実際に\nD1\nは任意の計算に\nおいて結果を変えることなく\nD2\nの代替にできます。\nこれと\nmake-simplified-withdraw\nの二度の呼出とを対比します。\n(\ndefine\nW1\n(\nmake-simplified-withdraw\n25))\n(\ndefine\nW2\n(\nmake-simplified-withdraw\n25))\nW1\nと\nW2\nは同じでしょうか\n?\nもちろん違います。\nW1\nと\nW2\nの呼出は区別可能な\n効果を持ちます。以下の応答列によりそれが示されます。\n(\nW1\n20)\n5\n(\nW1\n20)\n-15\n(\nW2\n20)\n5\n例え\nW1\nと\nW2\nが同じ式\n(make-simplified-withdraw 25)\nを評価することで作\n成されたという点で\n“\n同じ\n”\nであっても、\nW1\nが式の評価の結果を変えずに任意\nの式で\nW2\nの代替になるかというのは正しくありません。\n式において式の値を変化せずに\n“\n等しい物は等しい物で置き換えられる\n”\nという観念を支持する言語は\nreferentially transparent\n(\n参照透明\n)\nと呼ばれます。\n参照透明は私達の計算機言語に\nset!\nを含めた時侵害されました。これがいつ\n式を等価な式で置き換えることで簡約できるかを決定することを扱いにくくし\nます。結果的に、代入を用いるプログラムについての推測は大幅により難しく\nなります。\n参照透明を無しで済ませば、計算オブジェクトが\n“\n同じ\n”\nであることを意味\nする概念が形式的に捉えることが難しくなります。本当に実際の世界での\n“\n等\n価\n”\nの意味は私達のプログラムモデルはそれ自身において全く明確になりませ\nん。一般的に\n2\nつの恐らく同じオブジェクトが本当に\n“\n同じ物\n”\nであるかは一\n方のオブジェクトを変更した場合にもう一方のオブジェクトが同様に変化した\nかを観察するしか手立てがありません。しかしオブジェクトが\n“\n変更された\n”\nことを\n“\n同じ\n”\nオブジェクトを\n2\n回観察し\n,\nオブジェクトのある属性が\n1\n回目の\n観察から次に対して異なるかどうかを見る以外にどうやって判断できるのでし\nょうか。従って\n“\n同一性\n”\nの何らかの\na priori\n(\n先験的な\n)\n概念無しに\n“\n変化\n”\nを\n245","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":271},{"id":"./test/fixtures/pdf/sicp.pdf:272","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"判断することができません。そして変化の結果を観察せずに同一性を判断する\nことはできないのです。\nこの問題がプログラミングにおいてどのように発生するかの例として、\nPeter\nと\nPaul\nが\n$100\n入っている口座を持っている状態について考えましょう。\nこれをモデル化するに当たって以下の定義と\n(\ndefine\npeter-acc\n(\nmake-account\n100))\n(\ndefine\npaul-acc\n(\nmake-account\n100))\n以下の定義では大きな違いがあります。\n(\ndefine\npeter-acc\n(\nmake-account\n100))\n(\ndefine\npaul-acc\npeter-acc\n)\n最初の状況では、\n2\nつの銀行口座は区別できます。\nPeter\nにより行われた取引\nは\nPaul\nの口座には影響を与えません。逆も同じです。\n2\nつ目の状況ではしか\nし、\npaul-acc\nが\npeter-acc\nと同じ物になるよう定義しました。実際に\nPeter\nと\nPaul\nは今では連結銀行口座を持っており\nPeter\nが\npeter-acc\nから引き出し\nを行えば\nPaul\nは\npaul-acc\nの残額が減ったことを観察するでしょう。これら\nの\n2\nつの似ているが区別できる状況は計算モデルの構築において混乱の元とな\nり得ます。具体的には、共有口座のために\n1\nつのオブジェクト\n(\n銀行口座\n)\nが\n2\nつの異なる名前\n(\npeter-acc\nと\npaul-acc\n)\nを持つことは特に混乱します。プロ\nグラムの中で\npaul-acc\nを変更することができる箇所を全て探す場合、\npeter-\nacc\nを変更する箇所もまた探さねばならないことを覚えておかなければなりま\nせん。\n10\n上記の\n“\n同一性\n”\nと\n“\n変更\n”\n上の見解への参照と共に、もし\nPeter\nと\nPaul\nは\n差引残高を調べられるだけで差引残高を変更する命令を実行することができ\nない場合、\n2\nつの口座が区別できるかどうかという問題が無意味になるのかに\nついて注意して下さい。一般的に、データオブジェクトを変更しない限り、複\n10\n単一の計算オブジェクトが複数の名前によりアクセスされる事象は\naliasing\n(\nエイリ\nアシング\n)\nとして知られています。連結銀行口座の状況はエイリアスのとても簡単な例\nを説明します。\nSection 3.3\nでは\n“\n識別可能\n”\nな複合データ構造が一部を共有するような\nさらに複雑な例について学びます。バグはプログラムの中でオブジェクトに対する変更\nが\n“\n副作用\n”\nとして\n“\n異なる\n”\nオブジェクトに対しても変更を行い得る場合を忘れている\n時に発生します。\n2\nつの\n“\n異なる\n”\nオブジェクトが実際には異なるエイリアスの下に現れ\nる単一のオブジェクトであるためです。これらは\nside-effect bugs\n(\n副作用バグ\n)\nと呼ば\nれる物で位置の特定や分析がとても難しいため一部の人々はプログラミング言語は副作\n用やエイリアスを許可しないよう設計されるべきだと提案しています。\n(\nLampson et al.\n1981\n;\nMorris et al. 1980\n)\n246","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":272},{"id":"./test/fixtures/pdf/sicp.pdf:273","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"合データオブジェクトをまさにそれの部分の全体であると見做すことができ\nます。例えば、分数はその分子と分母により決定されます。しかしこの見方は\n変更が存在する時には、複合データオブジェクトがそれが組み立てられている\n部品とは異質の\n“\nアイデンティティ\n(\n自己同一性\n)”\nを持つ場合には有効ではあ\nりません。銀行口座は例え引き出しを行うことで残高を変更しても依然として\n“\n同じ\n”\n銀行口座です。反対に、同じ状態情報を持つ\n2\nつの異なる銀行口座を持\nつこともできるでしょう。この複雑さは私達のプログラミング言語による物で\nはなく、私達のオブジェクトとしての銀行口座の認知によるものです。例えば\n私達は通常分数を同一性を保ちながら変更可能なオブジェクトだとは見做しま\nせん。分子を変更したら\n“\n同じ\n”\n分数をだとは思いません。\n命令型プログラミングの落とし穴\n関数型プログラミングとは反対に、代入を広範囲に用いるプログラミング\nは\nimperative programming\n(\n命令型プログラミング\n)\nとして知られています。計\n算モデルに関する複雑さを上げるのに加えて、命令型スタイルで書かれたプロ\nグラムは関数型プログラムでは起こり得ないバグを起こしやすくなります。例\nえば\nSection 1.2.1\nの反復指数プログラムを思い出して下さい。\n(\ndefine\n(\nfactorial\nn\n)\n(\ndefine\n(\niter\nproduct\ncounter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\niter\n(*\ncounter\nproduct\n) (+\ncounter\n1))))\n(\niter\n1 1))\n内部の反復ループ内で引数を渡す代わりに変数\nproduct\nと\ncounter\nの値の明\n示的な代入を用いることでより命令型のスタイルを受け入れることができます\n(\ndefine\n(\nfactorial\nn\n)\n(\nlet\n((\nproduct\n1)\n(\ncounter\n1))\n(\ndefine\n(\niter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\nbegin\n(\nset!\nproduct\n(*\ncounter\nproduct\n))\n(\nset!\ncounter\n(+\ncounter\n1))\n(\niter\n))))\n247","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":273},{"id":"./test/fixtures/pdf/sicp.pdf:274","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\niter\n)))\nこれはプログラムにより生成される結果に違いがありません。しかし微妙な罠\nを招いています。私達は代入の順序をどのように決めたのでしょうか。たまた\nま上のプログラムは正しく書かれています。しかし代入を逆順に書くことは\n(\nset!\ncounter\n(+\ncounter\n1))\n(\nset!\nproduct\n(*\ncounter\nproduct\n))\n異なる間違った結果を生じることでしょう。一般的に代入を伴なうプログラミ\nングは各命令が変更された変数の正しい版を用いることを確認するために、私\n達に注意深く代入の相対順序を考えることを強制します。この問題は単純に関\n数型プログラミングでは起こりません。\n11\n命令型プログラムの複雑さは複数のプロセスが並行に実行されるアプリケ\nーションを考える場合により悪くなります。この点については\nSection 3.4\nにて\n戻ります。しかし最初に代入を含む表現のための計算モデルを提供する場合の\n問題を提示します。そしてシミュレーションの設計においてローカルな状態を\n持つオブジェクトの使用を検討します。\nExercise 3.7:\nExercise 3.3\nで記述したパスワード変更を用いる\nmake-account\nにより作成された銀行口座オブジェクトについて考\nえる。私達の銀行システムが連結口座の開設能力を必要とすると\n仮定しよう。これを達成する手続\nmake-joint\nを定義せよ。\nmake-\njoint\nは\n3\nつの引数を取らねばならない。第一はパスワードで守\nられた口座である。第二引数はパスワードで\nmake-joint\n命令が成\n功するためには口座が開設された時点のパスワードに合致しなけ\nればならない。第三引数は新しいパスワードである。\nmake-joint\nは元の口座に対して新しいパスワードを用いる追加のアクセスを\n作成する。例えば\npeter-acc\nがパスワード\nopen-sesame\nを用いる\n銀行口座であれば、\n11\nこの視点ではプログラミング入門が高度に命令型スタイルを用いながら最も頻繁に\n教えられていることは皮肉な事です。これは\n1960\n年代から\n1970\n年代までの間中、手続\nを呼ぶプログラムは本質的に代入を実行するプログラムよりも非効率であるに違いない\nという共通の信念の名残でしょう。\n(\nSteele 1977\nがこの論争が誤りであることを示しまし\nた\n)\n。あるいは行毎の代入を思い浮かべることが初心者にとって手続呼出よりも簡単であ\nるという見方もあるでしょう。どのような理由しろ、このことは初級プログラマに対し\n“\n私はこの変数をあれより前か後に設定するべきか\n?”\nといったプログラミングを複雑に\nし、重要な考慮点を不明瞭にする心配事をしばしば負わせることになります。\n248","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":274},{"id":"./test/fixtures/pdf/sicp.pdf:275","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\npaul-acc\n(\nmake-joint\npeter-acc\n'open-sesame\n'rosebud\n))\n上記は\npeter-acc\nに対し名前\npaul-acc\nとパスワード\nrosebud\nを\n用いて取引することを可能にする。この新しい機能に対応するた\nめあなたの\nExercise 3.3\nへの解答を変更したいと思うだろう。\nExercise 3.8:\nSection 1.1.3\nにて評価モデルを定義した時、式の評\n価の最初のステップはその部分式を評価することだと述べました。\nしかし部分式を評価する順については指定しませんでした。\n(\n例え\nば左から右や右から左です\n)\n。代入を導入する時、手続に対する引\n数が評価される順は結果に違いを起こせます。以下の式を評価し\nた時に、\n(+ (\nf\n0) (\nf\n1))\n+\nの引数が左から右へ評価された場合に\n0\nを返し、右から左へ評価\nされた場合に\n1\nを返すようにする簡単な手続\nf\nを定義せよ。\n3.2\n評価の環境モデル\n複合手続を\nChapter 1\nで紹介した時、手続を引数に適用することが何を意味\nするか定義するため評価の置換モデルを使用しました\n(\nSection 1.1.5\n)\n。\n•\n複合手続を引数に適用するため、手続のボディを各形式パラメータを相\n対する引数で置き換えて評価する。\n一旦代入を私達のプログラミング言語で認めれば、そのような定義は最早適切\nでありません。具体的には\nSection 3.1.3\nで議論しましたが、代入の出現により、\n変数は最早単に値に対する名前であると考えることができません。そうでなく、\n変数はどうにかして値が格納できる\n“\n場所\n”\nを指定することになります。私達\nの新しい評価モデルではこれらの場所は\nenvironments\n(\n環境\n)\nと呼ばれる構造に\n保存されます。\n環境は\nframes\n(\nフレーム\n)\nの列です。各フレームは\nbindings\n(\n束縛\n)\nの\n(\n空の可\n能性のある\n)\nテーブルで、変数名とそれらが相対する値とを結び付けます。\n(\n単\n一のフレームは任意の変数に対してたかだか\n1\nつの束縛を保持します\n)\n。各フ\nレームはまた議論の目的のためフレームが\nglobal\n(\nグローバル\n、大域的\n)\nだと認\n識されない限り、\nenclosing environment\n(\n外部環境\n)\nへのポインタを持ちます。\n249","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":275},{"id":"./test/fixtures/pdf/sicp.pdf:276","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"A\nB\nC  D\nI\nII\nIII\nz:6\nx:7\nm:1\ny:2\nx:3\ny:5\nFigure 3.1:\n単純な環境構造\n環境に対して\nvalue of a variable\n(\n変数の値\n)\nはその変数に対する束縛を持つ環\n境内の最初のフレーム内の変数の束縛により与えられる値です。もし列内の全\nてのフレームがその変数に対する束縛を指定しない場合、その変数はその環境\nに\nunbound\n(\n束縛されない\n)\nと呼びます。\nFigure 3.1\nは\nI, II, III\nとラベリングした\n3\nつのフレームから成る簡単な環\n境構造を示しています。図の中で\nA, B, C, D\nは環境へのポインタです。\nC\nと\nD\nは同じ環境を差しています。変数\nz\nと\nx\nはフレーム\nII\nに束縛され、一方\ny\nと\nx\nはフレーム\nI\nに束縛されます。環境\nD\nの\nx\nの値は\n3\nです。環境\nB\nに対する\nx\nの\n値もまた\n3\nです。これは次のように決定されます。列の最初のフレーム\n(\nフレ\nーム\nIII)\nを調べますが\nx\nに対する束縛を見つけられません。そのため外部環境\nD\nで続けてフレーム\nI\nの中に束縛を見つけます。一方で環境\nA\nでの\nx\nの値は\n7\nです。列の最初のフレーム\n(\nフレーム\nII)\nが\nx\nから\n7\nへの束縛を含んでいるか\nらです。環境\nA\nに対して、フレーム\nII\n内の\nx\nから\n7\nへの束縛はフレーム\nI\nの\nx\nから\n3\nへの束縛を\nshadow\n(\n隠蔽する\n)\nと言われます。\n環境は評価プロセスに対し不可欠な存在です。式が評価されるべきコンテキス\nト\n(\n文脈\n)\nを決定するためです。実際にプログラミング言語の式、それ自身は意\n味を持たないと言えるでしょう。そうでなく、式はそれが評価されるある環境\nに対してのみ意味を獲得します。\n(+ 1 1)\nのような簡単な式の逐次実行でさえ、\n+\nが加算のためのシンボルであるというコンテキストのなかで操作していると\nいう合意に依存しています。従って私達の評価モデルにおいて私達は常にある\n環境に対して式を評価すると述べます。インタプリタとの相互作用を説明する\nために、単一のフレームから成り立ち\n(\n外部環境を持たず\n)\n、プリミティブな手\n250","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":276},{"id":"./test/fixtures/pdf/sicp.pdf:277","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"続に関連するシステムの値を持つグローバル環境が存在すると仮定します。例\nえば\n+\nが加算に対するシンボルであるという考えは、シンボル\n+\nがグローバル\n環境においてプリミティブな加算手続に対し束縛されていると言うことで捉え\nられます。\n3.2.1\n評価のルール\nインタプリタが組み合わせをどのように評価するかの全体的な仕様は最初\nに\nSection 1.1.3\nにて紹介した時と同じに残っています。\n•\n組み合わせを評価するために\n1.\n組み合わせの部分式を評価する。\n12\n2.\nオペレータ部分式の値をオペランド部分式の値に適用する。\n評価の環境モデルは置換モデルを複合手続を引数に適用することの意味を指定\nすることで置き換えます。\n評価の環境モデルでは手続は常にあるコードと環境へのポインタのペアか\nら成り立ちます。手続はただ\n1\nつの方法で作成されます。それは\n휆\n式を評価す\nることです。これによりコードが\n휆\n式のテキストから得られる手続が生成さ\nれ、その環境は\n휆\n式が手続を生成するために評価された環境になります。例え\nば以下の手続定義について考えてみましょう。\n(\ndefine\n(\nsquare\nx\n)\n(*\nx\nx\n))\nこの式はグローバル環境で評価されました。この手続定義の文法は根底にある\n暗黙的な\n휆\n式のための構文糖です。これは次を行った場合と等価です。\n(\ndefine\nsquare\n(\nlambda\n(\nx\n) (*\nx\nx\n)))\n12\n代入は評価ルールのステップ\n1\nに微妙さを取り込みます。\nExercise 3.8\nに示されるよ\nうに代入の存在は組み合わせの部分式がどの順で評価されるかに依存して異なる値を生\nじます。従って正確に述べればステップ\n1\nにおける評価順を指定せねばなりません。\n(\n例\nえば左から右や右から左等\n)\n。しかしこの順は常に実装上の詳細と考えられねばなりませ\nん。例えば洗練されたコンパイラはどの部分式が評価されるかの順を最適化のために変\nえるかもしれません。\n251","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":277},{"id":"./test/fixtures/pdf/sicp.pdf:278","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"other variables\nsquare:\nglobal\nenv\n(define (square x)\n  (* x x))\nparameters:\n x\nbody: \n(* x x)\nFigure 3.2:\n大域環境内にて\n(define (square x) (* x x))\nを評価することにより生成された環境構造\nこれは\n(lambda (x) (* x x))\nを評価し、全てグローバル環境において\nsquare\nをその結果に束縛します。\nFigure 3.2\nはこの\ndefine\n式の評価結果を示します。手続オブジェクトは手\n続が\n1\nつの形式パラメータ\nx\nを持ち手続のボディが\n(* x x)\nことをコードが\n指定するペアです。手続の環境部分はグローバル環境へのポインタです。それ\nが\n휆\n式が手続を生じるため評価される環境なためです。シンボル\nsquare\nと手\n続オブジェクトを関連付ける新しい束縛はグローバルなフレームに追加されま\nす。一般的に\ndefine\nはフレームに束縛を追加することで定義を作成します。\nこれで手続がどのように作成されるのか学んだので手続がどのように適用され\nるのかを説明することができます。環境モデルは以下のことを指定します。手\n続を引数に適用するために、パラメタを引数の値に束縛するフレームを含む新\nしい環境を作成します。このフレームの外部環境は手続により指定された環境\nです。さて、この新しい環境で手続のボディを評価します。\nこのルールがどのように従われるかについて示すため、\nFigure 3.3\nは式\n(square 5)\nをグローバル環境にて\nsquare\nが\nFigure 3.2\nにて生成された手続あ\nる場合に評価することで作成された環境構造を図示しています。この手続の適\n用は図で\nE1\nと示される新しい環境の作成に帰着し、手続の形式パラメタ\nx\nが\n引数\n5\nに束縛されているフレームで始まっています。このフレームから情報へ\n向かうポインタはフレームの外部環境がグローバル環境であることを示しま\nす。\nsquare\n手続オブジェクトの一部として示される環境であるためここでグ\n252","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":278},{"id":"./test/fixtures/pdf/sicp.pdf:279","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"E1\n(* x x)\nparameters: \nx\nbody: \n(* x x)\n(square 5)\nglobal\nenv\nother variables\nsquare:\nx:5\nFigure 3.3:\n大域環境内にて\n(square 5)\nを評価することに\nより作られた環境\nローバル環境が選択されます。\nE1\nの中では手続のボディ\n(* x x)\nを評価しま\nす。\nE1\n中の\nx\nの値は\n5\nであるため結果は\n(* 5 5)\n、つまり\n25\nです。\n手続適用の環境モデルは\n2\nつのルールでまとめられます。\n•\n手続オブジェクトはフレームを構築、手続の形式パラメタを呼出の引数\nへ束縛し、新しく構築された環境のコンテキストにて手続のボディを評\n価することで引数の集合に手続を適用することができる。\n•\n手続は与えられた環境に関連する\n휆\n式を評価することで作成される。結\n果としての手続オブジェクトは\n휆\n式のテキストと手続が作成された環境\nへのポインタから成るペアである。\ndefine\nを用いてのシンボルの定義は現在の環境フレームに束縛を作成し、そ\nのシンボルに指示された値を束縛することもまた指摘します。\n13\n最後に、\nset!\nの振舞を指定します。私達にそもそも環境モデルの導入を強いた命令です。あ\nる環境で式\n(set!\n⟨\nvariable\n⟩ ⟨\nvalue\n⟩\n)\nを評価することはその環境に束縛を位置\n付け、その束縛を新しい値を示すよう変更します。つまり\nset!\nは環境でその\n13\nもし既にその変数への束縛が現在のフレームに存在する場合、束縛は変更されます。\nこれはシンボルの再定義を可能にするため便利です。しかし\ndefine\nが値の変更に使用で\nきること、そしてこれが明示的に\nset!\nを使用せずとも代入の問題を持ち出すことを意味\nします。このため既存のシンボルの再定義に対しエラーや警告を発することを好む人達\nもいます。\n253","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":279},{"id":"./test/fixtures/pdf/sicp.pdf:280","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"変数の束縛を持つ最初のフレームを探しそのフレームを変更します。もし変数\nがその環境では束縛されていないのであれば\nset!\nはエラーを発します。\nこれらの評価ルールは置換モデルより大幅により複雑ですが、依然として\n適度に容易です。さらに環境モデルは抽象的ですがインタプリタが式をどのよ\nうに評価するかの正し説明を与えます。\nChapter 4\nではこのモデルがどのよう\nにうまく働くインタプリタの実装のための設計図としての役を果たすのかにつ\nいて学ぶことになります。残りの節ではいくつかの実例となるプログラムを分\n析することによりこのモデルについての詳細を述べます。\n3.2.2\n単純な手続の適用\nSection 1.1.5\nにて置換モデルを紹介した時、以下の手続定義を与えられた場\n合に合成\n(f 5)\nがどのように\n136\nとして評価されるかについて説明しました。\n(\ndefine\n(\nsquare\nx\n)\n(*\nx\nx\n))\n(\ndefine\n(\nsum-of-squares\nx\ny\n)\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\ndefine\n(\nf\na\n)\n(\nsum-of-squares\n(+\na\n1) (*\na\n2)))\n同じ式を環境モデルを用いて分析できます。\nFigure 3.4\nは\n3\nつの手続オブジェ\nクトが\nf\n,\nsquare\n, and\nsum-of-squares\nの定義を評価することでグローバル環\n境に作成されたことを示します。各手続オブジェクトはいくつかのコードとグ\nローバル環境へのポインタから成り立ちます。\nFigure 3.5\nは式\n(f 5)\nを評価することで作成された環境構造です。\nf\nの呼出によ\nり\nf\nの形式パラメタ\na\nが引数\n5\nに束縛されるフレームで始まる新しい環境\nE1\nが作成されます。\nE1\nの中で\nf\nのボディを評価します。\n(\nsum-of-squares\n(+\na\n1) (*\na\n2))\nこの合成式を評価するために最初に部分式を評価します。最初の部分式\nsum-\nof-squares\nは手続オブジェクトである値を持っています。\n(\nこの値がどのよう\nに見つけられるかに注意して下さい。最初に\nE1\nの第一フレームを調べますが\nsum-of-squares\nの束縛はありません。次に外部環境に進みます。つまりグロ\nーバル環境です。そこで\nFigure 3.4\nに示すように束縛を見つけます\n)\n。他の\n2\nつ\nの部分式はプリミティブな命令\n+\nと\n*\nを、\n2\nつの合成式\n(+ a 1)\nと\n(* a 2)\nを\n評価しそれぞれ\n6\nと\n10\nを得るために適用することで評価されます。\n254","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":280},{"id":"./test/fixtures/pdf/sicp.pdf:281","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"square:\nsum-of-squares:\nf:\nglobal\nenv\nparameters: \na\nbody: \n(sum-of-squares\n       (+ a 1)\n       (* a 2))\nparameters: \nx\nbody: \n(* x x)\nparameters: \nx,y\nbody: \n(+ (square x)\n        (square y))\nFigure 3.4:\nグローバルフレーム内の手続オブジェクト\nこれで手続オブジェクト\nsum-of-squares\nを引数\n6\nと\n10\nに適用します。結\n果は形式パラメタ\nx\nと\ny\nが引数に束縛される新しい環境\nE2\nへ帰着します。\nE2\n内では合成\n(+ (square x) (square y))\nを評価します。これが\n(square x)\nの評価へと移り、\nsquare\nはグローバルフレームで見つかり、\nx\nは\n6\nです。もう\n一度、新しい環境\nE3\nを立ち上げ、\nx\nは\n6\nに束縛され\nE3\nの中で\nsquare\nのボデ\nィ\n(* x x)\nが評価されます。また\nsum-of-squares\nの適用の一部として部分式\n(square y)\nも評価さねばならずそこでは\ny\nは\n10\nです。この\n2\nつ目の\nsquare\nの呼出がまた別の環境\nE4\nを作成し、そこでは\nsquare\nの形式パラメタ\nx\nは\n10\nに束縛されます。そして\nE4\nの中では\n(* x x)\nを評価せねばなりません。\n確認すべき重要な点は\nsquare\nの各呼出が\nx\nの束縛を持つ新しい環境を構築す\nることです。ここで私達は異なるフレームがどのようにして全て\nx\nと名付け\nられた異なるローカル変数の独立を保つのかについて見ることができるます。\nsquare\nにより作られた各フレームがグローバル環境を差していることに注意\nして下さい。これは\nsquare\n手続オブジェクトが指す環境であるためです。\n部分式が評価された後に結果が返されます。\n2\nつの\nsquare\nの呼出により作\n成された値は\nsum-of-squares\nにより加算され、この結果が\nf\nにより返されま\nす。ここでの私達の焦点は環境構造上にありますのでこれらの返された値が呼\n出から呼出へどのように渡されるかについては長々と説明は致しません。しか\nし、これはまた評価処理の重要な側面であり、\nChapter 5\nにてこれの詳細に戻り\n255","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":281},{"id":"./test/fixtures/pdf/sicp.pdf:282","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(* x x)\nx:10\nE4\n(* x x)\nx:6\nE3\n(+ (square x)\n   (square y))\nx:6\ny:10\nE2\n(sum-of-squares\n  (+ a 1)\n  (* a 2))\na:5\nE1\n(f 5)\nglobal\nenv\nFigure 3.5:\nFigure 3.4\n内の手続を用いて\n(f 5)\nを評価するこ\nとで作られた環境\nます。\nExercise 3.9:\nSection 1.2.1\nにて指数演算のための\n2\nつの手続を解\n析するために置換モデルを使用した。以下が再帰版であり、\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (*\nn\n(\nfactorial\n(-\nn\n1)))))\n以下は反復版である。\n(\ndefine\n(\nfactorial\nn\n) (\nfact-iter\n1 1\nn\n))\n(\ndefine\n(\nfact-iter\nproduct\ncounter\nmax-count\n)\n(\nif\n(>\ncounter\nmax-count\n)\nproduct\n(\nfact-iter\n(*\ncounter\nproduct\n)\n(+\ncounter\n1)\nmax-count\n)))\n各版の\nfactorial\n手続を用いて\n(factorial 6)\nを評価した場合に\n作成される環境構造を示せ。\n14\n14\n環境モデルはインタプリタは\nfact-iter\nのような手続を末尾再帰を用いることで一\n定量の記憶域にて実行できるという\nSection 1.2.1\nでの私達の主張を明確にはしません。末\n256","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":282},{"id":"./test/fixtures/pdf/sicp.pdf:283","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"3.2.3\n局所状態のレポジトリとしてのフレーム\n手続と代入がどのようにしてローカルな状態を持つオブジェクトを表現\nするために利用できるかを知るために環境モデルに助けを求めることができ\nます。\n(\ndefine\n(\nmake-withdraw\nbalance\n)\n(\nlambda\n(\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n)))\n次の定義の評価について説明してみましょう。\n(\ndefine\nW1\n(\nmake-withdraw\n100))\n以下のように用いたとします。\n(\nW1\n50)\n50\nFigure 3.6\nはグローバル環境における\nmake-withdraw\n手続の定義の結果を示し\nます。グローバル環境へのポインタを持つ手続オブジェクトを作成します。今\nの所、これは今までに見た例から異なる点はありません。ただし手続のボディ\nそれ自身が\n휆\n式であることが異なります。\n演算の面白い部分は手続\nmake-withdraw\nを引数に適用した時に起こります。\n(\ndefine\nW1\n(\nmake-withdraw\n100))\n通常通りに形式パラメタ\nbalance\nが引数\n100\nに束縛される環境\nE1\nを設定する\nことから始まります。この環境の中で\nmake-withdraw\nのボディ、即ち\n휆\n式を評\n価します。これがコードは\nlambda\nで指定され、環境が\nE1\nである新しい手続オ\nブジェクトが構築されます。その\nE1\nの中で\nlambda\nが手続を生成するため評価\nされています。結果の手続オブジェクトは\nmake-withdraw\nを呼び出して返され\nた値です。これはグローバル環境にて\nW1\nに束縛されます。\ndefine\n自身がグロ\nーバル環境にて評価されたためです。\nFigure 3.7\nは結果の環境構造を示します。\nNow we can analyze what happens when\nW1\nis applied to an argument:\nこれで\nW1\nが引数に適用された時に何が起こるかを解析できます。\n尾再帰については\nSection 5.4\nにてインタプリタのコントロール構造を取り扱う時に議論\nします。\n257","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":283},{"id":"./test/fixtures/pdf/sicp.pdf:284","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"parameters:\n balance\nbody:\n (lambda (amount)\n        (if (>= balance amount)\n            (begin (set! balance (-- balance amount))\n                   balance)\n            \"insufficient funds\"))\nglobal\nenv\nmake-withdraw:\nFigure 3.6:\nグローバル環境にて\nmake-withdraw\nを定義し\nた結果\n(\nW1\n50)\n50\nW1\nの形式パラメタ\namount\nが引数\n50\nに束縛されるフレームを構築することか\nら始めます。観察すべき重大な点はこのフレームがその外部環境としてグロー\nバル環境ではなく環境\nE1\nを持っている点です。これが\nW1\n手続オブジェクトに\nより指示される環境だからです。この新しい環境の中で手続のボディを評価し\nます。\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n)\n結果の環境構造は\nFigure 3.8\nに示されます。評価された式は\namount\nと\nbalance\nの両方を参照します。\namount\nは環境の最初のフレームに見つかりますが、\nbalance\nは外部環境ポインタに従って\nE1\nにて見つかります。\nset!\nが実行された時、\nE1\n中の\nbalance\nの束縛は変更されます。\nW1\nの呼出が終\n了する時\nbalance\nは\n50\nで、\nbalance\nを含むフレームは依然手続オブジェクト\nW1\nから指されています。\namount\nを束縛する\n(\nその中で\nbalance\nを変更するコ\n258","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":284},{"id":"./test/fixtures/pdf/sicp.pdf:285","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"E1\nmake-withdraw:\nW1:\nglobal\nenv\nbalance: 100\nparameters:  \nbalance\nbody:  \n...\nparameters:  \namount\nbody:  \n(if (>= balance amount)\n          (begin (set! balance (- balance amount))\n                 balance)\n          \"insufficient funds\")\nFigure 3.7:\n(define W1 (make-withdraw 100))\nを評価した結果\nードを実行した\n)\nフレームは最早関係が存在しません。それを構築した手続呼\n出は停止したためです。そしてその環境の他の部分からそのフレームを指すポ\nインタは存在しません。次回\nW1\nが呼ばれた時、\namount\nを束縛する新しいフレ\nームが構築されその外部環境は\nE1\nになります。私達は\nE1\nが手続オブジェクト\nW1\nのためのローカル状態を持つ\n“\n場所\n”\nの役割を果たすのを見ました。\nFigure\n3.9\nは\nW1\nを呼び出した後の状況を示します。\n二つ目の\n“withdraw”\nオブジェクトを別の\nmake-withdraw\n呼出を行うこと\nで作成した時に何が起こるかについて観察して下さい。\n(\ndefine\nW2\n(\nmake-withdraw\n100))\nこれにより\nFigure 3.10\nの環境構造が生成され\nW2\nが手続オブジェクトであり、\nある程度のコードと環境によるペアであることを示しています。\nW2\nのための環\n境\nE2\nは\nmake-withdraw\nの呼出により作成されます。それ専用の\nbalance\nのた\nめのローカルな状態を持つフレームを含みます。一方で\nW1\nと\nW2\nは同じコード\nを持ちます。\nmake-withdraw\nのボディ内の\n휆\n式によりコードは指定されていま\n259","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":285},{"id":"./test/fixtures/pdf/sicp.pdf:286","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"E1\nmake-withdraw: ...\nW1:\nglobal\nenv\nbalance: 100\nparameters:  \namount\nbody:  \n...\namount: 50\nHere is the balance\nthat will be changed\nby the set!\n(if (>= balance amount)\n    (begin (set! balance \n                 (- balance amount))\n           balance)\n    \"insufficient funds\")\nFigure 3.8:\n手続オブジェクト\nW1\nを適用したことにより作成され\nた環境\nす。\n15\nなぜ\nW1\nと\nW2\nが独立したオブジェクトとして振る舞うのかをここで見\nました。\nW1\nの呼出は\nE1\nに格納された状態変数\nbalance\nを参照し、一方\nW2\nの\n呼出は\nE2\nに格納された\nbalance\nを参照します。従って一方のオブジェクトの\nローカル状態への変更は他方のオブジェクトに影響を与えません。\nExercise 3.10:\nmake-withdraw\n手続ではローカル変数\nbalance\nは\nmake-withdraw\nのパラメタとして作成される。ローカル状態変数\nを明示的に\nlet\nを使って以下の様に作成することもできる。\n(\ndefine\n(\nmake-withdraw\ninitial-amount\n)\n(\nlet\n((\nbalance\ninitial-amount\n))\n(\nlambda\n(\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\n15\nW1\nと\nW2\nが計算機内の同じ物理コードを共有しているかどうか、またはそれぞれがコ\nードのコピーを持っているのかは実装上の詳細です。\nChapter 4\nで実装するインタプリタ\nではコードは実際に共有されます。\n260","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":286},{"id":"./test/fixtures/pdf/sicp.pdf:287","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"E1\nmake-withdraw: ...\nW1:\nglobal\nenv\nbalance: 50\nparameters:  \namount\nbody:  \n...\nFigure 3.9:\nW1\n呼出後の環境\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))))\nSection 1.3.2\nで\nlet\nは手続呼出のための単純な構文糖であったこ\nとを思い出そう。\n(\nlet\n((\n⟨\nvar\n⟩\n⟨\nexp\n⟩\n))\n⟨\nbody\n⟩\n)\n上記は代替的な文法として以下に翻訳される。\n((\nlambda\n(\n⟨\nvar\n⟩\n)\n⟨\nbody\n⟩\n)\n⟨\nexp\n⟩\n)\n環境モデルを用いてこの\nmake-withdraw\nの代替版を解析し、先に\n記述したような図を描き相互作用を説明せよ。\n(\ndefine\nW1\n(\nmake-withdraw\n100))\n(\nW1\n50)\n(\ndefine\nW2\n(\nmake-withdraw\n100))\nmake-withdraw\nの\n2\nつの版が同じ振舞を持つオブジェクトを作成\nすることを示せ。環境構造は\n2\nつの版でどのように違うか\n?\n261","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":287},{"id":"./test/fixtures/pdf/sicp.pdf:288","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"E1\nW2:\nW1:\nglobal\nenv\nbalance: 50\nparameters:  \namount\nbody:  \n...\nE2\nbalance: 100\nmake-withdraw: ...\nFigure 3.10:\n(define W2 (make-withdraw 100))\nを用いて\n2\nつ目のオブジェクトを作成\n3.2.4\n内部定義\nSection 1.1.8\nでは手続が内部定義を持つこことができ、結果としてブロック\n構造へと導くことを説明しました。以下の平方根を求める手続がその例です。\n(\ndefine\n(\nsqrt\nx\n)\n(\ndefine\n(\ngood-enough?\nguess\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n(\ndefine\n(\nimprove\nguess\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\n(\ndefine\n(\nsqrt-iter\nguess\n)\n(\nif\n(\ngood-enough?\nguess\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\n))))\n(\nsqrt-iter\n1.0))\nさて環境モデルを用いてなぜこれらの内部定義が希望通りに振る舞うのかを調\nべることができます。\nFigure 3.11\nは内部手続\ngood-enough?\nが\nguess\nが\n1\nに等\n262","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":288},{"id":"./test/fixtures/pdf/sicp.pdf:289","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"しい場合に最初に呼ばれた状態で式\n(sqrt 2)\nを評価した時点を示しています。\n環境構造を観察して下さい。\nsqrt\nはグローバル環境におけるシンボルで\nあり手続オブジェクトに束縛され、その関連する環境はグローバル環境です。\nsqrt\nが呼ばれた時、新しい環境\nE1\nが形成されグローバル環境の下位に置かれ、\nその中ではパラメタ\nx\nが\n2\nに束縛されます。\nsqrt\nのボディが次に\nE1\nの中で評\n価されます。\nsqrt\nのボディの最初の式は以下であり、\n(\ndefine\n(\ngood-enough?\nguess\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\nこの式を評価すると手続\ngood-enough?\nが環境\nE1\nの中に定義されます。具体\n的には、シンボル\ngood-enough?\nが\nE1\nの最初のフレームに追加され環境\nE1\nを\n指す手続オブジェクトに束縛されます。同様に\nimprove\nと\nsqrt-iter\nが\nE1\nの\n中に手続として定義されます。簡潔さのために、\nFigure 3.11\nは\ngood-enough?\nに対する手続オブジェクトのみを示しています。\nローカル手続が定義された後に、式\n(sqrt-iter 1.0)\nがまた環境\nE1\nの中で\n評価されます。そのため\nE1\nの中で\nsqrt-iter\nに束縛された手続オブジェクト\nが引数\n1\nにて呼ばれます。これが環境\nE2\nを作成し\nsqrt-iter\nのパラメタであ\nる\nguess\nが\n1\nに束縛される。\nsqrt-iter\nは次に\ngood-enough?\nを\n(E2\nの\n)\nguess\nの値を引数として呼びます。これが別の環境\nE3\nを構築し\n(\ngood-enough?\nの\n引数である\n)\nguess\nが\n1\nに束縛されます。\nsqrt-iter\nと\ngood-enough?\nの両方が\nguess\nという名前のパラメタを持ちますが、\n2\nつの区別可能なローカル変数が\n異なるフレームの中に存在します。また\nE2\nと\nE3\nの両方が\nE1\nを外部環境とし\nて持ちます。手続\nsqrt-iter\nと\ngood-enough?\nの両方が\nE1\nをそれらの環境部\n分として持つためです。これの結果の\n1\nつとして\ngood-enough?\nのボディ内の\nシンボル\nx\nは\nE1\n内に存在する\nx\nの束縛を参照します。即ち元の\nsqrt\n手続が\n呼ばれた時の\nx\nの値です。\n環境モデルは従ってローカル手続定義をプログラムのモジュール化するた\nめの便利なテクニックとする\n2\nつの鍵となる性質を説明します。\n•\nローカル手続の名前は\n(\n直の\n)\n外部手続の外側の名前と衝突しない。ロー\nカル手続の名前は手続が実行される時に作成したフレーム内にて束縛さ\nれるのであり、グローバル環境内で束縛される訳でありません。\n•\nローカルな手続はそれを内包する外部手続の引数にアクセスすることが\nできます。単純にパラメタの名前を自由変数として用いるだけです。こ\nれはローカル手続のボディは外部手続のための評価環境の下位に置かれ\nる環境内で評価されるためです。\n263","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":289},{"id":"./test/fixtures/pdf/sicp.pdf:290","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"parameters:\nx\nbody:\n(define good-enough? ...)\n      (define improve ...)\n      (define sqrt-iter ...)\n      (sqrt-iter 1.0)\nglobal\nenv\nsqrt:\nE1\nx:2\ngood-enough?:\nimprove: ...\nsqrt-iter: ...\nparameters:\nguess\nbody:\n(< (abs ...)\n         ...)\nguess: 1\nguess: 1\ncall to\n sqrt-iter\nE2\ncall to\n good-enough?\nE3\nFigure 3.11:\n内部定義を持つ\nsqrt\n手続\nExercise 3.11:\nSection 3.2.3\nでは環境モデルがどのようにローカル\nな状態を持つ手続の振舞を説明するかについて学んだ。ここまでで\n内部定義がどのように働くかについて理解した。典型的なメッセ\nージパッシング手続はこれらの側面の両方を持っている。\nSection\n3.1.1\nの銀行口座について考えよう。\n(\ndefine\n(\nmake-account\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n264","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":290},{"id":"./test/fixtures/pdf/sicp.pdf:291","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n)\nwithdraw\n)\n((\neq?\nm\n'deposit\n)\ndeposit\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n)\n以下の応答により生成される環境構造を示せ。\n(\ndefine\nacc\n(\nmake-account\n50))\n((\nacc\n'deposit\n) 40)\n90\n((\nacc\n'withdraw\n) 60)\n30\nacc\nの局所状態はどこにあるか\n?\n別の口座を定義したとする。\n(\ndefine\nacc2\n(\nmake-account\n100))\n2\nつの口座の局所状態はどのように区別されるか\n?\n環境構造のどの\n部分が\nacc\nと\nacc2\nにて共有されるか\n?\n3.3\nミュータブルデータによるモデリング\nChapter 2\nでは複合データを計算オブジェクトを構築する手段として扱いま\nした。これは複数の側面を持つ実際の世界のオブジェクトをモデル化するため\nにいくつかの部品を持ちます。また\nChapter 2\nではデータオブジェクトを作成\nするコンストラクタと、複合データオブジェクトの部品にアクセスするセレク\nタを用いてどのデータ構造が指定されるかに準ずるデータ抽象化の規律につい\nても紹介しました。しかし今では\nChapter 2\nが解決しなかったデータの別の側\n面があることを私達は知りました。状態が変化するオブジェクトにより成るシ\nステムをモデル化したいという欲求複合データオブジェクトを構築することや\n265","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":291},{"id":"./test/fixtures/pdf/sicp.pdf:292","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"それらから選択することと同様に変更することの必要性へと導きます。変換す\nる状態を持つ複合オブジェクトをモデル化するために、セレクタやコンストラ\nクタに追加して、データオブジェクトを変更する\nmutators\n(\nミューテータ\n、変化\nさせる物\n)\nと呼ばれる命令を含むようにデータ抽象化を設計することにします。\n例えば、銀行システムのモデル化は口座の差引残高を変更する必要があります。\n従って銀行口座を表現するデータ構造は以下の命令を許可するでしょう。\n(\nsetbalance!\n⟨\naccount\n⟩\n⟨\nnewvalue\n⟩\n)\nこれは指定した口座の差引残高を指定した新しい値に変更します。ミューテー\nタが定義されたデータオブジェクトは\nmutable data objects\n(\nミュータブルデー\nタオブジェクト\n、変更可能なオブジェクト\n)\nとして知られます。\nChapter 2\nは複合データを合成するため汎用目的の\n“\n糊\n”\nとしてのペアを紹\n介しました。この節はペアのための基本的なミューテータを定義することから\n始め、ペアが変更可能なデータオブジェクトを構築するための架設ブロックと\nして供給できるようにします。これらのミューテータはペアの表現力を大きく\n拡張し、\nSection 2.2\nで用いた列と木以外のデータ構造をを構築することを可能\nにします。複雑なシステムが局所状態を持つオブジェクトの集合としてモデル\n化されるシミュレーションのいくつかの例も紹介します。\n3.3.1\nミュータブルなリスト構造\nペア上の基本的な命令\n—\ncons\n,\ncar\n,\ncdr\n—\nはリスト構造の構築とリスト構\n造からの部品の選択に用いることができます。しかしそれらはリスト構造を変\n更する能力はありませんでした。同じことが今までに使用した\nappend\nや\nlist\nの様なリスト命令にも正しいと言えます。これらが\ncons\n,\ncar\n,\ncdr\nを用いて定\n義できるためです。リスト構造を変更するため新しい命令が必要です。\nペアのプリミティブなミューテータは\nset-car!\nと\nset-cdr!\nです。\nset-\ncar!\nは\n2\nつの引数を取り、第一引数はペアでなければなりません。このペアの\ncar\nポインタを\nset-car!\nの第二引数へのポインタで置き換えることでペアを\n変更します。\n16\n例として\nFigure 3.12\nに示すように\nx\nがリスト\n((a b) c d)\nに、\ny\nがリスト\n(e f)\nに束縛されているとします。式\n(set-car! x y)\nの評価は\nx\nが束縛され\nているペアを変更し、その\ncar\nを\ny\nの値で置き換えます。命令の結果は\nFigure\n3.13\nに示されています。構造\nx\nが変更され\n((e f) c d)\nとなりました。リスト\n16\nset-car!\nと\nset-cdr!\nは実装依存な値を返します。\nset!\nと同様にそれらはそれらの\n効果のためだけに使用されるべきです。\n266","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":292},{"id":"./test/fixtures/pdf/sicp.pdf:293","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"c\nd\ny\nx\ne\nf\na\nb\nFigure 3.12:\nリスト\nx\n:\n((a b) c d)\nand\ny\n:\n(e f)\n(a b)\nを表すペアは、置き換えられたポインタにより特定されていましが、元\nの構造から取り外されました。\n17\nFigure 3.13\nと\nFigure 3.14\nを比べてください。これは\nx\nと\ny\nが\nFigure 3.12\nの\n元のリストに束縛されている時に\n(define z (cons y (cdr x)))\nを実行した\n結果を図示しています。変数\nz\nはこれで\ncons\n命令により作成された新しいペ\nアに束縛されます。\nx\nが束縛されるリストは変更されません。\n17\nこの点からリストの変更命令はどのアクセス可能な構造の部分でもない\n“garbage”(\nゴミ\n)\nを作り得ることがわかります。\nSection 5.3.2\nにて\nLisp\nのメモリ管理\nシステムが\ngarbage collector\n(\nガベージコレクタ\n、清掃局員\n)\nを持ち、それにより必要の無\nいペアにより使用されているメモリ空間を判断しリサイクルを行います。\n267","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":293},{"id":"./test/fixtures/pdf/sicp.pdf:294","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"c\nd\ny\nx\ne\nf\na\nb\nFigure 3.13:\nFigure 3.12\nのリスト上での\n(set-car! x y)\nの効果\nc\nd\ny\nx\ne\nf\na\nb\nz\nFigure 3.14:\nFigure 3.12\nのリスト上での\n(define z (cons y\n(cdr x)))\nの効果\n268","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":294},{"id":"./test/fixtures/pdf/sicp.pdf:295","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"set-cdr!\n命令は\nset-car!\nと同様です。違いは\ncar\nポインタでなく、\ncdr\nポイ\nンタが置き換えられます。\nFigure 3.12\nのリスト上での\n(set-cdr! x y)\nの実行\nの結果は\nFigure 3.15\nに示されます。ここでは\nx\nの\ncdr\nポインタは\n(e f)\nへのポ\nインタにて置き換えられます。また\nx\nの\ncdr\nとして用いられるリスト\n(c d)\nはこれで構造から取り外されます。\ncons\nは新しいリスト構造を新しいペアを作成することで構築します。一方、\nset-car!\nと\nset-cdr!\nは既存のペアを変更します。実際に\n2\nつのミューテータ\nと既存のリスト構造の一部ではない新しいペアを返す\nget-new-pair\nを一緒に\n用いて\ncons\nを実装することができます。新しいペアを得てからその\ncar\nと\ncdr\nポインタに指定されたオブジェクトを設定し、\ncons\nの結果として返します。\n18\n(\ndefine\n(\ncons\nx\ny\n)\n(\nlet\n((\nnew\n(\nget-new-pair\n)))\n(\nset-car!\nnew\nx\n)\n(\nset-cdr!\nnew\ny\n)\nnew\n))\n18\nget-new-pair\nは\nLisp\n実装にて必要とされるメモリ管理の一部として実装されなけ\nればならない命令の\n1\nつです。これについては\nSection 5.3.1\nにて議論します。\n269","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":295},{"id":"./test/fixtures/pdf/sicp.pdf:296","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"c\nd\ny\nx\ne\nf\na\nb\nFigure 3.15:\nFigure 3.12\nのリスト上での\n(set-cdr! x y)\nの効果\n270","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":296},{"id":"./test/fixtures/pdf/sicp.pdf:297","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.12:\nリストを接続するための以下の手続は\nSection 2.2.1\nで\n紹介した。\n(\ndefine\n(\nappend\nx\ny\n)\n(\nif\n(\nnull?\nx\n)\ny\n(\ncons\n(\ncar\nx\n) (\nappend\n(\ncdr\nx\n)\ny\n))))\nappend\nは\ny\nに連続して\nx\nの要素を\ncons\nすることで新しいリスト\nを作る。手続\nappend!\nは\nappend\nと同様だが、コンストラクタで\nはなくミューテータである。これは\nx\nの最後のペアを変更しその\ncdr\nを\ny\nにし両者を繋ぎ合わせることで\nappend(\n付け加え\n)\nする。\n(\nappend!\nを空の\nx\nにて呼ぶのはエラーとなる\n)\n。\n(\ndefine\n(\nappend!\nx\ny\n)\n(\nset-cdr!\n(\nlast-pair\nx\n)\ny\n)\nx\n)\nここで\nlast-pair\nはその引数の最後のペアを返す手続である。\n(\ndefine\n(\nlast-pair\nx\n)\n(\nif\n(\nnull?\n(\ncdr\nx\n))\nx\n(\nlast-pair\n(\ncdr\nx\n))))\n以下の応答について考えよ。\n(\ndefine\nx\n(\nlist\n'a\n'b\n))\n(\ndefine\ny\n(\nlist\n'c\n'd\n))\n(\ndefine\nz\n(\nappend\nx\ny\n))\nz\n(a b c d)\n(\ncdr\nx\n)\n⟨\nresponse\n⟩\n(\ndefine\nw\n(\nappend!\nx\ny\n))\nw\n(a b c d)\n(\ncdr\nx\n)\n⟨\nresponse\n⟩\n欠けている\n⟨\nresponse\n⟩\nは何か\n?\n箱とポインタの図をあなたの答を\n説明するために描け。\n271","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":297},{"id":"./test/fixtures/pdf/sicp.pdf:298","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.13:\n次の\nmake-cycle\n手続について考えよ。これは\nExercise\n3.12\nで定義した\nlast-pair\n手続を用いる。\n(\ndefine\n(\nmake-cycle\nx\n)\n(\nset-cdr!\n(\nlast-pair\nx\n)\nx\n)\nx\n)\n以下の様に作成される\nz\nを表す箱とポインタの図を描け。\n(\ndefine\nz\n(\nmake-cycle\n(\nlist\n'a\n'b\n'c\n)))\n(last-pair z)\nを演算すると何が置こるか\n?\nExercise 3.14:\n以下の手続はとても便利であるが不明瞭である。\n(\ndefine\n(\nmystery\nx\n)\n(\ndefine\n(\nloop\nx\ny\n)\n(\nif\n(\nnull?\nx\n)\ny\n(\nlet\n((\ntemp\n(\ncdr\nx\n)))\n(\nset-cdr!\nx\ny\n)\n(\nloop\ntemp\nx\n))))\n(\nloop\nx\n'\n()))\nloop\nは\n“temporary”(\n一時的\n)\nな変数\ntemp\nを用いて\nx\nの\ncdr\nを保\n存する。次の行の\nset-cdr!\nが\ncdr\nを破壊するためである。\nmystery\nが通常何を行うのか説明せよ。\nv\nが\n(define v (list 'a 'b 'c\n'd))\nで定義されているとする。\nv\nが束縛されるリストを表す箱と\nポインタの図を描け。次に\n(define w (mystery v))\nを評価した\nとする。この式を評価した後の\nv\nと\nw\nの構造を表す箱とポインタ\nの図を描け。\nv\nと\nw\nの値として何が表示されるか\n?\n共有と自己同一性\nSection 3.1.3\nで代入の導入に伴う\n“\n同一性\n”\nと\n“\n変更\n”\nという論理的な問題\nについて記述しました。これらの問題は実際の所個々のペアが異なるデータオ\nブジェクトの間で\nshared\n(\n共有\n)\nされている時に問題となります。例えば、以下\nの様に形成される構造について考えてみて下さい。\n(\ndefine\nx\n(\nlist\n'a\n'b\n))\n(\ndefine\nz1\n(\ncons\nx\nx\n))\n272","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":298},{"id":"./test/fixtures/pdf/sicp.pdf:299","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"z1\nx\na\nb\nFigure 3.16:\n(cons x x)\n.\nで形成されたリスト\nz1\nFigure 3.16\nで示されるように、\nz1\nはその\ncar\nと\ncdr\nの両者が同じペア\nx\nを指\nしている。この\nz1\nの\ncar\nと\ncdr\nによる\nx\nの共有は\ncons\nが直接的な方法で実装\nされていることによる結果です。一般的に\ncons\nを用いてリストを構築するこ\nとは多くの個別のペアが多くの異なる構造において共有される、ペアの連結構\n造に帰着します。\nFigure 3.16\nとは対照的に、\nFigure 3.17\nは以下の式で作成された構造を示し\nます。\n(\ndefine\nz2\n(\ncons\n(\nlist\n'a\n'b\n) (\nlist\n'a\n'b\n)))\nこの構造においては、\n2\nつの\n(a b)\nリスト内のペアは実際のシンボルが共有さ\nれていても区別可能です。\n19\nリストとして考えた時、\nz1\nと\nz2\nの両方が\n“\n同じ\n”\nリスト\n((a b) a b)\nを表現\nします。一般的に共有はリスト上で用いる命令が\ncons\n,\ncar\n,\ncdr\nだけならば完\n全に検出不可能です。しかしリスト構造上で変更を許可するのであれば、共有\nに気付くことができます。共有が作成できる違いの例として、適用された引数\nの構造の\ncar\nを変更する以下の手続について考えてみましょう。\n(\ndefine\n(\nset-to-wow!\nx\n) (\nset-car!\n(\ncar\nx\n)\n'wow\n)\nx\n)\n例え\nz1\nと\nz2\nが\n“\n同じ\n”\n構造だとしても、\nset-to-wow!\nをそれらに適用すると\n異なる結果を返します。\nz1\nでは\ncar\nの変更は\ncdr\nも変更します。\nz1\nでは\ncar\n19\n2\nつのペアは各\ncons\n呼出が新しいペアを返すため区別可能です。シンボルは共有さ\nれています。\nScheme\nではどの与えられた名前にも固有のシンボルが存在します。\nScheme\nがシンボルを変更する手段を全く提供しないため、この共有は判別不可能です。共有が\n単純にポインタの等価性をチェックする\neq?\nを用いてシンボルで比較することを可能に\nする物であることにも注意して下さい。\n273","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":299},{"id":"./test/fixtures/pdf/sicp.pdf:300","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a\nb\nz2\nFigure 3.17:\n(cons (list 'a 'b) (list 'a 'b))\nにより形\n成されたリスト\nz2\nと\ncdr\nが同じペアであるためです。\nz2\nでは\ncar\nと\ncdr\nは区別可能なので\nset-\nto-wow!\nは\ncar\nのみを変更します。\nz1\n((a b) a b)\n(\nset-to-wow!\nz1\n)\n((wow b) wow b)\nz2\n((a b) a b)\n(\nset-to-wow!\nz2\n)\n((wow b) a b)\nリスト構造中の共有を見つける一つの方法は\nSection 2.3.1\nで\n2\nつのシンボルが\n等しいかテストする方法として紹介した述語\neq?\nを用います。より一般的には\n(eq? x y)\nは\nx\nと\ny\nが同じオブジェクトであるかをテストします\n(\nこれはつま\nり\nx\nと\ny\nはポインタとして等しいかです\n)\n。従って\nFigure 3.16\nと\nFigure 3.17\nで\n示すよう定義された\nz1\nと\nz2\n以降の節で示されるように、ペアで表現可能なデータ構造のレパートリを\n大きく拡張することが共有を用いてできます。一方で、共有はまた危険であり\n構造に対して行われる変更がたまたま部品を共有する他の構造に対しても影響\nを与えます。ミューテータである\nset-car!\nと\nset-cdr!\nは注意深く利用せねば\nなりません。データオブジェクトがどのように共有されているかを良く理解し\nなければ変更は予期しない結果を引き起します。\n20\n20\nミュータブルなデータオブジェクトの共有の取扱の微妙な部分は\nSection 3.1.3\nで取\nり上げられた\n“\n等価性\n”\nと\n“\n変更\n”\nの根底に横たわる問題を反映しています。そこでは私\n274","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":300},{"id":"./test/fixtures/pdf/sicp.pdf:301","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.15:\n上記の構造\nz1\nと\nz2\n上での\nset-to-wow!\nの効果を\n説明する箱とポインタの図を描け。\nExercise 3.16:\nBen Bitdiddle\nは任意のリスト構造内のペアの数を\n数える手続を書くことに決めた。\n“\n簡単だよね\n”\nと彼は思った。\n“\n任\n意の構造内のペアの数は\ncar\nの中の数と\ncdr\nの中の数の和に現在\nのペアを数えるために\n1\nを足した物\n”\n。だから\nBen\nは以下の手続を\n書いた。\n(\ndefine\n(\ncount-pairs\nx\n)\n(\nif\n(\nnot\n(\npair?\nx\n))\n0\n(+ (\ncount-pairs\n(\ncar\nx\n))\n(\ncount-pairs\n(\ncdr\nx\n))\n1)))\nこの手続が正しくないことを示せ。具体的にはきっちり\n3\nつのペ\nアにより作られ\nBen\nの手続が\n3, 4, 7\nを返すだろう、また\nBen\nの手\n続が絶対に終了しないリスト構造を表現する箱とポインタの図を\n描け。\nExercise 3.17:\nExercise 3.16\nの\ncount-pairs\n手続の正しい版を考\n案せよ。これは任意の構造の中の固有のペアの数を返す。\n(\nヒント：\n構造を横断しながらどのペアが既に数えられたかを追跡するため\nに使用する補助的なデータ構造を保存する\n)\n。\nExercise 3.18:\nリストを検査しそれが循環を持つかどうか判断せ\nよ。つまりリストの最後を見つけようとしたプログラムが連続して\ncdr\nを取ることで無限ループに入るかどうかを判定せよ。\nExercise\n3.13\nにてそのようなリストを構築した。\n達の言語に変更を許すことは複合データがそれを構成する部分から何かが異なるという\n“\n自己同一性\n”\nを持たねばならないことを述べました。\nLisp\nではこの\n“\n自己同一性\n”\nを\neq?\nにてテストされる性質だと考えます。即ち、ポインタの等価性です。多くの\nLisp\n実装で\nはポインタが本質的にはメモリアドレスですので、オブジェクトの自己同一性を定義す\nることの\n“\n問題の解決\n”\nはデータオブジェクト\n“\nそれ自身\n”\nがいくつかの特定の計算機内\nのメモリ上の場所の集合に格納された情報であることを要求することにより解決します。\nこれは単純な\nLisp\nプログラムには十分ですが、計算モデルの\n“\n同一性\n”\nの問題を解決す\nる一般的な方法ではありません。\n275","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":301},{"id":"./test/fixtures/pdf/sicp.pdf:302","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.19:\nRedo\nExercise 3.18\nusing an algorithm that takes\nonly a constant amount of space. (This requires a very clever idea.)\nExercise 3.18\nを一定の容量のメモリのみを用いるアルゴリズムを\n用いて再度行え。\n(\nこれはとても巧妙なアイデアを必要とする\n)\n。\n変更とは代入のこと\n複合データを紹介した時、\nSection 2.1.3\nにてペアが手続をのみを利用するこ\nとで表現できることを観察しました。\n(\ndefine\n(\ncons\nx\ny\n)\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'car\n)\nx\n)\n((\neq?\nm\n'cdr\n)\ny\n)\n(\nelse\n(\nerror\n\"\nUndefined\noperation\n:\nCONS\n\"\nm\n))))\ndispatch\n)\n(\ndefine\n(\ncar\nz\n) (\nz\n'car\n))\n(\ndefine\n(\ncdr\nz\n) (\nz\n'cdr\n))\n同じ観察結果がミュータブルなデータに対しても正しいと言えます。ミュー\nタブル\n(\n可変\n)\nなデータオブジェクトを代入と局所状態を用いることで手続と\nして実装可能です。例として上のペアの実装を拡張し、\nSection 3.1.1\nで\nmake-\naccount\nを用いて銀行口座を実装した方法とある程度類似して、\nset-car!\nと\nset-cdr!\nを扱うことができます。\n(\ndefine\n(\ncons\nx\ny\n)\n(\ndefine\n(\nset-x!\nv\n) (\nset!\nx\nv\n))\n(\ndefine\n(\nset-y!\nv\n) (\nset!\ny\nv\n))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'car\n)\nx\n)\n((\neq?\nm\n'cdr\n)\ny\n)\n((\neq?\nm\n'set-car!\n)\nset-x!\n)\n((\neq?\nm\n'set-cdr!\n)\nset-y!\n)\n(\nelse\n(\nerror\n\"\nUndefined\noperation\n:\nCONS\n\"\nm\n))))\ndispatch\n)\n(\ndefine\n(\ncar\nz\n) (\nz\n'car\n))\n(\ndefine\n(\ncdr\nz\n) (\nz\n'cdr\n))\n276","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":302},{"id":"./test/fixtures/pdf/sicp.pdf:303","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nset-car!\nz\nnew-value\n)\n((\nz\n'set-car!\n)\nnew-value\n)\nz\n)\n(\ndefine\n(\nset-/cdr!\nz\nnew-value\n)\n((\nz\n'set-cdr!\n)\nnew-value\n)\nz\n)\n代入が可変データの振舞を説明するために論理上必要な物全てです。私達の言\n語に\nset!\nを認めると直ぐに、代入の問題のみでなく、一般的な可変データの\n全ての問題を引き起しました。\n21\nExercise 3.20:\n以下の連続した式の評価を説明する環境の図を\n描け。\n(\ndefine\nx\n(\ncons\n1 2))\n(\ndefine\nz\n(\ncons\nx\nx\n))\n(\nset-car!\n(\ncdr\nz\n) 17)\n(\ncar\nx\n)\n17\n上で与えられた手続型の実装を用いよ。\n(\nExercise 3.11\nと比較せよ\n)\n。\n3.3.2\nキューの表現\nミューテータの\nset-car!\nと\nset-cdr!\nはペアを用いて\ncons\n,\ncar\n,\ncdr\nのみ\nでは不可能なデータ構造を構築可能です。この節ではキューと呼ばれるデータ\n構造を表現するためにどのようにペアを用いるかについて示します。\nSection\n3.3.3\nではテーブル\n(\n表\n)\nと呼ばれるデータ構造の表現方法について学びます。\nqueue\n(\nキュー\n)\nはアイテムが一方の端\n(\nキューの\nrear\n(\nリア、\n終端\n))\nに挿入さ\nれ、他方の端\n(\nfront\n(\nフロント、\n先端\n))\nから削除される列です。\nFigure 3.18\nは初\n期化時に空のキューにアイテム\na\nと\nb\nが挿入された状態を示しています。次に\na\nが削除され、\nc\nと\nd\nが挿入され、\nb\nが削除されます。アイテムは常に挿入順に\n削除されるためキューは時々\nFIFO\n(first in, first out)(\n先入れ先出し\n)\nバッファ\nと呼ばれます。\nデータ抽象化の観点ではキューを以下の操作の集合であると見做すことができ\nます。\n21\n一方で、実装上の視点からは代入は環境を変更することを必要とし、環境はそれ自身\nが可変なデータ構造です。従って代入と変更は等位です。つまり一方は他方を用いるこ\nとで実装可能です。\n277","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":303},{"id":"./test/fixtures/pdf/sicp.pdf:304","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Operation                 Resulting Queue\n(define q (make-queue))\n(insert-queue! q 'a)      a\n(insert-queue! q 'b)      a b\n(delete-queue! q)         b\n(insert-queue! q 'c)      b c\n(insert-queue! q 'd)      b c d\n(delete-queue! q)         c d\nFigure 3.18:\nキュー命令\n•\nコンストラクタ：\n(make-queue)\nは空のキュー\n(\nアイテムを全く持たない\nキュー\n)\nを返す\n•\n2\nつのセレクタ：\n(\nempty-queue?\n⟨\nqueue\n⟩\n)\nキューが空であるかテストする\n(\nfront-queue\n⟨\nqueue\n⟩\n)\nキューの先頭のオブジェクトを返す。もしキューが空ならエラーを発す。\nキューを変更しない。\n•\n2\nつのミューテータ：\n(\ninsert-queue!\n⟨\nqueue\n⟩\n⟨\nitem\n⟩\n)\nキューの最後尾にアイテムを挿入し、変更されたキューをその値として\n返す。\n(\ndelete-queue!\n⟨\nqueue\n⟩\n)\nキューの先頭のアイテムを削除し、その値として変更されたキューを返\nす。もしキューが削除前に空であればエラーを発す。\nキューはアイテムの列であるため確かに順序有りリストであると表現できま\nす。キューの先頭はリストの\ncar\nであり、キューにアイテムを挿入するのは新\nしい要素をリストの最後に追加することで、キューからのアイテムの削除はた\n278","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":304},{"id":"./test/fixtures/pdf/sicp.pdf:305","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"c\nfront-ptr\nq\na\nb\nrear-ptr\nFigure 3.19:\n先端と終端のポインタを持つリストとしての\nキューの実装\nだリストの\ncdr\nを得ることと言えるでしょう。しかしこの表現は非効率です。\nなぜならアイテムを挿入するためにはリストを終端まで走査しなければなりま\nせん。リストの走査のための手段は\ncdr\n命令を連続して用いるしかなく、この\n走査は\n푛\nアイテムのリストに対し\nΘ(푛)\nステップを必要とします。リスト表現\nに対する簡単な変更がこの欠点を克服し\nΘ\n(1)\nステップを必要とするキュー命\n令の実装を可能にします。これはつまり必要なステップ数がキューの長さから\n独立するということです。\nリスト表現による困難はリストの終端を見つけるための走査が必要である\n点から生じています。走査が必要な理由はリストをペアの鎖として表現する標\n準的な方法が、事前にリストの先頭へのポインタを提供するのに対し、終端を\n指す簡単にアクセス可能なポインタを提供しないためです。欠点を避けるため\nの変更としてキューをリストとしながらリストの最終ペアを示す追加のポイン\nタをも用いて表現します。この方法ではアイテムを挿入する場合に終端ポイン\nタを調べることでリストの走査を避けることができます。\nするとキューはポインタのペア、\nfront-ptr\nと\nrear-ptr\nとして表現されま\nす。それぞれが通常のリストの先頭と最後のペアを指します。キューを識別可\n能なオブジェクトにするために\n2\nつのポインタを接続するのに\ncons\nを用いま\nす。従ってキューそれ自身が\n2\nつのポインタの\ncons\nになります。\nFigure 3.19\nは\nこの表現を図示します。\nキューの命令を定義するために以下の手続を用います。これはキューの先端と\n終端のポインタの選択、変更を可能にします。\n(\ndefine\n(\nfront-ptr\nqueue\n) (\ncar\nqueue\n))\n279","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":305},{"id":"./test/fixtures/pdf/sicp.pdf:306","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nrear-ptr\nqueue\n) (\ncdr\nqueue\n))\n(\ndefine\n(\nset-front-ptr!\nqueue\nitem\n) (\nset-car!\nqueue\nitem\n))\n(\ndefine\n(\nset-rear-ptr!\nqueue\nitem\n) (\nset-cdr!\nqueue\nitem\n))\nこれで実際のキューの命令を実装できます。もし先端のポインタが空リストな\nらばキューは空であると考えることにします。\n(\ndefine\n(\nempty-queue?\nqueue\n) (\nnull?\n(\nfront-ptr\nqueue\n)))\nmake-queue\nコンストラクタは初期値として空キューを意味する\ncar\nと\ncdr\nの\n両方が空リストのペアを返します。\n(\ndefine\n(\nmake-queue\n) (\ncons\n'\n()\n'\n()))\nキューの頭のアイテムを選択するために先端ポインタが指すペアの\ncar\nを返し\nます。\n(\ndefine\n(\nfront-queue\nqueue\n)\n(\nif\n(\nempty-queue?\nqueue\n)\n(\nerror\n\"\nFRONT\ncalled\nwith\nan\nempty\nqueue\n\"\nqueue\n)\n(\ncar\n(\nfront-ptr\nqueue\n))))\nキューにアイテムを挿入するために、\nFigure 3.20\nが示す結果を成す手法に従い\nます。最初に\ncar\nが挿入するアイテムであり\ncdr\nが空リストである新しいペア\nを作成します。もしキューが空であるならキューの先端と終端のポインタにこ\nの新しいペアを設定します。そうでなければキューの最終ペアを新しいペアを\n指すように変更し、また終端ポインタを新しいペアを指すようにします。\n(\ndefine\n(\ninsert-queue!\nqueue\nitem\n)\n(\nlet\n((\nnew-pair\n(\ncons\nitem\n'\n())))\n(\ncond\n((\nempty-queue?\nqueue\n)\n(\nset-front-ptr!\nqueue\nnew-pair\n)\n(\nset-rear-ptr!\nqueue\nnew-pair\n)\nqueue\n)\n(\nelse\n(\nset-cdr!\n(\nrear-ptr\nqueue\n)\nnew-pair\n)\n(\nset-rear-ptr!\nqueue\nnew-pair\n)\nqueue\n))))\n280","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":306},{"id":"./test/fixtures/pdf/sicp.pdf:307","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"front-ptr\nq\na\nb\nrear-ptr\nc\nd\nFigure 3.20:\nFigure 3.19\nのキューに\n(insert-queue! q 'd)\nを用いた結果\nキューの頭のアイテムを削除するために、ただ単に先端ポインタを変更しキュ\nーの二つ目のアイテムを指すようにします。これは最初のアイテムの\ncdr\nポイ\nンタに従うだけで見つけられます。\n(\nFigure 3.21\n参照\n)\n22\n(\ndefine\n(\ndelete-queue!\nqueue\n)\n(\ncond\n((\nempty-queue?\nqueue\n)\n(\nerror\n\"\nDELETE!\ncalled\nwith\nan\nempty\nqueue\n\"\nqueue\n))\n(\nelse\n(\nset-front-ptr!\nqueue\n(\ncdr\n(\nfront-ptr\nqueue\n)))\nqueue\n)))\nExercise 3.21:\nBen Bitdiddle\nは上で説明されたキューの実装をテ\nストすることに決めた。彼は\nLisp\nインタプリタに対し手続を入力\nし、続いて以下のように試行を行った。\n(\ndefine\nq1\n(\nmake-queue\n))\n(\ninsert-queue!\nq1\n'a\n)\n((a) a)\n22\nもし最初のアイテムがキューの最終アイテムでもある場合、先端ポインタは削除後に\n空リストになるでしょう。これはキューを空の状態にします。終端ポインタの更新を心\n配する必要はありません。これは依然として削除されたアイテムを指しますが、\nempty-\nqueue?\nは先端ポインタしか見ません。\n281","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":307},{"id":"./test/fixtures/pdf/sicp.pdf:308","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"front-ptr\nq\na\nb\nrear-ptr\nc\nd\nFigure 3.21:\nFigure 3.20\nのキューに\n(delete-queue! q)\nを\n用いた結果\n(\ninsert-queue!\nq1\n'b\n)\n((a b) b)\n(\ndelete-queue!\nq1\n)\n((b) b)\n(\ndelete-queue!\nq1\n)\n(() b)\n“\n間違っている！\n”\nと彼は文句を言った。\n“\nインタプリタの応答は\n最後のアイテムがキューに二回挿入されていることを示している。\nそして僕が両方のアイテムを消しても二つ目の\nb\nがまだそこにあ\nる。だからキューは空になるべきなのにそうならない\n”\n。\nEva Lu\nAtor\nは\nBen\nが何が起こったのか間違って理解していると示唆し\nた。\n“\nアイテムはキューに二回入ってはいないわ\n”\nと彼女は説明し\nた。\n“Lisp\n標準の応答がキュー表現の意味をどのように理解するの\nか知らないだけ。もしあなたがキューが正しく表示されるのを見\nたいなら自分でキューを表示する手続を定義する必要があるわ\n”\n。\nEva Lu\nが話していることを説明せよ。具体的にはなぜ\nBen\nの例が\nそのような表示の結果になるのか示せ。キューを入力に取りキュ\nー内のアイテムの列を表示する手続\nprint-queue\nを定義せよ。\nExercise 3.22:\nキューをポインタのペアとして表現する代わりに、\nキューを局所状態を持つ手続として構築することができる。局所\n282","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":308},{"id":"./test/fixtures/pdf/sicp.pdf:309","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"状態は通常のリストの先端と終端へのポインタから成る。従って\nmake-queue\n手続は以下の形式となる。\n(\ndefine\n(\nmake-queue\n)\n(\nlet\n((\nfront-ptr\n...\n)\n(\nrear-ptr\n...\n))\n⟨\ndefinitions of internal procedures\n⟩\n(\ndefine\n(\ndispatch\nm\n)\n...\n)\ndispatch\n))\nmake-queue\nの定義を完成させ、この表現を用いたキューの命令を\n実装せよ。\nExercise 3.23:\ndeque\n(“double-ended queue”\n、\n両頭キュー\n)\nはアイ\nテムの挿入と消去が先端と終端の両方に対して行える列であ\nる。\ndeque\n上の命令はコンストラクタ\nmake-deque\n、述語\nempty-\ndeque?\n、セレクタ\nfront-deque\nと\nrear-deque\n、ミューテータ\nfront-insert-deque!\n,\nrear-insert-deque!\n,\nfront-delete-deque!\n,\nrear-delete-deque!\nである。ペアを用いてどのように\ndeque\nを表\n現するか示せ。また命令の実装を提供せよ。\n23\n全ての命令は\nΘ\n(1)\nステップで達成すること。\n3.3.3\nテーブルの表現\nChapter 2\nで種々の集合の表現について学んだ時、\nSection 2.3.3\nにてキーで\n同定する索引を持つレコードの表を保存する作業について述べました。\nSection\n2.4.3\nでのデータ適従プログラミングの実装において二次元テーブルの広範な使\n用を行い、情報は\n2\nつのキーを用いて格納と取り出しされました。ここではど\nのように表をミュータブルなリスト構造として構築するかについて学びます。\n最初は一次元の表について考えます。各値が単一のキーの下に格納されます。\nテーブルをレコードのリストとして実装し、各レコードははキーと関連する\n値から成るペアとして実装します。レコードは\ncar\nが次のレコードを指すペ\nアによりリストを形成する様に連結されます。これらの連結されたペアは表\nの\nbackbone\n(\nバックボーン\n、基幹\n)\nと呼ばれます。テーブルに新しいレコードを\n追加する時に変更可能な場所を得るために、テーブルを\nheaded list\n(\n頭出しリ\n23\nインタプリタに循環を含む構造を表示させないように注意せよ。\n(\nExercise 3.13\n参\n照\n)\n。\n283","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":309},{"id":"./test/fixtures/pdf/sicp.pdf:310","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a\nb\nc\n1\n2\n3\n*table*\ntable\nFigure 3.22:\n頭出しリストとして表現されたテーブル\nスト\n)\nとして構築します。頭出しリストは特別なバックボーンペアを最初に持\nちます。これはダミーの\n“\nレコード\n”—\n今回の場合、自由裁量で選択したシンボ\nル\n*table*\n—\nを持っています。\nFigure 3.22\nは以下のテーブルの箱とポインタの\n図を示しています。\na\n:  1\nb\n:  2\nc\n:  3\nテーブルから情報を抽出するには鍵を引数として取り相対する値\n(\nまたはその\nキーの下に値が格納されていない場合には\nfalse)\nを返す\nlookup\n手続を用いま\nす。\nlookup\nはキーとレコードのリストを引数として期待する\nassoc\n命令を用\nいて定義します。\nassoc\nがダミーレコードを絶対に参照しないことに注意して\n下さい。\nassoc\nは与えられたキーを\ncar\nとして持つレコードを返します。\n24\nす\nると\nlookup\nは\nassoc\nが返した結果のレコードが\nfalse\nでないかチェックし、そ\nのレコードの値\n(\ncdr\n)\nを返します。\n(\ndefine\n(\nlookup\nkey\ntable\n)\n(\nlet\n((\nrecord\n(\nassoc\nkey\n(\ncdr\ntable\n))))\n(\nif\nrecord\n(\ncdr\nrecord\n)\n24\nassoc\nが\nequal?\nを用いるため、シンボル、数値、リスト構造であるキーを認識可能\nです。\n284","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":310},{"id":"./test/fixtures/pdf/sicp.pdf:311","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"false\n)))\n(\ndefine\n(\nassoc\nkey\nrecords\n)\n(\ncond\n((\nnull?\nrecords\n)\nfalse\n)\n((\nequal?\nkey\n(\ncaar\nrecords\n)) (\ncar\nrecords\n))\n(\nelse\n(\nassoc\nkey\n(\ncdr\nrecords\n)))))\n値をテーブルに指定したキーの下に挿入するために、最初に\nassoc\nを用いて既\nにテーブルの中にこのキーを持つレコードが存在しないか確認します。もし無\nければ鍵と値を\ncons\nすることで新しいレコードを作成しこれをテーブルのレ\nコードリストの先頭のダミーレコードの後ろに挿入します。もし既にこのキー\nのレコードが存在する場合にはそのレコードの\ncdr\nに新しい値を設定します。\nテーブルのヘッダは新しいレコードを挿入するために変更する固定位置を与え\nます。\n25\n(\ndefine\n(\ninsert!\nkey\nvalue\ntable\n)\n(\nlet\n((\nrecord\n(\nassoc\nkey\n(\ncdr\ntable\n))))\n(\nif\nrecord\n(\nset-cdr!\nrecord\nvalue\n)\n(\nset-cdr!\ntable\n(\ncons\n(\ncons\nkey\nvalue\n)\n(\ncdr\ntable\n)))))\n'ok\n)\n新しいテーブルを構築するためには単純にシンボル\n*table*\nを持つリストを作\n成します。\n(\ndefine\n(\nmake-table\n)\n(\nlist\n'*table*\n))\n二次元テーブル\n二次元テーブルでは各値は\n2\nつのキーにより索引付けられます。そのようなテ\nーブルを各キーが部分テーブルを特定する\n1\n次元テーブルとして構築すること\nができます。\nFigure 3.23\nは以下のテーブルを箱とポインタの図で示しています。\n25\n従って最初のバックボーンペアはテーブル\n“\nそれ自身\n”\nを表現するオブジェクトです。\nテーブルを指すポインタはこのペアを指すポインタです。この同じバックボーンペアが\n常にテーブルを始めます。もしこのようにしなければ\ninsert!\nは新しいレコードを追加\nした時にテーブルの新しい開始地点を返さなければならなくなるでしょう。\n285","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":311},{"id":"./test/fixtures/pdf/sicp.pdf:312","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"math:    +:  43\nletters:    a:  97\n-:  45\nb:  98\n*:  42\nこれは\n2\nつ部分テーブルを持ちます。\n(\n部分テーブルは特別なヘッダシンボルを\n必要としません。部分テーブルを特定するキーがこの目的を果たすためです\n)\n。\nアイテムを探す時、最初のキーを用いて正しい部分テーブルを特定します。\n次に二つ目のキーを用いて部分テーブル中のレコードを特定します。\n(\ndefine\n(\nlookup\nkey-1\nkey-2\ntable\n)\n(\nlet\n((\nsubtable\n(\nassoc\nkey-1\n(\ncdr\ntable\n))))\n(\nif\nsubtable\n(\nlet\n((\nrecord\n(\nassoc\nkey-2\n(\ncdr\nsubtable\n))))\n(\nif\nrecord\n(\ncdr\nrecord\n)\nfalse\n))\nfalse\n)))\nキーのペアの下に新しいアイテムを挿入するには\nassoc\nを用いて最初のキーの\n下に部分テーブルが存在するかどうかを確認します。もし無ければ単一のレコ\nード\n(\nkey-2\n,\nvalue\n)\nを含む新しい部分テーブルを構築し、それを最初のキーの\n下にテーブルに挿入します。もし最初のキーに対する部分テーブルが既に存在\nする場合新しいレコードをこの部分テーブルに先に説明した一次元テーブルに\n対する挿入方法を用いて挿入します。\n(\ndefine\n(\ninsert!\nkey-1\nkey-2\nvalue\ntable\n)\n(\nlet\n((\nsubtable\n(\nassoc\nkey-1\n(\ncdr\ntable\n))))\n(\nif\nsubtable\n(\nlet\n((\nrecord\n(\nassoc\nkey-2\n(\ncdr\nsubtable\n))))\n(\nif\nrecord\n(\nset-cdr!\nrecord\nvalue\n)\n(\nset-cdr!\nsubtable\n(\ncons\n(\ncons\nkey-2\nvalue\n)\n(\ncdr\nsubtable\n)))))\n(\nset-cdr!\ntable\n(\ncons\n(\nlist\nkey-1\n286","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":312},{"id":"./test/fixtures/pdf/sicp.pdf:313","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"+\n-\n*\n43\n45\n42\n*table*\na\nb\n97\n98\nletters\nmath\ntable\nFigure 3.23:\n二次元テーブル\n(\ncons\nkey-2\nvalue\n))\n(\ncdr\ntable\n)))))\n'ok\n)\nローカルなテーブルの作成\n上で定義された\nlookup\nと\ninsert!\n命令はテーブルを引数として取ります。\nこれが複数のテーブルにアクセスするプログラムを許可します。複数のテーブ\nルを扱う他の方法には各テーブルに対し分離された\nlookup\nと\ninsert!\n手続を\n持つ方法があります。これはテーブルを手続的に、その局所状態の一部に内部\n287","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":313},{"id":"./test/fixtures/pdf/sicp.pdf:314","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"テーブルを持つオブジェクトとして表現することにより可能となります。適切\nなメッセージを送った時に、この\n“\nテーブルオブジェクト\n”\nは内部テーブルを\n操作する手続を提供します。以下にこの様式で表現された二次元テーブルのた\nめのジェネレータ\n(\n生成器\n)\nを示します。\n(\ndefine\n(\nmake-table\n)\n(\nlet\n((\nlocal-table\n(\nlist\n'*table*\n)))\n(\ndefine\n(\nlookup\nkey-1\nkey-2\n)\n(\nlet\n((\nsubtable\n(\nassoc\nkey-1\n(\ncdr\nlocal-table\n))))\n(\nif\nsubtable\n(\nlet\n((\nrecord\n(\nassoc\nkey-2\n(\ncdr\nsubtable\n))))\n(\nif\nrecord\n(\ncdr\nrecord\n)\nfalse\n))\nfalse\n)))\n(\ndefine\n(\ninsert!\nkey-1\nkey-2\nvalue\n)\n(\nlet\n((\nsubtable\n(\nassoc\nkey-1\n(\ncdr\nlocal-table\n))))\n(\nif\nsubtable\n(\nlet\n((\nrecord\n(\nassoc\nkey-2\n(\ncdr\nsubtable\n))))\n(\nif\nrecord\n(\nset-cdr!\nrecord\nvalue\n)\n(\nset-cdr!\nsubtable\n(\ncons\n(\ncons\nkey-2\nvalue\n)\n(\ncdr\nsubtable\n)))))\n(\nset-cdr!\nlocal-table\n(\ncons\n(\nlist\nkey-1\n(\ncons\nkey-2\nvalue\n))\n(\ncdr\nlocal-table\n)))))\n'ok\n)\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'lookup-proc\n)\nlookup\n)\n((\neq?\nm\n'insert-proc!\n)\ninsert!\n)\n(\nelse\n(\nerror\n\"\nUnknown\noperation\n:\nTABLE\n\"\nm\n))))\ndispatch\n))\n288","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":314},{"id":"./test/fixtures/pdf/sicp.pdf:315","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"make-table\nを用いることで\nSection 2.4.3\nで用いたデータ適従プログラミングの\nための\nget\nと\nput\nを以下のように実装することができます。\n(\ndefine\noperation-table\n(\nmake-table\n))\n(\ndefine\nget\n(\noperation-table\n'lookup-proc\n))\n(\ndefine\nput\n(\noperation-table\n'insert-proc!\n))\nget\nは引数として\n2\nつのキーを取り、\nput\nは引数として\n2\nつのキーと値を取り\nます。両方の命令共に同じ局所テーブルをアクセスします。局所テーブルは\nmake-table\nの呼出により作成されたオブジェクトの中にカブセル化されます。\nExercise 3.24:\n上記のテーブル実装において、キーは\nequal?\nを用\nいて等価試験を行う。\n(\nassoc\nにより呼び出される\n)\n。これは常に適\n切な試験ではない。例として数値キーを用いるテーブルを用いる場\n合に、検索時に厳密に等しい必要が無く、ある許容範囲で数値を探\nしたいかもしれない。キーの\n“\n等価性\n”\nを試験するのに用いられる\nsame-key?\n手続を引数として取るテーブルコンストラクタ\nmake-\ntable\nを定義せよ。\nmake-table\nは内部テーブルに対して適切な手\n続\nlookup\nと\ninsert!\nにアクセスするのに使用可能な\ndispatch\n手\n続を返さねばならない。\nExercise 3.25:\n1\n次元と二次元のテーブルを一般化せよ。任意の数\nのキーの下で値を格納し、異なる値を異なる数のキーの下格納で\nきるテーブルをどのように実装するか示せ。\nlookup\nと\ninsert!\n手\n続は入力としてキーのリストを取りテーブルにアクセスする。\nExercise 3.26:\n上で実装されたテーブルを検索するにはレコードの\nリストを走査しなければならない。これは基本的に\nSection 2.3.3\nの\n順序無しリスト表現である。大きなテーブルに対しては異なる様\n式でテーブルを構造化するほうが効率が良い。\n(\nキー\n,\n値\n)\nのレコ\nードが二分木を用いて体系化されるテーブルの実装を説明せよ。\nキーは何らかの方法にて順序付可能であると想定する。\n(\nChapter\n2\nの\nExercise 2.66\nと比較せよ\n)\n。\nExercise 3.27:\nmemoization\n(\nメモ化\n)(\ntabulation\n(\n表形式化\n)\nとも呼\nばれる\n)\nとは手続の局所テーブルに事前に計算した値を記録する\nことを可能するテクニックである。このテクニックはプログラム\nのパフォーマンスに大幅な違いを与えることができる。メモ化さ\nれた手続は以前の呼出の値がその値を生成した引数をキーとして\n289","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":315},{"id":"./test/fixtures/pdf/sicp.pdf:316","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"格納するテーブルを持つ。メモ化された手続が値を計算するよう\n命じられた時、最初に値が既にテーブルにないかチェックを行い、\nもし存在すれば単にその値を返す。そうでなければ新しい値を通\n常の方法で計算しテーブルに保存する。メモ化の例として\nSection\n1.2.2\nからフィボナッチ数を演算するための指数関数処理を思い\n出せ。\n(\ndefine\n(\nfib\nn\n)\n(\ncond\n((=\nn\n0) 0)\n((=\nn\n1) 1)\n(\nelse\n(+ (\nfib\n(-\nn\n1)) (\nfib\n(-\nn\n2))))))\n同じ手続のメモ化版は以下である。\n(\ndefine\nmemo-fib\n(\nmemoize\n(\nlambda\n(\nn\n)\n(\ncond\n((=\nn\n0) 0)\n((=\nn\n1) 1)\n(\nelse\n(+ (\nmemo-fib\n(-\nn\n1))\n(\nmemo-fib\n(-\nn\n2))))))))\nこの時、\nmemoize\nは以下の様に定義される。\n(\ndefine\n(\nmemoize\nf\n)\n(\nlet\n((\ntable\n(\nmake-table\n)))\n(\nlambda\n(\nx\n)\n(\nlet\n((\npreviously-computed-result\n(\nlookup\nx\ntable\n)))\n(\nor\npreviously-computed-result\n(\nlet\n((\nresult\n(\nf\nx\n)))\n(\ninsert!\nx\nresult\ntable\n)\nresult\n))))))\n(memo-fib 3)\nの演算を分析するための環境図を描け。なぜ\nmemo-\nfib\nが\n푛\n番目のフィボナッチ数を\n푛\nに比例するステップ数で演算\nするのか説明せよ。単に\nmemo-fib\nを\n(memoize fib)\nと定義した\n場合にも\nScheme\nは正しく処理できるだろうか\n?\n290","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":316},{"id":"./test/fixtures/pdf/sicp.pdf:317","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"3.3.4\nデジタル回路のシミュレータ\nコンピュータのような複雑なデジタルシステムの設計は重要な工学の活動\n領域です。デジタルシステムは簡単な要素を相互接続することで構築されます。\nこれらの個々の要素の振舞は単純ですが、それらのネットワークはとても複雑\nな振舞をします。提案された回路設計のコンピュータシミュレーションはデジ\nタルシステムエンジニアにより使用される重要なツールです。この節ではデジ\nタル論理シミュレーションを実行するためのシステムを設計します。このシス\nテムは\nevent-driven simulation\n(\nイベント駆動シミュレーション\n)\nと呼ばれる種\n類の典型であり、その行動\n(“\nイベント\n”)\nは後に起こるさらなるイベントを引き\n起こし、順により多くのイベントを引き起します。\n私達の回路の計算モデルは回路を構築する基本となるコンポーネントに\n対応するオブジェクトにより成ります。\ndigital signals\n(\nデジタル信号\n)\nを運\nぶ\nwires\n(\n回路\n)\nが存在します。デジタル信号は任意の瞬間に可能な\n2\nつの値、\n0\nと\n1\nの内\n1\nつを取ります。また多様なタイプのデジタル\nfunction boxes\n(\n関数\n箱\n)\nが存在し、入力信号を運ぶ回路と別の出力回路を接続します。そのような\n箱は入力信号から計算された信号を出力します。出力信号は関数箱のタイプに\nより時間的に遅れを生じさせます。例えば\ninverter\n(\n逆変換器\n)\nは入力を反転す\nるプリミティブな関数箱です。もし逆変換器への入力信号が\n0\nに変化したなら、\nある逆変換器による遅延の後、逆変換器はその出力信号を\n1\nに変更します。も\nし逆変換器への入力信号が\n1\nに変化したならば、ある逆変換器による遅延の後、\n逆変換器は出力信号を\n0\nにします。逆変換器を記号として\nFigure 3.24\nに示すよ\nうに描きます。\nFigure 3.24\nに示される\nand-gate\n(\nAND\nゲート\n)\nも\n2\nつの入力と\n1\nつの出力を持つプリミティブな関数箱です。入力の\nlogical and\n(\n論理積\n)\nの値\nにその出力の値を駆動します。言い替えれば、もし入力信号の両方が\n1\nになれ\nばある\nAND\nゲートによる遅延の後に\nAND\nゲートはその出力信号を\n1\nにしま\nす。そうでなければ出力は\n0\nです。\nor-gate\n(\nOR\nゲート\n)\nも同様の\n2\nつの入力を\n持つプリミティブな関数箱でありその出力信号は入力に対する\nlogical or\n(\n論理\n和\n)\nの値になります。言い替えれば出力はもし少くとも\n1\nつの入力信号が\n1\nで\nあれば\n1\nになり、そうでなければ出力は\n0\nになります。\nプリミティブな関数を一緒に接続してより複雑な関数を構築できます。これを\n達成するためにある関数箱の出力から他の関数箱の入力へと回路を引きます。\n例えば\nFigure 3.25\nに示す\nhalf-adder\n(\n半加算器\n)\nは\nOR\nゲート、\n2\nつの\nAND\nゲ\nート、逆変換器から成り立ちます。これは\n2\nつの入力信号、\nA\nと\nB\nを取り\n2\nつ\nの出力信号\nS\nと\nC\nがあります。\nS\nは正確に\nA\nと\nB\nの内\n1\nつが\n1\nであるならば\n1\nになり、\nC\nは\nA\nと\nB\nの両方が\n1\nの場合に\n1\nになります。遅延が生じるため出\n291","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":317},{"id":"./test/fixtures/pdf/sicp.pdf:318","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Inverter\nAnd-gate\nOr-gate\nFigure 3.24:\nデジタル論理回路シミュレータにおけるプリミティブ\nな関数\nD\nE\nA\nB\nS\nC\nFigure 3.25:\n半加算器回路\n力が異なる時刻に生成されることが図から見てわかります。デジタル回路設計\nの困難の多くはこの事実から生じます。\n今から私達が学習を望むデジタル論理回路をモデル化するためのプログラムを\n構築します。プログラムは回路をモデル化する計算モデルを構築します。これ\nは信号を\n“\n保持\n”\nします。関数箱は信号間の正しい関係を強制する手続により\nモデル化されます。\n私達のシミュレーションの基本的要素の\n1\nつは手続\nmake-wire\nであり回路\nを構築します。例として\n6\nつの回路を以下のように構築できます。\n(\ndefine\na\n(\nmake-wire\n))\n(\ndefine\nb\n(\nmake-wire\n))\n(\ndefine\nc\n(\nmake-wire\n))\n(\ndefine\nd\n(\nmake-wire\n))\n(\ndefine\ne\n(\nmake-wire\n))\n(\ndefine\ns\n(\nmake-wire\n))\nある関数箱を回路の集合に対してその種類の箱を構築する手続を呼ぶことによ\nり取り付けることができます。コンストラクタ手続への引数は箱に取り付けら\n292","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":318},{"id":"./test/fixtures/pdf/sicp.pdf:319","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"れる回路です。例えば\nAND\nゲート、\nOR\nゲート、逆変換器を構築できる場合、\nFigure 3.25\nに示す半加算器を配線することができます。\n(\nor-gate\na\nb\nd\n)\nok\n(\nand-gate\na\nb\nc\n)\nok\n(\ninverter\nc\ne\n)\nok\n(\nand-gate\nd\ne\ns\n)\nok\nもっと良いことには、半加算器に取り付けられる\n4\nつの外部回路を与えられた\n時、この回路を構築する手続\nhalf-adder\nを定義することでこの操作に明示的\nに名前を付けることができます。\n(\ndefine\n(\nhalf-adder\na\nb\ns\nc\n)\n(\nlet\n((\nd\n(\nmake-wire\n)) (\ne\n(\nmake-wire\n)))\n(\nor-gate\na\nb\nd\n)\n(\nand-gate\na\nb\nc\n)\n(\ninverter\nc\ne\n)\n(\nand-gate\nd\ne\ns\n)\n'ok\n))\nこの定義を作ることの利点は\nhalf-adder\nそれ自身をより複雑な回路を作成す\nる時に建築用ブロックとして使用することができることです。例えば\nFigure\n3.26\nは\n2\nつの半加算器と\n1\nつの\nOR\nゲートより組み立てられる\nfull-adder\n(\n全加\n算器\n)\nを示しています。\n26\n全加算器を以下のように構築できます。\n(\ndefine\n(\nfull-adder\na\nb\nc-in\nsum\nc-out\n)\n(\nlet\n((\ns\n(\nmake-wire\n)) (\nc1\n(\nmake-wire\n)) (\nc2\n(\nmake-wire\n)))\n(\nhalf-adder\nb\nc-in\ns\nc1\n)\n(\nhalf-adder\na\ns\nsum\nc2\n)\n(\nor-gate\nc1\nc2\nc-out\n)\n'ok\n))\n26\n全加算器は\n2\nつの二進数の加算に用いられる基本的な回路要素です。ここで\nA\nと\nB\nは加算される\n2\nつの数の対応する位置のビットで、\n퐶\n푖푛\nは\n1\nつ右の加算からのキャリー\nビット\n(\n桁上げビット\n)\nです。この回路は対応する位置の合計のビットである\nSUM\nと左\nに伝播されるキャリービットである\n퐶\n표푢푡\nを算出します。\n293","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":319},{"id":"./test/fixtures/pdf/sicp.pdf:320","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"half-\nadder\nhalf-\nadder\nA\nB\nC\nin\nSUM\nC\nout\nor\nFigure 3.26:\n全加算器回路\n手続として定義された\nfull-adder\nを持つことでさらにより複雑な回路を作\n成するための建築ブロックとして利用することが可能です。\n(\n例えば\nExercise\n3.30\nを参照\n)\n。\n実質的に、私達のシミュレーターは回路の言語を構築するツールを提供し\nます。もし\nSection 1.1\nにおける\nLisp\nの学習への取り組みに用いた言語上の一般\n的な観点を受け入れれば、プリミティブな関数箱はプリミティブな言語の要素\nを形成し、箱の間に回路を引くことは組み合わせの手段を提供し、手続として\n回線を引くパターンを指定することは抽象化の手段としての役割を果たすとい\nうことが言えます。\nプリミティブな関数箱\nプリミティブな関数箱はある回路上の信号の変化が他の配線上の信号に影\n響を与える\n“\n力\n”\nを実装します。関数箱を構築するため以下の回路上の命令を\n用います。\n•\n(get-signal\n⟨\nwire\n⟩\n)\n回線上の信号の現在地を返す\n•\n(set-signal!\n⟨\nwire\n⟩  ⟨\nnew value\n⟩\n)\n回路上の信号の値を新しい値に変更する\n•\n(add-action!\n⟨\nwire\n⟩  ⟨\nprocedure of no arguments\n⟩\n)\n指定された手続が回路上の信号が値を変化した場合常に実行される様に\n宣言する。そのような手続は、回路上の信号の値の変化が他の回路と通\n信を行うための伝達手段である。\n294","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":320},{"id":"./test/fixtures/pdf/sicp.pdf:321","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"さらに手続\nafter-delay\nを使用し遅延時間と実行される手続を取得し、与えら\nれた手続を遅延時間後に実行します。\nこれらの手続を用いてプリミティブなデジタル論理関数を定義できます。\n入力を逆変換器を通して出力に接続するために\nadd-action!\nを用いて入力回路\nと入力回路上の信号が値を変化する度に実行される手続を関連付けます。その\n手続は入力信号の\nlogical-not\n(\n論理否定\n)\nを計算し、そして\ninverter-delay\n後に出力信号にこの新しい値を設定します。\n(\ndefine\n(\ninverter\ninput\noutput\n)\n(\ndefine\n(\ninvert-input\n)\n(\nlet\n((\nnew-value\n(\nlogical-not\n(\nget-signal\ninput\n))))\n(\nafter-delay\ninverter-delay\n(\nlambda\n()\n(\nset-signal!\noutput\nnew-value\n)))))\n(\nadd-action!\ninput\ninvert-input\n)\n'ok\n)\n(\ndefine\n(\nlogical-not\ns\n)\n(\ncond\n((=\ns\n0) 1)\n((=\ns\n1) 0)\n(\nelse\n(\nerror\n\"\nInvalid\nsignal\n\"\ns\n))))\nAND\nゲートはより少しだけ複雑です。アクション手続はゲートへの入力のど\nちらかが変化した場合に実行されねばなりません。それが入力回路上の信号の\n値の\nlogical-and\n(\n論理積\n)\nを\n(\nlogical-not\nと類似の手続を用いて\n)\n求め、出\n力回路上に起こる新しい値への変更を\nand-gate-delay\n後に設定します。\n(\ndefine\n(\nand-gate\na1\na2\noutput\n)\n(\ndefine\n(\nand-action-procedure\n)\n(\nlet\n((\nnew-value\n(\nlogical-and\n(\nget-signal\na1\n) (\nget-signal\na2\n))))\n(\nafter-delay\nand-gate-delay\n(\nlambda\n() (\nset-signal!\noutput\nnew-value\n)))))\n(\nadd-action!\na1\nand-action-procedure\n)\n(\nadd-action!\na2\nand-action-procedure\n)\n'ok\n)\nExercise 3.28:\nOR\nゲートをプリミティブな関数箱として定義せ\nよ。あなたの\nor-gate\nコンストラクタは\nand-gate\nと同様でなけ\n295","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":321},{"id":"./test/fixtures/pdf/sicp.pdf:322","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"A\n1\nB\n1\nC\n1\nA\n2\nB\n2\nC\n2\nA\n3\nB\n3\nC\n3\nA\nn\nB\nn\nC\nn\n = 0 \nS\n1\nC\nS\n2\nS\n3\nS\nn\nC\nn-1 \nFA\nFA\nFA\nFA\nFigure 3.27:\n푛\n-bit\n数の桁上げ伝播加算器\nればならない。\nExercise 3.29:\nOR\nゲートを構築する別の方法は複合デジタル論\n理デバイスとして\nAND\nゲートと逆変換器から構築するものであ\nる。これを達成する手続\nor-gate\nを定義せよ。\nand-gate-delay\nと\ninverter-delay\nを用いた遅延時間はどのようになるか\n?\nExercise 3.30:\nFigure 3.27\nは\n푛\n個の全加算器を繋げた\nripple-carry\nadder\n(\n桁上げ伝播加算器\n)\nを示している。これは\n2\nつの\n푛\nビット二\n進数を足すための最も簡単な形式の並列加算器である。入力\n퐴\n1\n,\n퐴\n2\n,\n퐴\n3\n,\n...\n,\n퐴\n푛\nと\n퐵\n1\n,\n퐵\n2\n,\n퐵\n3\n,\n...\n,\n퐵\n푛\nは足すべき\n2\nつの二進数\n(\n各\n퐴\n푘\nと\n퐵\n푘\nは\n0\nか\n1)\nである。回路は\n푆\n1\n,\n푆\n2\n,\n푆\n3\n,\n...\n,\n푆\n푛\nの\n푛\nビ\nットの和と、和算の桁上がりである\n퐶\nを生成する。この回路を生\n成する手続\nripple-carry-adder\nを書け。この手続は引数として\nそれぞれ\n푛\n個の配線を持つ\n3\nつのリスト\n—\n퐴\n푘\n,\n퐵\n푘\n,\n푆\n푘\n—\nと別の\n配線\n퐶\nを取る。桁上げ伝播加算器の主な欠点はキャリー信号の伝\n播を待つ必要があることである。\n푛\nビットの桁上げ伝播加算器に\nおける完全な出力を得るのに必要な遅延時間はいくらか\n? AND\nゲ\nート、\nOR\nゲート、逆変換器の遅延時間から表現せよ。\n回路の表現\n私達のシミュレーションにおけるワイヤ\n(wire\n、配線、回路\n)\nは\n2\nつのローカ\nルな状態変数を持つ計算オブジェクトになります。その\n2\nつは\nsignal-value\n(\n信\n号値\n)(\n初期値は\n0)\nと信号が値を変えた時に実行される\naction-procedures\n(\n行\n動手続\n)\nの集合です。メッセージパッシングスタイルを用いてワイヤを局所手\n296","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":322},{"id":"./test/fixtures/pdf/sicp.pdf:323","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"続の集合として適切な局所命令を選択する手続\ndispatch\nと共に実装します。\nSection 3.1.1\nでの簡単な銀行口座オブジェクトと同様に行います。\n(\ndefine\n(\nmake-wire\n)\n(\nlet\n((\nsignal-value\n0) (\naction-procedures\n'\n()))\n(\ndefine\n(\nset-my-signal!\nnew-value\n)\n(\nif\n(\nnot\n(=\nsignal-value\nnew-value\n))\n(\nbegin\n(\nset!\nsignal-value\nnew-value\n)\n(\ncall-each\naction-procedures\n))\n'done\n))\n(\ndefine\n(\naccept-action-procedure!\nproc\n)\n(\nset!\naction-procedures\n(\ncons\nproc\naction-procedures\n))\n(\nproc\n))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'get-signal\n)\nsignal-value\n)\n((\neq?\nm\n'set-signal!\n)\nset-my-signal!\n)\n((\neq?\nm\n'add-action!\n)\naccept-action-procedure!\n)\n(\nelse\n(\nerror\n\"\nUnknown\noperation\n:\nWIRE\n\"\nm\n))))\ndispatch\n))\n局所手続\nset-my-signal!\nは新しい信号値が配線上の信号を変えるかチェック\nします。もしそうであれば全ての行動手続を以下の手続\ncall-each\nを用いて実\n行します。\ncall-each\nは引数無し手続のリスト内の全てのアイテムを呼び出し\nます。\n(\ndefine\n(\ncall-each\nprocedures\n)\n(\nif\n(\nnull?\nprocedures\n)\n'done\n(\nbegin\n((\ncar\nprocedures\n))\n(\ncall-each\n(\ncdr\nprocedures\n)))))\n局所手続\naccept-action-procedure!\nは与えられた手続を実行対象手続リスト\nに追加します。次に新しい手続を一度実行します。\n(\nExercise 3.31\n参照\n)\nローカルの\ndispatch\n手続が指定通りに設定されていることから、以下の手\n続を与えて配線上の局所命令にアクセスすることができます。\n27\n27\nこれらの手続は単純にオブジェクトの局所手続にアクセスするために通常の手続的\nな文法を使用することを許可する構文糖に過ぎません。\n“\n手続\n”\nと\n“\nデータ\n”\nの役割をそ\n297","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":323},{"id":"./test/fixtures/pdf/sicp.pdf:324","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nget-signal\nwire\n) (\nwire\n'get-signal\n))\n(\ndefine\n(\nset-signal!\nwire\nnew-value\n)\n((\nwire\n'set-signal!\n)\nnew-value\n))\n(\ndefine\n(\nadd-action!\nwire\naction-procedure\n)\n((\nwire\n'add-action!\n)\naction-procedure\n))\n時間的に変化する信号を持ち付加的に装置に取り付けられる配線はミュータブ\nルなオブジェクトの特性を良く示しています。私達はそれを代入により変化す\nるローカル状態変数を持つ手続としてモデル化しました。新しい配線が作成さ\nれた時、新しい状態変数の信号は\n(\nmake-wire\n中の\nlet\n式により\n)\n確保され、新\nしい\ndispatch\n手続が構築され返され、新しい状態変数を持つ環境が確保され\nます。\n配線は様々なデバイスの間で共有され、それらに対して接続されます。従\nってあるデバイスとの応答により起こった変化はその配線に取り付けられた全\nての他のデバイスに影響を与えます。配線は接続が開設された時に提供された\n行動手続を呼ぶことによりその近傍に対し変化を通知します。\n予定表\nシミュレータを完成させるために必要な物は\nafter-delay\nのみです。ここ\nでのアイデアは\nagenda\n(\n予定表\n)\nと呼ばれるデータ構造を保持し、それに行う\nべき予定を保存します。以下の命令は予定表のために定義されます。\n•\n(make-agenda)\nは新しい空の予定表を返す。\n•\n(empty-agenda?\n⟨\nagenda\n⟩\n)\nは指定した予定表が空であるなら真である。\n•\n(first-agenda-item\n⟨\nagenda\n⟩\n)\nは予定表の最初のアイテムを返す。\n•\n(remove-first-agenda-item!\n⟨\nagenda\n⟩\n)\nは予定表から最初のアイテム\nを削除する。\n•\n(add-to-agenda!\n⟨\ntime\n⟩   ⟨\naction\n⟩   ⟨\nagenda\n⟩\n)\nは指定された時間後に\n実行される行動手続を追加する。\nのような簡単な方法で交換できることは印象的です。例えばもし\n(wire 'get-signal)\nと書いた場合、私達は\nwire\nをメッセージ\nget-signal\nを入力として呼び出される手続だ\nと考えるでしょう。その代わりに\n(get-signal wire)\nと書くことは私達に\nwire\nを手続\nget-signal\nに対する入力としてのデータオブジェクトだと考えることを促します。この\n問題の真実は私達が手続をオブジェクトとして扱う言語には\n“\n手続\n”\nと\n“\nデータ\n”\nの間に\n基本的な違いが存在せず、私達はどんなスタイルを選択してもプログラミングを可能に\nする構文糖を選択することができるということです。\n298","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":324},{"id":"./test/fixtures/pdf/sicp.pdf:325","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n(current-time\n⟨\nagenda\n⟩\n)\nは現在のシミュレーション時間を返す。\n使用する予定表は\nthe-agenda\nにより指定されます。手続\nafter-delay\nは新し\nい要素を\nthe-agenda\nに追加します。\n(\ndefine\n(\nafter-delay\ndelay\naction\n)\n(\nadd-to-agenda!\n(+\ndelay\n(\ncurrent-time\nthe-agenda\n))\naction\nthe-agenda\n))\nシミュレーションは手続\npropagate\n(\n伝播\n)\nにより駆動され、\nthe-agenda\n上で\n操作を行い、予定表上の各手続を順に実行します。一般的にシミュレータが実\n行されるにつれ、新しいアイテムが予定表に追加され、\npropagate\nはシミュレ\nーションを予定表にアイテムが存在する間は続けます。\n(\ndefine\n(\npropagate\n)\n(\nif\n(\nempty-agenda?\nthe-agenda\n)\n'done\n(\nlet\n((\nfirst-item\n(\nfirst-agenda-item\nthe-agenda\n)))\n(\nfirst-item\n)\n(\nremove-first-agenda-item!\nthe-agenda\n)\n(\npropagate\n))))\nサンプルシミュレーション\n回路上に\n“probe”(\nプローブ、探針\n)\nを置く以下の手続は実行中のシミュレ\nータを表示します。プローブは配線に対し信号値が変わる度に新しい信号値を\n現在に時刻と配線を識別する名前を一緒に表示せよと命じます。\n(\ndefine\n(\nprobe\nname\nwire\n)\n(\nadd-action!\nwire\n(\nlambda\n()\n(\nnewline\n)\n(\ndisplay\nname\n)\n(\ndisplay\n\"\n\"\n)\n(\ndisplay\n(\ncurrent-time\nthe-agenda\n))\n(\ndisplay\n\"\nNew-value\n=\n\"\n)\n(\ndisplay\n(\nget-signal\nwire\n)))))\n299","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":325},{"id":"./test/fixtures/pdf/sicp.pdf:326","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"予定表の初期化とプリミティブな関数箱に対し遅延時間を指定することから始\nめます。\n(\ndefine\nthe-agenda\n(\nmake-agenda\n))\n(\ndefine\ninverter-delay\n2)\n(\ndefine\nand-gate-delay\n3)\n(\ndefine\nor-gate-delay\n5)\nここで\n4\nつの配線を定義し、その内\n2\nつにプローブを仕込みます。\n(\ndefine\ninput-1\n(\nmake-wire\n))\n(\ndefine\ninput-2\n(\nmake-wire\n))\n(\ndefine\nsum\n(\nmake-wire\n))\n(\ndefine\ncarry\n(\nmake-wire\n))\n(\nprobe\n'sum\nsum\n)\nsum 0 New-value = 0\n(\nprobe\n'carry\ncarry\n)\ncarry 0 New-value = 0\n次に配線を\n(\nFigure 3.25\nの様に\n)\n半加算器回路に接続し、\ninput-1\n上の信号を\n1\nに設定し、シミュレーションを実行します。\n(\nhalf-adder\ninput-1\ninput-2\nsum\ncarry\n)\nok\n(\nset-signal!\ninput-1\n1)\ndone\n(\npropagate\n)\nsum 8 New-value = 1\ndone\nsum\nの進行は時刻\n8\nにおいて\n1\nに変化しました。シミュレーションの開始から\n8\n単位時間が経過しました。この時点で\ninput-2\n上の信号を\n1\nに設定し値の伝\n播を許可します。\n(\nset-signal!\ninput-2\n1)\ndone\n300","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":326},{"id":"./test/fixtures/pdf/sicp.pdf:327","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\npropagate\n)\ncarry 11 New-value = 1\nsum 16 New-value = 0\ndone\ncarry\nは時刻\n11\nにて\n1\nに変化し、\nsum\nは時刻\n16\nにおいて\n0\nに変化しました。\nExercise 3.31:\nmake-wire\n内で定義された内部手続\naccept-action-\nprocedure!\nは新しい行動手続が配線に追加された時に、その手続\nが即座に実行された。この初期化がなぜ必要であるのか説明せよ。\n具体的には、上の段落の半加算器の例をトレースし、システムの\n応答が、\naccept-action-procedure!\nが以下のように定義されてい\nた場合にどのように異なるかについて述べよ。\n(\ndefine\n(\naccept-action-procedure!\nproc\n)\n(\nset!\naction-procedures\n(\ncons\nproc\naction-procedures\n)))\n予定表の実装\n最後に将来に実行される予定の手続を保存する予定表データ構造の詳細に\nついて説明します。\n予定表は\ntime segments\n(\nタイムセグメント\n、時間区分\n)\nにより構成されてい\nます。各タイムセグメントは数値\n(\n時刻\n)\nと、そのタイムセグメントの間に実\n行されるよう予定された手続を持つキュー\n(\nExercise 3.32\n参照\n)\nから成るペア\nです。\n(\ndefine\n(\nmake-time-segment\ntime\nqueue\n)\n(\ncons\ntime\nqueue\n))\n(\ndefine\n(\nsegment-time\ns\n) (\ncar\ns\n))\n(\ndefine\n(\nsegment-queue\ns\n) (\ncdr\ns\n))\nタイムセグメントのキューは\nSection 3.3.2\n.\nで説明したキューの命令を用いて\n操作します。\n予定表自身は\n1\n次元のタイムセグメントの表です。\nSection 3.3.3\nで説明さ\nれた表との違いはセグメントが時間の増す順にソートされることです。加え\nて\ncurrent time\n(\n現在時刻\n) (\n言い換えると最後に処理された行動の時刻\n)\nを予定\n301","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":327},{"id":"./test/fixtures/pdf/sicp.pdf:328","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"表の頭に保存します。新しく構築された予定表はタイムセグメントを持ってお\nらず現在時刻として\n0\nを持ちます。\n28\n(\ndefine\n(\nmake-agenda\n) (\nlist\n0))\n(\ndefine\n(\ncurrent-time\nagenda\n) (\ncar\nagenda\n))\n(\ndefine\n(\nset-current-time!\nagenda\ntime\n)\n(\nset-car!\nagenda\ntime\n))\n(\ndefine\n(\nsegments\nagenda\n) (\ncdr\nagenda\n))\n(\ndefine\n(\nset-segments!\nagenda\nsegments\n)\n(\nset-cdr!\nagenda\nsegments\n))\n(\ndefine\n(\nfirst-segment\nagenda\n)\n(\ncar\n(\nsegments\nagenda\n)))\n(\ndefine\n(\nrest-segments\nagenda\n)\n(\ncdr\n(\nsegments\nagenda\n)))\n予定表はタイムセグメントを持っていなければ空です。\n(\ndefine\n(\nempty-agenda?\nagenda\n)\n(\nnull?\n(\nsegments\nagenda\n)))\n予定表に行動\n(\nアクション\n)\nを追加するために、最初に予定表が空であるか確認\nします。もしそうならばアクションのためのタイムセグメントを作成し、それ\nを予定表にインストールします。そうでなければ予定表を走査し、各セグメン\nトの時刻を調べます。もし指定時刻が存在するならば対応するキューにアクシ\nョンを追加します。もし指定時刻よりも後の時間に辿り着いたならば、新しい\nタイムセグメントを予定表のその時間の前に挿入します。もし予定表の最後ま\nで辿り着いたならば新しいタイムセグメントを最後に作らねばなりません。\n(\ndefine\n(\nadd-to-agenda!\ntime\naction\nagenda\n)\n(\ndefine\n(\nbelongs-before?\nsegments\n)\n(\nor\n(\nnull?\nsegments\n)\n(<\ntime\n(\nsegment-time\n(\ncar\nsegments\n)))))\n(\ndefine\n(\nmake-new-time-segment\ntime\naction\n)\n(\nlet\n((\nq\n(\nmake-queue\n)))\n(\ninsert-queue!\nq\naction\n)\n(\nmake-time-segment\ntime\nq\n)))\n28\n予定表は\nSection 3.3.3\nのような頭出しリストですが、このリストは時刻による頭出し\nですので追加のダミーヘッダ\n(\nテーブルにて用いられた\n*table*\nシンボルのような物\n)\nを\n必要としません。\n302","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":328},{"id":"./test/fixtures/pdf/sicp.pdf:329","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nadd-to-segments!\nsegments\n)\n(\nif\n(= (\nsegment-time\n(\ncar\nsegments\n))\ntime\n)\n(\ninsert-queue!\n(\nsegment-queue\n(\ncar\nsegments\n))\naction\n)\n(\nlet\n((\nrest\n(\ncdr\nsegments\n)))\n(\nif\n(\nbelongs-before?\nrest\n)\n(\nset-cdr!\nsegments\n(\ncons\n(\nmake-new-time-segment\ntime\naction\n)\n(\ncdr\nsegments\n)))\n(\nadd-to-segments!\nrest\n)))))\n(\nlet\n((\nsegments\n(\nsegments\nagenda\n)))\n(\nif\n(\nbelongs-before?\nsegments\n)\n(\nset-segments!\nagenda\n(\ncons\n(\nmake-new-time-segment\ntime\naction\n)\nsegments\n))\n(\nadd-to-segments!\nsegments\n))))\n予定表から最初のアイテムを削除する手続は最初のタイムセグメント中のキュ\nーの先頭のアイテムを削除します。もしこの削除がタイムセグメントを空にす\nるのであれば、セグメントのリストからそれを削除します。\n29\n(\ndefine\n(\nremove-first-agenda-item!\nagenda\n)\n(\nlet\n((\nq\n(\nsegment-queue\n(\nfirst-segment\nagenda\n))))\n(\ndelete-queue!\nq\n)\n(\nif\n(\nempty-queue?\nq\n)\n(\nset-segments!\nagenda\n(\nrest-segments\nagenda\n)))))\n最初の予定表のアイテムは最初のタイムセグメントのキューの頭に見つかりま\nす。アイテムを抽出する度に現在時刻の更新も行います。\n30\n29\nこの手続の中の\nif\n式が\n⟨\nalternative\n⟩\n式を持っていないことに注意して下さい。こ\nのような\n“\n片腕の\nif\n文\n”\nは\n2\nつの式の間から選択するのではなく何かをするかどう\nかを決定するのに使用されます。\nif\n式は述語が偽になった場合に未定義の値を返し、\n⟨\nalternative\n⟩\nは有りません。\n30\nこのようにして、現在時刻は常に最も最近に処理されたアクションの時刻になりま\nす。この時刻を予定表の頭に格納することで例え関連するタイムセグメントが削除され\nても依然として有効であることを確約します。\n303","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":329},{"id":"./test/fixtures/pdf/sicp.pdf:330","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nfirst-agenda-item\nagenda\n)\n(\nif\n(\nempty-agenda?\nagenda\n)\n(\nerror\n\"\nAgenda\nis\nempty\n:\nFIRST-AGENDA-ITEM\n\"\n)\n(\nlet\n((\nfirst-seg\n(\nfirst-segment\nagenda\n)))\n(\nset-current-time!\nagenda\n(\nsegment-time\nfirst-seg\n))\n(\nfront-queue\n(\nsegment-queue\nfirst-seg\n)))))\nExercise 3.32:\n予定表の各タイムセグメントの間に実行される手続\nはキューに保存される。従って各セグメントの手続は予定表に追\n加された順に呼び出される\n(FIFO)\n。なぜこの順が使用されるべき\nか説明せよ。具体的には入力が\n0,1\nから\n1,0\nに同じセグメントにて\n変化した時の\nAND\nゲートの振舞をトレースし、もしセグメントの\n手続を通常の順に格納し、手続の追加と削除を先頭でのみ行った\n場合\n(LIFO)\nに振舞がどのように異なるかについて述べよ。\n3.3.5\n制約伝播\nコンピュータプログラムは伝統的に一方向の演算として体系化されます。\nこれは事前に指定した引数上で命令を実行し、望んだ出力を生成します。一方\nで私達は時折、量の間の関係を用いてシステムをモデル化します。例えば機械\n構造の数理的モデルは金属棒の偏差\n푑\nが棒上の力\n퐹\n、棒の長さ\n퐿\n、断面積\n퐴\n、\n弾性率\n퐸\nに方程式を通して関連するという情報を含むでしょう。\n푑퐴퐸 = 퐹 퐿.\nそのような方程式は一方向ではありません。任意の\n4\nつの量を与えられる\nことで、\n5\nつ目を計算することができます。けれども方程式を伝統的なコンピ\nュータ言語へと翻訳することは\n1\nつの量を選択し他の\n4\nつを用いて求めること\nを私達は強制されます。従って断面積\n퐴\nを求める手続は偏差\n푑\nを求めること\nには、例え\n퐴\nと\n푑\nの演算が同じ方程式から起こっても使用できません。\n31\n31\n制約伝播は最初に信じられない程先進的であった\nIvan\nSutherland (1963)\nによる\nsketchpad\nシステムに現れました。\nSmalltalk\nをベースにした美しい制約伝播システ\nムは\nAlan\nBorning (1977)\nにより\nXerox\nパロアルト研究センタにて開発されました。\nSussman, Stallman, Steele\nの\n3\n人は制約伝播を電子回路分析に応用しました\n(\nSussman\nand Stallman 1975\n;\nSussman and Steele 1980\n)\n。\nTK!Solver(\nKonopasek and Jayaraman\n1984\n)\nは制約をベースにした大規模モデリング環境です。\n304","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":330},{"id":"./test/fixtures/pdf/sicp.pdf:331","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"m1\nm2\np\n*\np\nm1\nm2\n*\nu\nv\n325\n9\na1\na2\ns\n+\nF\nC\nw\nx  y\nFigure 3.28:\n制約ネットワークとして表した関係\n9퐶 = 5(퐹 − 32)\nこの節では関係性自身を用いて働くことが可能な言語の設計を描きます。\n言語のプリミティブな要素は\nprimitive constraints\n(\nプリミティブ制約\n)\nであり、\n幾らかの関係性が数量の間に保存されることを示します。例えば\n푐\nは方程式\n푎 + 푏 = 푐\nから参照されねばならず、\n(multiplier x y z)\nは制約\n푥푦 = 푧\nを表\nし、\n(constant 3.14 x)\nは\n푥\nの値が\n3.14\nに違いないと述べています。\n私達の言語はプリミティブ制約をより複雑な関係を表明するために接続す\nる手段を提供します。制約を\nconstraint networks\n(\n制約ネットワーク\n)\nを構築す\nることで接続し、その中で制約は\nconnectors\n(\nコネクタ\n)\nを用いて結合されます。\nコネクタは値を持つオブジェクトであり、\n1\nつ以上の制約に加わります。例え\nば華氏と摂氏の気温の間の関係が以下であることを知っています。\n9퐶 = 5(퐹 − 32).\nそのような制約はプリミティブな加算器、乗算器、不変制約\n(\nFigure 3.28\n)\nより成り立つネットワークとして考えることができます。図の中で左手に\n푚\n1,\n푚\n2,\n푝\nの\n3\nつの端子を持つ乗算の箱を見ることができます。これらは乗算器を\n以下のネットワークの残りに接続します。\n푚\n1\n端子は摂氏の気温を保持するコ\nネクタ\n퐶\nにリンクされます。\n푚\n2\n端子も\n9\nを持つ整数箱にリンクされます。乗\n算器の箱が\n푚\n1\nと\n푚\n2\nの積に制約を行う\n푝\n端子は別の乗算器の箱の\n푝\n端子に接\n続され、その箱の\n푚\n2\nは整数\n5\nに、\n푚\n1\nは合計の\n1\nつの端子に接続されます。\nこのようなネットワークによる計算は以下の様に進行されます。コネクタに値\nが\n(\nユーザ、またはリンクされた制約箱により\n)\n与えられた時、その関連する制\n約全てを\n(\nそれを起こした制約を除いて\n)\n起こし、それらに値を得たことを伝え\nます。起きた制約箱は全て次にコネクタに対しコネクタの値を決定するのに十\n分な情報が存在するかを調査\n(poll)\nします。もしそうであれば、制約箱はコネ\n305","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":331},{"id":"./test/fixtures/pdf/sicp.pdf:332","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"クタに値を設定し、コネクタはすると関係する制約を全て起こします。これが\n繰り返されます。例として摂氏と華氏の間の換算では\n푤\n,\n푥\n,\n푦\nは整数箱\n9, 5, 32\nそれぞれにより直ぐに設定されます。コネクタは乗算器と加算器を起動し、そ\nれらは続行に必要な情報が十分ではないことを判断します。もしユーザ\n(\nまた\nはネットワークの何らかの他の部分が\n)\n퐶\nに値\n(\n例えば\n25)\nを設定すると最も左\nの乗算器が起動され、\n푢\nに\n25 ⋅ 9 = 225\nを設定します。すると\n푢\nが\n2\nつ目の乗\n算器を起動し、それが\n푣\nに\n45\nを設定します。そして\n푣\nが加算器を起動し、加\n算器は\n푓\nを\n77\nに設定します。\n制約システムの利用\n制約システムを用いて上で説明された気温の計算を実行するには最初に\n2\nつのコネクタ、\nC\nと\nF\nをコンストラクタ\nmake-connector\nを呼ぶことで作成し、\nC\nと\nF\nをあるべきネットワークにリンクします。\n(\ndefine\nC\n(\nmake-connector\n))\n(\ndefine\nF\n(\nmake-connector\n))\n(\ncelsius-fahrenheit-converter\nC\nF\n)\nok\nネットワークを作成する手続は以下のように定義されます。\n(\ndefine\n(\ncelsius-fahrenheit-converter\nc\nf\n)\n(\nlet\n((\nu\n(\nmake-connector\n))\n(\nv\n(\nmake-connector\n))\n(\nw\n(\nmake-connector\n))\n(\nx\n(\nmake-connector\n))\n(\ny\n(\nmake-connector\n)))\n(\nmultiplier\nc\nw\nu\n)\n(\nmultiplier\nv\nx\nu\n)\n(\nadder\nv\ny\nf\n)\n(\nconstant\n9\nw\n)\n(\nconstant\n5\nx\n)\n(\nconstant\n32\ny\n)\n'ok\n))\nこの手続は内部コネクタ\nu\n,\nv\n,\nw\n,\nx\n,\ny\nを作成し、それらを\nFigure 3.28\nに示され\nるようにプリミティブな制約コンストラクタ\nadder\n,\nmultiplier\n,\nconstant\nを\n用いてリンクします。\n306","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":332},{"id":"./test/fixtures/pdf/sicp.pdf:333","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"実行中のネットワークを見るために、コネクタ\nC\nと\nF\nにプローブ\n(\n探針\n)\nを\nSection 3.3.4\nで配線の監視に用いた物と同様な\nprobe\n手続を用いて設置しま\nす。プローブのコネクタ上への設置はコネクタに値が与えられる度にメッセー\nジが表示されるようにします。\n(\nprobe\n\"\nCelsius\ntemp\n\"\nC\n)\n(\nprobe\n\"\nFahrenheit\ntemp\n\"\nF\n)\n次に\nC\nの値を\n25\nに設定します。\n(\nset-value!\nへの\n3\nつ目の引数は\nC\nにこの指\n示が\nuser\nによる物であることを伝えています\n)\n。\n(\nset-value!\nC\n25\n'user\n)\nProbe: Celsius temp = 25\nProbe: Fahrenheit temp = 77\ndone\nC\n上のプローブが起動され値を報告します。\nC\nはまたその値を上で説明された\nネットワークを通して伝播させます。これが\nF\nに\n77\nを設定し、\nF\n上のプローブ\nにより報告されます。\nここで\nF\nに新しい値、例えば\n212\nを設定してみましょう。\n(\nset-value!\nF\n212\n'user\n)\nError! Contradiction (77 212)\nコネクタが矛盾に気付いたと訴えています。その値は\n77\nの時、誰かが\n212\nを\n設定しようとしているのです。もし本当にネットワークを新しい値にて再利用\nしたいのであれば\nC\nに古い値を忘れるように指示できます。\n(\nforget-value!\nC\n'user\n)\nProbe: Celsius temp = ?\nProbe: Fahrenheit temp = ?\ndone\nC\nは元の値を設定した\nuser\nが今撤回しているのに気付き、\nC\nはその値をなくす\nことにプローブが示すように同意し、ネットワークの残りにこの結果について\n伝えます。この情報が結果的に\nF\nに伝播し、\nF\nは今となってはそれ自身の値が\n77\nであると信じ続けるための理由が無いことに気付きます。従って\nF\nもまたそ\nの値を諦めプローブにより表示されます。\nこれで\nF\nは値を持たず、私達は\nF\nに\n212\nを設定できます。\n307","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":333},{"id":"./test/fixtures/pdf/sicp.pdf:334","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nset-value!\nF\n212\n'user\n)\nProbe: Fahrenheit temp = 212\nProbe: Celsius temp = 100\ndone\nこの新しい値がネットワーク中に伝播された時、\nC\nに\n100\nの値を持つことを強\n制し、\nC\n上のプローブによりこのことが表されます。全く同じネットワークが\nF\nを与えて\nC\nを計算するのと、\nC\nを与えて\nF\nを計算することに用いられている\nことに注意して下さい。この方向性の無い演算が制約ベースシステムの特徴的\nな機能です。\n制約システムの実装\n制約システムは局所状態を持つ手続き型のオブジェクトにより、\nSection\n3.3.4\nのデジタル回路シミュレータに良く似た作法で実装されます。制約システ\nムのプリミティブなオブジェクトはいくらかより複雑ではあるものの、システ\nム全体は予定表や論理遅延時間についての考慮が不要な分、よりシンプルです。\nコネクタ上の基本的な命令は次のとおりです。\n•\n(has-value? <\nconnector\n>)\nはコネクタが値を持つかどうか判断する\n•\n(get-value <\nconnector\n>)\nはコネクタの現在地を返す\n•\n(set-value! <\nconnector\n> <\nnew-value\n> <\ninformant\n>)\nは情報がコネク\nタに対しその値を新しい値に設定するよう要求することを示す\n•\n(forget-value! <\nconnector\n> <\nretractor\n>)\nはコネクタに対し撤回を\n望む者が値を忘れることを要求していると伝える\n•\n(connect <\nconnector\n> <\nnew-constraint\n>)\nはコネクタに対し新しい制\n約への参加を指示する\nコネクタは与えられた制約にコネクタが値を持っていると伝える手続\ninform-\nabout-value\nと制約にコネクタが値を失ったと伝える手続\ninform-about-no-\nvalue\nを用いて制約と通信を行います。\nadder\nは加数コネクタ\na1\nと\na2\nと\nsum\nコネクタの間に加算器制約を構築す\nるコンストラクタです。加算器は局所状態を持つ手続\n(\n下記の手続\nme\n)\nとして\n実装されます。\n(\ndefine\n(\nadder\na1\na2\nsum\n)\n(\ndefine\n(\nprocess-new-value\n)\n308","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":334},{"id":"./test/fixtures/pdf/sicp.pdf:335","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncond\n((\nand\n(\nhas-value?\na1\n) (\nhas-value?\na2\n))\n(\nset-value!\nsum\n(+ (\nget-value\na1\n) (\nget-value\na2\n))\nme\n))\n((\nand\n(\nhas-value?\na1\n) (\nhas-value?\nsum\n))\n(\nset-value!\na2\n(- (\nget-value\nsum\n) (\nget-value\na1\n))\nme\n))\n((\nand\n(\nhas-value?\na2\n) (\nhas-value?\nsum\n))\n(\nset-value!\na1\n(- (\nget-value\nsum\n) (\nget-value\na2\n))\nme\n))))\n(\ndefine\n(\nprocess-forget-value\n)\n(\nforget-value!\nsum\nme\n)\n(\nforget-value!\na1\nme\n)\n(\nforget-value!\na2\nme\n)\n(\nprocess-new-value\n))\n(\ndefine\n(\nme\nrequest\n)\n(\ncond\n((\neq?\nrequest\n'I-have-a-value\n)\n(\nprocess-new-value\n))\n((\neq?\nrequest\n'I-lost-my-value\n)\n(\nprocess-forget-value\n))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nADDER\n\"\nrequest\n))))\n(\nconnect\na1\nme\n)\n(\nconnect\na2\nme\n)\n(\nconnect\nsum\nme\n)\nme\n)\nadder\nは新しい加算器を指定されたコネクタに接続し自身をその値として返し\nます。手続\nme\nは加算器を表現し、ローカル手続を起動する者の役割を果たし\nます。\n(\ndefine\n(\ninform-about-value\nconstraint\n)\n(\nconstraint\n'I-have-a-value\n))\n(\ndefine\n(\ninform-about-no-value\nconstraint\n)\n(\nconstraint\n'I-lost-my-value\n))\n加算器のローカル手続\nprocess-new-value\nはその加算器が繋るコネクタの内\n1\n309","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":335},{"id":"./test/fixtures/pdf/sicp.pdf:336","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"つが値を得た事を報された時に呼び出されます。加算器は最初に\na1\nと\na2\nの両\n方が値を持っているか確認します。もしそうならば\nsum\nに\n2\nつの加数の和をそ\nの値として設定するように指示します。\nset-value!\nの\ninformant\n(\n情報提供者\n)\n引数は加算器オブジェクト自身である\nme\nです。もし\na1\nと\na2\nの両方が値を持\nっていない場合、加算器はひょっとしたら\na1\nと\nsum\nが値を持っていないか確\n認します。もしそうならば\na2\nにその\n2\nつの差を設定します。最後に\na2\nと\nsum\nが値を持っているのならば加算器に\na1\nを接待させるために十分な情報を持っ\nていることになります。もし加算器がコネクタの\n1\nつが値を失なったと報され\nた場合、全てのコネクタに対しその値を捨てるよう指示します。\n(\nこの加算器に\nより設定された値のみが実際には失なわれます\n)\n。次に加算器は\nprocess-new-\nvalue\nを実行します。この理由は\n1\nつ、またはそれ以上のコネクタが依然とし\nて値を持っている可能性があり\n(\nつまり、コネクタが元々その加算器により設\n定されたのではない値を持っている\n)\n、これらの値は加算器を通して伝播し返\nす必要があります。\n乗算器は加算器にとても良く似ています。因数のどちらかが\n0\nなら例え他\n方の値がわからなくても\nproduct\nを\n0\nにします。\n(\ndefine\n(\nmultiplier\nm1\nm2\nproduct\n)\n(\ndefine\n(\nprocess-new-value\n)\n(\ncond\n((\nor\n(\nand\n(\nhas-value?\nm1\n) (= (\nget-value\nm1\n) 0))\n(\nand\n(\nhas-value?\nm2\n) (= (\nget-value\nm2\n) 0)))\n(\nset-value!\nproduct\n0\nme\n))\n((\nand\n(\nhas-value?\nm1\n) (\nhas-value?\nm2\n))\n(\nset-value!\nproduct\n(* (\nget-value\nm1\n) (\nget-value\nm2\n))\nme\n))\n((\nand\n(\nhas-value?\nproduct\n) (\nhas-value?\nm1\n))\n(\nset-value!\nm2\n(/ (\nget-value\nproduct\n)\n(\nget-value\nm1\n))\nme\n))\n((\nand\n(\nhas-value?\nproduct\n) (\nhas-value?\nm2\n))\n(\nset-value!\nm1\n(/ (\nget-value\nproduct\n)\n(\nget-value\nm2\n))\nme\n))))\n(\ndefine\n(\nprocess-forget-value\n)\n310","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":336},{"id":"./test/fixtures/pdf/sicp.pdf:337","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nforget-value!\nproduct\nme\n)\n(\nforget-value!\nm1\nme\n)\n(\nforget-value!\nm2\nme\n)\n(\nprocess-new-value\n))\n(\ndefine\n(\nme\nrequest\n)\n(\ncond\n((\neq?\nrequest\n'I-have-a-value\n)\n(\nprocess-new-value\n))\n((\neq?\nrequest\n'I-lost-my-value\n)\n(\nprocess-forget-value\n))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMULTIPLIER\n\"\nrequest\n))))\n(\nconnect\nm1\nme\n)\n(\nconnect\nm2\nme\n)\n(\nconnect\nproduct\nme\n)\nme\n)\nconstant\nコンストラクタは単純に指定されたコネクタの値を設定します。\nI-\nhave-a-value\nと\nI-lost-my-value\nのどちらのメッセージが定数箱に送られて\nもエラーを発します。\n(\ndefine\n(\nconstant\nvalue\nconnector\n)\n(\ndefine\n(\nme\nrequest\n)\n(\nerror\n\"\nUnknown\nrequest\n:\nCONSTANT\n\"\nrequest\n))\n(\nconnect\nconnector\nme\n)\n(\nset-value!\nconnector\nvalue\nme\n)\nme\n)\n最後にプローブは指定されたコネクタの設定、設定解除のメッセージを表示し\nます。\n(\ndefine\n(\nprobe\nname\nconnector\n)\n(\ndefine\n(\nprint-probe\nvalue\n)\n(\nnewline\n) (\ndisplay\n\"\nProbe\n:\n\"\n) (\ndisplay\nname\n)\n(\ndisplay\n\"\n=\n\"\n) (\ndisplay\nvalue\n))\n(\ndefine\n(\nprocess-new-value\n)\n(\nprint-probe\n(\nget-value\nconnector\n)))\n(\ndefine\n(\nprocess-forget-value\n) (\nprint-probe\n\"\n?\n\"\n))\n(\ndefine\n(\nme\nrequest\n)\n311","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":337},{"id":"./test/fixtures/pdf/sicp.pdf:338","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncond\n((\neq?\nrequest\n'I-have-a-value\n)\n(\nprocess-new-value\n))\n((\neq?\nrequest\n'I-lost-my-value\n)\n(\nprocess-forget-value\n))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nPROBE\n\"\nrequest\n))))\n(\nconnect\nconnector\nme\n)\nme\n)\nコネクタの表現\nコネクタは局所状態変数を持つ手続型のオブジェクトとして表現され、\nvalue\nはコネクタの現在地、\ninformant\nはコネクタの値を設定したオブジェク\nト、そして\nconstraints\nはコネクタが参加する制約のリストです。\n(\ndefine\n(\nmake-connector\n)\n(\nlet\n((\nvalue\nfalse\n) (\ninformant\nfalse\n) (\nconstraints\n'\n()))\n(\ndefine\n(\nset-my-value\nnewval\nsetter\n)\n(\ncond\n((\nnot\n(\nhas-value?\nme\n))\n(\nset!\nvalue\nnewval\n)\n(\nset!\ninformant\nsetter\n)\n(\nfor-each-except\nsetter\ninform-about-value\nconstraints\n))\n((\nnot\n(=\nvalue\nnewval\n))\n(\nerror\n\"\nContradiction\n\"\n(\nlist\nvalue\nnewval\n)))\n(\nelse\n'ignored\n)))\n(\ndefine\n(\nforget-my-value\nretractor\n)\n(\nif\n(\neq?\nretractor\ninformant\n)\n(\nbegin\n(\nset!\ninformant\nfalse\n)\n(\nfor-each-except\nretractor\ninform-about-no-value\nconstraints\n))\n'ignored\n))\n(\ndefine\n(\nconnect\nnew-constraint\n)\n(\nif\n(\nnot\n(\nmemq\nnew-constraint\nconstraints\n))\n(\nset!\nconstraints\n312","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":338},{"id":"./test/fixtures/pdf/sicp.pdf:339","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncons\nnew-constraint\nconstraints\n)))\n(\nif\n(\nhas-value?\nme\n)\n(\ninform-about-value\nnew-constraint\n))\n'done\n)\n(\ndefine\n(\nme\nrequest\n)\n(\ncond\n((\neq?\nrequest\n'has-value?\n)\n(\nif\ninformant\ntrue\nfalse\n))\n((\neq?\nrequest\n'value\n)\nvalue\n)\n((\neq?\nrequest\n'set-value!\n)\nset-my-value\n)\n((\neq?\nrequest\n'forget\n)\nforget-my-value\n)\n((\neq?\nrequest\n'connect\n)\nconnect\n)\n(\nelse\n(\nerror\n\"\nUnknown\noperation\n:\nCONNECTOR\n\"\nrequest\n))))\nme\n))\nコネクタの局所手続\nset-my-value\nはコネクタの値を設定する要求が存在した\n時に呼ばれます。もしコネクタが現在値を持っていない場合、その値を設定し、\n値の設定を要求した制約を\ninformant\nとして記憶します。\n32\n次にコネクタは参\n加している制約全てに対し値の設定を要求した制約を除いて通知します。これ\nは以下の\niterator(\nイテレータ、繰り返す者\n)\nを用いて達成されます。イテレー\nタは指定された手続を与えられた\n1\nつを除いたリスト中の全てのアイテムに対\nして適用します。\n(\ndefine\n(\nfor-each-except\nexception\nprocedure\nlist\n)\n(\ndefine\n(\nloop\nitems\n)\n(\ncond\n((\nnull?\nitems\n)\n'done\n)\n((\neq?\n(\ncar\nitems\n)\nexception\n) (\nloop\n(\ncdr\nitems\n)))\n(\nelse\n(\nprocedure\n(\ncar\nitems\n))\n(\nloop\n(\ncdr\nitems\n)))))\n(\nloop\nlist\n))\nもしコネクタがその値を忘れるりょう指示されたなら、局所手続\nforget-my-\nvalue\nを実行し、最初に要求が元々値を設定した同じオブジェクトからである\nかを確認します。もしそうならばコネクタは関連する制約に値の喪失について\n伝えます。\n32\nsetter\nは制約ではないかもしれません。気温の例では\nuser\nを\nsetter\nとして使用し\nました。\n313","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":339},{"id":"./test/fixtures/pdf/sicp.pdf:340","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"局所手続\nconnect\nは指定された新しい制約を制約リストに、既に存在しな\nい場合には追加します。次にもしコネクタが値を以ているのならば、新しい制\n約にその事実を伝えます。\nコネクタの手続\nme\nは他の内部手続を実行する役割を果たし、またコネクタ\nをオブジェクトとして表現します。以下の手続は起動のための文法上のインタ\nーフェイスを提供します。\n(\ndefine\n(\nhas-value?\nconnector\n) (\nconnector\n'has-value?\n))\n(\ndefine\n(\nget-value\nconnector\n) (\nconnector\n'value\n))\n(\ndefine\n(\nset-value!\nconnector\nnew-value\ninformant\n)\n((\nconnector\n'set-value!\n)\nnew-value\ninformant\n))\n(\ndefine\n(\nforget-value!\nconnector\nretractor\n)\n((\nconnector\n'forget\n)\nretractor\n))\n(\ndefine\n(\nconnect\nconnector\nnew-constraint\n)\n((\nconnector\n'connect\n)\nnew-constraint\n))\nExercise 3.33:\nプリミティブな乗算器、加算器、定数の制約を用い\nて、\n3\nつのコネクタ\na\n,\nb\n,\nc\nを入力として取り、\nc\nの値が\na\nと\nb\nの値\nの平均を見出す手続\naverager\nを定義せよ。\nExercise 3.34:\nLouis Reasoner\nは\n2\nつの端子を持ち、\n2\nつ目の端子\n上のコネクタ\nb\nが常に\n1\nつ目の端子上の値\na\nの二乗である制約端\n末\nsquarer\nを構築したいと考えた。彼は以下の簡単な乗算から作ら\nれた端末を提案した。\n(\ndefine\n(\nsquarer\na\nb\n) (\nmultiplier\na\na\nb\n))\nこのアイデアには致命的な問題がある。説明せよ。\nExercise 3.35:\nBen Bitdiddle\nは\nLouis\nに\nExercise 3.34\nの問題を避\nける\n1\nつの方法として\nsquarer\nを新しいプリミティブな制約とし\nて定義することを伝えた。\nBen\nの新しい制約の輪郭の欠けている\n部分を埋めそのような文脈での実装を行え。\n(\ndefine\n(\nsquarer\na\nb\n)\n(\ndefine\n(\nprocess-new-value\n)\n(\nif\n(\nhas-value?\nb\n)\n(\nif\n(< (\nget-value\nb\n) 0)\n(\nerror\n\"\nsquare\nless\nthan\n0:\nSQUARER\n\"\n314","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":340},{"id":"./test/fixtures/pdf/sicp.pdf:341","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nget-value\nb\n))\n⟨\nalternative1\n⟩\n)\n⟨\nalternative2\n⟩\n))\n(\ndefine\n(\nprocess-forget-value\n)\n⟨\nbody1\n⟩\n)\n(\ndefine\n(\nme\nrequest\n)\n⟨\nbody2\n⟩\n)\n⟨\nrest of definition\n⟩\nme\n)\nExercise 3.36:\n以下のグローバル環境内の式の列を評価したと\nする。\n(\ndefine\na\n(\nmake-connector\n))\n(\ndefine\nb\n(\nmake-connector\n))\n(\nset-value!\na\n10\n'user\n)\nset-value!\nの評価の間のある時点で、コネクタのローカル手続か\nら以下の式が評価される。\n(\nfor-each-except\nsetter\ninform-about-value\nconstraints\n)\n上の式が評価される環境を示す環境の図を描け。\nExercise 3.37:\ncelsius-fahrenheit-converter\n(\n摂氏華氏変換器\n)\n手続は以下のような式指向なスタイルと比べた時に煩わしい。\n(\ndefine\n(\ncelsius-fahrenheit-converter\nx\n)\n(\nc\n+ (\nc*\n(\nc/\n(\ncv\n9) (\ncv\n5))\nx\n)\n(\ncv\n32)))\n(\ndefine\nC\n(\nmake-connector\n))\n(\ndefine\nF\n(\ncelsius-fahrenheit-converter\nC\n))\nここで\nc+\n,\nc*\n等は数値演算命令の\n“\n制約\n”\n版である。例えば\nc+\nは\n2\nつのコネクタを引数として取り、これらに関係するコネクタを加\n算器制約にて返す。\n(\ndefine\n(\nc\n+\nx\ny\n)\n(\nlet\n((\nz\n(\nmake-connector\n)))\n(\nadder\nx\ny\nz\n)\nz\n))\n315","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":341},{"id":"./test/fixtures/pdf/sicp.pdf:342","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"同様の手続\nc-\n,\nc*\n,\nc/\n,\ncv\n(\n定数\n)\nを定義し、複合制約を上記の変換\n器の例の様に定義できるようにせよ。\n33\n3.4\n並行性\n:\n時間が本質\n私達はここまで局所状態をモデリングのためのツールとして持つ計算オブ\nジェクトの力を学びました。それにもかかわらず、\nSection 3.1.3\nで警告したよ\nうに、この力にはコストが伴います。参照等価性を失なうことは等価性と変更\nに関する問題のチケットを増加し、評価の置換モデルを断念し、より何回な環\n境モデルの支持を必要とします。\n状態、等価性、変更の複雑さの下に潜んでいる中心的課題は、代入を導入す\nることにより私達は計算モデルの中に\ntime\n(\n時間\n)\nの存在を認めることを強制さ\nれることです。代入の導入前は私達のプログラム全ては値を持つ任意の式が常\n33\n式指向形式は便利です。それは演算の中間式に名前を付ける必要性を回避できるた\nめです。私達の元々の制約言語の形式は多くの言語が複合データを取り扱う場合と同様\nに面倒でした。例として、変数がベクトルを表現する場合に積\n(푎 + 푏) ⋅ (푐 + 푑)\nを求めた\nい時、\n“\n命令型スタイル\n”\nで指定されたベクトルの値を設定するけれどもそれ自身はベク\nトルを値として返さない手続を用いて行うことは可能です。\n(\nv-sum\na\nb\ntemp1\n)\n(\nv-sum\nc\nd\ntemp2\n)\n(\nv-prod\ntemp1\ntemp2\nanswer\n)\n代替法として、ベクトルを値として返す手続を用いて式を用いて行うことも可能です。\nその場合、明示的に\ntemp1\nと\ntemp2\nを記述する必要を避けることができます。\n(\ndefine\nanswer\n(\nv-prod\n(\nv-sum\na\nb\n) (\nv-sum\nc\nd\n)))\nLisp\nは手続の値として複合オブジェクトを返すことができるため、命令型スタイル制\n約言語を式指向スタイルに課題で示されたように変形することができます。複合データ\nの扱いが乏しい言語、例えば\nAlgol\n、\nBasic\n、\nPascal(\n明示的に\nPascal\nのポインタ変数を用\nいる場合は除く\n)\nでは通常複合オブジェクトを操作する場合に命令型スタイルに行き詰\nまります。式指向形式の利点を与えられるとある人はシステムを私達がこの節で行った\nように命令型スタイルで実装することに何らかの意味があるのかと尋ねるかもしれませ\nん。\n1\nつの理由は非式指向の制約言語は制約オブジェクト上に、コネクタオブジェクト上\nと同様にハンドルを提供します\n(\n例えば\nadder\n手続の値\n)\n。これはもし我々がシステムを\nコネクタ上の命令を通して間接的に通信するだけでなく、制約と直接通信する新しい命\n令を用いてシステムを拡張したい場合にはとても便利です。式指向スタイルを命令型の\n実装を用いて実装するのは簡単ですが、逆はとても難しいのです。\n316","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":342},{"id":"./test/fixtures/pdf/sicp.pdf:343","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"に同じ値を持つという意味において恒久的でした。対照的に、\nSection 3.1.1\nで\n紹介した銀行口座からの引き出しと差引残高の返却のモデル化の例を思い出し\nて下さい。\n(\nwithdraw\n25)\n75\n(\nwithdraw\n25)\n50\nここでは同じ式の一連の評価が異なる値を生じています。この振舞は代入\n文の実行\n(\nこの場合では変数\nbalance\nへの代入\n)\nが値が変化した\nmoments in\ntime\n(\n時間の瞬間\n)\nを描いています。式の評価の結果は式自身だけではなく、こ\nれらの瞬間の前か後に評価が行われたかにも依存します。局所状態を持つ計算\nモデルを用いたモデルの構築は私達にプログラミングにおける本質的な概念と\nしての時間に直面することを強います。\n計算モデルの構造化において物理世界の私達の認知を一致させることをよ\nり進めることは可能です。世界の中のオブジェクトは一時に\n1\nつが順に変わる\nことはありません。そうではなく、私達はそれらが\nconcurrently\n(\n並行\n)\nに\n—\n同\n時に\n—\n行動することを知覚します。そのためシステムを並行に実行する計算処\n理の集合であるとモデル化することは多くにおいて自然です。分離された局所\n状態を持つオブジェクトを用いてモデルを体系化することにより私達のプログ\nラムをモジュラー化するのと同様に、計算モデルを別々に、並行に発展する部\n分に分割することは多くの場合に適切です。例えプログラムが逐次的な計算機\nにより実行されるとしてもプログラムを並行に実行される前提で書くことを練\n習することはプログラマに不必要な制約を防ぐことを強いるため、プログラム\nをよりモジュール式にします。\nプログラムをよりモジュール式にするのに加えて、並行演算は逐次的演算\nに対し速度上の利点を与えることが可能です。逐次的演算は一時に\n1\nつの命令\nのみを実行するためタスクの実行にかかる時間量は実行される命令の総量に比\n例します。\n34\nしかしもし問題を相対的に独立した部分に分割することが可能\nで、稀にしか通信を行う必要が無ければ、それらの部分を異なる計算機に配置\nし、存在する計算機の数に比例した速さの利点を生じることが可能となるでし\nょう。\n34\n本物の\nCPU\nの多くは実際にはいくつかの命令を同時に、\npipelining\n(\nパイプライン\n)\nと呼ばれる戦略に従い実行します。このテクニックは大きくハードウェアの実行効率を\n改善しますが、これは一連の命令ストリームの実行を、逐次的プログラムの振舞を保ち\nながら高速化するためのみに利用されます。\n317","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":343},{"id":"./test/fixtures/pdf/sicp.pdf:344","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"残念なことに、代入により持ち込まれた複雑性は並行性の出現により、よ\nり一層難しくなります。並行実行の結果は世界が並列に作動するためか計算機\nがそれを行うためかによらず、私達の時間の理解にさらなる複雑性をもたらし\nます。\n3.4.1\n並行システム内の時間の性質\n表面上は時間は簡単に見えます。時間はイベントに課される順序付けで\nす。\n35\n任意のイベント\n퐴\nと\n퐵\nに対し、\n퐴\nが\n퐵\nの前に起こるか、\n퐴\nと\n퐵\nが同\n時か、\n퐴\nが\n퐵\nの後に起こるかです。例えば、銀行口座の例に戻れば、最初に\n$100\nを持つ連結口座から\nPeter\nが\n$10\nを引き出し、\nPaul\nが\n$25\nを引き出した\n場合、口座には\n$65\nが残ります。二人の引き出し順により、口座の残高の列は\n$100 → $90 → $65\nか\n$100 → $75 → $65\nです。銀行システムの計算機実装\nにおいてこの口座の列の変化は連続した変数\nbalance\nへの代入としてモデル化\nできます。\n複雑な状況ではしかし、そのような見方は問題となりえます。\nPeter\nと\nPaul\nに加えて他の人々が同じ銀行口座に世界中に分散された現金自動預け払い機の\nネットワークを通してアクセスするとします。実際の口座の残高の列は大きく、\nアクセスタイミングの詳細と機械の間の通信の詳細に依存します。\nこのイベント順の非決定性は並行システムの設計において深刻な問題を提\n起します。例えば\nPeter\nと\nPaul\nの引き出しが共通の変数\nbalance\nを共有する\n2\nつの分離した処理だとします。各処理は\nSection 3.1.1\nにて与えられた手続によ\nり指定されます。\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\nもし\n2\nつの処理が独立に動作するなら、\nPeter\nは残高を確認し、正当な額面を\n引き出そうとします。しかし\nPaul\nが\nPeter\nが残高を確認した時点と\nPeter\nが引\nき出しを完了する時点の間にいくらかの資金を引き出すかもしれません。従っ\nて\nPeter\nの確認を無効にするかもしれません。\nさらに悪くなりえます。以下の式について考えてみましょう。\n35\nケンブリッジのビルの壁上のある落書きを引用すれば\n“\n時間とは全てが同時に起こる\nことを防ぐために発明された仕掛けだ\n”\n318","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":344},{"id":"./test/fixtures/pdf/sicp.pdf:345","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nset!\nbalance\n(-\nbalance\namount\n))\nこの式は各引き出し処理の部分として実行されます。これは\n3\nつのステップか\nら成り立ちます。\n(1)\n変数\nbalance\nの値にアクセスする。\n(2)\n新しい残高を計算\nする。\n(3)\nbalance\nに新しい値を設定する。もし\nPeter\nと\nPaul\nの引き出しがこ\nの命令を並行に実行した場合、二人の引き出しは\nbalance\nにアクセスし、それ\nに新しい値を設定する順を交互に配置するかもしれません。\nFigure 3.29\nのタイミング図は\nbalance\nが\n100\nで開始し、\nPeter\nが\n10\nを引き\n出し、\nPaul\nが\n25\nを引き出し、それでも\nbalance\nの最終の値が\n75\nである場合の\nイベントの順を描写しています。図に示されるとおり、この異例の理由は\nPaul\nの\nbalance\nへの\n75\nの代入が減算されるべき\nbalance\nの値が\n100\nであるという\n前提の下で行われているためです。しかしこの前提は\nPeter\nが\nbalance\nを\n90\nに変更した時に無効になります。これは銀行システムにとって最悪な失敗です。\nなぜならシステム中のお金の総量が保存されていません。取引前にお金の総額\nは\n100\nでした。その後、\nPeter\nは\n$10\nを持ち、\nPaul\nは\n$25\nを持ち、銀行は\n$75\nを持っています。\n36\nここに描かれた一般的な現象は、いくつかのプロセスが共通な状態変数を共有\nしていることです。このことを複雑にしているのは複数のプロセスが共有され\nた状態を同時に操作しようと試みていることです。銀行口座の例では、各取引\nの間に、各顧客は他の顧客が存在しないかのように行動できなければなりませ\nん。顧客が口座を残高に依存した形で更新する時、その顧客は、変更の瞬間の\n前に、残高が依然として彼が考えた状態であることを前提とできなければなり\nません。\n並行プログラムの正しい振舞\n先の例は並行プログラムに潜みがちな微妙なバグの類型です。この複雑性\nの根本は異なるプロセスの間で共有される変数への代入に横たわっています。\n36\nこのシステムでより悪い失敗が\n2\nつの\nset!\n命令が残高を同時に変更しようとした場\n合に起こり得ます。このような場合にはメモリ中に現れる実際のデータは\n2\nつの処理に\nより書かれる情報の不作為な組み合わせに最後にはなるかもしれません。多くのコンピ\nュータはプリミティブなメモリライト命令上に内部ロックを持つため、そのような同時\nアクセスを防ぎます。しかし、この見たところ簡単な種類のプロテクトでさえマルチプ\nロセスのコンピュータの設計においては実装上の課題を提起します。多様なプロセッサ\nが、データが異なるプロセッサの間でメモリアクセスのスピードを向上するためにレプ\nリケート\n(“\nキャッシュとして保存\n”)\nが行われるかもしれないという事実に係らず、静的\nなメモリ内容の見かけを得ることを保証するには、複雑な\ncache-coherence\n(\nキャッシュ\n一貫性\n)\nプロトコルが必要となります。\n319","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":345},{"id":"./test/fixtures/pdf/sicp.pdf:346","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Peter\nAccess balance: $100\nnew value: 100-10=90\nset!\n balance to $90\ntime\nBank\nPaul\n$100\n$90\n$75\nAccess balance: $100\nnew value: 100-25=75\nset!\n balance to $75\nFigure 3.29:\n2\n回の引き出しのイベント順の相互配置が不正\n確な最終残高へどのように導くかを示したタイミング図\n320","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":346},{"id":"./test/fixtures/pdf/sicp.pdf:347","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"私達は既に\nset!\nを用いるプログラムを書く場合には気をつけねばならないこ\nとを知っています。計算の結果が代入の起こる順に依存するためです。\n37\n並行\nプロセスでは特に代入に気をつけねばなりません。異なるプロセスにより作ら\nれる代入の順をコントロールできないかもしれないためです。もしいくつかの\nそのような変更が\n(\n二人の預金者が連結口座にアクセスするように\n)\n並行に行\nわれるのであれば私達のシステムの振舞が正しいことを確認するための何らか\nの方法を必要とします。例えば、連結口座からの引き出しの場合、お金が保管\nされていることを確認しなければなりません。並行プログラムの振舞を正しく\nするために、並行実行に何らかの制限を置かねばなりません。\n並行性への可能な\n1\nつの制限は、任意の共有状態変数を変更するどの\n2\nつ\nの命令もどうじには起こり得ないことです。これはとても厳しい制限です。分\n散銀行システムではシステム設計に対しただ\n1\nつの取引だけが一時に手続でき\nることを保証することを要求します。これは非効率であり、かつ過度に保守的\nです。\nFigure 3.30\nは\nPeter\nと\nPaul\nが銀行口座を共有し、\nPaul\nはまたプライベ\nートな口座を持っていることを示しています。共有口座からの\n2\nつの引き出し\n(1\nつは\nPeter\nによる、もう\n1\nつは\nPaul\nによるもの\n)\nと\nPaul\nのプライベート口\n座への預金を図示しています。\n38\n共有口座からの\n2\nつの引き出しは並行であっ\nてはなりません\n(\n両方が同じ口座にアクセスと更新を行うため\n)\n。また\nPaul\nの\n預金と引き出しは並行であってはなりません\n(\n両方が\nPaul\nの財布にアクセスと\n更新を行うため\n)\n。しかし\nPaul\nによる彼のプライベート口座への預金を\nPeter\nの共有アカウントからの引き出しと並行に進行することを許すことは何の問題\nも起こさないはずです。\n並行性上の比較的厳しくない制限は並行システムがまるでプロセスが同じ順に\n逐次的に実行されたかのように同じ結果を生成することを保証します。\n2\nつの\n重要な側面がこの制限にはあります。第一にプロセスに対し実際に逐次的に実\n行することを要求はしませんが、あたかも逐次的に実行された場合と同じ結果\nを生成することを要求します。\nFigure 3.30\nの例に対して銀行口座システムの設\n計者は安全に\nPaul\nの預金と\nPeter\nの引き出しを並行に起こすことを許可でき\nます。なぜなら\n2\nつの命令が逐次的に起こったのと最終結果が同じになるため\nです。第二に、複数の可能な\n“\n正しい\n”\n結果が並行プログラムにより生成され\n37\nSection 3.1.3\nにおける指数プログラムはこのことを単一の逐次処理にて説明しまし\nた。\n38\n列は\nPeter\nの財布、\n(Bank1\n内の\n)\n共有口座、\nPaul\nの財布、\n(Bank2\n内の\n)Paul\nのプ\nライベート口座の中身を各引き出し\n(W)\nと預金\n(D)\nの前後にて示しています。\nPeter\nは\n$10\nを\nBank1\nから引き出し、\nPaul\nは\n$5\nを\nBank2\nに預金し、次に\nBank1\nから\n$25\nを引\nき出しています。\n321","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":347},{"id":"./test/fixtures/pdf/sicp.pdf:348","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"$100$7\n$5\n$300\n$0\n$305\n$305$25\n$65$17\n$17\n$90\nW\nW\nD\ntime\nPeter\nBank1\nPaul\nBank2\nFigure 3.30:\n銀行\n1\nの連結口座と銀行\n2\nの個人口座への並\n行な預け入れと引き出し\nるでしょう。なぜなら結果がある逐次的順序と同じ結果であることのみを要求\nしているためです。例えば\nPeter\nと\nPaul\nの連結口座に\n$100\nが初めにあるとし、\nPeter\nが\n$40\nを預金し、\nPaul\nが並行に口座の半分のお金を引き出したとしま\nす。すると逐次的実行の口座残高は\n$70\nか\n$90\nのどちらかになります\n(\nExercise\n3.38\n参照\n)\n。\n39\n並行プログラムの正しい実行のためのより弱い要件はまだ有ります。拡散\nのシミュレーションのプログラム\n(\n例えば物質内の熱の流れ\n)\nは巨大な数のプ\nロセスから成り、各プロセスは小容量の空間を表し、その値を並行に更新しま\n39\nこの考えをより形式的に表す方法は、並行プログラムは本質的に\nnondeterministic\n(\n非\n決定的\n)\nであると述べることです。つまり、それらは単一の値を持つ関数ではなく、結果\nが起こり得る値の集合となる関数により説明されます。\nSection 4.3\nでは非決定的演算に\nついて学びます。\n322","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":348},{"id":"./test/fixtures/pdf/sicp.pdf:349","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"す。各プロセスはその値を、その値と近傍の値の平均へと繰り返し変更します。\nこのアルゴリズムは命令が行われる順から独立して正しい答に収束します。共\n有値の並行な使用上にどんな制限も必要としません。\nExercise 3.38:\nPeter, Paul, Mary\nが初めに\n$100\nを持つ連結銀行口\n座を共有すると仮定する。。並行に、\nPeter\nが\n$10\nの預金、\nPaul\nが\n$20\nの引き出し、\nMary\nは口座の半分のお金の引き出しを以下のコ\nマンドにより実行した。\nPeter: (set! balance (+ balance 10))\nPaul:  (set! balance (- balance 20))\nMary:  (set! balance (- balance (/ balance 2)))\na\nこれらの\n3\nつの取引が完了した後に、全ての異なる\nbalance\nの起こり得る値を並べよ。ただし銀行システムはこの\n3\nつの\nプロセスが何らかの順にて逐次的に実行する前提とする。\nb\nもしシステムがプロセスにインターリーブ\n(\n相互配置\n)\nを認\nめた場合に生成される他の値は何か\n?\nFigure 3.29\nの様なタイ\nミング図を描きこれらの値がどのように起こり得るのか説明\nせよ。\n3.4.2\n並行性制御のための仕組み\n並行プロセスの取扱における困難は異なるプロセスのイベント順の交互配\n置について考える必要性に原因があることを学びました。例えば\n2\nつのプロセ\nスがあり\n1\nつは\n3\nつの順序付けられたイベント\n(푎, 푏, 푐)\nで、もう\n1\nつは\n3\nつの\n順序付けられたイベント\n(푥, 푦, 푧)\nであるとします。もし\n2\nつのプロセスが、そ\nれらの実行がどのように相互配置されるのかについて制約無しで並行に実行さ\nれた時、\n2\nつのプロセスの個々の順は変わらないとしても、\n20\nの異なる起こり\n得るイベントの順が存在します。\n(a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)  (x,a,y,z,b,c)\n(a,b,x,c,y,z)  (a,x,b,y,z,c)  (x,a,b,y,c,z)  (x,y,a,b,c,z)\n(a,b,x,y,c,z)  (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)\n(a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)  (x,y,a,z,b,c)\n(a,x,b,c,y,z)  (a,x,y,z,b,c)  (x,a,y,b,z,c)  (x,y,z,a,b,c)\n323","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":349},{"id":"./test/fixtures/pdf/sicp.pdf:350","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"プログラマがこのシステムを設計するにつれ、これらの\n20\n種の順序のそれぞ\nれの結果について考慮して、各振舞が受け入れられるか確認する必要があるで\nしょう。そのような取り組み方はプロセスとイベントの数が増加するにつれ、\n急速に手に負えない物となるでしょう。\n並行システムの設計に対するより現実的なアプローチはプログラムの振舞\nが正しいことを確認できるよう並行プロセスのインターリーブを制約できる一\n般的な仕組みを工夫することです。多くの仕組みがこの目的のため開発されて\nきました。この節ではそれらの\n1\nつ、\nserializer\n(\nシリアライザ\n、並列直列変換\n器\n)\nについて学びます。\n共有状態へのアクセスの直列化\n直列化\n(serialization)\nは次の考えを実装します。プロセスは並行に実行し\nます。しかし幾つかの手続の集合が存在し、それらは並行には実行できません。\nもっと正確に言えば直列化は各直列化された集合内のただ\n1\nつの手続の実行が\n一時に許されるような複数の区別された手続の集合を作成します。もし\n1\nつの\n集合内のいくつかの手続が実行されるなら、集合内の任意の手続を実行しよう\nとするプロセスは最初の実行が完了するまで待つことを強制されます。\n直列化を用いて共有変数へのアクセスをコントロールできます。例えばも\nし共有変数をその変数の前の値に応じて変更したい時、同じ手続内でその変数\nの以前の値にアクセスし、その変数に新しい値を代入します。それからその変\n数に代入するどの他の手続もこの手続とは並行には実行でなきないことを、同\nじシリアライザを持つこれらの手続の全てを直列化することにより確実にしま\nす。これはその変数の値がアクセスとそれに対応する代入の間に変更されるこ\nとができないことを保証します。\nScheme\nのシリアライザ\n上記の仕組みをより確実に行うために、\nparallel-execute\n(\n並列実行\n)\nと呼\nばれる手続を含む拡張\nScheme\nを持っていると仮定しましょう。\n(\nparallel-execute\n⟨\n푝\n1\n⟩\n⟨\n푝\n2\n⟩\n...\n⟨\n푝\n푘\n⟩\n)\n各\n⟨푝⟩\nは引数無しの手続でなければなりません。\nparallel-execute\nは分離さ\nれたプロセスを各\n⟨푝⟩\nに対し作り、それらのプロセスは\n⟨푝⟩\nを\n(\n引数無しで\n)\n適\n用します。これらのプロセスは全て並行に実行されます。\n40\n40\nparallel-execute\nは標準\nScheme\nの一部ではありません。しかし\nmit\nScheme\nで実\n装することが可能です。私達の実装においては新しい並行プロセスはまたオリジナルの\n324","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":350},{"id":"./test/fixtures/pdf/sicp.pdf:351","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これがどのように利用されるかの例として、以下について考えてみて下\nさい。\n(\ndefine\nx\n10)\n(\nparallel-execute\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\n)))\n(\nlambda\n() (\nset!\nx\n(+\nx\n1))))\nこれ\n2\nつの並行プロセス\n—\nx\nに\nx\nかける\nx\nを設定する\n푃\n1\nと、\nx\nに\n1\nを足す\n푃\n2\nを作成します。実行完了後に、\n푃\n1\nと\n푃\n2\nのイベントのインターリーブに依存す\nるため、\nx\nは\n5\nつの起こり得る値の内\n1\nつに成ります。\n101:\n푃\n1\nが\nx\nに\n100\nを設定し、次に\n푃\n2\nが\nx\nを\n101\nに増やす\n121:\n푃\n2\nが\nx\nを\n11\nに増やし、次に\n푃\n1\nが\nx\nを\nx * x\nに設定\n110:\n푃\n2\nが\nx\nを\n10\nから\n11\nに以下の\n2\n度のアクセスの間に変化させる\n푃\n1\nが\nx\nの値に\n(* x x)\nの評価の間にアクセスする\n11:\n푃\n2\nが\nx\nにアクセスし\n,\n次に\n푃\n1\nが\nx\nに\n100\nを設定し、\n푃\n2\nが\nx\nを設定\n100:\n푃\n1\nが\nx\nに\n(\n二度\n)\nアクセスし、次に\n푃\n2\nが\nx\nを\n11\nに設定、次に\n푃\n1\nが\nx\nを設定\n並行性を\nserializers\n(\nシリアライザ\n)\nにより作成された直列化された手続を用い\nることで抑制することができます。シリアライザは\nmake-serializer\nにより構\n築され、この実装は後程与えられます。シリアライザは手続を引数として取り、\n元の手続の様に振る舞う\nserialized(\n被直列化\n)\n手続を返します。与えられたシ\nリアライザへの全ての呼出は同じ集合に属する被直列化手続を返します。\n従って上の例とは異なり、以下の実行は\n(\ndefine\nx\n10)\n(\ndefine\ns\n(\nmake-serializer\n))\n(\nparallel-execute\n(\ns\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\n))))\n(\ns\n(\nlambda\n() (\nset!\nx\n(+\nx\n1)))))\nx\nに対しただ\n2\nつの起こり得る値、\n101\nと\n121\nを返します。他の可能性は\n푃\n1\nと\n푃\n2\nの実行がインターリーブ\n(\n相互配置\n)\nされないため排除されました。\n以下に\nSection 3.1.1\nの\nmake-account\n手続を預け入れと引き出しが直列化さ\nれた版を示します。\nScheme\nプロセスと共に並行に実行できます。また私達の実装では\nparallel-execute\nに\nより返される値は特別なコントロールオブジェクトであり新しく作成されたプロセスを\n停止させるために使用できます。\n325","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":351},{"id":"./test/fixtures/pdf/sicp.pdf:352","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nmake-account\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\nlet\n((\nprotected\n(\nmake-serializer\n)))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n) (\nprotected\nwithdraw\n))\n((\neq?\nm\n'deposit\n) (\nprotected\ndeposit\n))\n((\neq?\nm\n'balance\n)\nbalance\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n))\nこの実装により、\n2\nつのプロセスは単一の口座に並行に預け入れと引き出しを\n行うことはできなくなりました。これにより\nFigure 3.29\nで図示されたエラーの\n原因、\nPaul\nの新しい値を求めるための残高へのアクセスと、\nPaul\nが実際に代\n入を行う時の間に、\nPeter\nが口座残高を変更する場合は排除されます。一方で、\n各口座はそれ自身のシリアライザを持つので、異なる口座への預金と引き出し\nは並行に行うことができます。\nExercise 3.39:\n上で示された並行実行における\n5\nつの可能性の内、\nもし変わりに以下のような実行を起こなった場合にどれが残るか\n?\n(\ndefine\nx\n10)\n(\ndefine\ns\n(\nmake-serializer\n))\n(\nparallel-execute\n(\nlambda\n() (\nset!\nx\n((\ns\n(\nlambda\n() (*\nx\nx\n))))))\n(\ns\n(\nlambda\n() (\nset!\nx\n(+\nx\n1)))))\nExercise 3.40:\n以下を実行した場合に\nx\nの起こり得る値の全てを上\nげよ。\n(\ndefine\nx\n10)\n326","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":352},{"id":"./test/fixtures/pdf/sicp.pdf:353","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nparallel-execute\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\n)))\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\nx\n))))\nこれらの内もし代わりに以下の直列化手続を用いた場合どれが残\nるか\n?\n(\ndefine\nx\n10)\n(\ndefine\ns\n(\nmake-serializer\n))\n(\nparallel-execute\n(\ns\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\n))))\n(\ns\n(\nlambda\n() (\nset!\nx\n(*\nx\nx\nx\n)))))\nExercise 3.41:\nBen Bitdiddle\nは以下のように銀行口座を実行すれ\nばより良くなるのではないかと心配している。\n(\nコメントの有る行\nが変更されている\n)\n。\n(\ndefine\n(\nmake-account\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\nlet\n((\nprotected\n(\nmake-serializer\n)))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n) (\nprotected\nwithdraw\n))\n((\neq?\nm\n'deposit\n) (\nprotected\ndeposit\n))\n((\neq?\nm\n'balance\n)\n((\nprotected\n(\nlambda\n()\nbalance\n))))\n; serialized\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n))\n327","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":353},{"id":"./test/fixtures/pdf/sicp.pdf:354","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"心配の理由は非直列化アクセスを銀行口座に許すと得意な振舞が\n起こり得るためだ。同意するか\n? Ben\nの懸念を実演するシナリオは\n存在するか\n?\nExercise 3.42:\nBen Bitdiddle\nは全ての\nwithdraw\nと\ndeposit\nメッ\nセージに対して新しい被直列化手続を作成することは時間の無駄\nであると提案した。彼は\nprotected\nへの呼出が\ndispatch\n手続の\n外で行われるよう\nmake-account\nを変更することができると述べ\nた。つまり\nwithdrawal\n手続が呼ばれる度に、口座が\n(\n口座が作成\nされたと同時に作成された\n)\n同じ被直列化手続を返すことになる\nだろう。\n(\ndefine\n(\nmake-account\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\nlet\n((\nprotected\n(\nmake-serializer\n)))\n(\nlet\n((\nprotected-withdraw\n(\nprotected\nwithdraw\n))\n(\nprotected-deposit\n(\nprotected\ndeposit\n)))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n)\nprotected-withdraw\n)\n((\neq?\nm\n'deposit\n)\nprotected-deposit\n)\n((\neq?\nm\n'balance\n)\nbalance\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n)))\nこれは行うことが安全な変更だろうか\n?\n具体的には、これらの\n2\nつ\nの版の\nmake-account\nにより許される並行性に違いは存在するだ\nろうか\n?\n328","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":354},{"id":"./test/fixtures/pdf/sicp.pdf:355","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"複数共有リソース使用の複雑さ\nシリアライザは並行プログラムの複雑性の分離を手助けすることで、注意\n深く\n(\n願わくは\n)\n正しく取り扱えるようにする強力な抽象化を与えます。しかし\nシリアライザの使用は\n(\n単一の銀行口座のような\n)\nただ単一の共有リソースが\n存在する場合には相対的に簡単ですが、並行プログラミングは複数の共有リソ\nースがある場合に、裏切るかのように難しくなります。\n提起できる困難さの内\n1\nつを説明するために、\n2\nつの銀行口座の残高を交\n換したいと考えます。各口座にアクセスし残高を見つけ、残高間の差を計算し、\n一方の口座からこの差を引き出し、もう一方の口座へ預け入れます。これを以\n下のように実装することができます。\n41\n(\ndefine\n(\nexchange\naccount1\naccount2\n)\n(\nlet\n((\ndifference\n(- (\naccount1\n'balance\n)\n(\naccount2\n'balance\n))))\n((\naccount1\n'withdraw\n)\ndifference\n)\n((\naccount2\n'deposit\n)\ndifference\n)))\nこの手続は単一のプロセスのみが交換を試みる場合にはうまく働きます。しか\nし\nPeter\nと\nPaul\nが二人共口座\n푎\n1,\n푎\n2,\n푎\n3\nにアクセスし、そして\nPeter\nが\n푎\n1\nと\n푎\n2\nを交換している間に\nPaul\nが並行に\n푎\n1\nと\n푎\n3\nを交換している場合を考えてみ\nて下さい。例え口座の預け入れと引き出しが個別の口座に対して\n(\nこの節の上\nで示された\nmake-account\n手続のように\n)\n直列化されたとしても、\nexchange\nは\n依然として不正確な結果を生じることができます。例えば\nPeter\nが\n푎\n1\nと\n푎\n2\nの\n残高の差を求める時、\nPaul\nが\nPeter\nが交換を完了する前に\n푎\n1\nの残高を変更す\nるかもしれません。\n42\n正しい振舞のためには、\nexchange\n手続を、交換の全体の\n時間の間、口座へのどの他の並行アクセスもロックアウト\n(\n締め出し\n)\nするよう\nに準備をしなければなりません。\nこれを達成する\n1\nつの方法は両方の口座のシリアライザを用いて\nexchange\n手続全体を直列化します。これを行うためには、口座のシリアライザへのアク\nセスに準備を行います。シリアライザを露出することで、銀行口座オブジェク\nトのモジュール化を意図的に破っていることに注意して下さい。\nmake-account\nの以下の版は\nSection 3.1.1\nで与えられた元の版とシリアライザが\nbalance\n変数\n41\ndeposit\nメッセージが負の額面を受け入れるという事実を利用することで\nexchange\nを簡略化しました。\n(\nこれは私達の銀行システムの深刻なバグです！\n)\n42\nもし口座残高が\n$10, $20, $30\nで始めた場合、任意の回数の交換の後に、残高は何ら\nかの順にて依然として\n$10, $20, $30\nにならねばなりません。個別の口座への預け入れの\n直列化はこれを保証するのに十分ではありません。\nExercise 3.43\nを参照して下さい。\n329","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":355},{"id":"./test/fixtures/pdf/sicp.pdf:356","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を守るため提供されていることを除けば同じです。そしてシリアライザはメッ\nセージパッシングを通して転送されます。\n(\ndefine\n(\nmake-account-and-serializer\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\nlet\n((\nbalance-serializer\n(\nmake-serializer\n)))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n)\nwithdraw\n)\n((\neq?\nm\n'deposit\n)\ndeposit\n)\n((\neq?\nm\n'balance\n)\nbalance\n)\n((\neq?\nm\n'serializer\n)\nbalance-serializer\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n))\nこれを用いて直列化された預け入れと引き出しを行うことができます。しかし\n最初の直列化された口座とは異なり、直列化を明示的に管理することは銀行口\n座オブジェクトの各ユーザの責任です。例えば以下の様にです。\n43\n(\ndefine\n(\ndeposit\naccount\namount\n)\n(\nlet\n((\ns\n(\naccount\n'serializer\n))\n(\nd\n(\naccount\n'deposit\n)))\n((\ns\nd\n)\namount\n)))\nシリアライザをこの方法で外出しすることは私達に直列化された交換プログラ\nムを実装するのに十分な柔軟性を与えます。単純に元の\nexchange\n手続を両方\nの口座のシリアライザにて直列化します。\n43\nExercise 3.45\nにてなぜ預け入れと引き出しがもはや自動的に口座により直列化され\nないのかについて調査します。\n330","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":356},{"id":"./test/fixtures/pdf/sicp.pdf:357","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nserialized-exchange\naccount1\naccount2\n)\n(\nlet\n((\nserializer1\n(\naccount1\n'serializer\n))\n(\nserializer2\n(\naccount2\n'serializer\n)))\n((\nserializer1\n(\nserializer2\nexchange\n))\naccount1\naccount2\n)))\nExercise 3.43:\n3\nつの口座の残高が\n$10, $20, $30\nで始まり、複数の\nプロセスが実行され口座の残高を交換すると考える。プロセスが逐\n次的に実行されるなら、任意の数の並行な交換の後に、口座残高が\nある順序において\n$10, $20, $30\nになると主張する。\nFigure 3.29\nの\nようなタイミング図を描き、交換がこの節の\naccount-exchange\nの\n最初の版を用いて実装された場合にこの前提がどのように破られ\nるかについて示せ。一方で、例えこの\nexchange\nプログラムを用い\nても口座の残高の合計は保存されると主張する。タイミング図を\n描き、個別の口座上の取引を直列化しない場合には例えこの前提\nでもどのように破られるかについて示せ。\nExercise 3.44:\nある口座から別の口座への振込の問題について考え\nる。\nBen Bitdiddle\nは例え複数の人々が並行にお金を複数の口座間\nにて転送をしても、以下の手続を用いることで、預金と引き出し\nの取引を直列化する任意の口座の仕組み、例えば上のテキストの\nmake-account\nの版を用いながら振込を達成できると主張する。\n(\ndefine\n(\ntransfer\nfrom-account\nto-account\namount\n)\n((\nfrom-account\n'withdraw\n)\namount\n)\n((\nto-account\n'deposit\n)\namount\n))\nLouis Reasoner\nはここにも問題があると主張した。交換問題を取\nり扱うのに必要とされた様なより洗練された手法が必要であると\nも述べた。\nLouis\nは正しいだろうか\n?\nもし正しくないのならば振込\n問題と交換問題の間の本質的な違いは何か\n? (\nfrom-account\nの残\n高は少くとも\namount\nであると考えること\n)\n。\nExercise 3.45:\nLouis Reasoner\nは私達の銀行口座システムは不必\n要に複雑、かつエラーを起こしやすく、預け入れと引き出しも自動\n的に直列化されないと考えた。彼は\nmake-account\nが行ったよう\nに口座と預け入れを直列化するためにそれを用いることに加えて\n331","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":357},{"id":"./test/fixtures/pdf/sicp.pdf:358","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nその代わりにではなく\n)\nmake-account-and-serializer\nはシリア\nライザを\n(\nserialized-exchange\nのような手続にて利用するため\nに\n)\n露出させるべきだったと主張した。彼は口座を以下のように再\n定義することを提案した。\n(\ndefine\n(\nmake-account-and-serializer\nbalance\n)\n(\ndefine\n(\nwithdraw\namount\n)\n(\nif\n(>=\nbalance\namount\n)\n(\nbegin\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n)\n\"\nInsufficient\nfunds\n\"\n))\n(\ndefine\n(\ndeposit\namount\n)\n(\nset!\nbalance\n(+\nbalance\namount\n))\nbalance\n)\n(\nlet\n((\nbalance-serializer\n(\nmake-serializer\n)))\n(\ndefine\n(\ndispatch\nm\n)\n(\ncond\n((\neq?\nm\n'withdraw\n) (\nbalance-serializer\nwithdraw\n))\n((\neq?\nm\n'deposit\n) (\nbalance-serializer\ndeposit\n))\n((\neq?\nm\n'balance\n)\nbalance\n)\n((\neq?\nm\n'serializer\n)\nbalance-serializer\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMAKE-ACCOUNT\n\"\nm\n))))\ndispatch\n))\nすると\ndeposit(\n預け入れ\n)\nは元々の\nmake-account\nで用いたように\n扱われる。\n(\ndefine\n(\ndeposit\naccount\namount\n)\n((\naccount\n'deposit\n)\namount\n))\nLouis\nの推論の何が間違っているか説明せよ。具体的には\nserialized-\nexchange\nが呼ばれた時に何が起こるかについて考えよ。\nシリアライザの実装\n私達はシリアライザを\nmutex\n(\nミューテックス\n、相互排除\n)\nと呼ばれるより\nプリミティブな同期の仕組みを用いて実装します。\nmutex\nは\n2\nつの命令をサ\nポートするオブジェクトです。\n1\nつは\nmutex\nが\nacquired\n(\n獲得\n)\nでき、もう\n1\nつ\nは\nmutex\nが\nreleased\n(\n解放\n)\nできます。一度\nmutex\nが獲得されれば、他のその\nmutex\nに対する獲得命令はその\nmutex\nが解放されるまで続行することができ\nません。\n44\n私たちの実装では、各シリアライザは関連付けられた\nmutex\nを持\n44\n“mutex”\nという用語は\nmutual exclusion\n(\n相互排除\n)\nの省略形です。並行処理が安全\nに資源を共有することを可能にする仕組みの準備における一般的な問題は相互排除問題\n332","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":358},{"id":"./test/fixtures/pdf/sicp.pdf:359","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ちます。手続\np\nを与えられた場合、シリアライザは\nmutex\nを獲得する手続を返\nし、\np\nを実行し、それから\nmutex\nを解放します。これがシリアライザにより生\n成された手続の\n1\nつのみが一度に実行できることを保証します。これがまさに\n私たちが保証する必要のある、直列化の特性です。\n(\ndefine\n(\nmake-serializer\n)\n(\nlet\n((\nmutex\n(\nmake-mutex\n)))\n(\nlambda\n(\np\n)\n(\ndefine\n(\nserialized-p\n.\nargs\n)\n(\nmutex\n'acquire\n)\n(\nlet\n((\nval\n(\napply\np\nargs\n)))\n(\nmutex\n'release\n)\nval\n))\nserialized-p\n)))\nmutex\nはミュータブルなオブジェクト\n(\nここで私達は\n1\n要素のリストを使用し、\ncell\n(\nセル\n)\nと参照します。\n)\nであり、\ntrue\nか\nfalse\nの値を保持します。値が\nfalse\nの時、\nmutex\nは獲得可能です。値が\ntrue\nの時、\nmutex\nは使用不可であり、この\nmutex\nを獲得しようと試みるプロセスは待たなければいけません。\n私達の\nmutex\nコンストラクタ\nmake-mutex\nはセルの中身を\nfalse\nに初期化\nすることから始めます。\nmutex\nを獲得するためにはセルを確認します。もし\nmutex\nが使用可能であれば、セルの中身を\ntrue\nにして続行します。そうでな\nければループの中で待ち、\nmutex\nが使用可能になるまで何度も獲得を試みます。\n45\nmutex\nを解放するためにはセルの中身に\nfalse\nを設定します。\n(\ndefine\n(\nmake-mutex\n)\nと呼ばれます。私達の\nmutex\nは\nsemaphore\n(\nセマフォ\n)\nという仕組みの簡単な改良型で\nす。\n(\nExercise 3.47\n参照\n)\n。これはアイントホーフェン技術大学にて開発された\n“THE”\nMultiprogramming system(\n訳注\n: THE\nは究極のとかこれぞとか唯一の等の意味になる\n)\nにて導入され、大学のオランダ語でのイニシャルから名付けられました\n(\nDijkstra 1968a\n)\n。\nacquire\nと\nrelease\nの命令は元々はオランダ語の単語\npasseren\n(\n渡す\n)\nと\nvrijgeven\n(\n解放す\nる\n)\nから\nP\nと\nV\nと呼ばれ、鉄道システムにて用いられた\nsemaphores(\n信号装置\n)\nを参照\nしています。\nDijkstra(\nダイクストラ\n)\nの古典的解説\n(\nDijkstra 1968b\n)\nは明確に並行コン\nトロールの問題を表した最も初期の\n1\nつであり、多様な並行問題をどのようにセマフォ\nを用いて扱うかについて示しました。\n45\n多くの時分割\nOS\nでは\nmutex\nでブロックされるプロセスは上記のように\n“busy-\nwaiting”(\n占有待ち\n)\nにて時間を無駄にはしません。その代わりにシステムは他のプロセ\nスを最初のプロセスが待っている間に実行するようにスケジュールし、ブロックされた\nプロセスは\nmutex\nが使用可能になると起こされます。\n333","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":359},{"id":"./test/fixtures/pdf/sicp.pdf:360","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\ncell\n(\nlist\nfalse\n)))\n(\ndefine\n(\nthe-mutex\nm\n)\n(\ncond\n((\neq?\nm\n'acquire\n)\n(\nif\n(\ntest-and-set!\ncell\n)\n(\nthe-mutex\n'acquire\n)))\n; retry\n((\neq?\nm\n'release\n) (\nclear!\ncell\n))))\nthe-mutex\n))\n(\ndefine\n(\nclear!\ncell\n) (\nset-car!\ncell\nfalse\n))\ntest-and-set!\nはセルをテストし、テストの結果を返します。さらに、もしテ\nストが\nfalse\nであれば\ntest-and-set!\nはセルの中身に\nfalse\nを返す前に\ntrue\nを\n設定します。この振舞は以下の手続のように表現できます。\n(\ndefine\n(\ntest-and-set!\ncell\n)\n(\nif\n(\ncar\ncell\n)\ntrue\n(\nbegin\n(\nset-car!\ncell\ntrue\n)\nfalse\n)))\nしかし、この\ntest-and-set!\nの実装は現状では十分ではありません。致命的\nな機微がここに存在し、ここが並行性コントロールがシステムに入る本質的な\n場所です。\ntest-and-set!\n命令は\natomically\n(\n不可分に、\nアトミック\nに\n)\n実行さ\nれなければなりません。つまり、一度プロセスがセルをテストし\nfalse\nである\nと知ったならば、セルの中身が実際にセルをテストできるどの他のプロセス\nよりも先に\ntrue\nと設定されることを保証せねばなりません。もしこの保証を\nしなければ\nmutex\nは\nFigure 3.29\nにおける銀行口座の失敗と似た失敗をします。\n(\nExercise 3.46\n参照\n)\n。\ntest-and-set!\nの実際の実装は私達のシステムが並行プロセスをどのよう\nに実行するかの詳細に依存します。例えば私達は並行プロセスを逐次的なプロ\nセッサ上に時分割のメカニズムを用いて複数のプロセスを循環させることで\n実行するかもしれません。各プロセスに少ない時間の間割り込みが発生するま\nで実行することを許し次のプロセスを開始します。このような場合には\ntest-\nand-set!\nはテストと設定の間は時分割を停止することでうまく行きます。\n46\n46\nシングルプロセッサ向けの\nmit\nScheme\nは時分割モデルを使うので\ntest-and-set!\nは以下の様に実装できます。\n(\ndefine\n(\ntest-and-set!\ncell\n)\n(\nwithout-interrupts\n(\nlambda\n()\n(\nif\n(\ncar\ncell\n)\ntrue\n(\nbegin\n(\nset-car!\ncell\ntrue\n)\n334","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":360},{"id":"./test/fixtures/pdf/sicp.pdf:361","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"代替法として、マルチプロセスのコンピュータはアトミックな命令を直接ハー\nドウェアにてサポートします。\n47\nExercise 3.46:\ntest-and-set!\nをテキストに示される通常の手続\nを用い、命令をアトミックにする試み無しで実装すると仮定する。\nFigure 3.29\nの様なタイミング図を描き、\n2\nつのプロセスが同時に\nmutex\nを獲得するのを許可した場合に\nmutex\nの実装がどのように\n失敗するのか説明せよ。\nExercise 3.47:\n(\nサイズ\n푛\nの\n)\nセマフォは\nmutex\nの一般化である。\nmutex\nのように、セマフォは\nacquire\nと\nrelease\n命令をサポートす\nるが、最大\n푛\nプロセスまでが並行に獲得できることではより一般\n的である。セマフォを獲得しようとする追加のプロセスは解放命\n令を待たなければならない。セマフォの実装を以下の条件で行え。\na\nmutex\nを用いる\nb\nアトミックな\ntest-and-set!\n命令を用いる\nデッドロック\nシリアライザをどのように実装するべきかについて学習したため、例え上\n記の\nserialized-exchange\nを用いても口座の交換が依然として問題を持つこ\nfalse\n)))))\nwithout-interrupts\nは時分割割り込みをその引数である手続が実行されている間、無\n効にします。\n47\nそのような命令には\ntest-and-set, test-and-clear, swap, compare-and-exchange,\nload-reserve, store-conditional\n等様々なものが存在し、その設計は注意深くマシンの\nプロセッサ\n-\nメモリ間インターフェイスに合わせなければいけません。ここで起こる\n1\nつ\nの問題にはそのような命令を用いて完全に同時に同じリソースを\n2\nつのプロセスが獲得\nしようと試みた場合に何が起こるかを決定することです。これはどのプロセスがコント\nロールを握るのかについて決定するための何らかの仕組みを要求します。そのような仕\n組みは\narbiter\n(\nアービタ\n、調停者\n)\nと呼ばれます。アービタは通常ある種のハードウェア\nデバイスにまとめられます。残念なことに、アービタに対し自由裁量の長さの時間を決定\nを行うのに許さない限り\n100%\nの時間を働く公平なアービタを構築することは物理的に\n不可能であることが証明できます。ここでの根本的な現象は元々\n14\n世紀のフランス人哲\n学者\nJean Buridan(\nジャンビュリダン\n)\nにより\nAristotle(\nアリストテレス\n)\nの\nDe caelo\n(\n天\n体論\n)\nへの注釈において観察されています。ビュリダンは\n2\nつの等しく魅力的な食事の情\n報源の間に置かれた完全に理性的な犬は飢えて死ぬと主張しました。最初にどちらに行\nくのか決めることが不可能なためです。\n335","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":361},{"id":"./test/fixtures/pdf/sicp.pdf:362","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"とを理解することができます。\nPeter\nが\n푎\n1\nと\n푎\n2\nを交換しようとした時、\nPaul\nが並行に\n푎\n2\nを\n푎\n1\nと交換しようと試みていると想像してみて下さい。\nPeter\nの\nプロセスが\n푎\n1\nを守る直列化された手続に入った時点に届いたとします。その\n直後に、\nPaul\nのプロセスが\n푎\n2\nを守る直列化された手続に入りました。さて\nPeter\nは\n(\n푎\n2\nを守っている直列化された手続に入ること\n)\nを進めることは\nPaul\nが\n푎\n2\nを守る直列化された手続から抜けるまでできません。同様に、\nPaul\nもま\nた\nPeter\nが\n푎\n1\nを守る直列化された手続を抜けるまで進めることができません。\nこの状況は\ndeadlock\n(\nデッドロック\n)\nと呼ばれます。デッドロックは並行なアク\nセスを複数の共有リソースに対し提供するシステムでは常に存在する危険性\nです。\nこの状況におけるデッドロックを防ぐ\n1\nつの方法は各口座に固有の識別番\n号を与え、\nserialized-exchange\nを書き換えることでプロセスが常に最も小さ\nな番号の口座を守る手続を最初に入るよう試みるようにします。この方法は交\n換問題に対してうまく行きますが、より洗練されたデッドロック防止技術を必\n要とする他の状況が存在します。またはデッドロックが全く防げない状況も存\n在します。\n(\nExercise 3.48\nと\nExercise 3.49\nを参照\n)\n48\nExercise 3.48:\nなぜ上で説明されたデッドロック防止手法\n(\n即ち\n口座に番号を付け各プロセスが最も小さな番号の口座を最初に\n獲得する\n)\nが交換問題のデッドロックを防ぐのか詳細に説明せ\nよ。\nserialized-exchange\nをこの考えを組込むように書き直せ。\n(\nmake-account\nも変更する必要があり、そうすることで各口座が\n番号と共に作られ、その番号が適切なメッセージを送ることによ\nりアクセスできるようにしなければならない。\n)\nExercise 3.49:\n上で説明されたデッドロック防止の仕組みがうまく\n行かない場合のシナリオを示せ。\n並行性、時間と通信\n並行システムのプログラミングが異なるプロセスが共有状態にアクセスす\nる時にイベントの順序をコントロールすることをどうして必要とするかについ\n48\nデッドロックを共有リソースに番号を付け、順に獲得する一般的なテクニック\nは\nHavender (1968)\nによります。デッドロックが防げない状況では\ndeadlock-recovery\n(\nデ\nッドロックリカバリ\n(\n復帰\n))\n手法を必要とし、それはプロセスにデッドロック状態の\n“back out”(\n取消\n)\nと再試行を引き起します。デッドロックリカバリの仕組みは広くデー\nタベース管理システムにて使用され、\nGray and Reuter 1993\nに詳細が取り上げられてい\nます。\n336","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":362},{"id":"./test/fixtures/pdf/sicp.pdf:363","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"て学びました。そして賢明なシリアライザの使用を通してこのコントロールを\nどのように達成するかについても学びました。しかし根本的な視点から、常に\n“\n共有状態\n”\nが何を意味するのかが明らかでないために、並行性の問題はそれよ\nりも深く位置します。\ntest-and-set!\nのような仕組みはプロセスに対し任意の時間にグローバル\nな共有フラグの試験を要求します。これは解決が難しく、現在の高速な\nCPU\nにおいて実装するのに非効率的です。パイプラインやキャッシュメモリの様な\n最適化の仕組みのためメモリの中身は各瞬間において静的な状態にはありませ\nん。現代のマルチプロセスシステムにおいては、従ってシリアライザのパラダ\nイムは並行性コントロールの新しい取り組みにより取って代わられてきていま\nす。\n49\n共有状態の問題となる側面は巨大な分散システムにおいても生じます。例\nとして、分散銀行システムを想像して下さい。個別の銀行支店は銀行残高のロ\nーカル値を保持し繰り返しそれらを他の支店により保存されている値と比較し\nます。そのようなシステムにおいては\n“\n口座残高\n”\nは同期直後を除いて不確定\nになるでしょう。もし\nPeter\nがお金を\nPaul\nと連結する口座に預け入れした時\nに、いつ口座残高が変更されたと言うべきか\n---\n地元の支店が残高を変更した時\nか、または同期の後までは言えないのか\n?\nそしてもし\nPaul\nが異なる支店から口\n座にアクセスした場合、振舞が\n“\n正しい\n”\n銀行システム上に設置する妥当な制\n約とは何か\n?\n正確性に対し問題となるものは\nPeter\nと\nPaul\nが独立して観察す\nる振舞と同期直後の口座の\n“\n状態\n”\nのみでしょう。\n“\n本当の\n”\n口座残高に関わる\n質問や同期の間のイベントの順は準用ではないか、意味がないでしょう。\n50\nここでの基本的な現象は異なるプロセスの同期、共有状態の設置、または\nイベントの順を強いることはプロセス間通信を必要とします。本質的に、並行\n性コントロールにおける任意の時間の概念は緊密に通信に結びつけられねばな\n49\nそのような直列化の代替法の\n1\nつは\nbarrier synchronization\n(\nバリア同期\n)\nと呼ばれ\nます。プログラマは並行プロセスにそれらが気に入るように実行することを許可しま\nす。しかしどのプロセスも全てのプロセスがバリアに着くまでは先に進むことができな\nいいくつかの同期点\n(“\nバリア\n”)\nを設置します。現代のプロセッサはプログラマに一貫\n性が要求される場所に同期点を設置することを可能にする機械語命令を提供します。例\nえば\npowerpc\nはこの目的のため\nsync\n(\n同期\n)\nと\neieio\n(Enforced In-order Execution of\nInput/Output, I/O\nの強制順序実行\n)\nと呼ばれる\n2\nつの命令を含んでいます。\n50\nこれはおかしな見方のように見えるかもしれません。しかしこのように動くシステ\nムは存在します。例えばクレジットカードの口座への国際課金は通常国毎の拠点上で精\n算され異なる国での課金は繰り返し消し込みされます。従って口座残高は異なる国では\n異なります。\n337","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":363},{"id":"./test/fixtures/pdf/sicp.pdf:364","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"りません。\n51\n面白いことに似たような時間と通信の間の繋がりが相対論にも生\nじています。光速\n(\nイベントの同期に使用可能な最も高速な信号\n)\nは基本的に時\n間と空間に関連して一定です。私達の計算モデルの時間と状態を取り扱うため\nに遭遇した複雑性は実際に物理的宇宙の根本的な複雑性を映しているのかもし\nれません。\n3.5\nストリーム\nモデリングにおけるツールとしての代入について、また代入が生じる複雑\nな問題の認識についても良い理解を得ることができました。次は我々が行って\nきたことを異なる方法で行えたのか、そうすることでこれらの問題を回避でき\nたのかについて尋ねる番です。この節では状態をモデル化する代替となる取り\n組み方について、\nstreams\n(\nストリーム\n)\nと呼ばれるデータ構造を基にして探求\nします。私達が学ぶにつれて、ストリームは状態のモデル化の複雑性のいくら\nかを和らげることができます。\n一旦戻って、この複雑性がどこから来たのか再検討してみましょう。実際\nの世界の現象をモデル化する試みにおいて、私達は幾らかの恐らく適切な決定\nをしました。私達は実際の世界のオブジェクトを局所状態を用いて、ローカル\n変数を持つ計算オブジェクトによってモデル化しました。私達はコンピュータ\n内の時間変化により実際の世界の時間変化を判断しました。私達はコンピュー\nタ内のモデルオブジェクトの状態の時系列変化をモデルオブジェクトのローカ\nル変数への代入を用いて実装しました。\n他に取り組み方があるでしょうか\n?\nコンピュータ内の時間をモデル化され\nた世界の時間を用いて判断することを避けられるでしょうか\n?\n変わり行く世界\nの事象をモデル化するためにモデルを時間と共に変化させなければならないの\nでしょうか\n?\n問題を数学の関数を用いて考えましょう。数量\n푥\nの時間的に変化\nする振舞を時間の関数\n푥(푡)\nとして説明できます。もし瞬間毎に\n푥\nに集中すれ\nば変化する数量だと考えることができます。けれどももし値の歴史全体の時間\n集中すれば私達は変化を重要視しません。関数それ自体は変化しません。\n52\n51\n分散システムに対するこの視点は\nLamport (1978)\nにより追求されました。彼は分散\nシステムにおいてイベントの順序付けを成立させるのに使用できる\n“\nグローバルな時計\n”\nを設立するためにどのように通信を用いるかについて示しました。\n52\n物理学者は時折粒子の\n“world lines”(\n世界線\n)\nを運動に関する推測のための手段とし\nて導入することでこの見方を受け入れます。私達もまた既に\n(\nSection 2.2.3\n)\nにおいてこ\nれが信号処理システムについて考える自然な方法であると説明しました。\nSection 3.5.3\nに\n338","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":364},{"id":"./test/fixtures/pdf/sicp.pdf:365","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"もし時間が不連続なステップにより測られるのであれば、\n(\n無限に成りう\nる\n)\n列として時間関数をモデル化できます。この節では変化をモデル化された\nシステムの時刻歴\n(time history)\nを表す列を用いてどのように変化をモデル化\nするかについて学びます。これを達成するために、\nstreams\n(\nストリーム\n)\nと呼ば\nれる新しいデータ構造を導入します。抽象的な視点からはストリームは単に列\nです。しかし私達はストリームの\n(\nSection 2.2.1\nにあるような\n)\nリストによる簡\n単な実装はストリーム処理の力を完全に明かすことができないことを知るでし\nょう。代替法として、\ndelayed evaluation\n(\n遅延評価\n)\nのテクニックを導入します。\n遅延評価は巨大な\n(\n例え無限でも\n)\n列をストリームして表現することを可能に\nします。\nストリーム処理は状態を持つシステムを代入やミュータブルなデータを用\nいずにモデル化することを可能にします。これは重要な意味合いを倫理的、物\n理的両方で持ちます。なぜなら代入の導入による固有の欠陥を防ぐモデルを構\n築できるためです。一方で、ストリームフレームワークはそれ自身の困難を持\nちます。そしてどのモデリングテクニックがよりモジュラでより簡単にシステ\nムを保守できるかの疑問が残ります。\n3.5.1\nストリームとは遅延化リスト\nSection 2.2.3\nで学んだように、列はプログラムモジュールを組み合わせるた\nめの標準的なインターフェイスの役割を果たすことができます。列を操作する\nための強力な抽象化を形式化しました。例えば\nmap\n,\nfilter\n,\naccumulate\nであ\nり、簡潔であり、かつ洗練された作法にて広範囲の操作を獲得します。\n残念なことに、列をリストとして表現するとこの洗練さは演算により必要\nとされる時間と記憶域に関する深刻な非効率性を犠牲にして得ることになりま\nす。列上の操作をリストの変形として表現した時、私達のプログラムは\n(\n大き\nくなりえる\n)\nデータ構造を処理の各ステップにおいて構築とコピーをせねばな\nりません。\nなぜこれが正しいのか知るために、ある区間の全ての素数の和を求めるた\nめの\n2\nつのプログラムを比較してみましょう。最初のプログラムは標準的な繰\nり返しのスタイルを用います。\n53\n(\ndefine\n(\nsum-primes\na\nb\n)\nて信号処理に対するストリームの適用について探求します。\n53\n素数性をテストする\n(\nSection 1.2.6\nのような\n)\n述語\nprime?\nを持っていると仮定しま\nす。\n339","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":365},{"id":"./test/fixtures/pdf/sicp.pdf:366","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\niter\ncount\naccum\n)\n(\ncond\n((>\ncount\nb\n)\naccum\n)\n((\nprime?\ncount\n)\n(\niter\n(+\ncount\n1) (+\ncount\naccum\n)))\n(\nelse\n(\niter\n(+\ncount\n1)\naccum\n))))\n(\niter\na\n0))\n2\nつ目のプログラムは同じ演算を\nSection 2.2.3\nの列命令を用いて実行します。\n(\ndefine\n(\nsum-primes\na\nb\n)\n(\naccumulate\n+\n0\n(\nfilter\nprime?\n(\nenumerate-interval\na\nb\n))))\n演算の実行において、最初のプログラムは蓄積される合計のみを格納する必要\nがあります。逆に、\n2\nつ目のプログラムのフィルタは\nenumerate-interval\nが\n区間の数の完全なリストを構築するまで一度もテストを行うことができませ\nん。フィルタは別のリストを生成し、合計を形成するため畳み込まれる前に順\nに\naccumulate\nに渡されます。そのような大きな中間ストレージは最初のプロ\nグラムでは必要ありません。最初のプログラムは区間を昇順に列挙し、各素数\nが生成されるにつれ合計に足していくと考えることができます。\nリスト使用における非効率性は、以下の式を評価して\n10,000\nから\n1,000,000\nの区間にて\n2\nつ目の素数を求めるのに列パラダイムを用いると、悲痛な程、明\nらかです\n.\n(\ncar\n(\ncdr\n(\nfilter\nprime?\n(\nenumerate-interval\n10000 1000000))))\nこの式は\n2\nつ目の素数を確かに見つけました。しかし計算上のコストは酷過ぎ\nます。ほとんど百万の整数のリストを構築し、このリストを各要素の素数性を\nテストすることで選別し、ほとんど全ての結果を無視します。より伝統的なプ\nログラミングスタイルにおいては列挙とフィルタリングを交互に配置し、\n2\nつ\n目の素数を見つけたら停止します。\nストリームは列をリストとして扱うコストを負担することなく列操作を用\nいることが可能な賢明な考えです。ストリームを用いると\n2\nつの世界の良い所\n取りができます。プログラムを列操作のように優雅に定式化できます。繰り返\nし演算の効率も獲得できます。基本的なアイデアはストリームを部分的にのみ\n構築する準備を行い、部分的な構築物をストリームを消費するプログラムに渡\n340","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":366},{"id":"./test/fixtures/pdf/sicp.pdf:367","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"します。もし消費プログラムがまだ構築されていないストリームの部分にアク\nセスしようと試みた場合、ストリームは要求された部分を生成するために自動\n的にそれ自身の十分な追加を構築します。従ってストリーム全体が存在すると\nいう錯覚を維持することができます。言い替えれば、私達は完全な列を処理す\nるようなプログラムを書きますが、私達のストリーム実装に自動的に、透過的\nにストリームの構築とその使用を相互配置するように設計します。\n表面上では、ストリームはそれを操作するための異なった名前を持つただ\nのリストです。コンストラクタ\ncons-stream\nと以下の制約を満たす\n2\nつのセレ\nクタ\nstream-car\nと\nstream-cdr\nが存在します。\n(stream-car (cons-stream x y)) = x\n(stream-cdr (cons-stream x y)) = y\n判別可能なオブジェクト\nthe-empty-stream\nが存在し、これはどんな\ncons-\nstream\n命令の結果にはなりえず、述語\nstream-null?\nにて識別できます。\n54\n従\nってストリームを作成し、使用して、リストの作成と使用と同様に、準備され\nた列のデータの集約を表現することができます。具体的には、\nChapter 2\nからス\nトリーム用のリスト命令の類似手続、例えば\nlist-ref\n,\nmap\n,\nfor-each\nを構築\nできます。\n55\n(\ndefine\n(\nstream-ref\ns\nn\n)\n(\nif\n(=\nn\n0)\n(\nstream-car\ns\n)\n(\nstream-ref\n(\nstream-cdr\ns\n) (-\nn\n1))))\n(\ndefine\n(\nstream-map\nproc\ns\n)\n(\nif\n(\nstream-null?\ns\n)\nthe-empty-stream\n(\ncons-stream\n(\nproc\n(\nstream-car\ns\n))\n(\nstream-map\nproc\n(\nstream-cdr\ns\n)))))\n(\ndefine\n(\nstream-for-each\nproc\ns\n)\n54\nmit\nの実装では\nthe-empty-stream\nは空のリスト\n'()\nと同じで、\nstream-null?\nは\nnull?\nと同じです。\n55\nこれはあなたを困惑させるでしょう。そのような似た手続をストリームとリストに\n定義するという事実は、私達がその根底にある抽象を見逃していることを示します。残\n念なことに、この抽象を利用するためには、現在可能なものよりより細かな評価過程に\n対するコントロールを行使する必要があります。この点については\nSection 3.5.4\nの終わ\nりにてより詳細に議論します。\nSection 4.2\nではリストとストリームを統合するフレーム\nワークを開発します。\n341","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":367},{"id":"./test/fixtures/pdf/sicp.pdf:368","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nif\n(\nstream-null?\ns\n)\n'done\n(\nbegin\n(\nproc\n(\nstream-car\ns\n))\n(\nstream-for-each\nproc\n(\nstream-cdr\ns\n)))))\nstream-for-each\nはストリームを見るのに便利です。\n(\ndefine\n(\ndisplay-stream\ns\n)\n(\nstream-for-each\ndisplay-line\ns\n))\n(\ndefine\n(\ndisplay-line\nx\n) (\nnewline\n) (\ndisplay\nx\n))\nストリームの実装に自動的、かつ透過的にストリームの構築とその使用を相互\n配置させるためには、ストリームの\ncdr\nが、ストリームが\ncons-stream\nにより\n構築された時でなく、\nstream-cdr\n手続によりアクセスされた時に評価される\nように手筈を整えます。この実装の選択は\nSection 2.1.2\nでの分数の異音を思い\n出させます。その場合は分子と分母の最小の項への約分を構築時または選択時\nに実行されるよう実装を選択できることを学びました。\n2\nつの分数実装は同じ\nデータ抽象化を生成しますが、選択が効率に影響を与えました。似た関係がス\nトリームと通常のリストの間にも存在します。データ抽象化としては、ストリ\nームはリストと同じです。違いは要素が評価されるタイミングです。通常のリ\nストでは\ncar\nと\ncdr\nの両方は構築時に評価されます。ストリームでは\ncdr\nは選\n択時に評価されます。\n私達のストリームの実装は\ndelay\n(\n遅延\n)\nと呼ばれる特別な形式を基にしま\nす。\n(delay <\nexp\n>)\nの評価は式\n⟨\nexp\n⟩\nを評価しません。しかしその代わりに\n所謂\ndelayed object\n(\n遅延オブジェクト\n)\nを返します。これはある将来の時点で\n⟨\nexp\n⟩\nを評価する\n“promise”(\nプロミス、約束\n)\nとして考えることができます。\ndelay\nの相方として\nforce\n(\n強いる\n)\nと呼ばれる手続が存在し、遅延オブジェク\nトを引数として取り、評価を実行します。実際に\ndelay\nにその約束を果たさせ\nることを強要します。以下で\ndelay\nと\nforce\nがどのように実装できるかについ\nて学びますが、最初にこれらを用いてストリームを構築しましょう。\ncons-stream\nは特別な形式で、\n(\ncons-stream\n⟨\na\n⟩\n⟨\nb\n⟩\n)\n上が以下と同じになるよう設計されています。\n(\ncons\n⟨\na\n⟩\n(\ndelay\n⟨\nb\n⟩\n))\nこれの意味する所は、私達はペアを用いてストリームを構築します。しかし、\nペアの\ncdr\nにストリームの残りの値を置くのではなく、そこにプロミスを置き\n342","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":368},{"id":"./test/fixtures/pdf/sicp.pdf:369","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"要求された時点で残りを計算します。これで\nstream-car\nと\nstream-cdr\nが手\n続として定義できます。\n(\ndefine\n(\nstream-car\nstream\n) (\ncar\nstream\n))\n(\ndefine\n(\nstream-cdr\nstream\n) (\nforce\n(\ncdr\nstream\n)))\nstream-car\nはペアの\ncar\nを選択します。\nstream-cdr\nはペアの\ncdr\nを選択し、\nそこに見つかった遅延表現を評価し、ストリームの残りを得ます。\n56\nストリーム実装の実践\nこの実装がどのように振る舞うのかを見るために、先に見た\n“\n法外な\n”\n素数\n演算をストリームを用いて再定式化したものを分析してみましょう。\n(\nstream-car\n(\nstream-cdr\n(\nstream-filter\nprime?\n(\nstream-enumerate-interval\n10000 1000000))))\nこれが本当に効率的に働くことを見るでしょう。\nstream-enumerate-interval\nを引数\n10,000\nと\n1,000,000\nと共に呼び出すこ\nとから始めます。\nStream-enumerate-interval\nは\nenumerate-interval\n(\nSec-\ntion 2.2.3\n)\nのストリーム版同等品です。\n(\ndefine\n(\nstream-enumerate-interval\nlow\nhigh\n)\n(\nif\n(>\nlow\nhigh\n)\nthe-empty-stream\n(\ncons-stream\nlow\n(\nstream-enumerate-interval\n(+\nlow\n1)\nhigh\n))))\n56\nstream-car\nと\nstream-cdr\nが手続として定義できるにも係わらず、\ncons-stream\nは\n特別形式でなければなりません。もし\ncons-stream\nが手続であるのならば、私達の評価\nモデルに従い、\n(cons-stream <\na\n> <\nb\n>)\nの評価は自動的に\n⟨\nb\n⟩\nの評価を起こします。こ\nれは明らかに私たちにとって起こって欲しくないことです。同じ理由から\ndelay\nも特別\n形式でなければなりません。しかし\nforce\nは通常の手続になります。\n343","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":369},{"id":"./test/fixtures/pdf/sicp.pdf:370","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"従って\nstream-enumerate-interval\nで返される結果は、\ncons-stream\nで形成\nされた\n57\n(\ncons\n10000\n(\ndelay\n(\nstream-enumerate-interval\n10001 1000000)))\nつまり\nstream-enumerate-interval\nはペアとして表現されたストリームを返\nしその\ncar\nは\n10,000\nで、その\ncdr\nはプロミスでありもし要求されれば区間の\nより多くを列挙します。このストリームはここでフィルタをかけ素数を残しま\nす。\nfilter\n手続\n(\nSection 2.2.3\n)\nのストリーム版同等品を用います。\n(\ndefine\n(\nstream-filter\npred\nstream\n)\n(\ncond\n((\nstream-null?\nstream\n)\nthe-empty-stream\n)\n((\npred\n(\nstream-car\nstream\n))\n(\ncons-stream\n(\nstream-car\nstream\n)\n(\nstream-filter\npred\n(\nstream-cdr\nstream\n))))\n(\nelse\n(\nstream-filter\npred\n(\nstream-cdr\nstream\n)))))\nstream-filter\nはストリームの\nstream-car\n(\nペアの\ncar\nであり\n10,000)\nをテ\nストします。これは素数ではないので\nstream-filter\nは入力ストリーム\nの\nstream-cdr\nを調査します。\nstream-cdr\nの呼出は遅延化された\nstream-\nenumerate-interval\nの評価を強制します。これは今、以下を返します。\n(\ncons\n10001\n(\ndelay\n(\nstream-enumerate-interval\n10002 1000000)))\nstream-filter\nは今このストリームの\nstream-car\nである\n10,001\nを見て、これ\nもまた素数ではないことを確認し、もう一度\nstream-cdr\nを強制します。これ\nを\nstream-enumerate-interval\nが素数\n10,007\nを生じるまで繰り返し、すると\n直ぐに\nstream-filter\nはその定義に従い以下を返します。\n(\ncons-stream\n(\nstream-car\nstream\n)\n(\nstream-filter\npred\n(\nstream-cdr\nstream\n)))\nこれはこの場合以下のようになります。\n57\nここで示されている数値は遅延オブジェクトの中には実際には現れません。実際に\n現れるのは元の式であり、環境の中で変数は適切な数値に束縛されています。例えば\nlow\nが\n10,000\nに束縛されながら\n(+ low 1)\nが\n10001\nが表示されている場所に現れます。\n344","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":370},{"id":"./test/fixtures/pdf/sicp.pdf:371","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncons\n10007\n(\ndelay\n(\nstream-filter\nprime?\n(\ncons\n10008\n(\ndelay\n(\nstream-enumerate-interval\n10009\n1000000))))))\nこれでこの結果は元の式の\nstream-cdr\nに渡されます。これにより遅延され\nた\nstream-filter\nが強制され、それが順に遅延された\nstream-enumerate-\ninterval\nを次の素数、\n10,009\nを見つけるまで強制します。最終的に、結果が私\n達の元の式の\nstream-car\nに渡された物が以下です。\n(\ncons\n10009\n(\ndelay\n(\nstream-filter\nprime?\n(\ncons\n10010\n(\ndelay\n(\nstream-enumerate-interval\n10011\n1000000))))))\nstream-car\nが\n10,009\nを返し計算が完了します。\n2\nつ目の素数を見つけるのに\n必要なだけの整数が素数性のテストを受け、区間は素数フィルタに入力するの\nに必要なだけ列挙されました。\n一般的に、遅延評価は\n“demand-driven”(\n要求駆動\n)\nプログラミングだと考\nえることができ、ストリーム処理の各ステージは次のステージを満たすのに十\n分な場合にのみ稼動されます。私達がここで行ったことは手続の見掛け上の構\n造から実際のイベントの順を分断することです。手続をストリームが\n“\n一度に\n揃って\n”\n存在するかのように書くが、実際には演算は漸増的に伝統的なプログ\nラミングスタイルのように実行されます。\ndelay\nと\nforce\nの実装\ndelay\nと\nforce\nはミステリアスな命令に見えるかもしれませんが、それら\nの実装は本当にとても簡単です。\ndelay\nは式を梱包して要求に応じて評価でき\nるようにせねばなりません。私達はこれを手続のボディのように式を扱うこと\nで簡単に達成できます。\ndelay\nは以下のような特別な形式です。\n(\ndelay\n⟨\nexp\n⟩\n)\n345","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":371},{"id":"./test/fixtures/pdf/sicp.pdf:372","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これは以下の構文糖になります。\n(\nlambda\n()\n⟨\nexp\n⟩\n)\nforce\nは単純に\ndelay\nにより生成された\n(\n引数無しの\n)\n手続を呼び出します。従\nって\nforce\nは手続として実装可能です。\n(\ndefine\n(\nforce\ndelayed-object\n) (\ndelayed-object\n))\nこの実装は\ndelay\nと\nforce\nが広報通りに動く程度には十分です。しかし導入可\n能な重要な最適化が存在します。多くのアプリケーションにおいては同じ遅延\nオブジェクトを何度も強制することになります。これがストリームを利用する\n再帰プログラムにおいて深刻な非効率の原因となります\n(\nExercise 3.57\n参照\n)\n。\n解決方法は遅延オブジェクトが初めて強制された時に計算された値を保存する\nように遅延オブジェクトを構築します。続く強制は格納された値を計算を繰り\n返さずに、単純に格納された値を返します。言い替えれば、\ndelay\nを特別な目\n的のメモ化手続として\nExercise 3.27\nにて説明された物と同様に実装します。こ\nれを達成する\n1\nつの方法は以下の手続を用います。これは引数として\n(\n引数の\n無い\n)\n手続を取りその手続のメモ化された版を返します。メモ化された手続が\n最初に実行される時、計算結果を格納します。以降の評価では単純に結果を返\nします。\n(\ndefine\n(\nmemo-proc\nproc\n)\n(\nlet\n((\nalready-run?\nfalse\n) (\nresult\nfalse\n))\n(\nlambda\n()\n(\nif\n(\nnot\nalready-run?\n)\n(\nbegin\n(\nset!\nresult\n(\nproc\n))\n(\nset!\nalready-run?\ntrue\n)\nresult\n)\nresult\n))))\ndelay\nはすると\n(delay <\nexp\n>)\nが以下と等価になるように定義されます。\n(\nmemo-proc\n(\nlambda\n()\n⟨\nexp\n⟩\n))\nそして\nforce\nは依然の定義と同じです。\n58\n58\nこの節で説明された物以外にも多くのストリームの実装が存在します。遅延評価は\nストリームを現実的にする鍵ですが、\nAlgol 60\nの\ncall-by-name\n(\nコールバイネーム\n、名\n前による呼出\n)\nパラメタパッシング法固有の物でした。ストリームの実装にこの仕組み\nを使用のは最初に\nLandin (1965)\nにより説明されました。ストリームに対する遅延評価\n346","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":372},{"id":"./test/fixtures/pdf/sicp.pdf:373","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.50:\n以下の定義を完成させよ。これは\nstream-map\nを\n複数の引数を取ることができるようにする\nSection 2.2.1\nの\nmap\n,\nFootnote 12\nの同等品である\n(\ndefine\n(\nstream-map\nproc\n.\nargstreams\n)\n(\nif\n(\n⟨\n??\n⟩\n(\ncar\nargstreams\n))\nthe-empty-stream\n(\n⟨\n??\n⟩\n(\napply\nproc\n(\nmap\n⟨\n??\n⟩\nargstreams\n))\n(\napply\nstream-map\n(\ncons\nproc\n(\nmap\n⟨\n??\n⟩\nargstreams\n))))))\nExercise 3.51:\n遅延評価のより詳細を見るために、単純に引数を表\n示した後に引数を返すだけの以下の手続を使用する。\n(\ndefine\n(\nshow\nx\n)\n(\ndisplay-line\nx\n)\nx\n)\nインタプリタが以下の一連の式のそれぞれを評価した時に何を表\n示するだろうか\n?\n59\n(\ndefine\nx\n(\nstream-map\nshow\n(\nstream-enumerate-interval\n0 10)))\nは\nFriedman and Wise (1976)\nにより\nLisp\nに導入されました。彼等の実装では\ncons\nは常\nにその引数の評価を遅延するので、リストは自動的にストリームとして振舞いました。メ\nモ化最適化は\ncall-by-need\n(\nコールバイニード\n、必要による呼出\n)\nとしても知られていま\nす。\nAlogol\nコミュニティは私達の元の遅延オブジェクトを\ncall-by-name thunks\n(\nコール\nバイネームサンク\n)\nと呼び最適化された版を\ncall-by-need thunks\n(\nコールバイニードサン\nク\n)\nと呼ぶでしょう。\n59\nExercise 3.51\nや\nExercise 3.52\nのような課題は\ndelay\nがどのように働くかについての\n私達の理解を試すために価値有るものです。一方で、遅延評価を表示\n—\nそしてさらに悪\nいことに代入と\n—\n混ぜることは大きな混乱要因であり、コンピュータ言語の授業のイン\nストラクタ達はこの節にあるような試験問題で学生達を苦しめてきました。言うまでも\nありませんが、そのような微妙さに依存するプログラムを書くことは醜悪なプログラミ\nングスタイルです。ストリーム処理の力の一部は私達にイベントが実際にプログラムの\n中で起こる順について忘れさせてくれることです。残念なことにこれは明らかに代入が\n存在する場合にはできない事です。代入は私達に時間と変更に関して心配することを強\nいるのです。\n347","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":373},{"id":"./test/fixtures/pdf/sicp.pdf:374","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nstream-ref\nx\n5)\n(\nstream-ref\nx\n7)\nExercise 3.52:\nConsider the sequence of expressions\n以下の一連の式について考える。\n(\ndefine\nsum\n0)\n(\ndefine\n(\naccum\nx\n) (\nset!\nsum\n(+\nx\nsum\n))\nsum\n)\n(\ndefine\nseq\n(\nstream-map\naccum\n(\nstream-enumerate-interval\n1 20)))\n(\ndefine\ny\n(\nstream-filter\neven?\nseq\n))\n(\ndefine\nz\n(\nstream-filter\n(\nlambda\n(\nx\n) (= (\nremainder\nx\n5) 0))\nseq\n))\n(\nstream-ref\ny\n7)\n(\ndisplay-stream\nz\n)\n上記の各式が評価された後の\nsum\nの値はいくつか\n?\n式\nstream-ref\nと\ndisplay-stream\nを評価した時表示される応答は何か\n?\nこれらの\n応答はもし\n(delay <\nexp\n>)\nを単純に\n(lambda () <\nexp\n>)\nと実装\nし\nmemo-proc\nにより提供される最適化を使用しなかった場合に異\nなるだろうか\n?\n説明せよ。\n3.5.2\n無限ストリーム\n実際にはアクセスに必要な分のストリームしか計算していないのにストリ\nームを完全な要素の集合として扱うイリュージョンをどのようにサポートする\nのかについて学びました。このテクニックを利用して例え列が実際にはとても\n長くても列を効率的にストリームとして表現することができます。より印象的\nなことに、ストリームを無限に長い列を表現するために使用することができま\nす。例として以下の正の整数のストリームの定義について考えてみましょう。\n(\ndefine\n(\nintegers-starting-from\nn\n)\n(\ncons-stream\nn\n(\nintegers-starting-from\n(+\nn\n1))))\n(\ndefine\nintegers\n(\nintegers-starting-from\n1))\n348","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":374},{"id":"./test/fixtures/pdf/sicp.pdf:375","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"integers\nが\ncar\nが\n1\nで\ncdr\nが\n2\nで始まる整数を生成するプロミスになるため\nこれは理にかなっています。これは無限に長いストリームです。しかし任意の\n与えれた時間にはその有限な一部しか検討することはできません。従って私達\nのプログラムは無限のストリーム全体がそこにあることを知ることはできま\nせん。\nintegers\nを用いて他の無限のストリームを定義できます。例えば\n7\nで割る\nことのできない整数のストリームです。\n(\ndefine\n(\ndivisible?\nx\ny\n) (= (\nremainder\nx\ny\n) 0))\n(\ndefine\nno-sevens\n(\nstream-filter\n(\nlambda\n(\nx\n) (\nnot\n(\ndivisible?\nx\n7)))\nintegers\n))\nすると\n7\nで割り切れない整数をこのストリームの要素にアクセスするだけで見\nつけることができます。\n(\nstream-ref\nno-sevens\n100)\n117\nintegers\nと同様に、フィボナッチ数の無限ストリームも定義できます。\n(\ndefine\n(\nfibgen\na\nb\n) (\ncons-stream\na\n(\nfibgen\nb\n(+\na\nb\n))))\n(\ndefine\nfibs\n(\nfibgen\n0 1))\nfibs\nはその\ncar\nが\n0\nで、その\ncdr\nは\n(fibgen 1 1)\nを評価するプロミスであ\nるペアです。この遅延化した\n(fibgen 1 1)\nを評価すると、\ncar\nが\n1\nで\ncdr\nが\n(fibgen 1 2)\nを評価するプロミスであるペアを生成します。以下、その繰り\n返しです。\nより刺激的な無限ストリームの調査のために、\nno-sevens\nの例を一般化し、\n素数の無限ストリームを\nsieve of Eratosthenes\n(\nエラトステネスの篩\n)\nとして知\nられる手法を用いて構築します。\n60\n私達は整数を最初の素数である\n2\nで始め\nます。残りの素数を得るために、整数の残りから\n2\nの倍数をフィルタリングす\nることから始めます。これは\n3\nで始まるストリームを残し、\n3\nは次の素数です。\n60\nエラトステネスは紀元前\n3\n世紀のアレキサンドリア学派のギリシャ人哲学者で、地\n球の外周を最初に正しく推測したとして有名です。彼は夏至の日の正午の影を観察する\nことでこれを求めました。エラトステネスの篩は古典ですが、特殊用途のハードウェア\n“\n篩\n”\nの基礎をなしており、最近まで巨大な素数を突き止める最も強力なツールでした。\nしかし\n70\n年代からこれらの手法は\nSection 1.2.6\nで議論された確率的な技術の成長により\n取って代わられました。\n349","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":375},{"id":"./test/fixtures/pdf/sicp.pdf:376","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ここで\n3\nの倍数をこのストリームの残りからフィルタリングします。これは\n5\nで始まるストリームを残し、\n5\nは次の素数です。以下これを繰り返します。言\nい換えれば、素数を次の様に説明する篩にかける処理により構築します。まず\nストリーム\nS\nに篩をかけるために、最初の要素が\nS\nの最初の要素であり、残り\nは\nS\nの残りから\nS\nの最初の要素の倍数をフィルタリングすることで得られるス\nトリームを形成します。そして結果をさらに篩にかけます。この処理は容易に\nストリーム命令を用いて記述できます。\n(\ndefine\n(\nsieve\nstream\n)\n(\ncons-stream\n(\nstream-car\nstream\n)\n(\nsieve\n(\nstream-filter\n(\nlambda\n(\nx\n)\n(\nnot\n(\ndivisible?\nx\n(\nstream-car\nstream\n))))\n(\nstream-cdr\nstream\n)))))\n(\ndefine\nprimes\n(\nsieve\n(\nintegers-starting-from\n2)))\nこれで特定の素数を見つけるのには以下のように尋ねるだけです。\n(\nstream-ref\nprimes\n50)\n233\nFigure 3.31\nの\n“\nヘンダーソン図\n”\nに示されるように\nsieve\nにより設定された信\n号処理システムを熟考することは面白いです。\n61\n入力ストリームは\n“un\ncons\ner”\nに流し込まれ、ストリームの最初の要素をストリームの残りから分離します。\n最初の要素は可分性フィルタを構築するのに用いられ、残りはそれに渡され通\nります。フィルタの出力はもう\n1\nつの篩の箱に流し込まれます。次に元の最初\nの用途は内側の篩の出力上に\ncons\nされ出力ストリームを形成します。従って\nストリームのみが無限ではなく、信号処理器もまた無限です。なぜなら篩がそ\nの中に篩を持っているからです。\n暗黙的ストリーム定義\n上記の\nintegers\nと\nfibs\nのストリームは明示的にストリーム要素を\n1\nつづ\nつ計算する\n“\n生成\n”\n手続を指定することにより定義されました。ストリームを\n61\n私達はこれらの図を\nPeter Henderson\nにちなんで名付けました。彼はこの種の図を\nストリーム処理について考える方法として示した最初の人物です。各実線は送信される\n値のストリームを表しています。\ncar\nから\ncons\nと\nfilter\nへの点線はこれがストリーム\nではなく単一の値であることを示します。\n350","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":376},{"id":"./test/fixtures/pdf/sicp.pdf:377","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"filter:\nnot\ndivisible?\nsieve\nsieve\ncar\ncdr\ncons\nFigure 3.31:\n信号処理システムとして見た素数の篩\n指定する代替法として遅延評価の利点を用いて暗黙的にストリームを定義する\nことが上げられます。例えば以下の式はストリーム\nones\nを\n1\nの無限ストリー\nムとして定義します。\n(\ndefine\nones\n(\ncons-stream\n1\nones\n))\nこれは再帰手続の定義そっくりに動きます。\nones\nはペアでその\ncar\nは\n1\nでそ\nの\ncdr\nは\nones\nを評価するプロミスです。\ncdr\nの評価は再び\n1\nと\nones\nを評価す\nるプロミスを与えます。以下、繰り返しです。\nより面白いこととしてストリームを\nadd-streams\nのような命令で操作する\nことができます。\nadd-streams\nは\n2\nつの与えらえたストリームのエレメント同\n士の和を生成します。\n(\ndefine\n(\nadd-streams\ns1\ns2\n) (\nstream-map\n+\ns1\ns2\n))\nこれで整数を以下のように定義できます。\n(\ndefine\nintegers\n(\ncons-stream\n1 (\nadd-streams\nones\nintegers\n)))\nこれは\nintegers\nが最初の要素は\n1\nで残りは\nones\nと\nintegers\nの和になります。\n従って\nintegers\nの\n2\nつ目の要素は\n1\n足す\nintegers\nの最初の要素、つまり\n2\nになります。\nintegers\nの\n3\nつ目の要素は\n1\n足す\nintegers\nの\n2\nつ目の要素、つ\nまり\n3\nです。以下繰り返しです。この定義は任意の時点で十分な\nintegers\nス\nトリームが生成されているので次の整数を生成するために定義にフィードバッ\nクすることあできるためうまく行くのです。\nフィボナッチ数も同じスタイルで定義できます。\n351","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":377},{"id":"./test/fixtures/pdf/sicp.pdf:378","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\nfibs\n(\ncons-stream\n0\n(\ncons-stream\n1 (\nadd-streams\n(\nstream-cdr\nfibs\n)\nfibs\n))))\nこの定義は\nfibs\nは\n0\nと\n1\nで始まるストリームであり残りのストリームは\nfibs\nを自身に\n1\nつずらして足すことで生成することができると述べています。\n1  1  2  3  5  8    13  21\n...\n=  (stream-cdr fibs)\n0  1  1  2  3  5    8    13\n...\n=  fibs\n0  1  1  2  3  5  8  13  21  34\n...\n=  fibs\nscale-stream\nはまた別の、そのようなストリーム定義を形成するのに便利な\n手続です。これはストリームの各要素に与えられた定数を掛けます。\n(\ndefine\n(\nscale-stream\nstream\nfactor\n)\n(\nstream-map\n(\nlambda\n(\nx\n) (*\nx\nfactor\n))\nstream\n))\n例として\n(\ndefine\ndouble\n(\ncons-stream\n1 (\nscale-stream\ndouble\n2)))\nは\n2\nの冪乗のストリームを生成します：\n1, 2, 4, 8, 16, 32,\n...\n素数ストリームの代替定義は整数で始まり、それらの素数性をテストする\nことでフィルタリングすることでも与えられます。最初の素数、\n2\nを開始に必\n要とします。\n(\ndefine\nprimes\n(\ncons-stream\n2\n(\nstream-filter\nprime?\n(\nintegers-starting-from\n3))))\nこの定義はあまり見かけほど簡単ではありません。\n푛\nが\n(\n任意の整数でなく\n)\n√\n푛\n以下の素数で割り切れるかどうかをチェックすることにより数\n푛\nが素数である\nかを決めるためです。\n(\ndefine\n(\nprime?\nn\n)\n(\ndefine\n(\niter\nps\n)\n(\ncond\n((> (\nsquare\n(\nstream-car\nps\n))\nn\n)\ntrue\n)\n((\ndivisible?\nn\n(\nstream-car\nps\n))\nfalse\n)\n352","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":378},{"id":"./test/fixtures/pdf/sicp.pdf:379","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nelse\n(\niter\n(\nstream-cdr\nps\n)))))\n(\niter\nprimes\n))\nこれは再帰定義であり、\nprimes\nが\nprimes\nを用いる\nprime?\n述語を用いて定義\nされています。この手続がうまく行く訳は、任意の時点で、十分な\nprimes\nス\nトリームが生成されており、次にチェックするのに必要な数の素数性をテスト\nできるからです。全ての\n푛\nに対して素数性をテストします。例え\n푛\nが素数でな\nくても\n(\nこの場合、それを割り切れる素数が既に生成されています。\n),\n例え\n푛\nが素数\n(\nこの場合、素数が既に生成されています\n—\n言い換えれば、\n√\n푛\nより大\nきく\n푛\n未満の素数\n)\nであってもです。\n62\nExercise 3.53:\nプログラムを実行すること無しに以下により定義さ\nれたストリームの要素について説明せよ。\n(\ndefine\ns\n(\ncons-stream\n1 (\nadd-streams\ns\ns\n)))\nExercise 3.54:\nadd-streams\nと類似の手続\nmul-streams\nを定義せ\nよ。これは\n2\nつの入力ストリームの要素同士の積を生成する。こ\nれを\nintegers\nストリームと共に用いて以下のストリームの定義\nを完成させよ。これの\n푛\n番目の要素\n(0\nで開始\n)\nは\n푛 + 1\nの階乗で\nある。\n(define factorials (cons-stream 1 (mul-streams\n⟨\n?\n⟩ ⟨\n?\n⟩\n)))\nExercise 3.55:\n手続\npartial-sums\nを定義せよ。これはストリーム\n푆\nを引数として取り、要素が\n푆\n0\n,\n푆\n0\n+ 푆\n1\n,\n푆\n0\n+ 푆\n1\n+ 푆\n2\n, ...\nであ\nるストリームを返す。例えば\n(partial-sums integers)\nは\n1, 3, 6,\n10, 15,\n...\nのストリームにならねばならない。\nExercise 3.56:\nR. Hamming(\nリチャードハミング\n)\nにより取り上げ\nられた有名な問題に、昇順に、重複無く、\n2, 3, 5\n以外の素因数を持\nたない正の整数を列挙せよというものがある。これを行う\n1\nつの\n62\nこの最後の点はとても微妙で\n푝\n푛+1\n≤ 푝\n2\n푛\nという事実に依存しています。\n(\nここで\n푝\n푘\nは\n푘\n番目の素数を示します\n)\n。このような予測を立証するのはとても難しいです。ユークリ\nッドによる太古の証明による、ある素数が無限に存在することが\n푝\n푛+1\n≤ 푝\n1\n푝\n2\n... 푝\n푛\n+ 1\nを示しています。そして実質的にはより良い結果が証明されることは\n1851\n年まであり\nませんでした。この年、ロシア人の数学者\nP. L. Chebyshev(\nパフヌティ・チェビシェフ\n)\nは全ての\n푛\nに対し\n푝\n푛+1\n≤ 2푝\n푛\nであることを証明しました。最初に\n1845\n年に予想さ\nれたこの結果は\nBertrand’s hypothesis\n(\nベルトランの仮説\n)\nとして知られています。証明\nは\nHardy and Wright 1960\nの節\n22.3\nに見つかります。\n353","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":379},{"id":"./test/fixtures/pdf/sicp.pdf:380","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"明らかな方法は単純に各整数を順に\n2, 3, 5\n以外の素因数を持つか\nどうかテストする方法です。しかしこれはとても非効率です。整\n数が大きくなる程に要求に合う数はより少なくなるためです。代\n替法として、要求された数のストリームを\nS\nと呼び、以下の事実\nについて注目してみましょう。\n•\nS\nは\n1\nで始まる。\n•\n(scale-stream S 2)\nの要素もまた\nS\nの要素である。\n•\n同じことが\n(scale-stream S 3)\nと\n(scale-stream 5 S)\nに\n対しても真である。\n•\nこれらは全て\nS\nの要素である。\nさて私達が行わなければならないこと全てはこれらの情報から要\n素を結合することである。このために\n2\nつの順序有りストリーム\nを重複を省き\n1\nつの順序付けられた結果のストリームに結合する\n手続\nmerge\nを定義する。\n(\ndefine\n(\nmerge\ns1\ns2\n)\n(\ncond\n((\nstream-null?\ns1\n)\ns2\n)\n((\nstream-null?\ns2\n)\ns1\n)\n(\nelse\n(\nlet\n((\ns1car\n(\nstream-car\ns1\n))\n(\ns2car\n(\nstream-car\ns2\n)))\n(\ncond\n((<\ns1car\ns2car\n)\n(\ncons-stream\ns1car\n(\nmerge\n(\nstream-cdr\ns1\n)\ns2\n)))\n((>\ns1car\ns2car\n)\n(\ncons-stream\ns2car\n(\nmerge\ns1\n(\nstream-cdr\ns2\n))))\n(\nelse\n(\ncons-stream\ns1car\n(\nmerge\n(\nstream-cdr\ns1\n)\n(\nstream-cdr\ns2\n)))))))))\n354","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":380},{"id":"./test/fixtures/pdf/sicp.pdf:381","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"次に要求されたストリームが\nmerge\nを用いて以下のよう構築され\nるだろう。\n(\ndefine\nS\n(\ncons-stream\n1 (\nmerge\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\n上で\n⟨\n??\n⟩\nとマークされた箇所の欠けた式を埋めよ。\nExercise 3.57:\n푛\n番目のフィボナッチ数を\nadd-streams\n手続を基\nにした\nfibs\nの定義を用いて計算した場合に加算は何回実行される\nか\n?\n加算回数が\n(delay <\nexp\n>)\nを単純に\nSection 3.5.1\nで説明した\nmemo-proc\n手続により提供される最適化を用いずに、\n(lambda ()\n<\nexp\n>)\nとして実装した場合に指数関数的に増加することを示せ。\n63\nExercise 3.58:\n以下の手続により計算されるストリームの解説を与\nえよ。\n(\ndefine\n(\nexpand\nnum\nden\nradix\n)\n(\ncons-stream\n(\nquotient\n(*\nnum\nradix\n)\nden\n)\n(\nexpand\n(\nremainder\n(*\nnum\nradix\n)\nden\n)\nden\nradix\n)))\n(\nquotient\nはプリミティブであり、\n2\nつの整数の、整数の商を返す\n)\n。\n(expand 1 7 10)\nにより生成される一連の要素は何か\n?\n(expand 3\n8 10)\nでは何が生成されるか\n?\nExercise 3.59:\nSection 2.5.3\nにて多項式を項のリストとして表現す\nる多項式数値演算システムをどのように実装するかについて学ん\nだ。同様な方法で以下のような\npower series\n(\nべき級数\n)\nについても\n扱うことができる。\n푒\n푥\n= 1 + 푥 +\n푥\n2\n2\n+\n푥\n3\n3 ⋅ 2\n+\n푥\n4\n4 ⋅ 3 ⋅ 2\n+ ... ,\n푐표푠 푥 = 1 −\n푥\n2\n2\n+\n푥\n4\n4 ⋅ 3 ⋅ 2\n− ... ,\n63\nこの課題は\ncall-by-need\nが\nExercise 3.27\nで説明された通常のメモ化に密接に関係し\nていることを示します。その課題では代入を明示的にローカルの表の構築に用いました。\n私達の\ncall-by-need\nストリームの最適化は効果的にそのようなテーブルを自動的に構築\nし、ストリームの以前に強制された部分の値を格納します。\n355","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":381},{"id":"./test/fixtures/pdf/sicp.pdf:382","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"푠푖푛 푥 = 푥 −\n푥\n3\n3 ⋅ 2\n+\n푥\n5\n5 ⋅ 4 ⋅ 3 ⋅ 2\n− ...\nこれらは無限ストリームとして表現されている。数列\n푎\n0\n+ 푎\n1\n푥 +\n푎\n2\n푥\n2\n+ 푎\n3\n푥\n3\n+ ...\nを要素が係数\n푎\n0\n,\n푎\n1\n,\n푎\n2\n,\n푎\n3\n,\n...\nのストリームと\nして表すことにする。\na\n級数\n푎\n0\n+ 푎\n1\n푥 + 푎\n2\n푥\n2\n+ 푎\n3\n푥\n3\n+ ...\nの積分は次に級数になる。\n푐 + 푎\n0\n푥 +\n1\n2\n푎\n1\n푥\n2\n+\n1\n3\n푎\n2\n푥\n3\n+\n1\n4\n푎\n3\n푥\n4\n+ ... ,\nここで\n푐\nは任意の定数である。羃級数を表すストリーム\n푎\n0\n,\n푎\n1\n,\n푎\n2\n,\n...\nを入力として取り、その級数の積分の非定数項の\n係数のストリーム\n푎\n0\n,\n1\n2\n푎\n1\n,\n1\n3\n푎\n2\n,\n...\nを返す手続\nintegrate-\nseries\nを定義せよ。\n(\n結果が定数項を持たないため、それは\n羃級数では無い。\nintegrate-series\nを使う時、後で適切な\n定数を\ncons\nする。\n)\nb\n関数\n푥 ↦ 푒\n푥\nはそれ自身導関数である。これは\n푒\n푥\nと\n푒\n푥\nの不\n定積分が定数項を除いて同じ級数になることを暗示する。定\n数項は\n푒\n0\n= 1\nである。結果的に、\n푒\n푥\nの級数を次のように生\n成できる。\n(\ndefine\nexp-series\n(\ncons-stream\n1 (\nintegrate-series\nexp-series\n)))\nsin\nと\ncos\nの級数をどのように生成するか示せ。\nsin\nの導関数\nが\ncos\nであり、\ncos\nの導関数が負の\nsin\nであることから始めよ。\n(\ndefine\ncosine-series\n(\ncons-stream\n1\n⟨\n??\n⟩\n))\n(\ndefine\nsine-series\n(\ncons-stream\n0\n⟨\n??\n⟩\n))\nExercise 3.60:\nExercise 3.59\nにおける係数ストリームとして表現さ\nれた羃級数を用いて、級数の加算は\nadd-streams\nにより実装され\nる。級数を乗算するための以下の手続の定義を完成させよ。\n(\ndefine\n(\nmul-series\ns1\ns2\n)\n(\ncons-stream\n⟨\n??\n⟩\n(\nadd-streams\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\n手続ができたら\nExercise 3.59\nの級数を用いて\n푠푖푛\n2\n푥 + 푐표푠\n2\n푥 = 1\nを確認せよ。\n356","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":382},{"id":"./test/fixtures/pdf/sicp.pdf:383","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.61:\n푆\nが定数項が\n1\nの羃級数\n(\nExercise 3.59\n)\nであると\nする。羃級数\n1/푆\nを見つけたいとする。つまり\n푆푋 = 1\nとなる\nような級数\n푋\nである。\n푆\n푅\nが\n푆\nの定数項の後の部分である場合に\n푆 = 1 + 푆\n푅\nを書け。そうすれば\n푋\nを以下のようにして求めるこ\nとができる。\n푆 ⋅ 푋 = 1,\n(1 + 푆\n푅\n) ⋅ 푋 = 1,\n푋 + 푆\n푅\n⋅ 푋 = 1,\n푋 = 1 − 푆\n푅\n⋅ 푋.\n言い換えれば、\n푋\nは定数項が\n1\nであり高次項が負の\n푆\n푅\nと\n푋\nの積\nにより与えられる羃級数である。この考えを用いて定数項\n1\nを持\nつ羃級数\n푆\nに対する\n1/푆\nを求める手続\ninvert-unit-series\nを書\nけ。\nExercise 3.60\nの\nmul-series\nを用いる必要がある。\nExercise 3.62:\nExercise 3.60\nと\nExercise 3.61\nの結果を用いて\n2\nつの\n羃級数を割る手続\ndiv-series\nを定義せよ。\ndiv-series\nは任意の\n2\nつの級数に対して利用できねばならず分母の級数は非ゼロな定数\n項で始まらねばならない。\n(\nもし分母がゼロの定数項を持つならば\ndiv-series\nはエラーを発すこと\n)\n。\ndiv-series\nを\nExercise 3.59\nの\n結果と一緒にどのように用いて\ntan\nの羃級数を生成するか示せ。\n3.5.3\nストリームパラダイムの利用\n遅延評価を伴なうストリームは強力なモデリングツールにすることができ、\n局所状態と代入の利点の多くを提供する。さらにプログラミング言語への代入\nの導入に伴う、いくつかの理論的な混乱を防ぎます。\nストリームのアプローチは私達に、状態変数への代入の周りに体系化され\nたシステムよりも、異なるモジュール境界を伴なうシステムを構築することを\n可能にするため、啓発的です。例えば私達は個別の瞬間における状態変数の値\nとしてではなく、時系列\n(\nまたは信号\n)\n全体を興味の中心として考えることがで\nきます。このことが異なる瞬間の状態のコンポーネントの比較と接続を行うの\nにより便利にします。\n反復をストリームプロセスとして定式化する\nSection 1.2.1\nにおいて、反復プロセスを紹介しました。これは状態変数を更\n新することで進行されます。私達は今、状態を更新される変数の集合としてで\n357","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":383},{"id":"./test/fixtures/pdf/sicp.pdf:384","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"はなく、\n“\n永遠\n”\nの値のストリームとして表すことができます。\nSection 1.1.7\nの\n平方根手続への再訪問にこの視点を導入しましょう。考え方は推測値を改善す\nる手続を何度も適用することで\n푥\nの平方根の推測値をより良い値の列を生成\nするということを思い出して下さい。\n(\ndefine\n(\nsqrt-improve\nguess\nx\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\n私達の元の\nsqrt\n手続では、これらの推測値を状態変数の一連の値にしました。\n代わりに推測値の無限ストリームを作ることができます。推測値の初期値は\n1\nで始めます。\n64\n(\ndefine\n(\nsqrt-stream\nx\n)\n(\ndefine\nguesses\n(\ncons-stream\n1.0\n(\nstream-map\n(\nlambda\n(\nguess\n) (\nsqrt-improve\nguess\nx\n))\nguesses\n)))\nguesses\n)\n(\ndisplay-stream\n(\nsqrt-stream\n2))\n1.\n1.5\n1.4166666666666665\n1.4142156862745097\n1.4142135623746899\n...\nより多くのストリームの項を生成することでより良い推測値を得ることができ\nます。もし望むなら、解答が十分に良くなるまで項の生成を続ける手続を書く\nことも可能です。\n(\nExercise 3.64\n参照\n)\n。\n同じ方法で扱えるもう\n1\nつの反復は\n휋\nの近似値を\nSection 1.3.1\nで見た交項\n級数\n(\n交代級数\n)\nを基にして生成することが可能です。\n휋\n4\n= 1 −\n1\n3\n+\n1\n5\n−\n1\n7\n+ ... .\n64\nlet\nをローカル変数\nguesses\nを束縛するのに使うことはできません。\nguesses\nの値\nは\nguesses\n自身に依存するためです。\nExercise 3.63\nはなぜここで局所変数を欲しがるの\nかを扱います。\n358","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":384},{"id":"./test/fixtures/pdf/sicp.pdf:385","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最初に級数の加数\n(\n符号が交互に代わる奇数の逆数\n)\nのストリームを生成し\nます。次に\n(\nExercise 3.55\nの\npartial-sums\n手続を用いてより多くの項の和のス\nトリームを取り、結果を\n4\n倍します。\n(\ndefine\n(\npi-summands\nn\n)\n(\ncons-stream\n(/ 1.0\nn\n)\n(\nstream-map\n- (\npi-summands\n(+\nn\n2)))))\n(\ndefine\npi-stream\n(\nscale-stream\n(\npartial-sums\n(\npi-summands\n1)) 4))\n(\ndisplay-stream\npi-stream\n)\n4.\n2.666666666666667\n3.466666666666667\n2.8952380952380956\n3.3396825396825403\n2.9760461760461765\n3.2837384837384844\n3.017071817071818\n...\nこれはより良い\n휋\nの近似値のストリームを提供します。しかし、近似値の収束\nはとても遅いです。列の\n8\n個の項は\n휋\nの値を\n3.284\nから\n3.017\nの間に束縛され\nます。\n今の所、状態のストリームを使用する取り組みは状態変数を更新する物か\nら大きくは異なりません。しかしストリームはある面白いトリックを行う機会\nを提供します。例えば、近似値の列を、同じ値に、ただしより速く収束する列\nに変換する\nsequence accelerator\n(\n列アクセラレータ\n)\nを用いてストリームを変\n換することができます。\n18\n世紀のスイスの数学者\nLeonhard Euler(\nレオンハルトオイラー\n)\nによるそ\nのようなアクセラレータの\n1\nつは交項級数\n(\n符号を互い違いにする項の列\n)\nの\n部分和である列とうまく働きます。オイラーの手法においては、もし\n푆\n푛\nが元\nの和の列の\n푛\n番目の項であるなら、加速された列は以下の項を持ちます。\n푆\n푛+1\n−\n(푆\n푛+1\n− 푆\n푛\n)\n2\n푆\n푛−1\n− 2푆\n푛\n+ 푆\n푛+1\n.\n359","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":385},{"id":"./test/fixtures/pdf/sicp.pdf:386","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"従って元の列が値のストリームとして表現されるならば、変換された列は\n以下により与えられる。\n(\ndefine\n(\neuler-transform\ns\n)\n(\nlet\n((\ns0\n(\nstream-ref\ns\n0))\n;\n푆\n푛−1\n(\ns1\n(\nstream-ref\ns\n1))\n;\n푆\n푛\n(\ns2\n(\nstream-ref\ns\n2)))\n;\n푆\n푛+1\n(\ncons-stream\n(-\ns2\n(/ (\nsquare\n(-\ns2\ns1\n))\n(+\ns0\n(* -2\ns1\n)\ns2\n)))\n(\neuler-transform\n(\nstream-cdr\ns\n)))))\nオイラーによる加速を私達の\n휋\nの近似値の列を用いて実演できます。\n(\ndisplay-stream\n(\neuler-transform\npi-stream\n))\n3.166666666666667\n3.1333333333333337\n3.1452380952380956\n3.13968253968254\n3.1427128427128435\n3.1408813408813416\n3.142071817071818\n3.1412548236077655\n...\nさらに良くなるよう、加速された列を加速でき、そして再帰的にそれの加速を\n繰り返すことが可能です。すなわち、ストリームのストリーム\n(\ntableau\n(\nタブロ\nー\n)\nと呼ぶ構造\n)\nを作り、その中では各ストリームは\n1\nつ前の変換です。\n(\ndefine\n(\nmake-tableau\ntransform\ns\n)\n(\ncons-stream\ns\n(\nmake-tableau\ntransform\n(\ntransform\ns\n))))\nタブローは以下の形を取ります。\n푠\n00\n푠\n01\n푠\n02\n푠\n03\n푠\n04\n...\n푠\n10\n푠\n11\n푠\n12\n푠\n13\n...\n푠\n20\n푠\n21\n푠\n22\n...\n...\n最後にタブローの各行の最初の項を取ることで列を形成します。\n360","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":386},{"id":"./test/fixtures/pdf/sicp.pdf:387","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\naccelerated-sequence\ntransform\ns\n)\n(\nstream-map\nstream-car\n(\nmake-tableau\ntransform\ns\n)))\n휋\nの列のこの種の\n“\n超加速\n”\nを実演することができます。\n(\ndisplay-stream\n(\naccelerated-sequence\neuler-transform\npi-stream\n))\n4.\n3.166666666666667\n3.142105263157895\n3.141599357319005\n3.1415927140337785\n3.1415926539752927\n3.1415926535911765\n3.141592653589778\n...\n結果は感動的です。列の\n8\nつの項を得ることで\n휋\nの小数点以下\n14\n桁の正しい\n値がもたらせられます。もし元の\n휋\nの列のみを使用したなら、\n10\n13\nのオーダ\nーの演算をする必要が\n(\nすなわち列の個々の項が\n10\n−13\nよりも小さくなるまで\n十分に長く展開する必要が\n)\n同じ程度の正確さを得るためには必要です！\nこれらの加速テクニックをストリームを用いずに実装することもできまし\nた。しかしストリームによる定式化はとりわけエレガントで便利です。状態の\n列全体が統一された命令の集合により操作可能なデータ構造として使用できる\nからです。\nExercise 3.63:\nLouis Reasoner\nはなぜ\nsqrt-stream\n手続が以下の\nより簡単な方法で、局所変数\nguesses\n無しで実装されていないの\nか尋ねた。\n(\ndefine\n(\nsqrt-stream\nx\n)\n(\ncons-stream\n1.0 (\nstream-map\n(\nlambda\n(\nguess\n)\n(\nsqrt-improve\nguess\nx\n))\n(\nsqrt-stream\nx\n))))\nAlyssa P. Hacker\nが問題の手続のこの版は冗長な演算を行うため、\nかなり非効率であるからと答えた。\nAlyssa\nの答を説明せよ。もし\ndelay\nの実装が\nmemo-proc\n(\nSection 3.5.1\n)\nで提供された最適化を\n361","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":387},{"id":"./test/fixtures/pdf/sicp.pdf:388","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"用いずに\n(lambda () <\nexp\n>)\nのみを使用したならば\n2\nつの版の間\nに依然として効率上の違いは存在するだろうか\n?\nExercise 3.64:\n引数としてストリームと許容値の数値を取る手続\nstream-limit\nを書け。差の絶対値が許容値未満である\n2\nつの連続\nする要素を見つけるまでストリームを検査し、その\n2\nつの要素の\n2\n番目を返す。これを用いて与えられた許容誤差以内の平方根を求\nめることができるだろう。\n(\ndefine\n(\nsqrt\nx\ntolerance\n)\n(\nstream-limit\n(\nsqrt-stream\nx\n)\ntolerance\n))\nExercise 3.65:\n以下の級数を用いて、\n푙푛 2 = 1 −\n1\n2\n+\n1\n3\n−\n1\n4\n+ ...\n휋\nに対して上で行ったのと同様に、\n2\nの自然対数の近似値を\n3\n種の\n近似値の列を求めよ。これらの列はどれだけ早く収束するか\n?\nペアの無限ストリーム\nSection 2.2.3\nにおいて列パラダイムがどのように伝統的な入れ子ループを\nペアの列上に定義された手続として扱うかについて学びました。もしこのテク\nニックを無限ストリームに対しても一般化すれば簡単には繰り返しとしては表\n現されないプログラムを書くことができます。なぜなら\n“\nループ\n”\nを無限集合\nの範囲にも渡らせなければなりません。\n例えば\nSection 2.2.3\nの\nprime-sum-pairs\n手続を一般化して、整数全てのペ\nア\n(푖, 푗)\n、但し\n푖 ≤ 푗\nで\n푖 + 푗\nが素数である場合のストリームを生成します。もし\nint-pairs\nが\n푖 ≤ 푗\nにおける全ての整数のペア\n(푖, 푗)\nの列であるのならば、私\n達が必要とするストリームは単純に以下のように定義されます。\n65\n(\nstream-filter\n(\nlambda\n(\npair\n) (\nprime?\n(+ (\ncar\npair\n) (\ncadr\npair\n))))\nint-pairs\n)\n65\nSection 2.2.3\nにもある通り、私達は整数のペアを\nLisp\nのペアではなく、リストにて\n表現します。\n362","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":388},{"id":"./test/fixtures/pdf/sicp.pdf:389","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"すると問題は\nint-pairs\nストリームを生成することになります。より一般的に\nは、\n2\nつのストリーム、\n푆 = (푆\n푖\n)\nと\n푇  = (푇\n푗\n)\nを持っているとした場合に、無限\nの長方形の配列を想像してみて下さい。\n(푆\n0\n, 푇\n0\n)    (푆\n0\n, 푇\n1\n)    (푆\n0\n, 푇\n2\n)    ...\n(푆\n1\n, 푇\n0\n)    (푆\n1\n, 푇\n1\n)    (푆\n1\n, 푇\n2\n)    ...\n(푆\n2\n, 푇\n0\n)    (푆\n2\n, 푇\n1\n)    (푆\n2\n, 푇\n2\n)    ...\n...\n配列内の、対角線上かその上部の全てのペアを含むストリームを生成したいと\n考えます。つまり、以下のペアです。\n(푆\n0\n, 푇\n0\n)    (푆\n0\n, 푇\n1\n)    (푆\n0\n, 푇\n2\n)    ...\n(푆\n1\n, 푇\n1\n)    (푆\n1\n, 푇\n2\n)    ...\n(푆\n2\n, 푇\n2\n)    ...\n...\n(\nもし\n푆\nと\n푇\nの両方を整数のストリームとして取るなら、これが望んだストリ\nーム\nint-pairs\nです。\n)\n一般的なペアのストリームを\n(pairs S T)\nと呼び、それが\n3\nつの部分から\n組み立てられていると考えます。ペア\n(푆\n0\n, 푇\n0\n)\n、最初の行の残りのペア、残り\nのペアです。\n66\n(푆\n0\n, 푇\n0\n)\n(푆\n0\n, 푇\n1\n)    (푆\n0\n, 푇\n2\n)    ...\n(푆\n1\n, 푇\n1\n)    (푆\n1\n, 푇\n2\n)    ...\n(푆\n2\n, 푇\n2\n)    ...\n...\nこの分解の\n3\nつ目の断片\n(\n最初の行にないペア\n)\nは\n(\n再帰的に\n)\n(stream-cdr\nS)\nと\n(stream-cdr T)\nから形成されることに注意して下さい。また\n2\n番目の断\n片\n(\n最初の行の残り\n)\nは以下により求められます。\n(\nstream-map\n(\nlambda\n(\nx\n) (\nlist\n(\nstream-car\ns\n)\nx\n))\n(\nstream-cdr\nt\n))\n従って私達のペアのストリームは以下により形成できます。\n(\ndefine\n(\npairs\ns\nt\n)\n(\ncons-stream\n66\nなぜ私達が分解を選ぶのかについての見識については\nExercise 3.68\nを参照して下さ\nい。\n363","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":389},{"id":"./test/fixtures/pdf/sicp.pdf:390","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlist\n(\nstream-car\ns\n) (\nstream-car\nt\n))\n(\n⟨\ncombine-in-some-way\n⟩\n(\nstream-map\n(\nlambda\n(\nx\n) (\nlist\n(\nstream-car\ns\n)\nx\n))\n(\nstream-cdr\nt\n))\n(\npairs\n(\nstream-cdr\ns\n) (\nstream-cdr\nt\n)))))\n手続を完成させるためには、\n2\nつの内部ストリームを接続する何らかの方法を\n選択せねばなりません。アイデアの\n1\nつは\nSection 2.2.1\nの\nappend\n手続の類似ス\nトリームを用いる方法です。\n(\ndefine\n(\nstream-append\ns1\ns2\n)\n(\nif\n(\nstream-null?\ns1\n)\ns2\n(\ncons-stream\n(\nstream-car\ns1\n)\n(\nstream-append\n(\nstream-cdr\ns1\n)\ns2\n))))\nしかし、これは無限ストリームには不適切です。なぜならばこれは最初のスト\nリームからの要素を全て、\n2\nつ目のストリームとの合併前に取ります。具体的\nには、もし全ての正の整数のペアを以下のようにして生成しようとすると、\n(\npairs\nintegers\nintegers\n)\n結果のストリームは最初に\n1\n番目の整数が\n1\nの場合の全てのペアを通して実行\nしようとします。そしてそれ故に\n1\n番目の整数が他の値のペアを全く生成する\nことができません。\n無限ストリームを扱うためには、プログラムを十分に長く実行したならば\n全ての要素がいつかは得られることを保証する組み合わせの順を工夫する必要\nがあります。これを達成する洗練された方法は以下の\ninterleave\n(\n相互配置\n)\n手続を用います。\n67\n(\ndefine\n(\ninterleave\ns1\ns2\n)\n(\nif\n(\nstream-null?\ns1\n)\ns2\n(\ncons-stream\n(\nstream-car\ns1\n)\n(\ninterleave\ns2\n(\nstream-cdr\ns1\n)))))\n67\n組み合わせの順に要求された属性を正しく上げると次にようになります。\n2\nつの引数\nを取る関数が必須であり、最初のストリームの要素\n푖\nと\n2\nつ目のストリームの要素\n푗\nに\n対応するペアは出力ストリームの\n푓(푖, 푗)\n番目として現れます。\ninterleave\nを用いてこ\nれを達成するトリックは、\nKRC\n言語にこれを採用した\nDavid Turner\nにより示されまし\nた。\n(\nTurner 1981\n)\n364","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":390},{"id":"./test/fixtures/pdf/sicp.pdf:391","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"interleave\nは\n2\nつのストリームから交代に要素を得るため、\n2\nつ目のストリー\nムの各要素がいつかは相互配置ストリームへ入ることが、例え最初のストリー\nムが無限でもわかります。\n従って要求されたペアのストリームを以下のように生成できます。\n(\ndefine\n(\npairs\ns\nt\n)\n(\ncons-stream\n(\nlist\n(\nstream-car\ns\n) (\nstream-car\nt\n))\n(\ninterleave\n(\nstream-map\n(\nlambda\n(\nx\n) (\nlist\n(\nstream-car\ns\n)\nx\n))\n(\nstream-cdr\nt\n))\n(\npairs\n(\nstream-cdr\ns\n) (\nstream-cdr\nt\n)))))\nExercise 3.66:\nストリーム\n(pairs integers integers)\nを試験せ\nよ。\npairs\nがストリーム内に配置する順について全体的なコメント\nを行え。例えばペア\n(1, 100)\nの前にはおよそどれだけの数のペアが\n先行するか\n? (99, 100)\nと\n(100, 100)\nの場合についても答えよ。\n(\nも\nし正確な数学上の説明ができるなら、なおさら良い。しかし行き\n詰まったと感じるのならばより程度的な回答を気楽に上げて欲し\nい。\n)\nExercise 3.67:\npairs\n手続を変更し、\n(pairs integers integers)\nが全ての整数のペア\n(푖, 푗)\nを\n(\n푖 ≤ 푗\nという条件無しで\n)\n生成するよ\nうにせよ。ヒント：追加のストリームを混ぜ合わせる必要がある。\nExercise 3.68:\nLouis Reasoner\nは\n3\nつの部分からペアストリーム\nを構築することは不必要に複雑なのではないかと考えた。最初の\n行のペア\n(푆\n0\n, 푇\n0\n)\nを残りのペアから分離する代わりに、以下のよ\nうに最初の行全体を用いて行うことを提案した。\n(\ndefine\n(\npairs\ns\nt\n)\n(\ninterleave\n(\nstream-map\n(\nlambda\n(\nx\n) (\nlist\n(\nstream-car\ns\n)\nx\n))\nt\n)\n(\npairs\n(\nstream-cdr\ns\n) (\nstream-cdr\nt\n))))\nこれはうまく行くだろうか\n?\n(pairs integers integers)\nを\nLouis\nの\npairs\nの定義を用いて評価した場合に何が起こるか考えよ。\n365","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":391},{"id":"./test/fixtures/pdf/sicp.pdf:392","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 3.69:\n3\nつの無限ストリーム、\n푆\n,\n푇\n,\n푈\nを取り、三つ組\n(푆\n푖\n, 푇\n푗\n, 푈\n푘\n)\nのストリームを生成する手続\ntriples\nを書け。但し\n푖 ≤ 푗 ≤ 푘\nとする。\ntriples\nを用いて全ての正の整数のピタゴラス\n数の\n3\nつ組のストリームを生成せよ。すなわち三つ組\n(푖, 푗, 푘)\nは\n푖 ≤ 푗\n、かつ\n푖\n2\n+ 푗\n2\n= 푘\n2\nである。\nExercise 3.70:\nアドホック\n(\nその場その場\n)\nな相互配置処理の結果\nの順ではなく、ペアが何らかの便利な順で現れるストリームを生\n成できれば便利だろう。もし整数の\n1\nつのペアが別のペアよりも\n“\n小さい\n”\nと言える方法を定義できるならば\nExercise 3.56\nの\nmerge\n手続に似たテクニックを用いることができる。これを行う\n1\nつの\n方法は\n“\n重み関数\n”\n푊 (푖, 푗)\nを定義し\n푊 (푖\n1\n, 푗\n1\n) < 푊 (푖\n2\n, 푗\n2\n)\nである\nなら\n(푖\n1\n, 푗\n1\n)\nは\n(푖\n2\n, 푗\n2\n)\n未満であると取り決める。\nmerge\nに似た手\n続\nmerge-weighted\nを書け。ただし\nmerge-weighted\nは追加の引数\nweight\nを取り、\nweight\nはペアの重みを計る手続でありマージされ\nた結果のストリームの中でどの要素が現れるべきかの順を決定す\nるのに利用される。\n68\n重み関数を計算する手続と一緒にこれを用\nいて、\npairs\nを\n2\nつのストリームを取る手続\nweighted-pairs\nに一\n般化し、重みに従った順のペアのストリームを生成する。作成し\nた手続を用いて以下を生成せよ。\na\n全ての正の整数のペア\n(푖, 푗)\nのストリームを\n푖 ≤ 푗\nの条件で、\n和\n푖 + 푗\nに従った順で生成する\nb\n全ての正の整数のペア\n(푖, 푗)\nのストリームを\n푖 ≤ 푗\nかつ\n푖\nと\nmathj\nがどちらも\n2, 3, 5\nで割り切れない条件で、和\n2푖+3푗+5푖푗\nに従う順序で生成する\nExercise 3.71:\n2\nつの立方数の和で表す方法が複数ある数は時\n折\nRamanujan numbers\n(\nラマヌジャン数\n)\nと呼ばれる。これは数学\n者\nSrinivasa Ramanujan(\nシュリニヴァーサ・ラマヌジャン\n)\nに敬\n意を表している。\n69\nペアの順序有りストリームはこれらの数を計\n算する問題に対し洗練された解法を提供する。\n2\nつの立方数の和\n68\nペアの重みがペアの配列の中で行に沿って外へ動くか、列に沿って下った場合に増\nえるように重み関数に対して要求するだろう。\n69\nG. H. Hardy(\nゴッドフレイ・ハロルド・ハーディ\n)\nによるラマヌジャンの死亡告知\n(\nHardy 1921\n)\nから引用すれば、\n“Mr. Littlewood\nこそが\n‘\n全ての自然数が彼の友達であっ\nた\n’\nと述べられた\n(\n私が信じる\n)\n人だ。私は彼が\nPutney\nで病気で倒れた時に\n1\n度会いに\n行った。その時私は車番\n1729\nのタクシーに乗ったのでとてもつまらない数に見えたと\n366","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":392},{"id":"./test/fixtures/pdf/sicp.pdf:393","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"として表現する方法が\n2\nつある数を見付けるためには、\n푖\n3\n+ 푗\n3\nの\n和に従い重み付けられた整数のペア\n(푖, 푗)\nのストリームを生成し\n(\nExercise 3.70\n参照\n)\n、次にストリームから同じ重みを持つ連続した\nペアを探すだけで良い。ラマヌジャン数を生成する手続を書け。そ\nのような最初の数は\n1,729\nである。次の\n5\nつは何か\n?\nExercise 3.72:\nExercise 3.71\nと同様な方法で\n2\nつの平方数の和とし\nて\n3\nつの異なる方法で書ける全ての数のストリームを生成せよ。\n(\nそれらがどのようにして、そう書けるのか示せ\n)\n。\n信号としてのストリーム\nストリームの議論を信号処理システムにおける\n“\n信号\n”\nの計算可能な同類で\nあると説明することから始めました。実際に、ストリームを用いて信号処理シ\nステムをとても直接的な方法でモデル化することができ、連続する時間区間の\n信号の値をストリームの連続する要素として表現します。例えば\nintegrator\n(\n積\n分器\n)\n、つまり\nsummer\n(\nアナログ加算器\n)\nを実装し、入力ストリーム\n푥 = (푥\n푖\n)\nと\n初期値\n퐶\n、小さな増分\n푑푡\nに対し、以下の合計を累算し、\n푆\n푖\n= 퐶 +\n푖\n∑\n푗=1\n푥\n푗\n푑푡\n値\n푆 = (푆\n푖\n)\nのストリームを返します。以下の\nintegral\n手続は\n(\nSection 3.5.2\n)\nの整数ストリームの\n“\n暗黙的なスタイル\n”\nの定義を思い出させます。\n(\ndefine\n(\nintegral\nintegrand\ninitial-value\ndt\n)\n(\ndefine\nint\n(\ncons-stream\ninitial-value\n(\nadd-streams\n(\nscale-stream\nintegrand\ndt\n)\nint\n)))\nint\n)\nFigure 3.32\nは\nintegral\n手続に相当する信号処理システムの絵です。入力スト\nリームは\n푑푡\nによりスケール\n(\n拡大\n)\nされ加算器を通して渡され、その出力は同\n告げ、それが良くない前触れでないことを祈ると伝えた。\n‘\nいいえ\n’\nと彼が答えた。\n‘\nそれ\nはとても面白い数です。それは\n2\nつの立方数の和により表現する方法が\n2\nつ有る最小の\n数です\n”’\nラマヌジャン数を生成する重み付けられたペアのトリックは\nCharles Leiserson\nにより私達に示されました。\n367","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":393},{"id":"./test/fixtures/pdf/sicp.pdf:394","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"add\ncons\ninitial-value\nintegral\ninput\nscale: dt\nFigure 3.32:\n信号処理システムとして見た\nintegral\n手続\nじ加算器に戻されます。\nint\nの定義内の自己参照が図では加算器の出力が入力\nの\n1\nつに接続されるフィードバックループにより反映されています。\nExercise 3.73:\n電子回路をストリームを用いて一連の時間の時系列\n電流や電圧の値を表すことでモデル化できる。例えば、抵抗値\n푅\nの抵抗と静電容量\n퐶\nのコンデンサから成る\nRC circuit\n(\nRC\n回路\n)\nを連続して持っているとする。入力された電流\n푖\nに対する回路の\n電圧レスポンス\n푣\nは\nFigure 3.33\nの式により決定し、その構造は添\n付の信号フロー図により示される。\n368","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":394},{"id":"./test/fixtures/pdf/sicp.pdf:395","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"v\nv\n0\ni\nR\nC\ni\n+\n--\nv\nscale: \nR\nintegral\nadd\nscale: \n1\nC\nv = v\n0\n +  \n1\n     \nidt \n+\n Ri\n0\nt\nC\nZ\nFigure 3.33:\nRC\n回路と対応する信号処理図\nこの回路をモデル化する手続\nRC\nを書け。\nRC\nは入力として\n푅\n,\n퐶\n,\n푑푡\nを取り、手続を返さねばならない。返り値の手続は入力として\n電流\n푖\nを表すストリームとコンデンサの初期電圧\n푣\n0\nを取り、出力\nとして電圧\n푣\nのストリームを生成する。例えば\nRC\nを用いて\n푅\nが\n5[Ω]\n、\n퐶\nが\n1[F]\n、タイムステップが\n0.5\n秒の\nRC\n回路を\n(define\nRC1 (RC 5 1 0.5))\nを評価することでモデル化できなければなら\nない。これは\nRC1\nを電流の時系列を表すストリームとコンデンサ\nの初期電圧を取り電圧の出力ストリームを生成する。\nExercise 3.74:\nAlyssa P. Hacker\nは物理センサから来る信号を処理\nするシステムを設計している。彼女が作りたい重要な機能は入力\n信号の\nzero crossings\n(\nゼロ交差\n)\nを記録する信号である。結果の信\n号は入力信号が負から正に変わった時に\n+1\n、正から負に変わった\n時に\n−1\n、その他の場合は\n0\nである。\n(\n入力が\n0\nの場合の符号は正\nとする\n)\n。例えば典型的な入力信号とその関連するゼロ交差信号は\n以下のようになる。\n...\n1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4\n...\n...\n0 0  0  0  0    -1    0  0  0    0    1  0 0\n...\n369","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":395},{"id":"./test/fixtures/pdf/sicp.pdf:396","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Alyssa\nのシステムではセンサからの信号はストリーム\nsense-data\nで表され、ストリーム\nzero-crossings\nが関連するゼロ交差のスト\nリームである。\nAlyssa\nは最初に手続\nsign-change-detector\nを書\nいた。これは\n2\nつの値を引数として取り値の符号を比べ値に対応\nした\n0, 1, -1\nを生成する。次にゼロ交差ストリームを以下のように\n構築した。\n(\ndefine\n(\nmake-zero-crossings\ninput-stream\nlast-value\n)\n(\ncons-stream\n(\nsign-change-detector\n(\nstream-car\ninput-stream\n)\nlast-value\n)\n(\nmake-zero-crossings\n(\nstream-cdr\ninput-stream\n)\n(\nstream-car\ninput-stream\n))))\n(\ndefine\nzero-crossings\n(\nmake-zero-crossings\nsense-data\n0))\nAlyssa\nの上司、\nEva Lu Ator\nが歩み寄り、このプログラムは以下\nの、\nExercise 3.50\nの\nstream-map\nを一般化した版を使用した物とほ\nぼ同じであると提案した。\n(\ndefine\nzero-crossings\n(\nstream-map\nsign-change-detector\nsense-data\n⟨\nexpression\n⟩\n))\n⟨\nexpression\n⟩\nで示された部分を与えてプログラムを完成させよ。\nExercise 3.75:\n残念なことに、\nExercise 3.74\nの\nAlyssa\nのゼロ交差判\n別器は十分でないことが証明された。センサからのノイズの多い信\n号が誤ったゼロ交差へと導くためである。ハードウェアのスペシ\nャリスト、\nLem E. Tweakit\nは\nAlyssa\nにゼロ交差を試験する前にノ\nイズを排除するために信号を滑らかにすることを提案した。\nAlyssa\nは彼のアドバイスを受け入れ、センサのデータの各値を前の値と\nの平均を取ることで構築された信号からゼロ交差を抽出すること\nを決めた。彼女は問題を彼女のアシスタント、\nLouis Reasoner\nに\n370","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":396},{"id":"./test/fixtures/pdf/sicp.pdf:397","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"伝えた。彼はその考えを実装しようと試み、\nAlyssa\nのプログラム\nを以下のように変更した。\n(\ndefine\n(\nmake-zero-crossings\ninput-stream\nlast-value\n)\n(\nlet\n((\navpt\n(/ (+ (\nstream-car\ninput-stream\n)\nlast-value\n)\n2)))\n(\ncons-stream\n(\nsign-change-detector\navpt\nlast-value\n)\n(\nmake-zero-crossings\n(\nstream-cdr\ninput-stream\n)\navpt\n))))\nこれは\nAlyssa\nの計画を正しく実装していない。\nLouis\nが入れてし\nまったバグを見つけプログラムの構造を変更せずに直せ。\n(\nヒント：\nmake-zero-crossings\nの引数の数を増やす必要がある。\n)\nExercise 3.76:\nEva Lu Ator\nは\nExercise 3.75\nにおける\nLouis\nの取り\n組み方を批判した。彼が書いたプログラムはモジュラ化されてい\nない。滑らかにする操作とゼロ交差抽出が混ざってしまっている\nためである。例えば抽出器は\nAlyssa\nが入力信号を調整するより良\nい手段を見つければ変更する必要が無かった。\nLouis\nを手助けし、\n入力としてストリームを取り、\n2\nつの連続する入力ストリームの要\n素の平均を要素とするストリームを生成する手続\nsmooth\nを書け。\n次に\nsmooth\nをゼロ交差判定機を実装するためのコンポーネントと\nしてよりモジュラー化スタイルにて用いよ。\n3.5.4\nストリームと遅延評価\n先の節の終わりの\nintegral\n手続はどのようにストリームを用いてフィー\nドバックループを持つ信号処理システムをモデル化できるかを示しています。\nFigure 3.32\nに示される加算器のフィードバックループは\nintegral\nの内部スト\nリーム\nint\nがそれ自身を用いて定義されている事実によりモデル化されてい\nます。\n(\ndefine\nint\n(\ncons-stream\ninitial-value\n371","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":397},{"id":"./test/fixtures/pdf/sicp.pdf:398","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"y\n0\ndy\ny\nintegral\nmap: \nf\nFigure 3.34:\n方程式\n푑푦/푑푡 = 푓 (푦)\nを解く\n“\nアナログ演算回\n路\n”\n(\nadd-streams\n(\nscale-stream\nintegrand\ndt\n)\nint\n)))\n暗黙的定義のような物を扱うインタプリタの能力は\ncons-stream\nに組込まれ\nている\ndelay\nに依存している。この\ndelay\n無しではインタプリタは、\nint\nが\n既に定義されていることを要件とする\ncons-stream\nへの引数両方を評価する\n前には\nint\nを構築することができませんでした。一般的に、\ndelay\nはストリ\nームを用いてループを含む信号処理システムをモデル化するのに不可欠です。\ndelay\n無しでは任意の信号処理コンポーネントへの入力が、出力を生成する前\nに完全に評価されるように、私達のモデルが定式化されなければなりません。\n残念なことに、ループを伴うシステムのストリームモデルは\ncons-stream\nに\nより提供される\n“\n隠れた\n”\ndelay\nを越えて、\ndelay\nの使用を要求します。例え\nば\nFigure 3.34\nは\n푓\nが与えられた関数である場合に微分方程式信号\n푑푦/푑푡 = 푓(푦)\nを解く処理システムを示しています。図は\n푓\nをその入力信号に適用するマッピ\nングコンポーネント\n(map)\nを示しています。\nmap\nはフィードバックループの\n中に積分器へ向けて実際にそのような方程式を解くために利用されているアナ\nログ計算機回路にとても似た作法で接続されています。\n푦\nに対し初期値\n푦\n0\nを与えられたとした時、このシステムを以下の手続を用\nいてモデル化を試みることができるでしょう。\n(\ndefine\n(\nsolve\nf\ny0\ndt\n)\n(\ndefine\ny\n(\nintegral\ndy\ny0\ndt\n))\n(\ndefine\ndy\n(\nstream-map\nf\ny\n))\ny\n)\n372","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":398},{"id":"./test/fixtures/pdf/sicp.pdf:399","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この手続はうまく行きません。\nsolve\nの最初の行にて\nintegral\nの呼出は入力\ndy\nが定義されてることを要求します。これは\nsolve\nの二行目までは起こり得\nません。\n一方で、私達の定義の意図もつじつまが合いません。原理上は、\ny\nストリー\nムを\ndy\nを知らずに生成し始めることができます。再に\nintegral\nや他の多く\nのストリーム命令は\ncons-stream\nに、引数に関する部分的な情報を与えられた\nだけで応答の部分を生成できるという点で似た性質を持っています。\nintegral\nでは出力ストリームの最初の要素は\ninitial-value\nで与えられます。従って出\n力ストリームの最初の要素を被積分関数\ndy\nを評価せずに生成することができ\nます。一度\ny\nの最初の要素を知ることができれば、\nsolve\nの\n2\n行目の\nstream-\nmap\nは\ndy\nの最初の要素を生成する仕事を開始できます。これにより\ny\nの次の\n要素を生成することもでき、以下繰り返しとなります。\nこの考えの利点を得るために、\nintegral\nを再定義し、被積分関数ストリー\nムが\ndelayed argument\n(\n遅延引数\n)\nを要求するようにします。\nIntegral\nは出力\nストリームの最初の要素より多くを生成することを要求された時のみ、被積分\n関数を\nforce\nし評価させます。\n(\ndefine\n(\nintegral\ndelayed-integrand\ninitial-value\ndt\n)\n(\ndefine\nint\n(\ncons-stream\ninitial-value\n(\nlet\n((\nintegrand\n(\nforce\ndelayed-integrand\n)))\n(\nadd-streams\n(\nscale-stream\nintegrand\ndt\n)\nint\n))))\nint\n)\nこれで\nsolve\n手続の実装が、\ny\nの定義内で\ndy\nを遅延させればできます。\n70\n(\ndefine\n(\nsolve\nf\ny0\ndt\n)\n(\ndefine\ny\n(\nintegral\n(\ndelay\ndy\n)\ny0\ndt\n))\n(\ndefine\ndy\n(\nstream-map\nf\ny\n))\ny\n)\n全体的に、\nintegral\nを呼び出す者は今では被積分関数を\ndelay\nしなければな\nりません。\n푒 ≈ 2.718\nの近似値を微分方程式\n푑푦/푑푡 = 푦\nに対する解が\n푦 = 1\nの場\n70\nこの手続は全ての\nScheme\n実装で動くことが保証されていません。とはいえ、任意の\n実装に対して簡単な変更で動作します。問題は\nScheme\n実装の内部定義の扱い方に関係\nがあります。\n(\nSection 4.1.6\n参照\n)\n373","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":399},{"id":"./test/fixtures/pdf/sicp.pdf:400","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"合の値を初期条件\n푦(0) = 1\nで求めることで\nsolve\n手続がうまく働くことを実\n演できます。\n(\nstream-ref\n(\nsolve\n(\nlambda\n(\ny\n)\ny\n) 1 0.001) 1000)\n2.716924\nExercise 3.77:\n上で使用された\nintegral\n手続は\nSection 3.5.2\nの整\n数無限ストリームの\n“\n暗示的\n”\n定義に似ている。代替的に、より\nintegers-starting-from\nに似た\nintegral\nの定義を与えることが\nできない。\n(\nこれも\nSection 3.5.2\n参照\n)\n(\ndefine\n(\nintegral\nintegrand\ninitial-value\ndt\n)\n(\ncons-stream\ninitial-value\n(\nif\n(\nstream-null?\nintegrand\n)\nthe-empty-stream\n(\nintegral\n(\nstream-cdr\nintegrand\n)\n(+ (*\ndt\n(\nstream-car\nintegrand\n))\ninitial-value\n)\ndt\n))))\nループを持つシステム内で利用された場合、この手続は\nintegral\nの元の版が抱えた問題と同じ問題を持つ。手続をを変更して\nintegrand\nに対し遅延された引数を要求するようにし、それ故に\n上で示されたように\nsolve\n手続で利用できるようにせよ。\nExercise 3.78:\n単項二次線形微分方程式を学ぶための信号処理シス\nテムの設計問題について考えよ。\n푑\n2\n푦\n푑푡\n2\n− 푎\n푑푦\n푑푡\n− 푏푦 = 0.\n푦\nをモデル化する出力ストリームはループを含むネットワークに\nより生成される。これは\n푑\n2\n푦/푑푡\n2\nの値が\n푦\nと\n푑푦/푑푡\nの値に依存し、\nこれらの両方が\n푑\n2\n푦/푑푡\n2\nを積分することにより決定されるからで\nある。\nFigure 3.35\nに示される図の符号化を行いたい。定数\n푎\n,\n푏\n,\n푑푡\nと初期値、\n푦\nに対する\n푦\n0\nと\n푑푦\n0\nを引数として取り、\n푦\nの一連の値\nのストリームを生成する手続\nsolve-2nd\nを書け。\n374","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":400},{"id":"./test/fixtures/pdf/sicp.pdf:401","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ddy\ny\n0\ndy\ny\nscale: \nb\nintegral\nintegral\nscale: \na\nadd\ndy\n0\nFigure 3.35:\n二次線形微分方程式の解のための信号フロー図\nExercise 3.79:\nExercise 3.78\nの\nsolve-2nd\n手続を一般化し、一般的\nな二次微分方程式\n푑\n2\n푦/푑푡\n2\n= 푓(푑푦/푑푡, 푦)\nを解くのに使用できるよ\nうにせよ。\nExercise 3.80:\nseries RLC circuit\n(\n連続\nRLC\n回路\n)\nは抵抗、コンデ\nンサ、インダクタンスが\nFigure 3.36\nに示されるように連結されて\nいる。\n푅\n,\n퐿\n,\n퐶\nが抵抗、インダクタンス、コンデンサである場合、\n3\nつのコンポーネントに対する電圧\n(\n푣\n)\nと電流\n(\n푖\n)\nの間の関係は以\n下の方程式により説明される。\n푣\n푅\n= 푖\n푅\n푅,\n푣\n퐿\n= 퐿\n푑푖\n퐿\n푑푡\n,\n푖\n퐶\n= 퐶\n푑푣\n퐶\n푑푡\n,\nそして回路の接続が以下の関係を決定する。\n푖\n푅\n= 푖\n퐿\n= −푖\n퐶\n,\n푣\n퐶\n= 푣\n퐿\n+ 푣\n푅\n.\nこれらの方程式の組み合わせは\n(\nコンデンサに渡る電圧\n푣\n퐶\nとイン\nダクタンスの電流\n푖\n퐿\nにてまとめれば\n)\n回路の状態が以下の微分方\n375","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":401},{"id":"./test/fixtures/pdf/sicp.pdf:402","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"+\n--\nv\nR\nR\ni\nR\nL\nv\nL\n+\n--\ni\nL\nC\ni\nC\nv\nC\n+\n--\nFigure 3.36:\n連続\nRLC\n回路\n程式のペアで説明されることを示している。\n푑푣\n퐶\n푑푡\n= −\n푖\n퐿\n퐶\n,\n푑푖\n퐿\n푑푡\n=\n1\n퐿\n푣\n퐶\n−\n푅\n퐿\n푖\n퐿\n.\nこの微分方程式のシステムを表す信号フロー図は\nFigure 3.37\nに示\nされる。\n引数として回路のパラメタ\n푅\n,\n퐿\n,\n퐶\nと時間の増分\n푑푡\nを取る手続\nRLC\nを書け。ある意味では\nExercise 3.73\nの\nRC\n手続のそれに似てい\nるが、\nRLC\nは状態変数の初期値\n푣\n퐶\n0\nと\n푖\n퐿\n0\nを取り、\n(\ncons\nを用い\nて\n)\n푣\n퐶\nと\n푖\n퐿\nの状態のストリームのペアを生成する手続を生成せ\nねばならない。\nRLC\nを用いて、連結\nRLC\n回路の振舞をモデル化す\nるストリームのペアを生成せよ。ただし\n푅\n= 1[Ω],\n퐶\n= 0.2[F],\n퐿\n= 1 henry,\n푑푡\n= 0.1[s], soreni\n初期値\n푖\n퐿\n0\n= 0[A],\n푣\n퐶\n0\n= 10[V]\nと\nする。\n正規順評価\nこの節の例は明示的な\ndelay\nと\nforce\nの使用がどのようにして大きなプロ\nグラミングの柔軟性を与えるかについて説明します。しかし同じ例がまたこの\nことがどのようにして私達のプログラムをより複雑にするかについても示しま\nす。例として私達の新しい\nintegral\n手続はループを伴うシステムをモデル化\nするための力を与えます。しかし今では\nintegral\nが遅延化された被積分関数\nと共に呼び出されなければならないことを忘れてはならなくなりました。そし\n376","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":402},{"id":"./test/fixtures/pdf/sicp.pdf:403","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"di\nL\nv\nC\n0\ni\nL\nv\nC\ndv\nC\ni\nL\n0\nscale: 1\n/L\nintegral\nscale:-1\n/C\nintegral\nscale:-\nR/L\nadd\nFigure 3.37:\n連続\nRLC\n回路の解のための信号フロー図\nて\nintegral\nを使用する全ての手続はこのことについて注意しなければなりま\nせん。実際には、手続の\n2\nつの組を作りました。通常の手続と遅延化された引\n数を取る手続です。一般的に、分離された手続の組を作ることは私達に分離さ\nれた高階手続の組もまた作ることを強います。\n71\n71\nこれは\nPascal\nの様な旧来の強い方の言語が高階手続をこなす場合に持つ困難さの\n(Lisp\nにとっては\n)\n小さな反射です。そのような言語ではプログラマは必ず各手続の引数\nと結果のデータ型を指定せねばなりません。数値、論理値、配列、等です。その結果と\nして\n“\n与えられた手続\nproc\nを列の全ての要素に\nmap\nする\n”\nような抽象化を\nstream-map\nのような単一の高階手続にて表すことができませんでした。それどころか\nproc\nに対し\nて指定されるかもしれない異なる引数と結果のデータ型の組み合わせ全てに対して異な\nるマッピング手続を必要としました。高階手続の存在における\n“\nデータ型\n”\nの実用的な概\n念を維持することは多くの困難な問題を提起しました。この問題を処理する\n1\nつの方法\nは言語\nML(\nGordon et al. 1979\n)\nにより説明され、その\n“\n多層データ型\n”\nはデータ型間の\n377","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":403},{"id":"./test/fixtures/pdf/sicp.pdf:404","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"2\nつの異なる手続の組の必要性を防ぐ\n1\nつの方法は全ての手続に対し遅延\n引数を取らせることです。手続に対する全ての引数が自動的に遅延化され、引\n数が実際に必要とされる時\n(\n例えばプリミティブ命令に要求された時\n)\n強制さ\nれる評価のモデルを受け入れることができるでしょう。これは私達の言語を正\n規順評価を用いるように変形します。これは私達が\nSection 1.1.5\nの評価の置換\nモデルを紹介した時、最初に説明しました。正規順評価への変換は統一、洗練\nされた方法で遅延評価の利用を簡易化します。そしてこれはストリーム処理の\nみについて考慮するのならば受け入れるべき自然な戦略です。\nSection 4.2\nでは\n評価機を学んだ後に、私達の言語をどのようにしてこのように変形するのかに\nついて学びます。残念なことに手続呼出に遅延を導入することはイベント順に\n依存するプログラムを設計する能力に混乱をもたらします。例えば代入を利用\nする、データを変更する、入出力を実行するプログラムです。例え\n1\nつの\ncons-\nstream\n内の\ndelay\nでも\nExercise 3.51\nや\nExercise 3.52\nで説明された大きな混乱\nを招きます。誰もが知っているように、変更可能性と遅延評価はプログラミン\nグ言語の中でうまく混ざりません。そしてこれらの両方を一度に取り扱う方法\nの発明は活発な研究領域です。\n3.5.5\n関数型プログラムのモジュール化とオブジェクトの\nモジュール化\nSection 3.1.2\nで学んだように、代入の導入の主な利点の\n1\nつは巨大システ\nムの状態の一部をローカル変数の中にカプセル化、または\n“\n隠す\n”\nことにより\nシステムのモジュール化の容易性を増すことができます。ストリームモジュー\nルは同等なモジュールの容易性を代入の使用成しに提供可能です。例として\n휋\nのモンテカルロ推定を再実装してみましょう。\nSection 3.1.2\nにてこれをストリ\nーム処理の視点から試しました。\nモジュール化容易性の鍵となる問題は、乱数生成器の内部状態を乱数を使\n用するプログラムから隠したいと願ったことです。手続\nrand-update\nから始め\nました。これの連続する値が私達の乱数を供給し、そしてこれを乱数生成器を\n作り出すのに使用しました。\n(\ndefine\nrand\n高階変換のためのテンプレートを含んでいます。さらに\nML\nのほとんどの手続データ型\nは明示的にプログラマにより宣言されることはありません。その代わりに\nML\nは\ntype-\ninferencing\n(\n型推論\n)\nメカニズムを含み、環境の情報を用いて新しく定義された手続のデ\nータ型を推論します。\n378","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":404},{"id":"./test/fixtures/pdf/sicp.pdf:405","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\nx\nrandom-init\n))\n(\nlambda\n()\n(\nset!\nx\n(\nrand-update\nx\n))\nx\n)))\nストリームの定式化においては乱数生成器が単体では存在しません。乱数のス\nトリームがただ\nrand-update\nを連続して呼ぶことで生成されます。\n(\ndefine\nrandom-numbers\n(\ncons-stream\nrandom-init\n(\nstream-map\nrand-update\nrandom-numbers\n)))\nこれを用いて乱数ストリームにおける連続したペア上で行われた\nCesàro(\nチェ\nザロ\n)\nの実験の結果のストリームを構築します。\n(\ndefine\ncesaro-stream\n(\nmap-successive-pairs\n(\nlambda\n(\nr1\nr2\n) (= (\ngcd\nr1\nr2\n) 1))\nrandom-numbers\n))\n(\ndefine\n(\nmap-successive-pairs\nf\ns\n)\n(\ncons-stream\n(\nf\n(\nstream-car\ns\n) (\nstream-car\n(\nstream-cdr\ns\n)))\n(\nmap-successive-pairs\nf\n(\nstream-cdr\n(\nstream-cdr\ns\n)))))\ncesaro-stream\nが次に\nmonte-carlo\n手続に与えられます。これは確率の推測の\nストリームを生成します。するとその結果は\n휋\nの推測値のストリームへと変換\nされます。このプログラムのこの版は何回試行を行うかのパラメタが必要あり\nません。より良い\n휋\nの推測値\n(\nより多くの試行からの\n)\nはより多くの\npi\nストリ\nームを見ることで得られます。\n(\ndefine\n(\nmonte-carlo\nexperiment-stream\npassed\nfailed\n)\n(\ndefine\n(\nnext\npassed\nfailed\n)\n(\ncons-stream\n(/\npassed\n(+\npassed\nfailed\n))\n(\nmonte-carlo\n(\nstream-cdr\nexperiment-stream\n)\npassed\nfailed\n)))\n(\nif\n(\nstream-car\nexperiment-stream\n)\n(\nnext\n(+\npassed\n1)\nfailed\n)\n(\nnext\npassed\n(+\nfailed\n1))))\n379","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":405},{"id":"./test/fixtures/pdf/sicp.pdf:406","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\npi\n(\nstream-map\n(\nlambda\n(\np\n) (\nsqrt\n(/ 6\np\n)))\n(\nmonte-carlo\ncesaro-stream\n0 0)))\n考慮すべきモジュール化容易性がこの取り組み方には存在します。なぜなら依\n然として任意の実験を取り扱うことが可能な一般的な\nmonte-carlo\n手続を定\n式化できるためです。その上、代入やローカル変数が存在しません。\nExercise 3.81:\nExercise 3.6\nは乱数生成器に乱数列のリセットを許\n可することで\n“\nランダム\n”\nな数の列を繰り返し生成させる一般化\nについて議論した。入力ストリームの要求に従い操作するこれと\n同じ生成器のストリーム定式化を実現せよストリームの要素が\ngenerate\nなら新しい乱数を生成し、また\nreset\nなら指定された値\nに列をリセットすることで希望の乱数列を生成する。代入は使用\nしないこと。\nExercise 3.82:\nExercise 3.5\nのモンテカルロ積分をストリームを用\nいて再度行え。ストリーム版の\nestimate-integral\nは何度試行を\n行うのか伝える引数は持たない。その代わり連続するより多くの\n試行を基に推測値のストリームを生成する。\n時間の関数型プログラミング的視点\nさて、この章の始めに提起されたオブジェクトと状態の問題に戻り新しい\n光の下で調査しましょう。私達は代入とミュータブルオブジェクトを導入し状\n態を持つシステムのモデル化を行うプログラムのモジュラー方式の構築のため\nの仕組みを提供しました。ローカル状態変数を持つ計算オブジェクトを構築し、\n代入を用いてこれらの変数を変更しました。世界のオブジェクトの一時的な振\n舞を相当する計算オブジェクトの一時的な振舞によりモデル化しました。\n今までストリームが局所状態を持つオブジェクトのモデル化する代替法を\n提供することを学んできました。何らかのオブジェクトの局所状態のような変\n化する数量を、連続する状態の時刻歴を表現するストリームを用いてモデル化\nできます。本質的に、私達はストリームを用いることで時間を明示的に表現し\nています。そうすることで私達のシミュレートされた世界の時間を評価の間に\n現れる一連のイベントから分断しています。実際に、\ndelay\nの存在のため、モ\nデルのシミュレートされた時間と評価中のイベントの順の間には何の関係も無\nいでしょう。\n380","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":406},{"id":"./test/fixtures/pdf/sicp.pdf:407","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これらの\n2\nつのモデル化の取り組み方を対比するために、\n“\n銀行の引き出し\n機\n”\nの実装について再考してみましょう。これは銀行口座の残高を監視します。\nSection 3.1.3\nではそのような処理機の単純化された版を実装しました。\n(\ndefine\n(\nmake-simplified-withdraw\nbalance\n)\n(\nlambda\n(\namount\n)\n(\nset!\nbalance\n(-\nbalance\namount\n))\nbalance\n))\nmake-simplified-withdraw\nへの呼出は計算オブジェクトを生成します。各計\n算オブジェクトは局所状態変数\nbalance\nを個別に持ち、そのオブジェクトを続\nけて呼ぶと\nbalance\nは減少します。銀行口座のユーザが連続したそのようなオ\nブジェクトに対する入力を打ち、ディスプレイの画面に表われる一連の返り値\nを観察するのを想像できます。\n代替的に、引き出し処理機を入力として残高と引き出す金額のストリーム\nを取り口座の一連の残高のストリームを生成する手続としてモデル化すること\nが可能です。\n(\ndefine\n(\nstream-withdraw\nbalance\namount-stream\n)\n(\ncons-stream\nbalance\n(\nstream-withdraw\n(-\nbalance\n(\nstream-car\namount-stream\n))\n(\nstream-cdr\namount-stream\n))))\nstream-withdraw\nは明確な数学上の関数を実装し、関数の出力はその入力のみ\nにより完全に決定します。しかし入力\namount-stream\nがユーザにより打鍵され\nた一連の値のストリームであり結果の残高ストリームが表示されたと考えてみ\nて下さい。すると、値を入力し結果を見ているユーザの視点からはストリーム\n処理が\nmake-simplified-withdraw\nにより作成されたかのように、同じ振舞を\nしています。しかしストリーム版では代入が無く、局所状態変数が無く、それ\n故に\nSection 3.1.3\nで遭遇した論理的な困難に存在しません。それにもかかわら\nずシステムは状態を持っています！\nこれは本当に驚くべきことです。\nstream-withdraw\nは明確な数学上の関数\nを実装しその振舞は代わらないのに、ここでのユーザの知覚はシステムとの相\n互作用の\n1\nつであり変化する状態を持ちます。このパラドックスを解決する\n1\nつの方法はユーザの一時的な存在がシステムに状態を与えていると認識するこ\nとです。もしユーザが相互作用から一歩離れて個々の取引でなく、残高のスト\nリームに関して考えれば、システムはステートレス\n(\n状態が無く\n)\nとして現われ\n381","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":407},{"id":"./test/fixtures/pdf/sicp.pdf:408","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"るでしょう。\n72\n複雑な処理のある部分の視点からは、他の部分は時間と共に変化するよう\nに見えます。それらは隠された時間と伴に変化する局所状態を持ちます。もし\n私達がこの種の自然な分解を私達の世界において\n(\n世界の一部である私達の視\n点から見たままに\n)\n計算機内のモデル化したプログラムを計算機内の構造を用\nいて書きたいのならば、関数型でない計算オブジェクトを作成します。それら\nは時間と共に変化します。状態を局所状態変数でモデル化し、そして状態の変\n化をそれらの変数への代入を用いてモデル化します。これを行うことにより計\n算の実行時間を、私達がその一部である世界の時間のモデルとし、従って私達\nは\n“\nオブジェクト\n”\nを計算機の中に得ることになります。\nオブジェクトを用いるモデリングは強力、かつ直感的です。その理由の多\nくはこれが私達がその一部である世界との相互作用の視点に合うためです。し\nかしこの章を通して繰り返し学んできた様に、これらのモデルは悩ましいイベ\nント順の制約とと複数の処理間の同期の問題を提起します。これらの問題を\n防ぐ可能性から\nfunctional programming languages\n(\n関数型プログラミング言語\n)\nの開発が促進されてきました。これは代入や変更可能なデータを提供しません。\nそのような言語では全ての手続は引数の明確な数学の関数を実装し、その振舞\nは変化しません。関数型の取り組み方は並行システムを扱うのにとても魅力的\nです。\n73\n一方で、もしきっちりと見てみれば時間に関係する問題が関数型のモデル\nにも潜んでいることが見えます。ある特に厄介な領域がインタラクティブシス\nテム\n(\n応答システム\n)\nを設計したい時に、特に独立した要素の間で相互作用を\n行うシステムにおいて提起されます。例として、もう\n1\n度連結銀行口座を許可\nする銀行システムについて考えてみましょう。代入とオブジェクトを用いる保\n守的なシステムでは、\nPeter\nと\nPaul\nが口座を共有しているという事実をモデル\n化します。共有は\nSection 3.1.3\nで見たように、\nPeter\nと\nPaul\nの両者が彼等の取\n引要求を同じ銀行口座オブジェクトに送ることにより行われます。ストリーム\nの視点からは、\n“\nオブジェクト\n”\nそれ自身は無いため、銀行口座を取引要求の\n操作を行う処理としてモデル化し、応答のストリームを生成できることが既に\n示されています。従って、\nPeter\nと\nPaul\nが連結銀行口座を持つことが、\nFigure\n72\n物理でも同様に、私達が移動点を観察する時、点の位置\n(\n状態\n)\nは変化していると言\nえます。しかし、移動点の時空の世界線の視点からは何の変化も起こってはいません。\n73\nFortran\nの開発者である\nJohn Backus\nは\n1978\n年に\nacm\nのチューリング賞を授与さ\nれた時に関数型プログラミングに高い知名度を与えました。彼の受賞スピーチ\n(\nBackus\n1978\n)\nは関数型のアプローチを強く支持しました。関数型プログラミングの良い概観\nは\nHenderson 1980\nと\nDarlington et al. 1982\nで与えられます。\n382","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":408},{"id":"./test/fixtures/pdf/sicp.pdf:409","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"merge\nbank\naccount\nPaul's requests\nPeter's requests\nFigure 3.38:\n取引要求リクエストの\n2\nつのストリームをマ\nージすることでモデル化した連結銀行口座\n3.38\nで示すように\nPeter\nの取引要求ストリームと\nPaul\nの取引要求リクエスト\nをマージし、その結果を銀行口座ストリーム処理へ渡すという事実をモデル化\nすることができるでしょう。\nこの定式化に伴う問題は\nmerge\n(\nマージ\n)\nという概念にあります。これは\n2\nつの\nストリームを単純に交互に\nPeter\nの要求を\n1\nつ、\nPaul\nの要求を\n1\nつと取りマー\nジすることはしません。\nPaul\nが口座にとても稀にしかアクセスしないと考えて\nみましょう。\nPeter\nに対し、彼が\n2\nつ目の取引を発行できる前に\nPaul\nが口座に\nアクセスするのを待つよう強いることはできません。しかしそのようなマージ\nが実装された場合、\nPeter\nと\nPaul\nにより知覚される\n“\n実時間\n”\nに制約された何\nらかの方法で\n2\nつの取引ストリームを相互配置しなければなりません。何らか\nの方法とはもし\nPeter\nと\nPaul\nが会えば、いくつかの取引が会う前に処理され、\n他の取引が会った後に処理されることに合意できるという意味でです。\n74\nこれ\nは正確に、\nSection 3.4.1\nで扱わねばならなかったのと同じ制約です。そこでは\n状態を持つオブジェクトの並行処理におけるイベントの\n“\n正しい\n”\n順を保証す\nる明示的な同期の導入の必要性が見つかりました。従って、関数型のスタイル\nをサポートする取り組みにおいて、異なる要因からの入力のマージの必要性は\n関数型のスタイルが排除するはずだった同じ問題を再び導入します。\n私達はこの章を、私達がモデル化しようとする実際の世界の私達の視点に\n合う構造を持つ計算モデルの構築をゴールとして始めました。世界を分離した、\n時間制約のある、相互応答する、状態を持つオブジェクトでモデル化できます。\nまたは世界を単一の、時間制約のない、状態の無い、個体によりモデル化でき\nます。それぞれの視点が強力な利点を持ちますが、どちらの視点も単独では十\n74\n任意の\n2\nつのストリームに対し一般的に複数の受け入れ可能な相互配置の順が存在\nすることに注意して下さい。従って技術的には\n“\nマージ\n”\nは関数ではなく関係です。その\n答は入力の決定的な関数ではありません。私達は既に\n(\nFootnote 39\n)\nで非決定論が並行\nの扱いの本質であると述べました。マージの関係は同じ本質的な非決定論を関数型の視\n点から説明します。\nSection 4.3\nでは非決定論をまた別の視点から見ることになります。\n383","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":409},{"id":"./test/fixtures/pdf/sicp.pdf:410","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"分ではありません。大統一は未だ現われてはいません。\n75\n75\nオブジェクトモデルは世界を分割し分離した部分にすることで近似します。関数型\nモデルはオブジェクト境界に従ってモジュラ化はしません。オブジェクトモデルは\n“\nオ\nブジェクト\n”\nの非共有下の状態が共有されている状態よりもとても大きい場合に便利で\nす。オブジェクトの視点が失敗する場合の例は量子力学です。そこでは物を個別の点と\nして考えることは逆説と混乱を招きます。オブジェクトの視点を関数型の視点と統一す\nることはプログラミングとはあまり関係が無いかもしれません。しかしより根本的な認\n識論の問題と関係するのです。\n384","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":410},{"id":"./test/fixtures/pdf/sicp.pdf:411","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4\nメタ言語抽象化\n...\n魔法とは言葉の中にある\n—\nアブラカダブラ、開けゴマ、その他\nもろもろ\n—\nしかしあるお話の魔法の言葉は次のお話では魔法では\nない。真の魔法とはどの言葉が、いつ、何に対して働くかを知るこ\nとだ。トリックを学ぶことがトリックなんだ。\n...\nそしてそれらの言葉は私達のアルファベットの文字から出来て\nいる。ペンで書ける\n2\n、\n3\nダースの走り書きだ。これが鍵なんだ！\nそして宝でもある、もしそれに手をつけることさえできれば！そ\nれはまるで\n—\nまるで宝の鍵こそが宝のようだ！\n—John Barth,\nChimera\nプログラム設計の学習において、エキスパートなプログラマが設計の複雑さを\n全ての複雑なシステムの設計者が用いるのと同じ一般的な技術を用いてコント\nロールすることを学んできました。彼等はプリミティブな要素を接続して複合\nオブジェクトを形成し、複合オブジェクトを抽象化することでより高いレベル\nの建築ブロックを形成しそして適切な大規模のシステム構造の見方を受け入れ\nることでモジュール化方式は維持しました。これらのテクニックの説明におい\nて、私達は\nLisp\nをプロセスを記述するための言語として用い、また計算データ\nオブジェクトと実世界の複雑な現象をモデル化する処理を構築するためにも用\nいてきました。しかし、複雑さを増す問題に取り組むにつれ、\nLisp\n、またはど\nのような固定されたプログラミング言語も、我々の必要には十分でないことを\n385","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":411},{"id":"./test/fixtures/pdf/sicp.pdf:412","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"知ることでしょう。私達は、私達の考えをより効果的に表現するために、耐え\nず新しい言語に向かわねばなりません。新しい言語を定めることは工学上の設\n計の複雑さをコントロールするための強力な戦略です。私達は良く、問題を異\nなった方法で記述できる\n(\nそしてそれ故に考えることができる\n)\n新しい言語を\n受け入れることで、複雑な問題への対処能力を拡張することができます。プリ\nミティブな、組み合わせの手段や抽象化の手段を、目前の問題に特によく合っ\nたものを用います。\n1\nプログラミングは数多くの言語により生じます。特定のコンピュータのた\nめの機械語のような物理言語も存在します。これらの言語は個別のストレージ\nの断片とプリミティブな機械命令を用いてデータとコントロールの表現に関係\nします。機械語プログラマは与えられたハードウェアの使用に関心を持つこと\nでリソースに限りある演算の効率的な実装のためのシステムとユーティリティ\nを組み立てます。高級言語は機械語の素地の上にありますが、データをビット\nの集合として表したり、プログラムをプリミティブな命令の列で表すという懸\n念を隠します。これらの言語は手続定義のような組み合わせと抽象化の手段を\n持ち大規模なシステム構成に適しています。\nMetalinguistic abstraction\n(\nメタ言語抽象化\n)—\n新しい言語を構築すること\n—\nが工学設計の全ての部門にて重要な役割を果たします。これは計算機プログ\nラミングでとても重要です。プログラミングでは新しい言語を形成するだけで\nなく、これらの言語を評価機を構築することで実装することもできるからです。\nプログラミング言語の\nevaluator\n(\n評価機\n)(\nまたは\ninterpreter\n(\nインタプリタ\n))\nは\n手続であり、言語の式に対して適用された時、その式を評価するために要求さ\nれる行動を実行します。\n1\n同じ考えが工学全てに渡り普及しています。例えば電子工学は多くの異なる言語を\n回路の記述に用います。これらの内\n2\nつは電子ネットワークの言語と電子システムの言\n語です。ネットワーク言語は別個の電子素子に関する装置の物理モデリングを重視しま\nす。ネットワーク言語のプリミティブなオブジェクトはプリミティブな抵抗や、キャパ\nシタ\n(\nコンデンサ\n)\n、コイルやトランジスタ等の電子コンポーネントであり電圧と電流と\n呼ばれる物理的変数を用いて特徴付けられます。回路をネットワーク言語で記述する時、\n技術者は設計の物理特性に関心を持ちます。逆に、システム言語のプリミティブなオブ\nジェクトはフィルタやアンプのような信号処理モジュールです。モジュールの機能上の\n振舞のみが関係し、信号はそれらの電圧や電流のような物理的な認識に関心を持ちませ\nん。信号処理システムの要素が電子ネットワークから構築される意味の上ではシステム\n言語はネットワーク言語の上に組み立てられます。しかしここでは関心事は与えられた\n応用問題を解くための大規模な電子装置の編成にあります。パーツの物理的実現可能性\nは当然と考えられています。この階層化された言語の集合は\nSection 2.2.4\nのピクチャー\n言語にて説明された階層化された設計テクニックのまた別の例になります。\n386","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":412},{"id":"./test/fixtures/pdf/sicp.pdf:413","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"プログラミングにおける考えで最も根本的な物と見做すことに何の誇張も\nありません。\n評価機はプログラミング言語の評価手段を決定するが、それ自体\nは別のプログラムである。\nこの点を理解することはプログラマとしての私達自身のイメージを変更するこ\nとです。私達は私達自身を、他人が設計した言語のユーザとしてのみではなく、\n言語の設計者として見る時点に辿りつきました。\n実際に、私達はほとんど全てのプログラムをある言語の評価機だと見做す\nことができます。例えば、\nSection 2.5.3\nの多項式操作システムは多項式の数値\n演算のルールを具象化し、リスト構造データ上の命令を用いて実装しました。\nもし私達がこのシステムを多項式を読み込み、表示する手続と共に拡張した\nなら、記号数学の問題を扱う特定目的言語のコア\n(\n核\n)\nを持つことになります。\nSection 3.3.4\nのデジタル論理シミュレータと\nSection 3.3.5\nの制約伝播はそれら\n自身の正しさにおける論理的言語であり、それぞれがそれ自身のプリミティブ\nと組み合わせの手段、抽象化の手段を持ちます。この視点から見れば大規模計\n算機システムをこなす技術は新しい計算機言語を構築する技術と結合し、計算\n機科学それ自身が適切な記述言語を構築する分野それ以上でも以下でもなくな\nります。\n私達は今から他言語を用いて言語が構築される技術を巡り始めます。この\n章では\nLisp\nを基盤として用い、評価機を\nLisp\nの手続として実装します。\nLisp\nはこの任務にとても良く合います。記号式を表現し、操作する能力がその理由\nです。私達は\nLisp\n自身の評価機を構築することで言語がどのように実装され\nているかを理解することから最初の一歩を踏み出します。私達の評価機により\n実装される言語はこの本で用いる\nLips\nの\nScheme\n方言の部分集合となります。\nこの章で説明される評価機が\nLisp\nの特定の方言に向けて書かれていても、逐\n次式計算機のプログラムを書くために設計された任意の式指向言語のための評\n価機の本質的な構造を含みます。\n(\n実際に、多くの言語処理機がそれらの奥深く\nに小さな\n“Lisp”\n評価機を含んでいるのです。\n)\n評価機は説明と議論のために簡\n略化されており、製品品質の\nLisp\nシステムに含まれるべき重要な機能が省略\nされています。それにもかかわらず、この単純な評価機はこの本に現われる多\nくのプログラムを実行するのに適しています。\n2\n2\n私達の評価機が取り除いた最も重要な機能はエラーを扱う仕組みとデバッグのサポ\nートです。評価機のより広範囲の議論については\nFriedman et al. 1992\nを参照して下さ\nい。これは\nScheme\nで書かれた一連の評価機を通して進められたプログラミング言語の\n解説を与えます。\n387","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":413},{"id":"./test/fixtures/pdf/sicp.pdf:414","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"評価機を\nLisp\nプログラムとして利用可能にする重要な利点は代替となる評\n価ルールを評価機プログラムへの変更として記述することで実装できること\nです。この力を良い効果として用いることが可能な箇所として、\nChapter 3\nの\n議論のまさに中心であった、計算モデルが時間の概念を統合する方法に対し特\n別なコントロールを得ることです。そこではストリームを用いて世界の時間表\n現を計算機の時間から分離することで、状態と代入の複雑さのいくらかを緩\n和しました。しかし、私達のストリームプログラムは時々扱いにくい物でし\nた。\nScheme\nの評価の適用順により制約されていたためです。\nSection 4.2\nではよ\nり洗練された取り組み方を準備するために、\nnormal-order evaluation\n(\n正規順評\n価\n)\nに対応する様に評価機を変更することで基盤となる言語を変更します。\nSection 4.3\nでは式が単一の値のみでなく多くの値を持つ場合において、よ\nり野心的な言語の変更を実装します。この\nnondeterministic computing\n(\n非決定\n的演算\n)\nの言語においては、式の全ての可能な値を生成する過程を生成し、次\nにそれらの値からいくつかの制約を充足する値を探索することが自然に表現で\nきます。。計算と時間のモデルにを用いれば、これは\n“\n可能な未来\n”\nの集合を成\nす時間の分岐を持ち、次に適切な時系列を探すような物です。私達の非決定的\n評価機を用いる複数の値の追跡と探索の実行は、根底に存在する言語の仕組み\nにより自動的に取り扱われます。\nSection 4.4\nでは\nlogic-programming\n(\n論理プログラミング\n)\n言語を実装します。\nそれにより知識が入出力を伴なう計算を用いてではなく、関係性を用いて表現\nされます。これは言語を\nLisp\nから、または本当に全ての従来の言語から大幅に\n異なる物にしますが、論理プログラミング評価機が\nLisp\n評価機の本質的な構\n造を共有することを学びます。\n4.1\nメタ循環評価機\n私達の\nLisp\n評価機は\nLisp\nプログラムとして実装されます。\nLisp\nプログラ\nムを\nLisp\nで実装された評価機を用いて評価することについて考えることは循\n環論に見えるかもしれません。しかし評価はプロセス\n(\n処理、過程\n)\nであり、従\nって評価過程を\nLisp\nを用いて説明することは適切です。\nLisp\nは結局の所、プ\nロセスを記述するためのツールなのです。\n3\n評価する対象と同じ言語で書かれ\n3\n例えそうだとしても、私達の評価機により説明されない評価プロセスの重要な側面\nが残ります。これらの最も重要なことは手続が他の手続を呼び出し、そしてそれらを呼\nび出した物に値を返す原因となる詳細な仕組みです。これらの問題は\nChapter 5\nで解明し\nます。そこで私達は評価機を簡単なレジスタマシンとして実装することで評価プロセス\n388","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":414},{"id":"./test/fixtures/pdf/sicp.pdf:415","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"た評価機は\nmetacircular\n(\nメタ循環\n)\nと呼ばれます。\nメタ循環評価機は本質的には\nSection 3.2\nで説明された評価の環境モデルの\nScheme\n形式化です。モデルには以下の\n2\nつの基本的パーツがあることを思い\n出して下さい\n1.\n組み合わせ\n(\n特殊な形式を除く複合式\n)\nを評価するためには、部分式を評\n価し、次にオペレータ部分式をオペランド部分式の値に適用する。\n2.\n複合手続を引数の集合に適用するためには、手続のボディを新しい環境\nで評価する。この環境を構築するためには、手続オブジェクトの環境部\n分をフレームにより拡張する。フレームの中ではその手続の形式パラメ\nタが、その手続が適用される引数に対して束縛される\nこれら\n2\nつのルールが評価プロセスの本質を説明します。環境の中で式が評価\nされる基本的なサイクルは引数に適用される手続に簡約され、引数は順に新し\nい環境で評価される新しい式へと簡約され、以下、値がその環境の中で見つか\nるシンボルか直接適用されるプリミティブな手続\n(\nFigure 4.1\n参照\n)\nに辿り着く\nまで繰り返されます。\n4\nこの評価サイクルは評価機内の\n2\nつの重大な手続、\neval\nと\napply\nの間の相\n互作用により具体化されます。これらの手続は\nSection 4.1.1\nにて説明されます。\n(\nFigure 4.1\n参照\n)\nにより詳細に調べます。\n4\nもし私達自身にプリミティブを適用する能力を与えるのであれば、評価機の実装に\nは何が残っているのでしょうか\n?\n評価機の仕事は言語のプリミティブを指定することで\nはなく、結合組織\n—\n組み合わせと抽象化の手段\n—\nを提供することであり、それがプリミ\nティブの集合を言語を形成するために束縛します。具体的には、\n•\n評価機は入れ子の式の取扱を許可します。例えば単純にプリミティブを適用するこ\nとは式\n(+ 1 6)\nを評価するのには十分ですが、\n(+ 1 (* 2 3))\nを取り扱うには十分では\nありません。プリミティブな手続\n+\nが対象である限り、その引数は数値でなければなら\nなず、もし式\n(* 2 3)\nを引数として渡せば失敗します。評価機の重要な役割の\n1\nつは手\n続合成を演出することで、\n(* 2 3)\nを\n+\nに引数として渡す前に\n6\nに簡約します。\n•\n評価機は変数の使用を許可します。例えば加算のためのプリミティブな手続は\n(+ x\n1)\nのような式に対応する手段を持ちません。私達は評価機に変数を追跡しその値をプリ\nミティブな手続を実行する前に得るようにする必要があります。\n•\n評価機は複合手続の定義を許可します。これは手続定義の追跡を含み、これらの手続\nを式評価においてどのように使用するかを知っています。そして手続に引数を受け入れ\nることを許可する仕組みを提供します。\n•\n評価機は特別な形式を提供します。これは手続呼出と異なった形で評価されねばな\nりません。\n389","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":415},{"id":"./test/fixtures/pdf/sicp.pdf:416","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Eval\nApply\nProcedure,\nArguments\nExpression,\nEnvironment\nFigure 4.1:\neval\n-\napply\nサイクルがコンピュータ言語の本質\nを顕在化させる\n評価機の実装は評価される式の\nsyntax\n(\n構文\n)\nを定義する手続に依存しま\nす。私達はデータ抽象化を用いて評価機を言語の表現に非依存にします。例\nえば代入はシンボル\nset!\nで始まるリストにより表現されるべきという選択に\n委ねるのではなく、代入のためのテストに抽象述語\nassignment?\nを用い、そ\nして代入の部品にアクセスするために抽象セレクタ\nassignment-variable\nと\nassignment-value\nを用います。式の実装については\nSection 4.1.2\nで詳細に説\n明されます。また\nSection 4.1.3\nで説明される\n“\n命令\n”\nもあり、これは手続と環境\nの表現を指定します。例えば\nmake-procedure\nは複合手続を構築し、\nlookup-\nvariable-value\nは変数の値にアクセスし、\napply-primitive-procedure\nはプ\nリミティブな手続を与えられた引数のリストに対し適用します。\n4.1.1\n評価機の核\n評価プロセスは\n2\nつの手続\neval\nと\napply\nの相互作用であると説明可能\nです。\nEval\neval\nは引数として式と環境を取ります。これは式と分類しその評価を監督\nします。\neval\nは評価される式の構文上の方の事例分析として構造化されます。\n390","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":416},{"id":"./test/fixtures/pdf/sicp.pdf:417","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"手続の一般性を保つため、式の型の決定を抽象的に表現し、多種の式に対する\nどんな特定の表現にも委託しません。式の各型はそれをテストする述語と、そ\nの部分を選択する抽象手段を持ちます。この\nabstract syntax\n(\n抽象構文\n)\nは同じ\n評価機を用いつつ、異なる構文手続の集合と合わせることで、言語の文法をど\nのようにして変更できるかについて知ることを簡単にします。\nプリミティブな式\n•\n数値のような自己評価式に対しては\neval\nは式それ自身を返す。\n•\neval\nは環境の中で変数をその値を見つけるために探さなければなら\nない。\n特別な形式\n•\nクォートされた式に対しては\neval\nはクォートされた式を返す。\n•\n変数への代入\n(\nまたは定義\n)\nは再帰的に\neval\nを呼び出し変数に関連付け\nられる新しい値を計算しなければならない。環境は変数の束縛を変更\n(\nま\nたは作成\n)\nしなければならない。\n•\nif\n式はその部品に対し特別な処理を要求する。もし述語が真であれば\nconsequent(\n結果\n)\nを評価し、そうでなければ\nalternative(\n代替\n)\nを評価す\nるためである。\n•\nlambda\n(\nラムダ\n)\n式は適用可能な手続に変形しなければならない。変形は\nラムダ式により指定されたパラメタとボディを評価の環境と共にパッケ\nージ化することにより行う。\n•\nbegin\n式はその一連の式をそれらが現れる順で評価する必要がある。\n•\n事例分析\n(\ncond\n)\nは入れ子の\nif\n式に変形し、それから評価する。\n組み合わせ\n•\n手続の適用に対して、\neval\nは再帰的に組み合わせの演算子とオペランド\nの部分を評価しなければならない。結果となる手続と引数は\napply\nに渡\nす。これは実際の手続適用を取り扱う。\n以下に\neval\nの定義を示します。\n(\ndefine\n(\neval\nexp\nenv\n)\n(\ncond\n((\nself-evaluating?\nexp\n)\nexp\n)\n((\nvariable?\nexp\n) (\nlookup-variable-value\nexp\nenv\n))\n((\nquoted?\nexp\n) (\ntext-of-quotation\nexp\n))\n391","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":417},{"id":"./test/fixtures/pdf/sicp.pdf:418","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"((\nassignment?\nexp\n) (\neval-assignment\nexp\nenv\n))\n((\ndefinition?\nexp\n) (\neval-definition\nexp\nenv\n))\n((\nif?\nexp\n) (\neval-if\nexp\nenv\n))\n((\nlambda?\nexp\n)\n(\nmake-procedure\n(\nlambda-parameters\nexp\n)\n(\nlambda-body\nexp\n)\nenv\n))\n((\nbegin?\nexp\n)\n(\neval-sequence\n(\nbegin-actions\nexp\n)\nenv\n))\n((\ncond?\nexp\n) (\neval\n(\ncond->if\nexp\n)\nenv\n))\n((\napplication?\nexp\n)\n(\napply\n(\neval\n(\noperator\nexp\n)\nenv\n)\n(\nlist-of-values\n(\noperands\nexp\n)\nenv\n)))\n(\nelse\n(\nerror\n\"\nUnknown\nexpression\ntype\n:\nEVAL\n\"\nexp\n))))\n明快さのために、\neval\nは\ncond\nを用いた条件分岐として実装されています。こ\nれの欠点は手続がいくつかの判別可能な式の型のみを取り扱い、\neval\nの定義を\n編集すること無しに新しい式が定義できないことです。多くの\nLisp\n実装では\n式の型に従う呼出はデータ適従スタイルにより行われています。これはユーザ\nに\neval\nが判別可能な新しい式の型の追加を許可します。\neval\n自身の定義の変\n更は必要有りません。\n(\nExercise 4.3\n参照\n)\nApply\napply\nは\n2\nつの引数、手続と手続が適用されるべき引数のリストを取りま\nす。\napply\nは手続を\n2\nつ種類に分類します。プリミティブの適用には\napply-\nprimitive-procedure\nを呼びます。複合手続の適用には手続のボディを作る式\nを連続して評価することにより行います。複合手続のボディの評価のための環\n境は手続により運ばれた基礎環境を拡張することで構築し、手続のパラメタを\n手続が適用される引数に束縛するフレームを含めます。以下が\napply\nの定義\nです。\n(\ndefine\n(\napply\nprocedure\narguments\n)\n(\ncond\n((\nprimitive-procedure?\nprocedure\n)\n(\napply-primitive-procedure\nprocedure\narguments\n))\n((\ncompound-procedure?\nprocedure\n)\n392","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":418},{"id":"./test/fixtures/pdf/sicp.pdf:419","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\neval-sequence\n(\nprocedure-body\nprocedure\n)\n(\nextend-environment\n(\nprocedure-parameters\nprocedure\n)\narguments\n(\nprocedure-environment\nprocedure\n))))\n(\nelse\n(\nerror\n\"\nUnknown\nprocedure\ntype\n:\nAPPLY\n\"\nprocedure\n))))\n手続の引数\neval\nが手続適用を処理する時、\nlist-of-values\nを用いて手続が適用され\nる引数のリストを生成します。\nlist-of-values\nは引数として組み合わせのオ\nペランドを取ります。各オペランドを評価し対応する値のリストを返します。\n5\n(\ndefine\n(\nlist-of-values\nexps\nenv\n)\n(\nif\n(\nno-operands?\nexps\n)\n'\n()\n(\ncons\n(\neval\n(\nfirst-operand\nexps\n)\nenv\n)\n(\nlist-of-values\n(\nrest-operands\nexps\n)\nenv\n))))\n条件文\neval-if\nは与えられた環境において\nif\n式の述語部分を評価します。もし結果\nが真なら\neval-if\nは\nconsequent(\n結果\n)\nを評価し、そうでなければ\nalternative(\n代\n替\n)\nを評価します。\n(\ndefine\n(\neval-if\nexp\nenv\n)\n(\nif\n(\ntrue?\n(\neval\n(\nif-predicate\nexp\n)\nenv\n))\n(\neval\n(\nif-consequent\nexp\n)\nenv\n)\n5\neval\nの\napplication?\n節は明示的に\nlist-of-values\n手続を書くのではなく、\nmap\nを\n用いることで\n(\nそして\noperands\nがリストを返すよう規定することで\n)\nより単純にするこ\nとができました。ここでは\nmap\nを用いないことを選択することで高階手続を用いなくと\nも、例え評価機がサポートする言語が高階手続をサポートすることになっても、評価機\nが実装できることを強調しました。\n(\n従って高階手続を持たない言語で評価機を書くこと\nも可能です\n)\n。\n393","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":419},{"id":"./test/fixtures/pdf/sicp.pdf:420","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\neval\n(\nif-alternative\nexp\n)\nenv\n)))\neval-if\n内での\ntrue?\nの使用は実装言語と被実装言語の間の接続の問題を強調\nします。\nif-predicate\nは被実装言語にて評価されるのでその言語の値を生じ\nます。インタプリタの述語\ntrue?\nはその値を実装言語の\nif\nでテストできる値\nに翻訳します。真実性のメタ循環表現は根底をなす\nScheme\nのそれとは同じで\nはないかもしれません。\n6\n列\neval-sequence\nは\napply\nにより用いられ手続のボディの中にある連続した\n式を評価します。また\neval\nでも使用され\nbegin\n式の中の一連の式を評価しま\nす。引数として一連の式と環境を取り、式が現われる順で評価します。返り値\nは最後の式の値です。\n(\ndefine\n(\neval-sequence\nexps\nenv\n)\n(\ncond\n((\nlast-exp?\nexps\n)\n(\neval\n(\nfirst-exp\nexps\n)\nenv\n))\n(\nelse\n(\neval\n(\nfirst-exp\nexps\n)\nenv\n)\n(\neval-sequence\n(\nrest-exps\nexps\n)\nenv\n))))\n代入と定義\n以下の手続は変数への代入を扱います。\neval\nを呼び代入される値を見つけ\n値と結果となる変数を\nset-variable-value!\nへ転送することで指定された環\n境へ設定されるようにします。\n(\ndefine\n(\neval-assignment\nexp\nenv\n)\n(\nset-variable-value!\n(\nassignment-variable\nexp\n)\n(\neval\n(\nassignment-value\nexp\n)\nenv\n)\nenv\n)\n'ok\n)\n6\n今回は実装言語と被実装言語は同じです。ここでの\ntrue?\nの意味に対する熟考は本\n質を誤解することなく理解の発展を促します。\n394","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":420},{"id":"./test/fixtures/pdf/sicp.pdf:421","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"変数の定義は同様の方法で扱われます。\n7\n(\ndefine\n(\neval-definition\nexp\nenv\n)\n(\ndefine-variable!\n(\ndefinition-variable\nexp\n)\n(\neval\n(\ndefinition-value\nexp\n)\nenv\n)\nenv\n)\n'ok\n)\nここで代入、または定義の値としてシンボル\nok\nを返すことを選択しました。\n8\nExercise 4.1:\nメタ循環評価機がオペランドを左から右へ評価する\nのか、右から左へなのか判断が付かないことに注意せよ。評価順\nは下位に横たわる\nLisp\nから継承する。もし\nlist-of-values\n内の\ncons\nの引数が左から右へ評価されるのなら、\nlist-of-values\nは\nオペランドを左から右へと評価する。もし\ncons\nの引数が右から左\nへ評価されるなら、\nlist-of-values\nは右から左へ評価する。\nオペランドを左から右へと下位に横たわる\nLisp\nの評価順に係らず\n評価する\nlist-of-values\nの版を書け。またオペランドを右から左\nへ評価する\nlist-of-values\nの版も書け。\n4.1.2\n式の表現\n評価機は\nSection 2.3.2\nで議論された記号微分プログラムを思い出させます。\n双方のプログラムが記号式を操作します。両方のプログラムにおいて、複合式\n上の操作の結果は式の断片を再帰的に操作し、式の型に依存した方法で結合す\nることにより決定します。両方のプログラムにおいて、私達はデータ抽象化を\n用いて式がどのように表現されるかの詳細から命令の一般的なルールを分離し\nます。微分プログラムではこのことが、同じ微分手続が接頭辞形式、接中辞形\n式、またはいくつかの他の形式の代数式を扱えることを意味しました。評価機\nにとっては、これは評価される言語の文法がもっぱら式を分類し、断片を抽出\nする手続により決定されることを意味します。\n以下に私達の言語の構文の仕様を示します。\n7\nこの\ndefine\nの実装は内部定義の扱いの微妙な問題を無視します。しかし多くの場合\nでは正しく動きます。問題が何か、どのようにして解決するかについては\nSection 4.1.6\nで\n学びます。\n8\ndefine\nと\nset!\nを導入した時に述べたように、これらの値は\nScheme\nの実装依存で\nす\n—\nつまり、実装者がどんな値を返すのか選択できます。\n395","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":421},{"id":"./test/fixtures/pdf/sicp.pdf:422","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n自己評価アイテムは数値と文字列のみです。\n(\ndefine\n(\nself-evaluating?\nexp\n)\n(\ncond\n((\nnumber?\nexp\n)\ntrue\n)\n((\nstring?\nexp\n)\ntrue\n)\n(\nelse\nfalse\n)))\n•\n変数はシンボルにより表現されます。\n(\ndefine\n(\nvariable?\nexp\n) (\nsymbol?\nexp\n))\n•\n引用は\n(quote <\ntext-of-quotation\n>)\nの形式を持ちます。\n9\n(\ndefine\n(\nquoted?\nexp\n) (\ntagged-list?\nexp\n'quote\n))\n(\ndefine\n(\ntext-of-quotation\nexp\n) (\ncadr\nexp\n))\nquoted?\nは手続\ntagged-list?\nを用いて定義されます。これはリストが\n指定されたシンボルで開始するかを判断します。\n(\ndefine\n(\ntagged-list?\nexp\ntag\n)\n(\nif\n(\npair?\nexp\n)\n(\neq?\n(\ncar\nexp\n)\ntag\n)\nfalse\n))\n•\n代入は\n(set! <\nvar\n> <\nvalue\n>)\nの形式を取ります。\n(\ndefine\n(\nassignment?\nexp\n) (\ntagged-list?\nexp\n'set!\n))\n(\ndefine\n(\nassignment-variable\nexp\n) (\ncadr\nexp\n))\n(\ndefine\n(\nassignment-value\nexp\n) (\ncaddr\nexp\n))\n•\n定義は以下の形式を取ります。\n(\ndefine\n⟨\nvar\n⟩\n⟨\nvalue\n⟩\n)\nまたは以下の形式になります。\n(\ndefine\n(\n⟨\nvar\n⟩\n⟨\n푝푎푟푎푚푒푡푒푟\n1\n⟩\n...\n⟨\n푝푎푟푎푚푒푡푒푟\n푛\n⟩\n)\n⟨\nbody\n⟩\n)\n9\nSection 2.3.1\nで述べたとおり、評価機は引用\n(quote)\nされた式を\nquote\nで始まるリス\nトだと見ます。例え式がクォーテーションマークで入力されていてもです。例えば式\n'a\nはこの評価機では\n(quote a)\nと見られます。\nExercise 2.55\nを参照して下さい。\n396","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":422},{"id":"./test/fixtures/pdf/sicp.pdf:423","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"後者の形式\n(\n標準手続定義\n)\nは以下に対する構文糖です。\n(\ndefine\n⟨\nvar\n⟩\n(\nlambda\n(\n⟨\n푝푎푟푎푚푒푡푒푟\n1\n⟩\n...\n⟨\n푝푎푟푎푚푒푡푒푟\n푛\n⟩\n)\n⟨\nbody\n⟩\n))\n対応する構文手続は以下となります。\n(\ndefine\n(\ndefinition?\nexp\n) (\ntagged-list?\nexp\n'define\n))\n(\ndefine\n(\ndefinition-variable\nexp\n)\n(\nif\n(\nsymbol?\n(\ncadr\nexp\n))\n(\ncadr\nexp\n)\n(\ncaadr\nexp\n)))\n(\ndefine\n(\ndefinition-value\nexp\n)\n(\nif\n(\nsymbol?\n(\ncadr\nexp\n))\n(\ncaddr\nexp\n)\n(\nmake-lambda\n(\ncdadr\nexp\n)\n; formal parameters\n(\ncddr\nexp\n))))\n; body\n•\nlambda\n式はシンボル\nlambda\nで始まるリストです。\n(\ndefine\n(\nlambda?\nexp\n) (\ntagged-list?\nexp\n'lambda\n))\n(\ndefine\n(\nlambda-parameters\nexp\n) (\ncadr\nexp\n))\n(\ndefine\n(\nlambda-body\nexp\n) (\ncddr\nexp\n))\nまた\nlambda\n式に対するコンストラクタも提供します。これは上記の\ndefinition-value\nで使用されます。\n(\ndefine\n(\nmake-lambda\nparameters\nbody\n)\n(\ncons\n'lambda\n(\ncons\nparameters\nbody\n)))\n•\n条件式は\nif\nで始まり述語、結果式、持ち、\n(\n任意で\n)\n代替式を持ちます。\nもし式が代替式の部分を持たないのであれば代替式として\nfalse\nを与え\nます。\n10\n10\n述語が\nfalse\nになり代替式が存在しない場合の\nif\n式の値は\nScheme\nでは未定義です。\nここでは私達は\nfalse\nにすることを選択しました。私達は変数\ntrue\nと\nfalse\nの式内での\n利用をサポートし、グローバル環境でのそれらの束縛により評価されるようにします。\nSection 4.1.4\n参照。\n397","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":423},{"id":"./test/fixtures/pdf/sicp.pdf:424","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nif?\nexp\n) (\ntagged-list?\nexp\n'if\n))\n(\ndefine\n(\nif-predicate\nexp\n) (\ncadr\nexp\n))\n(\ndefine\n(\nif-consequent\nexp\n) (\ncaddr\nexp\n))\n(\ndefine\n(\nif-alternative\nexp\n)\n(\nif\n(\nnot\n(\nnull?\n(\ncdddr\nexp\n)))\n(\ncadddr\nexp\n)\n'false\n))\nまた\nif\n式に対するコンストラクタも提供します。これは\ncond->if\nによ\nり\ncond\n式を\nif\n式に変換するのに用いられます。\n(\ndefine\n(\nmake-if\npredicate\nconsequent\nalternative\n)\n(\nlist\n'if\npredicate\nconsequent\nalternative\n))\n•\nbegin\nは一連の式を\n1\nつの式へとまとめます。\nbegin\n式から実際の列を\n取り出す命令と同時に、列の最初の式とその残りの式を返すセレクタも\n含まれます。\n11\n(\ndefine\n(\nbegin?\nexp\n) (\ntagged-list?\nexp\n'begin\n))\n(\ndefine\n(\nbegin-actions\nexp\n) (\ncdr\nexp\n))\n(\ndefine\n(\nlast-exp?\nseq\n) (\nnull?\n(\ncdr\nseq\n)))\n(\ndefine\n(\nfirst-exp\nseq\n) (\ncar\nseq\n))\n(\ndefine\n(\nrest-exps\nseq\n) (\ncdr\nseq\n))\nまた\ncond->if\nで用いるコンストラクタ\nsequence->exp\nも含めます。こ\nれは列を単一の式に、必要ならば\nbegin\nを用いて、変換します。\n(\ndefine\n(\nsequence->exp\nseq\n)\n(\ncond\n((\nnull?\nseq\n)\nseq\n)\n((\nlast-exp?\nseq\n) (\nfirst-exp\nseq\n))\n(\nelse\n(\nmake-begin\nseq\n))))\n(\ndefine\n(\nmake-begin\nseq\n) (\ncons\n'begin\nseq\n))\n•\n手続の適用は上記の式の型ではない任意の複合式です。その式の\ncar\nは\nオペレータであり、\ncdr\nはオペランドのリストです。\n11\n式のリストに対するこれらのセレクタ\n—\nそれに対応するオペランドのリスト向けの\nものも含めて\n—\nはデータ抽象化を意図するものではありません。それらは基本的なリス\nト命令のための\nmnemonic(\nニーモニック\n)\n名として\nSection 5.4\nにて明示的コントロール\n評価機を理解することを易しくするために導入されます。\n398","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":424},{"id":"./test/fixtures/pdf/sicp.pdf:425","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\napplication?\nexp\n) (\npair?\nexp\n))\n(\ndefine\n(\noperator\nexp\n) (\ncar\nexp\n))\n(\ndefine\n(\noperands\nexp\n) (\ncdr\nexp\n))\n(\ndefine\n(\nno-operands?\nops\n) (\nnull?\nops\n))\n(\ndefine\n(\nfirst-operand\nops\n) (\ncar\nops\n))\n(\ndefine\n(\nrest-operands\nops\n) (\ncdr\nops\n))\n派生式\nいくつかの私達の言語内での特別な形式は直接実装されるのでなく、他の\n特別な形式を含む式を用いて定義できます。例の\n1\nつは\ncond\nです。これは入\nれ子の\nif\n式として実装できます。例えば以下の式の評価上の問題を、\n(\ncond\n((>\nx\n0)\nx\n)\n((=\nx\n0) (\ndisplay\n'zero\n) 0)\n(\nelse\n(-\nx\n)))\n次の\nif\nと\nbegin\nの式を含む式の評価問題へと簡約することができます。\n(\nif\n(>\nx\n0)\nx\n(\nif\n(=\nx\n0)\n(\nbegin\n(\ndisplay\n'zero\n) 0)\n(-\nx\n)))\ncond\nの評価をこのように実装することは評価機を簡略化します。評価過程が明\n示的に指定されねばならない特別な形式の数を減らすことができるからです。\ncond\n式の部分を抽出する構文手続と\ncond\n式を\nif\n式に変形する式\ncond->if\nを含めます。事例分析は\ncond\nで始まり述語\n-\n行動節のリストを持ちます。節は\nもしその述語がシンボル\nelse\nならば\nelse\n節です。\n12\n(\ndefine\n(\ncond?\nexp\n) (\ntagged-list?\nexp\n'cond\n))\n(\ndefine\n(\ncond-clauses\nexp\n) (\ncdr\nexp\n))\n(\ndefine\n(\ncond-else-clause?\nclause\n)\n(\neq?\n(\ncond-predicate\nclause\n)\n'else\n))\n(\ndefine\n(\ncond-predicate\nclause\n) (\ncar\nclause\n))\n12\n全ての述語が\nfalse\nで\nelse\n節が存在しない場合の\ncond\n式の値は\nScheme\nでは未定義\nです。ここではそれを\nfalse\nにしました。\n399","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":425},{"id":"./test/fixtures/pdf/sicp.pdf:426","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ncond-actions\nclause\n) (\ncdr\nclause\n))\n(\ndefine\n(\ncond->if\nexp\n) (\nexpand-clauses\n(\ncond-clauses\nexp\n)))\n(\ndefine\n(\nexpand-clauses\nclauses\n)\n(\nif\n(\nnull?\nclauses\n)\n'false\n; no\nelse\nclause\n(\nlet\n((\nfirst\n(\ncar\nclauses\n))\n(\nrest\n(\ncdr\nclauses\n)))\n(\nif\n(\ncond-else-clause?\nfirst\n)\n(\nif\n(\nnull?\nrest\n)\n(\nsequence->exp\n(\ncond-actions\nfirst\n))\n(\nerror\n\"\nELSE\nclause\nisn't\nlast\n:\nCOND->IF\n\"\nclauses\n))\n(\nmake-if\n(\ncond-predicate\nfirst\n)\n(\nsequence->exp\n(\ncond-actions\nfirst\n))\n(\nexpand-clauses\nrest\n))))))\n文法上の変形を実装することを選択した\ncond\nのような式は\nderived expres-\nsions\n(\n派生式\n)\nと呼ばれます。\nlet\n式もまた派生式です。\n(\nExercise 4.6\n参照\n)\n13\nExercise 4.2:\nLouis Reasoner\nは\neval\nの\ncond\nの順を変えて手続適\n用の節が代入のための節の前になるようにする計画を立てた。彼\nはこうすることでインタプリタをより効率良くできると主張した。\nプログラムは通常代入、定義等より適用を含んでいるためだ、と。\n彼の変更した\neval\nは元の\neval\nよりも通常より少ない節を式の型\nが判明する前にチェックするだろうという主張だ\na\nLouis\nの計画の何が間違っているか\n? (\nヒント：\nLouis\nの評価\n機は式\n(define x 3)\nに対し何を行うか\n?)\nb\nLouis\nは彼の計画がうまく行かないことに激昂した。彼は他\nの多くの型の式をチェックする前に彼の評価機をいくらでも\n長くして手続適用を認識させようとしている。評価される言\n13\n実用的な\nLisp\nシステムはユーザに対し新しい派生式を追加し、評価機の変更無し\nに文法上の変形としての実装を指定できる仕組みを提供します。そのようなユーザ定義\n変形は\nmacro\n(\nマクロ\n)\nと呼ばれます。マクロ定義の初歩的な仕組みを追加することは簡\n単なのですが、結果的にその言語は微妙な名前衝突の問題を持ちます。これらの困難を\nもたらさないマクロ定義の仕組みに関する多くの研究が存在します。例えば\nKohlbecker\n1986\n,\nClinger and Rees 1991\n,\nHanson 1991\nを参照して下さい。\n400","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":426},{"id":"./test/fixtures/pdf/sicp.pdf:427","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"語を変更し手続適用が\ncall\nで始まるようにすることで彼の\n手助けをせよ。例えば\n(factorial 3)\nの代わりに変更後は\n(call factorial 3)\nと書かねばならず、\n(+ 1 2)\nは\n(call +\n1 2)\nと書かねばならない。\nExercise 4.3:\neval\nを書き直し呼出がデータ適従スタイルにて行わ\nれるようにせよ。これを\nExercise 2.73\nのデータ適従型微分手続と\n比較せよ。この節で実装された文法に適切であるとおり、\n(\n複合式\nの\ncar\nを式の型として用いてよい。\nExercise 4.4:\nChapter 1\nの特別な形式\nand\nと\nor\nの定義を思い出せ。\n•\nand\n:\n式は左から右へと評価される。もし任意の式が\nfalse\nと\n評価されるなら\nfalse\nが返される。残りの式全ては評価され\nない。もし全ての式が\ntrue\nの値に評価されるなら最後の式の\n評価値が返される。もし式が全く存在しないなら\ntrue\nが返さ\nれる。\n•\nor\n:\n式は左から右へと評価される。もし任意の式が\ntrue\nと評\n価されるのならその値が返される。残りの式全ては評価され\nない。もし全ての式が\nfalse\nと評価されるのなら、またはもし\n式が全く存在しないなら、\nfalse\nが返される。\nand\nと\nor\nを評価機に対する新しい特別な形式として適切な構文手\n続と評価手続\neval-and\nと\neval-or\nを定義することで導入せよ。代\n替法として、\nand\nと\nor\nを派生式として実装する方法を示せ。\nExercise 4.5:\nScheme\nは\ncond\nの節に追加の文法、\n(<\ntest\n>  =>\n<\nrecipient\n>)\nを認めている。もし\n⟨\ntest\n⟩\nが\ntrue\nとして評価さ\nれるなら、\n⟨\nrecipient\n⟩\nが評価される。その値は\n1\n引数の手続でな\nければならない。そしてこの手続が\n⟨\ntest\n⟩\nの値で起動され、その\n結果が\ncond\n式の値として返される。例えば、\n(\ncond\n((\nassoc\n'b\n'\n((\na\n1) (\nb\n2))) =>\ncadr\n)\n(\nelse\nfalse\n))\nは\n2\nを返す。\ncond\nを変更してこの拡張文法をサポートするように\nせよ。\nExercise 4.6:\nlet\n式は派生式である。なぜなら、\n401","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":427},{"id":"./test/fixtures/pdf/sicp.pdf:428","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\n⟨\n푣푎푟\n1\n⟩\n⟨\n푒푥푝\n1\n⟩\n)\n...\n(\n⟨\n푣푎푟\n푛\n⟩\n⟨\n푒푥푝\n푛\n⟩\n))\n⟨\nbody\n⟩\n)\nは以下と等価である。\n((\nlambda\n(\n⟨\n푣푎푟\n1\n⟩\n...\n⟨\n푣푎푟\n푛\n⟩\n)\n⟨\nbody\n⟩\n)\n⟨\n푒푥푝\n1\n⟩\n...\n⟨\n푒푥푝\n푛\n⟩\n)\n文法上の変形\nlet->combination\nを実装せよ。これは\nlet\n式の評\n価を上記で示された型の組み合わせの評価へと簡約する。そして\nlet\n式を扱うために\neval\nに適切な節を追加する。\nExercise 4.7:\nlet*\nは\nlet\nに似ているが、\nlet*\nの変数の束縛が左か\nら右へと続けて実行され、全ての先行する束縛が可視となるよう\n各束縛が環境へ追加されていく。例えば、\n(\nlet*\n((\nx\n3)  (\ny\n(+\nx\n2))  (\nz\n(+\nx\ny\n5)))\n(*\nx\nz\n))\nは\n39\nを返す。\nlet*\n式が入れ子の\nlet\n式の集合としてどのように\n書き直すことができるか説明せよ。そしてこの変形を実行する手\n続\nlet*->nested-lets\nを書け。もし私達が既に\nlet\nを実装してい\nて\n(\nExercise 4.6\n)\n、評価機を拡張し\nlet*\nを扱いたいとしたら、以\n下の処理を行う節を\neval\nに追加することは十分であろうか\n?\n(\neval\n(\nlet*->nested-lets\nexp\n)\nenv\n)\nまたは私達は明示的に\nlet*\nを非派生式を用いて拡張するべきであ\nろうか\n?\nExercise 4.8:\n“\n名前付き\nlet\n”\nは\nlet\nの変種であり以下の形式を\n持つ。\n(\nlet\n⟨\nvar\n⟩\n⟨\nbindings\n⟩\n⟨\nbody\n⟩\n)\n⟨\nbindings\n⟩\nと\n⟨\nbody\n⟩\nは通常の\nlet\nと同様である。しかし\n⟨\nvar\n⟩\nが\n⟨\nbody\n⟩\n内部で束縛される手続であり、ボディが\n⟨\nbody\n⟩\nであり、か\nつパラメタが\n⟨\nbindings\n⟩\nの変数である点が異なる。従って\n⟨\nvar\n⟩\n402","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":428},{"id":"./test/fixtures/pdf/sicp.pdf:429","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"で名付けられた手続を呼び出すことで繰り返し\n⟨\nbody\n⟩\nを実行す\nることができる。例えば、反復フィボナッチ手続\n(\nSection 1.2.2\n)\nは\n名前付き\nlet\nを用いて以下のように書き直すことができる。\n(\ndefine\n(\nfib\nn\n)\n(\nlet\nfib-iter\n((\na\n1)\n(\nb\n0)\n(\ncount\nn\n))\n(\nif\n(=\ncount\n0)\nb\n(\nfib-iter\n(+\na\nb\n)\na\n(-\ncount\n1)))))\nExercise 4.6\nの\nlet->combination\nを変更して名前付き\nlet\nもサポ\nートするようにせよ。\nExercise 4.9:\n多くの言語が\ndo\n,\nfor\n,\nwhile\n,\nuntil\nのような多様な\n反復構造をサポートする。\nScheme\nでは反復処理が通常の手続呼出\nを用いて表現できるため特別な反復構造が演算能力に対し本質的\nな利益を与えることはない。一方でそのような構造は時折便利で\nもある。いくつかの反復構造を設計せよ。それらの使用の例を与\nえどのように派生式として実装するかについて示せ。\nExercise 4.10:\nデータ抽象化を用いることで、評価されるべき言語\nの特定の文法から独立した\neval\n手続を書くことができる。これを\n説明するために\neval\nと\napply\nを変更することなくこの節の手続\nを変更することで\nScheme\nの新しい文法を設計し、実装せよ。\n4.1.3\n評価機のデータ構造\n式の外側の文法を定義するのに加えて、評価機の実装は評価機が内部的に\n操作するデータ構造もプログラムの実行の一部として、手続と環境の表現や\ntrue\nと\nfalse\nの表現を定義しなければなりません。\n述語のテスト\n条件節に対しては真になるものは全て受け入れます。真とは明示的な\nfalse\nオブジェクトでは無いものです。\n403","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":429},{"id":"./test/fixtures/pdf/sicp.pdf:430","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ntrue?\nx\n)  (\nnot\n(\neq?\nx\nfalse\n)))\n(\ndefine\n(\nfalse?\nx\n) (\neq?\nx\nfalse\n))\n手続の表現\nプリミティブを扱うために、以下の手続が利用可能であると仮定します。\n•\n(apply-primitive-procedure <\nproc\n> <\nargs\n>)\n与えられたプリミティブな手続をリスト\n⟨\nargs\n⟩\n中の引数の値に適用し、\n適用の結果を返します。\n•\n(primitive-procedure? <\nproc\n>)\n⟨\nproc\n⟩\nがプリミティブな手続であるか確認します。\nプリミティブを扱うこれらの仕組みは\nSection 4.1.4\nでさらに説明されます。\n複合手続はパラメタ、手続のボディ、環境からコンストラクタ\nmake-\nprocedure\nを用いて構築されます。\n(\ndefine\n(\nmake-procedure\nparameters\nbody\nenv\n)\n(\nlist\n'procedure\nparameters\nbody\nenv\n))\n(\ndefine\n(\ncompound-procedure?\np\n)\n(\ntagged-list?\np\n'procedure\n))\n(\ndefine\n(\nprocedure-parameters\np\n) (\ncadr\np\n))\n(\ndefine\n(\nprocedure-body\np\n) (\ncaddr\np\n))\n(\ndefine\n(\nprocedure-environment\np\n) (\ncadddr\np\n))\n環境上の命令\n評価機は環境を操作する命令を必要とします。\nSection 3.2\nで説明された通\nり、環境は連続するフレームであり、各フレームは変数をその対応する値に関\n連付ける束縛のテーブルです。以下の命令を用いて環境を操作します。\n•\n(lookup-variable-value <\nvar\n> <\nenv\n>)\n環境\n⟨\nenv\n⟩\n内でシンボル\n⟨\nvar\n⟩\nに束縛された値を返します。または変数\nが束縛されていない場合エラーを発します。\n•\n(extend-environment <\nvariables\n> <\nvalues\n> <\nbase-env\n>)\n新しいフレームから成る環境を返します。フレームの中ではリスト\n⟨\nvariables\n⟩\n中のシンボルがリスト中\n⟨\nvalues\n⟩\nの対応する要素に束縛され\nます。取り囲む環境は環境\n⟨\nbase-env\n⟩\nです。\n404","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":430},{"id":"./test/fixtures/pdf/sicp.pdf:431","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n(define-variable! <\nvar\n> <\nvalue\n> <\nenv\n>)\n環境\n⟨\nenv\n⟩\nの最初のフレームに変数\n⟨\nvar\n⟩\nを値\n⟨\nvalue\n⟩\nに関連付ける新し\nい束縛を追加します。\n•\n(set-variable-value! <\nvar\n> <\nvalue\n> <\nenv\n>)\n環境\n⟨\nenv\n⟩\n中の変数\n⟨\nvar\n⟩\nの束縛を変更し、その変数が新しく値\n⟨\nvalue\n⟩\nに束縛されるようにします。またはもし変数が束縛されていない場合に\nはエラーを発します。\nこれらの命令を実装するためには環境をフレームのリストとして表現します。\n環境を内包する環境はリストの\ncdr\nです。空の環境は単純に空リストです。\n(\ndefine\n(\nenclosing-environment\nenv\n) (\ncdr\nenv\n))\n(\ndefine\n(\nfirst-frame\nenv\n) (\ncar\nenv\n))\n(\ndefine\nthe-empty-environment\n'\n())\n環境の各フレームはリストのペアとして表現されます。フレームに束縛される\n変数のリストと対応する値のリストです。\n14\n(\ndefine\n(\nmake-frame\nvariables\nvalues\n)\n(\ncons\nvariables\nvalues\n))\n(\ndefine\n(\nframe-variables\nframe\n) (\ncar\nframe\n))\n(\ndefine\n(\nframe-values\nframe\n) (\ncdr\nframe\n))\n(\ndefine\n(\nadd-binding-to-frame!\nvar\nval\nframe\n)\n(\nset-car!\nframe\n(\ncons\nvar\n(\ncar\nframe\n)))\n(\nset-cdr!\nframe\n(\ncons\nval\n(\ncdr\nframe\n))))\n環境を変数を値に関連付ける新しいフレームにより拡張するために、変数のリ\nストと値のリストから成るフレームを作成します。そしてその環境に隣接させ\nます。もし変数の数が値の数に合わない場合にはエラーを発します。\n(\ndefine\n(\nextend-environment\nvars\nvals\nbase-env\n)\n(\nif\n(= (\nlength\nvars\n) (\nlength\nvals\n))\n(\ncons\n(\nmake-frame\nvars\nvals\n)\nbase-env\n)\n(\nif\n(< (\nlength\nvars\n) (\nlength\nvals\n))\n(\nerror\n\"\nToo\nmany\narguments\nsupplied\n\"\nvars\nvals\n)\n(\nerror\n\"\nToo\nfew\narguments\nsupplied\n\"\nvars\nvals\n))))\n14\nフレームは実際には以下のコードにおいてデータ抽象化されていません。\nSet-\nvariable-value!\nと\ndefine-variable!\nは\nset-car!\nを用いて直接フレームの値を変更\nしています。フレーム手続の目的は環境操作手続を読み易くすることです。\n405","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":431},{"id":"./test/fixtures/pdf/sicp.pdf:432","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"環境内の変数を探すためには、最初のフレームの変数のリストを走査します。\n希望の変数を見つければ対応する値リスト内の要素を返します。もし現在のフ\nレーム内にその変数が見つからなければ内包する環境を探します。以下、繰り\n返しです。もし空環境まで辿り着いたならば\n“\n束縛されていない変数\n”\nのエラ\nーを発します。\n(\ndefine\n(\nlookup-variable-value\nvar\nenv\n)\n(\ndefine\n(\nenv-loop\nenv\n)\n(\ndefine\n(\nscan\nvars\nvals\n)\n(\ncond\n((\nnull?\nvars\n)\n(\nenv-loop\n(\nenclosing-environment\nenv\n)))\n((\neq?\nvar\n(\ncar\nvars\n)) (\ncar\nvals\n))\n(\nelse\n(\nscan\n(\ncdr\nvars\n) (\ncdr\nvals\n)))))\n(\nif\n(\neq?\nenv\nthe-empty-environment\n)\n(\nerror\n\"\nUnbound\nvariable\n\"\nvar\n)\n(\nlet\n((\nframe\n(\nfirst-frame\nenv\n)))\n(\nscan\n(\nframe-variables\nframe\n)\n(\nframe-values\nframe\n)))))\n(\nenv-loop\nenv\n))\n変数に新しい値を指定された環境にて設定するには、\nlookup-variable-value\nと同様に変数を走査し、対応する見つかった場合には対応する値を変更します。\n(\ndefine\n(\nset-variable-value!\nvar\nval\nenv\n)\n(\ndefine\n(\nenv-loop\nenv\n)\n(\ndefine\n(\nscan\nvars\nvals\n)\n(\ncond\n((\nnull?\nvars\n)\n(\nenv-loop\n(\nenclosing-environment\nenv\n)))\n((\neq?\nvar\n(\ncar\nvars\n)) (\nset-car!\nvals\nval\n))\n(\nelse\n(\nscan\n(\ncdr\nvars\n) (\ncdr\nvals\n)))))\n(\nif\n(\neq?\nenv\nthe-empty-environment\n)\n(\nerror\n\"\nUnbound\nvariable\n:\nSET!\n\"\nvar\n)\n(\nlet\n((\nframe\n(\nfirst-frame\nenv\n)))\n(\nscan\n(\nframe-variables\nframe\n)\n(\nframe-values\nframe\n)))))\n(\nenv-loop\nenv\n))\n変数を定義するには、最初にその変数の束縛を最初のフレームにて探します。\n束縛が存在すれば変更を行います。\n(\nset-variable-value!\nと同様です\n)\n。その\n406","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":432},{"id":"./test/fixtures/pdf/sicp.pdf:433","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ような束縛がなければ最初のフレームに追加します。\n(\ndefine\n(\ndefine-variable!\nvar\nval\nenv\n)\n(\nlet\n((\nframe\n(\nfirst-frame\nenv\n)))\n(\ndefine\n(\nscan\nvars\nvals\n)\n(\ncond\n((\nnull?\nvars\n)\n(\nadd-binding-to-frame!\nvar\nval\nframe\n))\n((\neq?\nvar\n(\ncar\nvars\n)) (\nset-car!\nvals\nval\n))\n(\nelse\n(\nscan\n(\ncdr\nvars\n) (\ncdr\nvals\n)))))\n(\nscan\n(\nframe-variables\nframe\n) (\nframe-values\nframe\n))))\nここで記述された手法は環境を表現する多くのもっともな方法の\n1\nつでしか\nありません。データ抽象化を用いて評価機の他の部分を表現の詳細な選択から\n分離したので、もし望めば環境の表現を変更することが可能です。\n(\nExercise\n4.11\n参照\n)\n。実運用品質の\nLisp\nシステムでは評価機の環境向け命令のスピード\nが\n—\n特に変数探索の物が\n—\nシステムのパフォーマンスに主に影響を与えます。\nここで説明された表現は概念上シンプルではありますが、効率的ではなく通常\nは実運用システムでは用いられません。\n15\nExercise 4.11:\nフレームをリストのペアと表現する代わりに、フレ\nームを束縛のリストとして表現可能である。この場合、各束縛は\n名前と値のペアだ。環境の命令を書き換えこの代替表現を用いる\nようにせよ。\nExercise 4.12:\n手続\nset-variable-value!\n,\ndefine-variable!\n,\nlookup-\nvariable-value\nは環境の構造を縦断するためのより抽象的な手続\nを用いて表現することができる。共通なパターンを捕える抽象化\nを定義し、\n3\nつの手続をこられの抽象化を用いて再定義せよ。\nExercise 4.13:\nScheme\nは\ndefine\nを用いて新しい束縛を作成する\nことができる。しかし束縛を取り除く手段は提供しない。評価機\nに特別形式\nmake-unbound!\nを実装せよ。これは\nmake-unbound!\nが\n評価された環境から与えられたシンボルの束縛を削除する。この\n問題は完全には指示されていない。例えば環境の最初のフレーム\n15\nこの表現の欠点は\n(\nExercise 4.11\nの亜種も同様に\n)\n評価機が与えられた変数を見つけ\nるために数多くのフレームを探索しなければならないかもしれない点です。\n(\nこのような\n取り組み方は\ndeep binding\n(\n深い束縛\n)\nと参照されます\n)\n。この非効率性を防ぐ\n1\nつの方法\nは\nlexical addressing\n(\nレキシカルアドレッシング\n)\nと呼ばれ\nSection 5.5.6\nにて議論されま\nす。\n407","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":433},{"id":"./test/fixtures/pdf/sicp.pdf:434","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"の束縛のみを削除するべきだろうか\n?\n仕様を完成させあなたが行\nった選択について理由を述べよ。\n4.1.4\n評価機をプログラムとして実行する\n評価機を与えられたことで、\nLisp\n式が評価されるプロセスの\n(Lisp\nで表現\nされた\n)\n記述を手中にしました。評価機をプログラムとして表現することの利\n点の\n1\nつはプログラムを実行できることです。これにより\nLisp\nの中で実行す\nることで\nLisp\n自身がどのように式を評価するのかについての実行モデルを得\nることができました。これは評価ルールを検証するフレームワークの役割を果\nたします。実際にこの章の後の方で行います。\n評価機プログラムは式を究極的にはプリミティブな手続の適用まで簡約し\nます。従って評価機を実行するのに必要なもの全ては基盤を無す\nLisp\nシステ\nムを呼び出す仕組みを作成することでプリミティブ手続の適用をモデル化する\nことです。\n各プリミティブな手続の名前の束縛が存在しなければなりません。そのた\nめ\neval\nがプリミティブの適用の命令を評価する時、\napply\nに渡すオブジェク\nトを見つけます。従って私達は評価しようとする式の中に現れることが可能な\nプリミティブな手続の名前と独自のオブジェクトを関連付けするグローバル環\n境を設定します。グローバル環境はまたシンボル\ntrue\nと\nfalse\nのための束縛\nも含めます。そうすることでそれらが評価される式の中で変数として利用する\nことができます。\n(\ndefine\n(\nsetup-environment\n)\n(\nlet\n((\ninitial-env\n(\nextend-environment\n(\nprimitive-procedure-names\n)\n(\nprimitive-procedure-objects\n)\nthe-empty-environment\n)))\n(\ndefine-variable!\n'true\ntrue\ninitial-env\n)\n(\ndefine-variable!\n'false\nfalse\ninitial-env\n)\ninitial-env\n))\n(\ndefine\nthe-global-environment\n(\nsetup-environment\n))\nどのようにプリミティブ手続オブジェクトを評価するかは、\napply\nがそれらを手\n続\nprimitive-procedure?\nと\napply-primitive-procedure\nを用いて判別でき\nる限り問題ではありません。私達はプリミティブな手続をシンボル\nprimitive\n408","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":434},{"id":"./test/fixtures/pdf/sicp.pdf:435","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"で始まり、そのプリミティブを実装する低層の\nLisp\nの手続を含むリストとし\nて表現することを選択しました。\n(\ndefine\n(\nprimitive-procedure?\nproc\n)\n(\ntagged-list?\nproc\n'primitive\n))\n(\ndefine\n(\nprimitive-implementation\nproc\n) (\ncadr\nproc\n))\nsetup-environment\nはプリミティブの名前と実装手続をリストから得ます。\n16\n(\ndefine\nprimitive-procedures\n(\nlist\n(\nlist\n'car\ncar\n)\n(\nlist\n'cdr\ncdr\n)\n(\nlist\n'cons\ncons\n)\n(\nlist\n'null?\nnull?\n)\n⟨\nmore primitives\n⟩\n))\n(\ndefine\n(\nprimitive-procedure-names\n)\n(\nmap\ncar\nprimitive-procedures\n))\n(\ndefine\n(\nprimitive-procedure-objects\n)\n(\nmap\n(\nlambda\n(\nproc\n) (\nlist\n'primitive\n(\ncadr\nproc\n)))\nprimitive-procedures\n))\nプリミティブ手続を適用するためには単純に実装手続を引数に対して低層の\nLisp\nシステムを用いて適用します。\n17\n(\ndefine\n(\napply-primitive-procedure\nproc\nargs\n)\n16\n低層の\nLisp\nで定義される任意の手続はメタ循環評価機のプリミティブとして使用で\nきます。評価機にインストールされるプリミティブの名前は低層の\nLisp\nにおける実装の\n名前と同じである必要はありません。ここで名前が同じなのはメタ循環評価機が\nScheme\nそれ自身を実装するためです。従って例えば\n(list 'first car)\nや\n(list 'square\n(lambda (x) (* x x)))\nを\nprimitive-procedures\nに入れることもできたでしょう。\n17\napply-in-underlying-scheme\nは前の章で使用した\napply\n手続です。メタ循環評価\n機の\napply\n手続\n(\nSection 4.1.1\n)\nはこのプリミティブの動き方をモデルにしています。\n2\nつの異なる\napply\nと呼ばれる物を持つことはメタ循環評価機を実行するにおいて問題へ\nと導きます。メタ循環評価機の\napply\nを定義することがプリミティブの定義を隠してし\nまうためです。これを回避する\n1\nつの方法はメタ循環の\napply\nをリネームすることでプ\nリミティブ手続の名前との衝突を避けることです。私達はその代わりに下層の\napply\nへ\nの参照をメタ循環の\napply\nを定義する前に以下のようにすることで保存しました。\n(\ndefine\napply-in-underlying-scheme\napply\n)\nこれで元の版の\napply\nに異なる名前でアクセスできるようになりました。\n409","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":435},{"id":"./test/fixtures/pdf/sicp.pdf:436","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\napply-in-underlying-scheme\n(\nprimitive-implementation\nproc\n)\nargs\n))\nメタ循環評価機実行時の利便性のために、低層の\nLisp\nシステムの\nread-eval-\nprint loop (REPL:\nレプル\n)\nをモデルにした\ndriver loop\n(\nドライバループ\n)\nを提供\nします。これは\nprompt\n(\nプロンプト\n)\nを表示し、入力式を読み込み、この式をグ\nローバル環境の中で評価し、結果を表示します。私達は各表示された結果の前\nに\noutput prompt\n(\n出力プロンプト\n)\nを置きます。そうすることで式の値を他の\n表示されるかもしれない出力から判別するためです。\n18\n(\ndefine\ninput-prompt\n\"\n;;;\nM-Eval\ninput\n:\n\"\n)\n(\ndefine\noutput-prompt\n\"\n;;;\nM-Eval\nvalue\n:\n\"\n)\n(\ndefine\n(\ndriver-loop\n)\n(\nprompt-for-input\ninput-prompt\n)\n(\nlet\n((\ninput\n(\nread\n)))\n(\nlet\n((\noutput\n(\neval\ninput\nthe-global-environment\n)))\n(\nannounce-output\noutput-prompt\n)\n(\nuser-print\noutput\n)))\n(\ndriver-loop\n))\n(\ndefine\n(\nprompt-for-input\nstring\n)\n(\nnewline\n) (\nnewline\n) (\ndisplay\nstring\n) (\nnewline\n))\n(\ndefine\n(\nannounce-output\nstring\n)\n(\nnewline\n) (\ndisplay\nstring\n) (\nnewline\n))\n私達は特別なプリント手続、\nuser-print\nを使用します。これは複合手続の環境\n部分を表示するのを防ぐためです。これはとても長いリストに成り得ます。\n(\nま\nたはさらにループを含んでいるかもしれません。\n)\n(\ndefine\n(\nuser-print\nobject\n)\n(\nif\n(\ncompound-procedure?\nobject\n)\n(\ndisplay\n(\nlist\n'compound-procedure\n(\nprocedure-parameters\nobject\n)\n(\nprocedure-body\nobject\n)\n'<procedure-env>\n))\n18\nプリミティブな手続\nread\nはユーザからの入力を待ち、次の入力された完全な式を返\nします。例えばもしユーザが\n(+ 23 x)\nと入力した場合、\nread\nは\n3\nつの要素、シンボル\n+\n、数値\n23\n、シンボル\nx\nを含むリストを返します。もしユーザが\n'x\nと入力したなら\nread\nは\n2\nつの要素、シンボル\nquote\nとシンボル\nx\nを含むリストを返します。\n410","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":436},{"id":"./test/fixtures/pdf/sicp.pdf:437","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndisplay\nobject\n)))\nこれで評価機を実行するのに必要なことはグローバル環境の初期化とドライバ\nーループの開始のみです。以下がサンプルの応答です。\n(\ndefine\nthe-global-environment\n(\nsetup-environment\n))\n(\ndriver-loop\n)\n;;; M-Eval input:\n(\ndefine\n(\nappend\nx\ny\n)\n(\nif\n(\nnull?\nx\n)\ny\n(\ncons\n(\ncar\nx\n) (\nappend\n(\ncdr\nx\n)\ny\n))))\n;;; M-Eval value:\nok\n;;; M-Eval input:\n(\nappend\n'\n(\na\nb\nc\n)\n'\n(\nd\ne\nf\n))\n;;; M-Eval value:\n(a b c d e f)\nExercise 4.14:\nEva Lu Ator\nと\nLouis Reasoner\nはそれぞれ評価機\nを検証している。\nEva\nは\nmap\nの定義を入力しいくつかそれを用い\nるテストプログラム実行している。それらはうまく動いた。\nLouis\nは逆に\nmap\nのシステム版をメタ循環評価機のプリミティブとして\n導入した。彼がそれを確かめた時、全くうまく動かなかった。なぜ\nEva\nはうまく行ったのに\nLouis\nの\nmap\nは失敗するのか。説明せよ。\n4.1.5\nプログラムとしてのデータ\nLisp\n式を評価する\nLisp\nプログラムについて考えることにおいて、例えはと\nても良い手助けになるでしょう。プログラムの意味についての命令上の視点の\n1\nつに、プログラムは\n(\n恐らく無限に大きな\n)\n抽象機械の記述であるという物が\nあります。例えば階乗を計算する親しみのあるプログラムについて考えてみま\nしょう。\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (* (\nfactorial\n(-\nn\n1))\nn\n)))\n411","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":437},{"id":"./test/fixtures/pdf/sicp.pdf:438","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"=\nfactorial\n--\n*\nfactorial\n6\n720\n1\n1\n1\nFigure 4.2:\n抽象機械として見た階乗プログラム\n私達はこのプログラムを減算、乗算、等価試験の部品と一緒に\n2\nつの位置を持\nつスイッチと他の階乗機械を含める機械の説明であると見做すことができるで\nしょう。\n(\n階乗機械は無限です。他の階乗機械をその中に含んでいるためです\n)\n。\nFigure 4.2\nは階乗機械の流れ図でありその部品がどのようにお互いに接続され\nているかを示しています。\n同様な方法で、評価機を入力として機械の説明書を取るとても特殊な機械\nだと見做すことができます。この入力を与えられると、評価機はそれ自身を記\n述された機械を真似るように設定します。例えばもし評価機に\nFigure 4.3\nで示\nされる\nfactorial\nの記述を与えれば、評価機は階乗の計算ができるようになり\nます。\nこの視点からは、私達の評価機は\nuniversal machine\n(\n万能機械\n)\nであると見えま\nす。他の機械が\nLisp\nにて説明される時、それを真似します。\n19\nこれは特筆すべ\n19\n機械が\nLisp\nで記述されるということは本質ではありません。もし私達の評価機に\nC\n言語の様な他の言語のための評価機として振る舞う\nLisp\nプログラムを与えた場合、\nLisp\n評価機は\nC\n評価機の真似をします。それは順に、\nC\n言語で記述された任意の機械の真\n似が可能です。同様に\nC\nで書かれた\nLisp\n評価機は任意の\nLisp\nプログラムを実行でき\nる\nC\nのプログラムを生成します。ここでの深い意図は評価機は任意の他の物を真似で\nきることです。従って\n“\n原理上、何が計算できるのか\n”\nという概念\n(\n必要な時間とメモ\n412","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":438},{"id":"./test/fixtures/pdf/sicp.pdf:439","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"きことです。電子回路向けの同等な評価機について想像することを試してみて\n下さい。入力としてフィルタのようなある他の回路の計画を符号化した信号を\n取る回路になるでしょう。この入力を与えられて、回路評価機はそこで記述と\n同じフィルタのように振る舞うでしょう。そのような万能電子回路はほとんど\n想像不可能なほど複雑です。プログラム評価機がとても簡単なプログラムであ\nることは特筆に値します。\n20\nもう\n1\nつの特筆すべき評価機の側面はそれがプログラミング言語により操作さ\nれるデータオブジェクトとプログラミング言語それ自身との間のブリッジ\n(\n橋\n)\nとして働くことです。\n(Lisp\nで実装された\n)\n評価機プログラムが実行中であり、\nユーザが式をその評価機に入力し結果を観察していると想像してみて下さい。\nユーザの視点からは\n(* x x)\nの様な入力式はプログラミング言語による式であ\nり、評価機が実行すべき物です。しかし、評価機の視点からは式は単純なリス\nト\n(\nこの場合ではシンボル\n*\n,\nx\n,\nx\nのリスト\n)\nであり、これは明確なルール集合\nに従って操作されねばならぬ物です。\nユーザのプログラムが評価機のデータだということは混乱の元となる必要\nはありません。実際に、時々はこの区別は無視したほうが便利です。そしてユー\nザに対し明示的にデータオブジェクトを\nLisp\nの式として評価する能力を\neval\n手続をプログラム中で使用できるようにすることで与えることもまた便利なこ\nリの実現性は無視\n)\nは言語や計算機に非依存です。その代わりに根底を成す概念である\ncomputability\n(\n計算可能性\n)\nを反映します。これは最初に\nAlan M. Turing (1912-1954)\nに\nより明確に証明されました。彼の\n1936\n年の論文は計算機科学理論の基礎を導きました。\nこの論文でチューリングは簡素な計算モデル\n—\n今日、\nTuring machine\n(\nチューリングマ\nシン\n)\nとして知られる\n—\nを公開し、任意の\n“\n実効的な処理\n”\nはそのような機械のプログラ\nムとして定式化できると主張しました。\n(\nこの論拠は\nChurch-Turing thesis\n(\nチャーチ・チ\nューリングのテーゼ\n、または提唱\n)\nとして知られます\n)\n。チューリングは次に万能機械、即\nちチューリングマシン向けプログラムの評価機として振る舞うチューリングマシンを実\n装しました。彼はこのフレームワークを用いてチューリングマシンでは計算できない上\n手く設定された問題が存在することを証明しました。\n(\nExercise 4.15\n参照\n)\n。そのため暗に\n“\n実効的な処理\n”\nとして定式化できない問題の存在も示したのです。チューリングは実用\n的な計算機科学への基礎的な貢献の行いも続けました。例えば彼は汎用目的サブルーチ\nンを用いて構造化プログラミングの考えを発明しました。チューリングの経歴について\nは\nHodges 1983\nを参照して下さい。\n20\nある人々は比較的単純な手続により実装された評価機が評価機それ自身より複雑な\nプログラムの真似ができることが直感的でないと感じました。万能評価機械の存在は深\nく、そして素晴しい演算処理の特性です。\nRecursion theory\n(\n再帰理論\n)\nは数理論理学の\n1\n部門であり、演算処理の論理上の制約に関係します。\nDouglas Hofstadter(\nダグラスホフ\nスタッター\n)\nの美しい本\nGödel, Escher, Bach\n(\n邦題\n:\nゲーデルエッシャーバッハ\n)\nはこれ\nらの考えのいくつかについて探求します。\n(\nHofstadter 1979\n)\n413","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":439},{"id":"./test/fixtures/pdf/sicp.pdf:440","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(define (factorial n)\n  (if (= n 1)\n      1\n      (* (factorial (- n 1)) n)))\neval6\n720\nFigure 4.3:\n階乗マシンを真似する評価機\nとです。多くの\nLisp\n方言は引数として式と環境を取り、その環境に関連してそ\nの式を評価するプリミティブな\neval\n手続を与えます。\n21\n従って、\n(\neval\n'\n(* 5 5)\nuser-initial-environment\n)\nと\n(\neval\n(\ncons\n'*\n(\nlist\n5 5))\nuser-initial-environment\n)\nの両方は\n25\nを返します。\n22\nExercise 4.15:\n1\n引数手続\np\nとオブジェクト\na\nを与えられた時、式\n(p a)\nが\n(\nエラーメッセージや無限に停止しない場合とは対照的\nに\n)\n値を返す場合に、\np\nは\na\nに対して\n“halt”(\n停止\n)\nすると呼ばれ\nる。\np\nが\na\nに対し停止するかどうかを任意の手続\np\nと任意のオブ\n21\n警告：この\neval\nプリミティブは私達が\nSection 4.1.1\nで実装した\neval\n手続とは異な\nります。それは私達が\nSection 4.1.3\nで構築したサンプルの環境構造ではなく、実際の\nScheme\n環境を用いるためです。これらの実際の環境はユーザにより通常のリストとして\n操作することはできません。それらは\neval\nによりアクセスされるか、他の特別な命令を\n用います。同様に以前に見た\napply\nプリミティブもメタ循環\napply\nとは異なります。そ\nれが私達が\nSection 4.1.3\nと\nSection 4.1.4\nで構築した手続オブジェクトではなく、実際の\nScheme\n手続を用いるからです。\n22\nScheme\nの\nmit\n実装は\neval\nと同様にユーザの入力式が評価される初期環境に束縛さ\nれるシンボル\nuser-initial-environment\nも含みます。\n414","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":440},{"id":"./test/fixtures/pdf/sicp.pdf:441","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ジェクト\na\nに対して正確に決定する手続\nhalts?\nを書くことは不可\n能であることを示せ。以下の推測を用いろ：もしそのような手続\nhalts?\nが存在するなら以下のプログラムを実装できるだろう。\n(\ndefine\n(\nrun-forever\n) (\nrun-forever\n))\n(\ndefine\n(\ntry\np\n)\n(\nif\n(\nhalts?\np\np\n) (\nrun-forever\n)\n'halted\n))\nここで式\n(try try)\nの評価について考え、どんな可能な結末\n(\n停\n止するか、無限に実行するか\n)\nも\nhalts?\nの意図した振舞に違反す\nることを示せ。\n23\n4.1.6\n内部定義\n私達の評価の環境モデルとメタ循環評価機は定義を順に実行し、環境のフ\nレームを\n1\n度に\n1\n定義づつ拡張します。これはインタラクティブなプログラム\n開発に対しては特に便利です。その場合にはプログラマは自由に手続の適用を\n新しい手続の定義に混ぜる必要があります。しかし、\n(\nSection 1.1.8\nで紹介され\nた\n)\nブロック構造を実装するために用いられた内部定義について注意深く考え\nてみれば、環境の名前毎の拡張はローカル変数の定義に最良の方法ではないの\nではと気付くのではないでしょうか。\n内部定義を伴なう以下のような手続について考えてみます。\n(\ndefine\n(\nf\nx\n)\n(\ndefine\n(\neven?\nn\n) (\nif\n(=\nn\n0)\ntrue\n(\nodd?\n(-\nn\n1))))\n(\ndefine\n(\nodd?\nn\n)  (\nif\n(=\nn\n0)\nfalse\n(\neven?\n(-\nn\n1))))\n⟨\nrest of body of f\n⟩\n)\nここでの意図は手続\neven?\nのボディ内の名前\nodd?\nは\neven?\nの後に定義された\n手続\nodd?\nを参照しなければなりません。名前\nodd?\nのスコープは\nf\nのボディ全\n体であり、\nodd?\nの定義が起こった箇所から始まる\nf\nのボディの一部分ではあ\nりません。実際に\nodd?\nがそれ自身\neven?\nを用いて定義されていることについ\nて考えると\n—\neven?\nと\nodd?\nは相互再帰手続であり\n—2\nつの\ndefine\nを満足さ\n23\nhalts?\nが手続オブジェクトを与えらえたと規定したが、この推測が例え\nhalts?\nが\n手続のテキストとその環境へのアクセスを得ることが出来るとしても依然として適用で\nきることに注意せよ。これはチューリングの著名な\nHalting Theorem\n(\n停止性問題\n)\nであ\nり、\nnon-computable\n(\n計算不可能\n)\nな問題の最初の明確な例を与える。言い換えれば、計\n算手続として実行不可能なうまく設定された課題である。\n415","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":441},{"id":"./test/fixtures/pdf/sicp.pdf:442","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"せる解釈はそれらを名前\neven?\nと\nodd?\nが環境に同時に追加されたと見做すこ\nとのみだとわかります。より一般的には、ブロック構造において、ローカルな\n名前のスコープは\ndefine\nが評価された手続のボディ全体だということです。\n偶然にも私達のインタプリタは\nf\nの呼出を正確に評価します。しかし\n“\n予想\n外\n”\nの理由のためです。内部手続の定義が最初に来るため、これらの手続への\n呼出はそれらの全てが定義されるまで起こりません。従って\nodd?\nは\neven?\nが\n実行された時に定義されるのです。内部定義がボディの最初に来て定義された\n変数の値の式の評価が実際にはどの定義された変数も用いない任意の手続に対\nし直接、同時定義を実装する仕組みと、私達の逐次的な評価システムの仕組み\nは実際に同じ結果を与えます。\n(\nこれらの制限に従わず、その結果逐次定義が同\n時定義と等価でない手続の例に対しては\nExercise 4.19\nを参照して下さい\n)\n。\n24\nしかし内部定義の名前が真に同時にスコープを持つようになる簡単な定義\nの扱い方が存在します。単に現在の環境に入ることになる全てのローカル変数\nをどの値の式が評価されるよりも早く作成することです。これを行う\n1\nつの方\n法は\nlambda\n式上の構文変形によります。\nlambda\n式のボディを評価する前に、\nボディの中の全ての内部定義を走査し、削除します。内部で定義された変数は\nlet\nを用いて作成され、次に代入を用いてそれらの値に設定されます。例えば、\n以下の手続は、\n(\nlambda\n⟨\nvars\n⟩\n(\ndefine\nu\n⟨\ne1\n⟩\n)\n(\ndefine\nv\n⟨\ne2\n⟩\n)\n⟨\ne3\n⟩\n)\n以下の形式に変形されます。\n(\nlambda\n⟨\nvars\n⟩\n(\nlet\n((\nu\n'*unassigned*\n)\n(\nv\n'*unassigned*\n))\n(\nset!\nu\n⟨\ne1\n⟩\n)\n24\nプログラムにこの評価の仕組みに依存して欲しくないというのが\nChapter\n1\nの\nFootnote 28\nでの見解、\n“\n管理は責任を取れない\n”\nに対する理由です。これを主張\nすることで内部定義は最初に来て、定義中でお互いを定義が評価されている間に使用は\nしません。\nScheme\nの\nieee\n標準は実装者にこれらの定義の評価に用いられる仕組みにつ\nいて幾つかの選択を残します。別のルールではなくある評価ルールを選択することはこ\nこでは\n“\n悪い形式\n”\nのプログラムの解釈のみに影響する小さな問題に見えるかもしれませ\nん。しかし\nSection 5.5.6\nでは同時に内部定義を行うモデルへの移行が、そうしなければコ\nンパイラの実装にて起こり得る意地の悪い問題を防ぐことを学びます。\n416","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":442},{"id":"./test/fixtures/pdf/sicp.pdf:443","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nset!\nv\n⟨\ne2\n⟩\n)\n⟨\ne3\n⟩\n))\nここで\n*unassigned*\nは特別なシンボルであり、変数が調べられた時にもしま\nだ値が割り当てられていない変数を使用しようとしたならばエラーを発せさせ\nます。\n内部定義を全て走査する方法の代替となる戦略は\nExercise 4.18\nにて示され\nます。上で示された変形とは異なり、これは定義された変数の値がその変数の\nどんな値も用いずに評価できるという制約を強制します。\n25\nExercise 4.16:\nこの課題では内部定義を逐次実行するためについ先\n程説明された手法を実装する。評価機は\nlet\nをサポートすると仮\n定する。\n(\nExercise 4.6\n参照\n)\na\nlookup-variable-value\n(\nSection 4.1.3\n)\nを変更してもし見つ\nけた値がシンボル\n*unassigned*\nならエラーを発するように\nする。\nb\n手続のボディを取り内部手続を持たない同等な手続を返す手\n続\nscan-out-defines\nを上で説明された変形を作成すること\nにより、書け。\nc\nscan-out-defines\nをインタプリタの\nmake-procedure\nまた\nは\nprocedure-body\n(see\nSection 4.1.3\n)\nの中に導入せよ。どち\nらの場所が良いか\n?\nそれは何故か\n?\nExercise 4.17:\nこの本の手続の式\n⟨\ne3\n⟩\nの評価を実施している時の\n環境図を書くことで、定義が逐次的に翻訳された時にどのように\n構築されるかと、定義が説明されたように走査された場合にどの\nように構築されるかとの違いを比較せよ。変形されたプログラム\nにはなぜ余分なフレームが存在するのか\n?\n環境構造内のこの違い\nが正しいプログラムの振舞に違いを起こさないのか説明せよ。イ\nンタプリタに内部定義の\n“\n同時\n”\nスコープのルールを余分なフレー\nムの構築成しに実装させる方法を設計せよ。\n25\nScheme\nの\nieee\n標準はこの制約を強制する実装にまかせるのではなく、プログラマ\nに対してこの制約に従うかをまかせると指定することで、異なる実装戦略を許していま\nす。\nmit\nScheme\nを含むいくつかの\nScheme\n実装は上で示された変形を用いています。従\nってこの制約に従わないプログラムは実際にはそのような実装の下では動作します。\n417","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":443},{"id":"./test/fixtures/pdf/sicp.pdf:444","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 4.18:\nテキストの例を以下の様に変形する定義の走査に対\nする代替となる戦略を考えよ。\n(\nlambda\n⟨\nvars\n⟩\n(\nlet\n((\nu\n'*unassigned*\n)\n(\nv\n'*unassigned*\n))\n(\nlet\n((\na\n⟨\ne1\n⟩\n) (\nb\n⟨\ne2\n⟩\n))\n(\nset!\nu\na\n)\n(\nset!\nv\nb\n))\n⟨\ne3\n⟩\n))\nここで\na\nと\nb\nは新しい変数の名前を表現することを意味し、インタ\nプリタにより作成され、ユーザのプログラムには現れない。\nSection\n3.5.4\nの\nsolve\n手続について考える。\n(\ndefine\n(\nsolve\nf\ny0\ndt\n)\n(\ndefine\ny\n(\nintegral\n(\ndelay\ndy\n)\ny0\ndt\n))\n(\ndefine\ndy\n(\nstream-map\nf\ny\n))\ny\n)\nこの手続はこの課題に示されたように内部定義が走査された場合\nにうまく動くだろうか\n?\nテキストに示されたように走査された場\n合には動くだろうか\n?\n説明せよ。\nExercise 4.19:\nBen Bitdiddle, Alyssa P. Hacker, Eva Lu Ator\nの\n3\n人は以下の式を評価した場合の望まれた結果について議論して\nいる。\n(\nlet\n((\na\n1))\n(\ndefine\n(\nf\nx\n)\n(\ndefine\nb\n(+\na\nx\n))\n(\ndefine\na\n5)\n(+\na\nb\n))\n(\nf\n10))\nBen\nは結果は\ndefine\nに対する逐次的実行のルールを用いて得ら\nれるべきだと主張した。\nb\nは\n11\nに定義され、\na\nは\n5\nに定義される。\n従って結果は\n16\nである。\nAlyssa\nは相互再帰は同時スコープのルー\nルが内部手続定義に要求されるとして異議を唱えた。手続の名前\n418","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":444},{"id":"./test/fixtures/pdf/sicp.pdf:445","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"を他の名前から異なって扱うのは不合理だ。従って彼女は\nExercise\n4.16\nで実装された仕組みに賛成した。これは\na\nが\nb\nの値が計算され\nる時点では割り当てられていないという結論に導くだろう。従っ\nて\nAlyssa\nの視点では手続はエラーを生じなければならない。\nEva\nは\n3\nつ目の立ち位置を取る。彼女はもし\na\nと\nb\nの定義が真に同時\nであることを意味するのであれば、\na\nに対する値\n5\nは\nb\nの評価にて\n用いられるべきであると述べた。従って\nEva\nの視点では\na\nは\n5\nで\nなければならず、\nb\nは\n15\nでなければならない。そして結果は\n20\nに\nならなければならない。\n(\nもし同意するなら\n)3\n人の視点であなたは\nどれを支持するのか\n?\nあなたは\nEva\nが好んだように振る舞う内部\n定義を実装する方法を考案できるか\n?\n26\nExercise 4.20:\n内部定義は逐次的に見えるが実際には同時である\nため、いくらかの人々はこれを完全に回避するほうを好むだろう。\nそして特別な形式\nletrec\nを代わりに用いる。\nletrec\nは\nlet\nに似\nているため、それが束縛する変数が同時に束縛されお互いに同じ\nスコープを持つことは不思議ではないだろう。上記のサンプル手\n続\nf\nは内部手続を用いずに、しかし全く同じ意味を持つように書\nくことができる。\n(\ndefine\n(\nf\nx\n)\n(\nletrec\n((\neven?\n(\nlambda\n(\nn\n)\n(\nif\n(=\nn\n0)\ntrue\n(\nodd?\n(-\nn\n1)))))\n(\nodd?\n(\nlambda\n(\nn\n)\n(\nif\n(=\nn\n0)\nfalse\n(\neven?\n(-\nn\n1))))))\n⟨\nrest of body of f\n⟩\n))\nletrec\n式は以下の形式を持つ。\n(\nletrec\n((\n⟨\n푣푎푟\n1\n⟩\n⟨\n푒푥푝\n1\n⟩\n)\n...\n(\n⟨\n푣푎푟\n푛\n⟩\n⟨\n푒푥푝\n푛\n⟩\n))\n⟨\nbody\n⟩\n)\n26\nmit\nScheme\nの実装者達は次の根拠に従って\nAlyssa\nを支持する。\nEva\nは原理上は正\nしい。定義は同時だと見做されるべきだ。しかし\nEva\nが要求することを行う一般的でか\nつ効率的な仕組みを実装することは難しく見える。そのような仕組みが不足している状\n況では、同時定義の難しい場合についてはエラーを生成するほうが\n(Alyssa\nの意見\n)\n、正\nしくない答を生成するよりも\n(Ben\nの様に\n)\n、より良いだろう。\n419","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":445},{"id":"./test/fixtures/pdf/sicp.pdf:446","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"letrec\n式は\nlet\nの亜種であり、変数\n⟨푣푎푟\n푘\n⟩\nに初期値を与える式\n⟨푒푥푝\n푘\n⟩\nは、全ての\nletrec\nの束縛を含む環境にて評価される。これ\nは上の例においての\neven?\nと\nodd?\nの相互再帰のような束縛の中\nでの再帰を許す。または以下の様な\n10\nの階乗の評価も可能である。\n(\nletrec\n((\nfact\n(\nlambda\n(\nn\n)\n(\nif\n(=\nn\n1) 1 (*\nn\n(\nfact\n(-\nn\n1)))))))\n(\nfact\n10))\na\nletrec\nを派生式として実装せよ。\nletrec\n式を\nlet\nを上で示\nしたように、または\nExercise 4.18\nの様に変形することで行え。\n即ち、\nletrec\nの変数は\nlet\nを用いて作成しなければならず、\nそして次にそれらの値を\nset!\nで代入すること。\nb\nLouis Reasoner\nは内部定義に関するこの全ての空騒ぎにより\n混乱してしまった。彼の見解は、もし手続の中での\ndefine\nの\n使用を好まないのであれば、単に\nlet\nを使えるのではないか\nである。彼の\nreasoning(\n推測\n)\nの何が緩いのかを、この課題と\n同様に定義された\nf\nを用いて、式\n(f 5)\nの評価の間に\n⟨\nrest\nof body of\nf\n⟩\nが評価された環境を示す環境図を書くことによ\nって説明せよ。同じ環境の、ただし\nf\nの定義中の\nletrec\nの\n場所に\nlet\nを用いた場合の環境図を書け。\nExercise 4.21:\n驚くべきことに、\nExercise 4.20\nにおける\nLouis\nの直\n感は正しい。\nletrec\nを\n(\nまたは\ndefine\nすらも\n)\n用いずに再帰手続\nを指定することは本当に可能である。しかしこれを達成する手法\nは\nLouis\nが存在したよりもずっと繊細である。以下の式は\n10\nの階\n乗を再帰階乗手続を適用することで求めている。\n27\n((\nlambda\n(\nn\n)\n((\nlambda\n(\nfact\n) (\nfact\nfact\nn\n))\n(\nlambda\n(\nft\nk\n)\n27\nこの例は再帰手続を\ndefine\nを用いずに定式化するためのプログラミング上の技を説\n明しています。最も一般的なこの種の技は\n푌\noperator\n(\nY\nコンビネータ\n、不動点演算子\n)\nです。これは\n“pure\n휆\n-calculus”(\n純粋ラムダ計算\n)\nによる再帰の実装を与えます。\n(\n휆\n計算\nの詳細については\nStoy 1977\nを参照して下さい。また\nScheme\nによる\n푌\nコンビネータの\n解説については\nGabriel 1988\nを参照して下さい。\n420","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":446},{"id":"./test/fixtures/pdf/sicp.pdf:447","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nif\n(=\nk\n1) 1 (*\nk\n(\nft\nft\n(-\nk\n1)))))))\n10)\na\n(\n式を評価することで\n)\nこれが実際に階乗を計算することを確\n認せよ。フィボナッチ数を計算する同様な式を工夫せよ。\nb\n以下の手続について考える。これは相互再帰内部定義を含む。\n(\ndefine\n(\nf\nx\n)\n(\ndefine\n(\neven?\nn\n)\n(\nif\n(=\nn\n0)\ntrue\n(\nodd?\n(-\nn\n1))))\n(\ndefine\n(\nodd?\nn\n)\n(\nif\n(=\nn\n0)\nfalse\n(\neven?\n(-\nn\n1))))\n(\neven?\nx\n))\nf\nの代替的な定義を完成するために欠けている式を埋めよ。\nこれは内部定義も\nletrec\nも使用してはいない。\n(\ndefine\n(\nf\nx\n)\n((\nlambda\n(\neven?\nodd?\n) (\neven?\neven?\nodd?\nx\n))\n(\nlambda\n(\nev?\nod?\nn\n)\n(\nif\n(=\nn\n0)\ntrue\n(\nod?\n⟨\n??\n⟩\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))\n(\nlambda\n(\nev?\nod?\nn\n)\n(\nif\n(=\nn\n0)\nfalse\n(\nev?\n⟨\n??\n⟩\n⟨\n??\n⟩\n⟨\n??\n⟩\n)))))\n4.1.7\n構文分析を実行から分離する\n上で実装された評価機は簡単ですが、非効率です。式の構文上の分析がそ\nの実行と相互配置されているためです。従ってもしプログラムが何度も実行さ\nれた場合、その構文は何度も分析されます。例えば次の\nfactorial\nを用いて\n(factorial 4)\nを評価することを考えてみて下さい。\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (* (\nfactorial\n(-\nn\n1))\nn\n)))\nfactorial\nが呼ばれる度に、評価機はボディが\nif\n式であることを判断せね\nばならず、それから述語を取り出します。その後にのみ述語を評価しその値\nにより振り分けが行えます。式\n(* (factorial (- n 1)) n)\n、または部分式\n(factorial (- n 1))\nと\n(- n 1)\nを評価する度に、評価機は\neval\nにて状況分\n421","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":447},{"id":"./test/fixtures/pdf/sicp.pdf:448","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"析を行い式が適用であるかを判断せねばならず、また演算子とオペランドの抽\n出をせねばなりません。この分析はコストが高いのです。これを繰り返し実行\nすることは無駄が多いでしょう。\n評価機を変形し構文上の分析をたった\n1\n度のみ実行されるように準備する\nことで著しく効率良くすることができます。\n28\n私達は式と環境を取る\neval\nを\n2\nつに分けます。手続\nanalyze\nは式のみを取ります。構文上の分析を行い新しい\n手続\nexecution procedure\n(\n実行手続\n)\nを返します。この手続は分析された式を実\n行するにおいて行われた結果をカプセル化します。実行手続は環境を引数とし\nて取り評価を完了します。これは実行手続が何度も呼ばれるのに対し、\nanalyze\nが式に対して\n1\n度しか呼ばれないため作業量を減らせます。\n分析と実行への分離に伴ない、\neval\nは以下の様になります。\n(\ndefine\n(\neval\nexp\nenv\n) ((\nanalyze\nexp\n)\nenv\n))\nanalyze\nの呼出の結果は環境に適用される実行手続です。\nanalyze\n手続は\nSection\n4.1.1\nの元の\neval\nにより実行されたのと同じ状況分析です。ただし私達が呼び\n出す手続は完全な評価ではなく分析のみを実行します。\n(\ndefine\n(\nanalyze\nexp\n)\n(\ncond\n((\nself-evaluating?\nexp\n)\n(\nanalyze-self-evaluating\nexp\n))\n((\nquoted?\nexp\n) (\nanalyze-quoted\nexp\n))\n((\nvariable?\nexp\n) (\nanalyze-variable\nexp\n))\n((\nassignment?\nexp\n) (\nanalyze-assignment\nexp\n))\n((\ndefinition?\nexp\n) (\nanalyze-definition\nexp\n))\n((\nif?\nexp\n) (\nanalyze-if\nexp\n))\n((\nlambda?\nexp\n) (\nanalyze-lambda\nexp\n))\n((\nbegin?\nexp\n)\n(\nanalyze-sequence\n(\nbegin-actions\nexp\n)))\n((\ncond?\nexp\n) (\nanalyze\n(\ncond->if\nexp\n)))\n((\napplication?\nexp\n) (\nanalyze-application\nexp\n))\n(\nelse\n(\nerror\n\"\nUnknown\nexpression\ntype\n:\nANALYZE\n\"\nexp\n))))\n28\nこの技はコンパイル過程に不可欠な要素であり、\nChapter 5\nで議論します。\nJonathan\nRees\nは\n1982\n年頃にこのような\nScheme\nインタプリタを\nT\nプロジェクトのために書きま\nした\n(\nRees and Adams 1982\n)\n。\nMarc\nFeeley (1986)\n(\nFeeley and Lapalme 1987\nも参照\n)\nは彼の修士論文にて独力でこの技を発明しました。\n422","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":448},{"id":"./test/fixtures/pdf/sicp.pdf:449","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"以下に最も簡単な構文分析手続があります。これは自己評価式です。環境引数\nを無視し、ただ式を返す実行手続を返します。\n(\ndefine\n(\nanalyze-self-evaluating\nexp\n)\n(\nlambda\n(\nenv\n)\nexp\n))\nクォートされた式に対してはそのテキストの取り出しを実行フェーズでなく、\n分析フェーズで\n1\n度だけ行うことでほんの少し効率良くすることができます。\n(\ndefine\n(\nanalyze-quoted\nexp\n)\n(\nlet\n((\nqval\n(\ntext-of-quotation\nexp\n)))\n(\nlambda\n(\nenv\n)\nqval\n)))\n変数の値の探索は依然として実行フェーズで行わねばなりません。これは環境\nを知ることに依存するためです。\n29\n(\ndefine\n(\nanalyze-variable\nexp\n)\n(\nlambda\n(\nenv\n) (\nlookup-variable-value\nexp\nenv\n)))\nanalyze-assignment\nもまた実際の変数の設定を環境の供給が完了する実行時\nまで遅らせなければなりません。しかし\nassignment-value\n式が分析の間に\n(\n再\n帰的に\n)\n分析されることができることは効率を大きく向上します。\nassignment-\nvalue\n式は今はただ\n1\n度しか分析されないためです。同じことが定義に対して\nも言えます。\n(\ndefine\n(\nanalyze-assignment\nexp\n)\n(\nlet\n((\nvar\n(\nassignment-variable\nexp\n))\n(\nvproc\n(\nanalyze\n(\nassignment-value\nexp\n))))\n(\nlambda\n(\nenv\n)\n(\nset-variable-value!\nvar\n(\nvproc\nenv\n)\nenv\n)\n'ok\n)))\n(\ndefine\n(\nanalyze-definition\nexp\n)\n(\nlet\n((\nvar\n(\ndefinition-variable\nexp\n))\n(\nvproc\n(\nanalyze\n(\ndefinition-value\nexp\n))))\n(\nlambda\n(\nenv\n)\n(\ndefine-variable!\nvar\n(\nvproc\nenv\n)\nenv\n)\n29\nしかし、構文上の分析の部分にて終わらせられる変数探索の重要な部分があります。\nSection 5.5.6\nにて示されるように、環境構造の中でどこで変数の値が見つかるか、その位\n置を決定することが可能です。従って変数にマッチするエントリのために環境を走査す\nる必要を防ぐことができます。\n423","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":449},{"id":"./test/fixtures/pdf/sicp.pdf:450","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"'ok\n)))\nif\n式に対しては分析時に述語、結果、代替を取り出し分析します。\n(\ndefine\n(\nanalyze-if\nexp\n)\n(\nlet\n((\npproc\n(\nanalyze\n(\nif-predicate\nexp\n)))\n(\ncproc\n(\nanalyze\n(\nif-consequent\nexp\n)))\n(\naproc\n(\nanalyze\n(\nif-alternative\nexp\n))))\n(\nlambda\n(\nenv\n) (\nif\n(\ntrue?\n(\npproc\nenv\n))\n(\ncproc\nenv\n)\n(\naproc\nenv\n)))))\nlambda\n式の分析もまた効率が大きく向上します。\nlambda\nのボディは\n1\n度し\nか分析しません。例え\nlambda\nの評価の結果としての手続が何度適用されても\nです。\n(\ndefine\n(\nanalyze-lambda\nexp\n)\n(\nlet\n((\nvars\n(\nlambda-parameters\nexp\n))\n(\nbproc\n(\nanalyze-sequence\n(\nlambda-body\nexp\n))))\n(\nlambda\n(\nenv\n) (\nmake-procedure\nvars\nbproc\nenv\n))))\n(\nbegin\nや\nlambda\n式のボディの中としての\n)\n式の列の評価の分析はより必要と\nされます。\n30\n列の各式は分析され実行手続を生じます。これらの実行手続は環\n境を引数として取り順番に各個別の実行手続を引数としての環境と共に呼び出\nす実行手続を生成するために組み合わせれます。\n(\ndefine\n(\nanalyze-sequence\nexps\n)\n(\ndefine\n(\nsequentially\nproc1\nproc2\n)\n(\nlambda\n(\nenv\n) (\nproc1\nenv\n) (\nproc2\nenv\n)))\n(\ndefine\n(\nloop\nfirst-proc\nrest-procs\n)\n(\nif\n(\nnull?\nrest-procs\n)\nfirst-proc\n(\nloop\n(\nsequentially\nfirst-proc\n(\ncar\nrest-procs\n))\n(\ncdr\nrest-procs\n))))\n(\nlet\n((\nprocs\n(\nmap\nanalyze\nexps\n)))\n(\nif\n(\nnull?\nprocs\n) (\nerror\n\"\nEmpty\nsequence\n:\nANALYZE\n\"\n))\n(\nloop\n(\ncar\nprocs\n) (\ncdr\nprocs\n))))\n30\n列の処理に関する実態については\nExercise 4.23\nを参照して下さい。\n424","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":450},{"id":"./test/fixtures/pdf/sicp.pdf:451","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"適用を分析するためには、演算子とオペランドを分析し、演算子の実行手続\nを\n(\n実際に適用される手続を得るために\n)\n呼び出し、オペランドの実行手続\nを\n(\n実際の引数を得るために\n)\n呼び出す実行手続を構築します。次にこれらを\nexecute-application\nに渡します。これは\nSection 4.1.1\nの\napply\nの類似品で\nす。\nexecute-application\nは\napply\nとは複合手続のための手続のボディが既\nに分析されている点が異なります。そのためさらなる分析の必要性がありませ\nん。その代わりに、ただ拡張された環境上のボディに対して手続実行を呼び出\nします。\n(\ndefine\n(\nanalyze-application\nexp\n)\n(\nlet\n((\nfproc\n(\nanalyze\n(\noperator\nexp\n)))\n(\naprocs\n(\nmap\nanalyze\n(\noperands\nexp\n))))\n(\nlambda\n(\nenv\n)\n(\nexecute-application\n(\nfproc\nenv\n)\n(\nmap\n(\nlambda\n(\naproc\n) (\naproc\nenv\n))\naprocs\n)))))\n(\ndefine\n(\nexecute-application\nproc\nargs\n)\n(\ncond\n((\nprimitive-procedure?\nproc\n)\n(\napply-primitive-procedure\nproc\nargs\n))\n((\ncompound-procedure?\nproc\n)\n((\nprocedure-body\nproc\n)\n(\nextend-environment\n(\nprocedure-parameters\nproc\n)\nargs\n(\nprocedure-environment\nproc\n))))\n(\nelse\n(\nerror\n\"\nUnknown\nprocedure\ntype\n:\nEXECUTE-APPLICATION\n\"\nproc\n))))\n私達の新しい評価機は節\nSection 4.1.2\n,\nSection 4.1.3\n,\nSection 4.1.4\nにあるよう\nに、同じデータ構造、構文手続、実行時サポート手続を用います。\nExercise 4.22:\nこの節の評価機を特別な形式\nlet\nをサポートする\nように拡張せよ。\n(\nExercise 4.6\n参照\n)\nExercise 4.23:\nAlyssa P. Hacker\nはなぜ\nanalyze-sequence\nがそん\nなに複雑になるのか理解できなかった。他の分析手続全ては\nSection\n425","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":451},{"id":"./test/fixtures/pdf/sicp.pdf:452","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4.1.1\nの対応する評価手続\n(\nまたは\neval\n節\n)\nの簡単な変形である。彼\n女は\nanalyze-sequence\nは以下のようになるのではと予想した。\n(\ndefine\n(\nanalyze-sequence\nexps\n)\n(\ndefine\n(\nexecute-sequence\nprocs\nenv\n)\n(\ncond\n((\nnull?\n(\ncdr\nprocs\n))\n((\ncar\nprocs\n)\nenv\n))\n(\nelse\n((\ncar\nprocs\n)\nenv\n)\n(\nexecute-sequence\n(\ncdr\nprocs\n)\nenv\n))))\n(\nlet\n((\nprocs\n(\nmap\nanalyze\nexps\n)))\n(\nif\n(\nnull?\nprocs\n)\n(\nerror\n\"\nEmpty\nsequence\n:\nANALYZE\n\"\n))\n(\nlambda\n(\nenv\n) (\nexecute-sequence\nprocs\nenv\n))))\nEva Lu Ator\nは\nAlyssa\nに対し、テキストの版は分析時に列を評価\nする仕事よりもより多くのことを行っていると説明した。\nAlyssa\nの逐次実行手続は個別の組み込みの実行手続に対する呼出を行う\nのではなく、複数の手続を通してそれらを呼び出すためにループ\nする。実際に列内の個別の式は分析されるが、列それ自身は分析\nされない。\n2\nつの版の\nanalyze-sequence\nを比較せよ。例として、列がただ\n1\nつの式を持つ場合において\n(\n手続のボディ特有の\n)\n共通な場合につ\nいて考えよ。\nAlyssa\nのプログラムにより生成された実行手続はど\nのような行いをするか\n?\n上のテキスト内のプログラムで生成され\nた実行手続についてはどうか\n? 2\nつの版は\n2\nつの式を持つ列に対し\nてはどのように比較されるか\n?\nExercise 4.24:\n元のメタ循環評価機とこの節の版のスピードを比較\nするためのいくつかの実験を設計し実行せよ。あなたの結果を用\nいて種々の手続に対して分析と実行で消費された時間を概算せよ。\n4.2\nScheme\n上でのバリエーション\n—\n遅延評価\n今や私達は\nLisp\nプログラムとして表現された評価機を得ました。これで言\n語設計上の代替となる選択を単純に評価機を変更することで試験することがで\nきます。実際に新しい言語は良く、最初に既存の高級言語の中に新しい言語を\n426","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":452},{"id":"./test/fixtures/pdf/sicp.pdf:453","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"埋め込む評価機を書くことで開発されます。例えばもしわたしたちが\nLisp\nに\n対する変更の提案のある側面について\nLisp\nコミュニティの他のメンバと議論\nしたい時に、変更を組み込んだ評価機を与えることができます。受け手はする\nと新しい評価機を持ちいて実験を行いさらなる変更としてのコメントを返すこ\nとができます。高レベルな実装ベースが評価機のテストとデバッグをより簡単\nにするだけではありません。加えて組込むことは設計者に対し下層の言語から\n機能を\nsnarf\nする\n31\nことを可能にします。これは私達の組込\nLisp\n評価機が下\n層の\nLisp\nからプリミティブやコントロール構造を使用するのと同じです。設\n計者は\n(\nもし必要があれば\n)\n後で低レベル言語やハードウェアにて完全な実装\nを構築するだけです。この節と次では\nScheme\nの、優位な追加の表現力を提供\nするいくつかのバリエーションについて探求します。\n4.2.1\n正規順と適用順\nSection 1.1\nでは評価のモデルについての議論を始めましたが、\nScheme\nは\napplicative-order\n(\n適用順序\n)\n言語であると記しました。即ち、\nScheme\nの手続\nへの全ての引数は手続が適用される時に評価される、と。逆に、\nnormal-order\n(\n正\n規順序\n)\n言語は手続引数の評価を実際に引数の値が必要とされるまで遅らせま\nす。手続引数の評価を可能な限り最後の瞬間まで\n(\n例えばプリミティブ命令に\nより必要とされるまで\n)\n遅らせることは\nlazy evaluation\n(\n遅延評価\n)\nと呼ばれま\nす。\n32\n以下の手続について考えてみましょう。\n(\ndefine\n(\ntry\na\nb\n) (\nif\n(=\na\n0) 1\nb\n))\n(try 0 (/ 1 0))\nの評価は\nScheme\nではエラーを生成します。遅延評価ではエ\nラーは現れません。その式の評価は\n1\nになります。なぜなら絶対に引数は評価\nされないためです。\n遅延評価を利用した例で、手続\nunless\nの定義です。\n(\ndefine\n(\nunless\ncondition\nusual-value\nexceptional-value\n)\n31\nSnarf: “\nつかみ取ること、特に巨大な文書やファイルを持ち主の許可を得ても得な\nくても使う目的のため\n” Snarf Down: “snarf\nすること、稀に吸収する、処理する、また\nは理解するの含意を持つ\n” (\nこれらの定義は\nSteele et al. 1983\nから\nsnarf\nした。\nRaymond\n1993\nも参照すること\n)\n32\n専門用語\n“lazy”\nと\n“normal-order”\nの間の違いはいささか曖昧\n(fuzzy)\nです。一般的\nに\n“lazy”\nは特定の評価機の仕組みを参照しますが、一方で\n“normal-order”\nは言語の意\n味を参照し、どんな特定の評価戦術からも独立しています。しかしこれは確かな区別で\nはありません。そして\n2\nつの専門用語は良く同義的に用いられています。\n427","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":453},{"id":"./test/fixtures/pdf/sicp.pdf:454","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nif\ncondition\nexceptional-value\nusual-value\n))\nこれは以下のような式で使用できます。\n(\nunless\n(=\nb\n0)\n(/\na\nb\n)\n(\nbegin\n(\ndisplay\n\"\nexception\n:\nreturning\n0\n\"\n) 0))\nこれは適用順序の言語では動きません。通常値と例外値の両方が\nunless\nが呼\nばれる前に評価されるためです。\n(\nExercise 1.6\nと比較してみて下さい\n)\n。遅延評\n価の利点は\nunless\nのような手続は例えそれらの引数の幾つかの評価がエラー\nを発したり、停止しなかったとしても役立つ計算ができます。\n引数の評価が完了する前に手続のボディに入ることを、手続がその引数に\nおいて\nnon-strict\n(\n非厳密\n)\nであると呼びます。もし引数が手続のボディに入る\n前に評価されたなら手続はその引数に対し\nstrict\n(\n厳密\n)\nであると言います。\n33\n純\n粋適用順序言語では全ての手続が全ての引数に対し厳密です。そしてプリミテ\nィブな手続は厳密にも非厳密にも成り得ます。またプログラマに彼等が定義す\nる手続の厳密さに細かなコントロールを提供する言語もあります。\n(\nExercise\n4.31\n参照\n)\n実用性のため非厳密にすることができる手続の印象的な例には\ncons\n(\nまた\nは一般的に、ほとんど全てのデータ構造のコンストラクタが\n)\nあります。例え\nもし要素の値がわからなくても、データ構造を形成するよう要素を組み立て、\n結果のデータ構造上で操作する実用的な計算を行えます。例えばリストの長さ\nをリスト内の個々の要素の値を知ること無しに計算することは完璧に意味があ\nります。私達はこの考えを\nSection 4.2.3\nで非厳密な\ncons\nペアにより形成された\nリストとして\nChapter 3\nのストリームを実装するために利用します。\nExercise 4.25:\n(\n通常の適用順\nScheme\nにおいて\n)\nunless\nを上で示さ\nれたように定義し、次に\nunless\nを用いて以下のように\nfactorial\nを定義する。\n(\ndefine\n(\nfactorial\nn\n)\n(\nunless\n(=\nn\n1)\n(*\nn\n(\nfactorial\n(-\nn\n1)))\n33\n“\n厳密\n”\n対\n“\n非厳密\n”\nの技術用語は本質的には\n“\n適用順序\n”\n対\n“\n正規順序\n”\nと同じこと\nを言っています。しかし個別の手続と引数を言及しており、言語全体を言及してはいま\nせん。プログラミング言語のカンファレンスでは誰かがこのようなことを言うのを聞く\nかもしれません。\n“\n正規順序言語の\nHassle\nはいくつか厳密なプリミティブを持っている。\n他の手続はそれらの引数を遅延評価で取る。\n”\n428","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":454},{"id":"./test/fixtures/pdf/sicp.pdf:455","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"1))\nもし\n(factorial 5)\nを評価したら何が起こるか\n?\nこの定義は正規\n順序言語では動くか\n?\nExercise 4.26:\nBen Bitdiddle\nと\nAlyssa P. Hacker\nは\nunless\nのよ\nうな物を実装するための遅延評価の重要性について意見が分かれ\nた。\nBen\nは\nunless\nを適用順序でも特別形式として実装可能である\n点を指摘した。\nAlyssa\nはもしそれを行えば\nunless\nはただ単に構\n文であり高階手続と連動して使用できる手続ではないと反論した。\n議論の両サイド上の詳細を埋めよ。\nunless\nをどのようにして派生\n手続として\n(\ncond\nや\nlet\nのように\n)\n実装するかを示せ。そして特別\n形式ではなく手続として存在する\nunless\nを持つことが有効である\n状況の例を与えよ。\n4.2.2\n遅延評価を持つインタプリタ\nこの節では\nScheme\nと同じですが、複合手続が全ての引数に対して非厳密\nであることが異なる正規順言語を実装します。プリミティブな手続は依然とし\nて厳密です。\nSection 4.1.1\nの評価機を、それが解釈する言語がこのように振る\n舞うように変更するのは難しくありません。ほとんど全ての必要な変更は手続\n適用が中心となります。\n基本的な考えは、手続を適用する時、インタプリタはどの引数が評価され\nるべきかと、どの引数が遅延されるべきかを決定しなければなりません。遅延\n化された引数は評価されません。その代わりにそれらは\nthunks\n(\nサンク\n)\nと呼ば\nれるオブジェクトに変形されます。\n34\nサンクは引数の値を生成するために必要\nな情報を必要な時に含んでなければなりません。それはまるで適用時に評価さ\nれたかのようにです。従って、サンクは引数の式と手続適用がその中で評価さ\nれる環境を持たなければなりません。\nサンク中の式の評価プロセスは\nforcing\n(\n強制\n)\nと呼ばれます。\n35\n一般的には\n34\nthunk\nという単語は非公式な作業部会により考案されました。彼等は\nAlgol 60\nにて\ncall-by-name\nの実装について議論していたのです。彼等は式のほとんどの分析は\n(“\n式に\nついての考えは\n”)\nコンパイル時に行えることに気付きました。従って実行時には式は既\nに\n(\nIngerman et al. 1960\n)\nに係わる\n“\nサンク\n”\nを持っていました。\n35\nこれは\nChapter 3\nでストリームを表現するのに導入された遅延化オブジェクト上で\nforce\nを用いることに類似しています。ここで行っていることと、\nChapter 3\nで行ったこ\nとの重大な違いは、ここでは遅延化と強制を評価機の中に構築していることです。従っ\nてこれを言語を通して同一化し、自動化しています。\n429","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":455},{"id":"./test/fixtures/pdf/sicp.pdf:456","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"サンクはその値が必要になった時のみ強制されます。サンクの値を使用するプ\nリミティブな手続に渡された時です。またオペレータの値であり手続として適\n用される時です。設計上の\n1\nつの選択として可能なこととして、\nSection 3.5.1\nに\nて遅延化オブジェクトに我々がしたように、サンクを\nmemoize\n(\nメモ化\n)\nするか\n否かがあります。メモ化を用いれば、サンクが初めて強制された時、計算され\nた値が格納されます。続く強制は単純に演算を繰り返すことなく単純に格納さ\nれた値を返します。私達はインタプリタをメモ化します。これはとても多くの\nアプリケーションに対して効率的だからです。しかし、これには用心しなけれ\nばならない考慮点が存在します。\n36\n評価機を変更する\n遅延評価と\nSection 4.1\nの評価との主な違いは\neval\nと\napply\nにおける手続\n適用の取扱に存在します。\neval\nの\napplication?\n節は以下になります。\n((\napplication?\nexp\n)\n(\napply\n(\nactual-value\n(\noperator\nexp\n)\nenv\n)\n(\noperands\nexp\n)\nenv\n))\nこれは\nSection 4.1.1\nの\neval\nの\napplication?\n節とほとんど同じです。遅延評価\nのためにはしかし、\napply\nをオペランド式と共に呼びます。それらを評価する\nことで生成された引数と共にではありません。もし引数が遅延化されるのであ\nれば環境にサンクを構築させる必要が出るので、これも渡さなければいけませ\nん。依然として演算子は評価します。\napply\nは実際の手続が必要です。その型\n(\nプリミティブであるか複合であるか\n)\nに従って呼出と適用を行うためです。\n式の実際の値が必要になる度に、\neval\nするだけの代わりに以下を用います。\n(\ndefine\n(\nactual-value\nexp\nenv\n)\n(\nforce-it\n(\neval\nexp\nenv\n)))\n36\nメモ化と組み合わされた遅延評価は時々、\ncall-by-need\n(\n必要時呼出\n)\n引数渡しと呼ば\nれます。\ncall-by-name\n(\n名前呼出\n)\n引数渡しと対照的です。\n(call-by-name\nは\nAlgol 60\nで導\n入されましたが、メモ化を行わない遅延評価と同類です\n)\n。言語設計者として、私達は評\n価機をメモ化することも、しないことも、プログラマに任せることも可能です\n(\nExercise\n4.31\n)\n。\nChapter 3\nからおわかりかと思いますが、これらの選択は微妙で、かつ混乱を招く\n問題を代入の存在において提起します。\n(\nExercise 4.27\nと\nExercise 4.29\nを参照\n)\n。\nClinger\n(1982)\nによる素晴しい論文がここで提起される混乱の複数の特徴を明らかにしようと試\nみています。\n430","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":456},{"id":"./test/fixtures/pdf/sicp.pdf:457","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これでもし式の値がサンクであれば強制されます。\nまた新しい版の\napply\nもほとんど\nSection 4.1.1\nの版と同じです。違いは\neval\nが未評価のオペランド式を通り直ぎたことです。\n(\n厳密である\n)\nプリミテ\nィブな手続に対してはプリミティブを適用する前に全ての引数を評価します。\n(\n非厳密である\n)\n複合手続に対しては全ての引数を手続に適用する前に遅延化し\nます。\n(\ndefine\n(\napply\nprocedure\narguments\nenv\n)\n(\ncond\n((\nprimitive-procedure?\nprocedure\n)\n(\napply-primitive-procedure\nprocedure\n(\nlist-of-arg-values\narguments\nenv\n)))\n;\nchanged\n((\ncompound-procedure?\nprocedure\n)\n(\neval-sequence\n(\nprocedure-body\nprocedure\n)\n(\nextend-environment\n(\nprocedure-parameters\nprocedure\n)\n(\nlist-of-delayed-args\narguments\nenv\n)\n;\nchanged\n(\nprocedure-environment\nprocedure\n))))\n(\nelse\n(\nerror\n\"\nUnknown\nprocedure\ntype\n:\nAPPLY\n\"\nprocedure\n))))\n引数を処理する手続は\nSection 4.1.1\nの\nlist-of-values\nそっくりです。しかし\nlist-of-delayed-args\nが引数を評価するのではなく遅延化することと、\nlist-\nof-arg-values\nが\neval\nの代わりに\nactual-value\nを用いることが違います。\n(\ndefine\n(\nlist-of-arg-values\nexps\nenv\n)\n(\nif\n(\nno-operands?\nexps\n)\n'\n()\n(\ncons\n(\nactual-value\n(\nfirst-operand\nexps\n)\nenv\n)\n(\nlist-of-arg-values\n(\nrest-operands\nexps\n)\nenv\n))))\n(\ndefine\n(\nlist-of-delayed-args\nexps\nenv\n)\n(\nif\n(\nno-operands?\nexps\n)\n'\n()\n(\ncons\n(\ndelay-it\n(\nfirst-operand\nexps\n)\nenv\n)\n431","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":457},{"id":"./test/fixtures/pdf/sicp.pdf:458","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlist-of-delayed-args\n(\nrest-operands\nexps\n)\nenv\n))))\n評価機で変更しなければいけない他の場所は\nif\nの取扱の中にあります。そこ\nでは\neval\nの代わりに\nactual-value\nを使用して述語が真であるか偽であるか\nテストする前に、述語式の値を取らねばなりません。\n(\ndefine\n(\neval-if\nexp\nenv\n)\n(\nif\n(\ntrue?\n(\nactual-value\n(\nif-predicate\nexp\n)\nenv\n))\n(\neval\n(\nif-consequent\nexp\n)\nenv\n)\n(\neval\n(\nif-alternative\nexp\n)\nenv\n)))\n最後に、\nSection 4.1.4\nの\ndriver-loop\n手続を変更して、\neval\nの代わりに\nactual-\nvalue\nを使用せねばなりあせん。そうすることでもし遅延化された値が\nREPL\nに伝播して返った場合に、表示される前に強制されます。またプロンプトも変\n更してこれが遅延評価であることを示します。\n(\ndefine\ninput-prompt\n\"\n;;;\nL-Eval\ninput\n:\n\"\n)\n(\ndefine\noutput-prompt\n\"\n;;;\nL-Eval\nvalue\n:\n\"\n)\n(\ndefine\n(\ndriver-loop\n)\n(\nprompt-for-input\ninput-prompt\n)\n(\nlet\n((\ninput\n(\nread\n)))\n(\nlet\n((\noutput\n(\nactual-value\ninput\nthe-global-environment\n)))\n(\nannounce-output\noutput-prompt\n)\n(\nuser-print\noutput\n)))\n(\ndriver-loop\n))\nこれらの変更を行うことで、評価機を開始しテストすることができます。\nSection\n4.2.1\nで議論された\ntry\n式の評価の成功はインタプリタが遅延評価を実行してい\nることを示しています。\n(\ndefine\nthe-global-environment\n(\nsetup-environment\n))\n(\ndriver-loop\n)\n;;; L-Eval input:\n(\ndefine\n(\ntry\na\nb\n) (\nif\n(=\na\n0) 1\nb\n))\n;;; L-Eval value:\nok\n432","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":458},{"id":"./test/fixtures/pdf/sicp.pdf:459","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":";;; L-Eval input:\n(\ntry\n0 (/ 1 0))\n;;; L-Eval value:\n1\nサンクの表現\n私達の評価機は手続が引数に適用される時にサンクを作成することと、こ\nれらのサンクを後で強制することの準備をせねばなりません。サンクは式を環\n境と一緒にまとめなければなりません。そうすることで引数が後から生成され\nることができます。サンクを強制するためには単純に式と環境をサンクから取\nり出しその環境の中で式を評価します。\neval\nではなく\nactual-value\nを用いる\nことで式の値それ自身がサンクである場合にその強制をサンクでない物に辿り\n着くまで繰り返します。\n(\ndefine\n(\nforce-it\nobj\n)\n(\nif\n(\nthunk?\nobj\n)\n(\nactual-value\n(\nthunk-exp\nobj\n) (\nthunk-env\nobj\n))\nobj\n))\n式と環境をまとめる\n1\nつの簡単な方法はその式と環境を含むリストを作成する\nことです。従ってサンクを以下のように作成します。\n(\ndefine\n(\ndelay-it\nexp\nenv\n)\n(\nlist\n'thunk\nexp\nenv\n))\n(\ndefine\n(\nthunk?\nobj\n)\n(\ntagged-list?\nobj\n'thunk\n))\n(\ndefine\n(\nthunk-exp\nthunk\n) (\ncadr\nthunk\n))\n(\ndefine\n(\nthunk-env\nthunk\n) (\ncaddr\nthunk\n))\n実際に私達のインタプリタに欲っしたものはこれではなく、メモ化されたサン\nクです。サンクが強制された時に格納された式とその値に置き換え、\nthunk\nタ\nグを変更することでサンクをサンクが評価された物に変更することで、既に評\n価されたと認識させることができます。\n37\n37\n一度式の値が計算されればサンクから\nenv\nもまた消去します。これによりインタプ\nリタにより返される値に違いは生じません。しかしこれはスペースを本当に節約しま\nす。サンクから\nenv\nへの参照を必要が無くなったら直ぐに削除することで、この構造が\ngarbage-collected\n(\nガベージコレクション\n、\nGC\n、ゴミ集め\n)\nされ、そのスペースは\nSection\n433","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":459},{"id":"./test/fixtures/pdf/sicp.pdf:460","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nevaluated-thunk?\nobj\n)\n(\ntagged-list?\nobj\n'evaluated-thunk\n))\n(\ndefine\n(\nthunk-value\nevaluated-thunk\n)\n(\ncadr\nevaluated-thunk\n))\n(\ndefine\n(\nforce-it\nobj\n)\n(\ncond\n((\nthunk?\nobj\n)\n(\nlet\n((\nresult\n(\nactual-value\n(\nthunk-exp\nobj\n)\n(\nthunk-env\nobj\n))))\n(\nset-car!\nobj\n'evaluated-thunk\n)\n(\nset-car!\n(\ncdr\nobj\n)\nresult\n)\n;\nexp\nをその値で置き換える\n(\nset-cdr!\n(\ncdr\nobj\n)\n'\n())\n;\n不必要な\nenv\nを忘れる\nresult\n))\n((\nevaluated-thunk?\nobj\n) (\nthunk-value\nobj\n))\n(\nelse\nobj\n)))\n同じ\ndelay-it\n手続がメモ化有りでも無しでも動作することに注意して下さい。\nExercise 4.27:\n以下の定義を遅延評価機に入力したとする。\n(\ndefine\ncount\n0)\n(\ndefine\n(\nid\nx\n) (\nset!\ncount\n(+\ncount\n1))\nx\n)\n以下の一連の応答の欠けた値を与えよ。そして貴方の回答につい\nて説明せよ。\n38\n(\ndefine\nw\n(\nid\n(\nid\n10)))\n;;; L-Eval input:\ncount\n;;; L-Eval value:\n⟨\nresponse\n⟩\n5.3\nで議論されるようにリサイクルされます。\n同様に、\nSection 3.5.1\nのメモ化、遅延化されたオブジェクトの中の不必要な環境を\nGC\nされるように許可することも、\nmemo-proc\nに\n(set! proc '())\nの様な何かを行わせて\n(\ndelay\nが中で評価される環境を含む\n)\n手続\nproc\nをその値を格納した後に捨てることでで\nきました。\n38\nこの課題は遅延評価と副作用の間の応答が大きな混乱の原因となりえることを実演\nしている。これこそが\nChapter 3\nの議論からあなたが予期するかもしれないことである。\n434","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":460},{"id":"./test/fixtures/pdf/sicp.pdf:461","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":";;; L-Eval input:\nw\n;;; L-Eval value:\n⟨\nresponse\n⟩\n;;; L-Eval input:\ncount\n;;; L-Eval value:\n⟨\nresponse\n⟩\nExercise 4.28:\neval\nは\neval\nでなく\nactual-value\nを用いて\napply\nに渡す前に演算子を評価する。演算子の値を強制するためである。\nこの強制の必要性を実演する例を与えよ。\nExercise 4.29:\nメモ化しない場合に、メモ化した場合よりも非常に\n遅く実行されると予測するプログラムを示せ。また以下の応答に\nついて考えよ。\nid\n手続は\nExercise 4.27\nと同じに定義され\ncount\nは\n0\nから始める。\n(\ndefine\n(\nsquare\nx\n) (*\nx\nx\n))\n;;; L-Eval input:\n(\nsquare\n(\nid\n10))\n;;; L-Eval value:\n⟨\nresponse\n⟩\n;;; L-Eval input:\ncount\n;;; L-Eval value:\n⟨\nresponse\n⟩\n評価機がメモ化された場合とメモ化されない場合の両方について\n応答を与えよ。\nExercise 4.30:\nCy D. Fect\nは元\nC\n言語プログラマである。彼はい\nくつかの\nside effects(\n副作用\n)\nが起こらないのではないかと心配し\nている。遅延評価が列内の式に強制を行わないためである。最後\nの\n1\nつ以外の列内の式の値は使用されないため\n(\n式は変数への代入\nや表示等の作用のためだけに存在している\n)\n、この値の強制を引き\n起こす後の使用は存在しない\n(\n例えばプリミティブな手続の引数\nとして\n)\n。\nCy\nは従って列を評価する時には列内の最後の\n1\nつを除\n435","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":461},{"id":"./test/fixtures/pdf/sicp.pdf:462","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"いた全ての式を評価せねばならないと考えた。彼は\nSection 4.1.1\nの\neval-sequence\nを変更し\neval\nでなく\nactual-value\nを使用するこ\nとを提案した。\n(\ndefine\n(\neval-sequence\nexps\nenv\n)\n(\ncond\n((\nlast-exp?\nexps\n) (\neval\n(\nfirst-exp\nexps\n)\nenv\n))\n(\nelse\n(\nactual-value\n(\nfirst-exp\nexps\n)\nenv\n)\n(\neval-sequence\n(\nrest-exps\nexps\n)\nenv\n))))\na\nBen Bitdiddle\nは\nCy\nが間違っていると考えた。彼は\nCy\nに\nExercise 2.23\nで説明された\nfor-each\n手続を見せた。こ\nれは副作用を伴う列の重要な例を与える。\n(\ndefine\n(\nfor-each\nproc\nitems\n)\n(\nif\n(\nnull?\nitems\n)\n'done\n(\nbegin\n(\nproc\n(\ncar\nitems\n))\n(\nfor-each\nproc\n(\ncdr\nitems\n)))))\n彼はテキストの評価機\n(\nオリジナルの\neval-sequence\nを持つ\n物\n)\nはこれを正しく取り扱うと主張した。\n;;; L-Eval input:\n(\nfor-each\n(\nlambda\n(\nx\n) (\nnewline\n) (\ndisplay\nx\n))\n(\nlist\n57 321 88))\n57\n321\n88\n;;; L-Eval value:\ndone\nなぜ\nBen\nが\nfor-each\nの振舞について正しいのか説明せよ。\nb\nCy\nは\nBen\nが\nfor-each\nについて正しいのは同意した。しか\nし彼が\neval-sequence\nに対する変更を提案した時、彼が考え\nていたのはこの種のプログラムではないと言った。彼は以下\nの\n2\nつの遅延評価の手続を定義した。\n(\ndefine\n(\np1\nx\n)\n(\nset!\nx\n(\ncons\nx\n'\n(2)))\n436","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":462},{"id":"./test/fixtures/pdf/sicp.pdf:463","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"x\n)\n(\ndefine\n(\np2\nx\n)\n(\ndefine\n(\np\ne\n)\ne\nx\n)\n(\np\n(\nset!\nx\n(\ncons\nx\n'\n(2)))))\nオリジナルの\neval-sequence\nを用いた時、\n(p1 1)\nと\n(p2 1)\nの値はいくらか\n? Cy\nが提案した\neval-sequence\nへの変更を\n用いた時には値はどうなるか\n?\nc\nCy\nは彼が提案した通りの\neval-sequence\nへの変更は\na\nの例\nの振舞に影響を与えないと指摘した。なぜこれが正しいのか\n説明せよ。\nd\n遅延評価では列はどのように扱われるべきと考えるか\n?\nあな\nたは\nCy\nのアプローチ、テキストのアプローチ、または他の\nアプローチのどれを好むか\n?\nExercise 4.31:\nこの節で取り上げられた取り組み方は少々、不愉快\nである。\nScheme\nに対して互換性のない変更を行うためだ。遅延評\n価を\nupward-compatible extension\n(\n上位互換性のある拡張\n)\nとして\n実装するほうがより良いだろう。それは通常の\nScheme\nプログラ\nムが依然と同じように働くということである。これをユーザに引\n数が遅延されるか、されないかをコントロールさせるように手続\n定義の構文を拡張することで可能である。それを行う間、ユーザ\nに遅延をメモ化させるか、させないかの選択も同様に与えること\nができるだろう。例えば、以下の定義は\n(\ndefine\n(\nf\na\n(\nb\nlazy\n)\nc\n(\nd\nlazy-memo\n))\n...\n)\nf\nは\n4\nつの引数の手続であり、最初と\n3\n番目の引数は手続が呼ばれ\nた時に評価され、\n2\n番目は遅延化され、\n4\n番目は遅延化とメモ化が\n行われる。従って通常の手続定義は通常の\nScheme\nと同じ振舞を\n行うが、\nlazy-memo\n宣言を各複合手続の各パラメタに追加するこ\nとでこの節で定義された遅延評価の振舞を行う。この変更の設計\nと実装は\nScheme\nに対しそのような拡張の生成を必要とする。あ\nなたは\ndefine\nに対する新しい構文を取り扱う新しい構文手続を実\n437","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":463},{"id":"./test/fixtures/pdf/sicp.pdf:464","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"装しなければならない。また引数がいつ遅延化されるか、そして\nいつ強制するか、またはそれに応じて引数を遅延化するか決定す\nるために\neval\nや\napply\nに対して準備もしなければならない。同時\nに強制に対してメモ化するか、しないかも適切に準備すること。\n4.2.3\n遅延化リストとしてのストリーム\nSection 3.5.1\nではどのようにストリームを遅延化されたリストとして実装\nするかについて示しました。特別な形式\ndelay\nと\ncons-stream\n導入しました。\nこのことは私達にストリームの\ncdr\nを求める\n“promise”(\nプロミス、約束\n)\nを、\n実際には後になるまではプロミスを実行すること無しに構築することを可能に\nしました。\n遅延評価ではストリームとリストは同一にできます。そのため特別な形式\nやリストとストリームの命令を分ける必要はありません。私達が行わなけれ\nばならないこと全ては\ncons\nが非厳密になるよう問題を準備することです。こ\nれを達成する\n1\nつの方法は遅延評価を拡張しプリミティブにも非厳密を許し\ncons\nをこれらの内の\n1\nつとすることです。より簡単な方法は\n(\nSection 2.1.3\n)\nの\ncons\nをプリミティブとして実装する必要性は本質的には全く無いということ\nを思い出すことです。その代わりに、ペアは手続として表現可能です。\n39\n(\ndefine\n(\ncons\nx\ny\n) (\nlambda\n(\nm\n) (\nm\nx\ny\n)))\n(\ndefine\n(\ncar\nz\n) (\nz\n(\nlambda\n(\np\nq\n)\np\n)))\n(\ndefine\n(\ncdr\nz\n) (\nz\n(\nlambda\n(\np\nq\n)\nq\n)))\nこれらの基本的な命令において、リスト命令の標準定義は無限リスト\n(\nストリ\nーム\n)\nと同様に有限な物としても働きます。そしてストリーム命令はリスト命\n令として実装可能です。以下にいくつかの例を示します。\n(\ndefine\n(\nlist-ref\nitems\nn\n)\n(\nif\n(=\nn\n0)\n(\ncar\nitems\n)\n(\nlist-ref\n(\ncdr\nitems\n) (-\nn\n1))))\n39\nこれが\nExercise 2.4\nで説明された手続表現です。本質的にはどんな手続表現\n(\n例えば\nメッセージパッシングによる実装\n)\nも同じことが行えるでしょう。これらの定義を遅延評\n価に単純にドライバーループにて型を付けることのみでインストールできることに注意\nして下さい。もし私達が元々\ncons\n,\ncar\n,\ncdr\nをグローバル環境のプリミティブとして含\nめていたのならば、それらは再定義されるでしょう。\n(\nExercise 4.33\nと\nExercise 4.34\nも参\n照して下さい。\n438","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":464},{"id":"./test/fixtures/pdf/sicp.pdf:465","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nmap\nproc\nitems\n)\n(\nif\n(\nnull?\nitems\n)\n'\n()\n(\ncons\n(\nproc\n(\ncar\nitems\n)) (\nmap\nproc\n(\ncdr\nitems\n)))))\n(\ndefine\n(\nscale-list\nitems\nfactor\n)\n(\nmap\n(\nlambda\n(\nx\n) (*\nx\nfactor\n))\nitems\n))\n(\ndefine\n(\nadd-lists\nlist1\nlist2\n)\n(\ncond\n((\nnull?\nlist1\n)\nlist2\n)\n((\nnull?\nlist2\n)\nlist1\n)\n(\nelse\n(\ncons\n(+ (\ncar\nlist1\n) (\ncar\nlist2\n))\n(\nadd-lists\n(\ncdr\nlist1\n) (\ncdr\nlist2\n))))))\n(\ndefine\nones\n(\ncons\n1\nones\n))\n(\ndefine\nintegers\n(\ncons\n1 (\nadd-lists\nones\nintegers\n)))\n;;; L-Eval input:\n(\nlist-ref\nintegers\n17)\n;;; L-Eval value:\n18\nこれらの遅延リストは\nChapter 3\nのストリームよりもさらに遅延化されていま\nす。リストの\ncar\nも\ncdr\nと同様に遅延化されます。\n40\n実際に、遅延化ペアの\ncar\nや\ncdr\nに対するアクセスさえもリスト要素の値を強制する必要がありませ\nん。その値はそれが本当に必要になった場合\n—\n例えばプリミティブの引数とし\nてや回答として表示される場合に\n—\n強制されることになります。\n遅延化ペアはまた\nSection 3.5.4\nでストリームに対して提起された問題に対\nする手助けにもなります。その時はループを伴なうシステムのストリームモデ\nルを定式化することは明示的な\ndelay\n命令を\ncons-stream\nで提供されるもの\nを越えてプログラムの中に撒き散らすことを必要としました。遅延評価では全\nての手続の引数は遅延化に統一されています。例えばリストと統合する手続\nを実装し微分方程式を\nSection 3.5.4\nで元々意図したように実装することが可能\nです。\n(\ndefine\n(\nintegral\nintegrand\ninitial-value\ndt\n)\n(\ndefine\nint\n(\ncons\ninitial-value\n40\nこのことはより一般的な種類の、ただの列ではない、リスト構造の遅延化版を作るこ\nとを可能にします。\nHughes 1990\nは\n“\n遅延化木\n”\nのいくつかのアプリケーションについて\n議論しています。\n439","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":465},{"id":"./test/fixtures/pdf/sicp.pdf:466","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nadd-lists\n(\nscale-list\nintegrand\ndt\n)\nint\n)))\nint\n)\n(\ndefine\n(\nsolve\nf\ny0\ndt\n)\n(\ndefine\ny\n(\nintegral\ndy\ny0\ndt\n))\n(\ndefine\ndy\n(\nmap\nf\ny\n))\ny\n)\n;;; L-Eval input:\n(\nlist-ref\n(\nsolve\n(\nlambda\n(\nx\n)\nx\n) 1 0.001) 1000)\n;;; L-Eval value:\n2.716924\nExercise 4.32:\nChapter 3\nのストリームとこの節で説明された\n“\nよ\nり遅延化された\n”\n遅延化リストの間の違いを説明する例をいくつ\nか上げよ。この拡張された遅延性の利点をどのように活用するか\n?\nExercise 4.33:\nBen Bitdiddle\nは上で与えられた遅延リスト実装を\n式\n(car '(a b c))\nを評価することでテストした。\n(\ncar\n'\n(\na\nb\nc\n))\n驚いたことにこれはエラーを生じる。幾らか考えた後に、彼はク\nォートされた式を読み込むことで得られた\n“\nリスト\n”\nが\ncons\n,\ncar\n,\ncdr\nの新しい定義で操作されたリストから異なることに気が付い\nた。評価機のクォートされた式の扱いを修正しドライバループで\n型付けされたクォートされたリストが正しい遅延リストを生成す\nるようにせよ。\nExercise 4.34:\n評価機のドライバループを変更し遅延化したペアと\nリストが何らかの妥当な方法で表示を行うようにせよ。\n(\n無限リス\nトに対しては何を行うか\n?)\n。遅延化ペアの表現も変更が必要にな\nるだろう。評価機がそれらを表示するためにそれらを判別するこ\nとができるようにするためである。\n4.3\nScheme\n上でのバリエーション\n—\n非決定性\n演算\nこの節では\nnondeterministic computing\n(\n非決定性演算\n)\nと呼ばれるプログラ\nミングパラダイムをサポートするよう、評価機の中に自動的な探索をサポート\n440","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":466},{"id":"./test/fixtures/pdf/sicp.pdf:467","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"するための機能を構築することで、\nScheme\n評価機を拡張します。これは\nSection\n4.2\nでの遅延評価の導入に比べ、とても深い言語への変更です。\n非決定性演算はストリーム処理のように、\n“\n生成してテストする\n”\nアプリケ\nーションに対して便利です。正の整数の\n2\nつのリストを用いて開始する、整数\nのペアを見つけるタスクについて考えます\n1\nつは最初のリストから、もう\n1\nつ\nは別のリストから取得し、その和は素数となります。私達はこの問題をどのよ\nうに扱うかについて、\nSection 2.2.3\nでは有限列の命令を用いて、\nSection 3.5.3\nで\nは無限ストリームを用いる方法について学びました。私達の取り組み方は全て\nの可能なペアを生成し、これらから和が素数になるペアを選択するという方法\nでした。実際にペアの列全体を最初に生成する\nChapter 2\nや、生成とフィルタリ\nングを相互配置する\nChapter 3\nに係わらず演算がどのように体系化されるかの\n本質的なイメージに対しては重要ではありませんでした。\n非決定性の取り組み方は異なるイメージを喚起します。単純に\n(\n何らかの方\n法で\n)\n最初のリストから数値を選択し、別の数値を\n2\nつ目のリストから選択し、\n(\n何らかの仕組みで\n)\nそれらの和が素数であることを要求とすると想像してみて\nください。これは以下の手続により表現されます。\n(\ndefine\n(\nprime-sum-pair\nlist1\nlist2\n)\n(\nlet\n((\na\n(\nan-element-of\nlist1\n))\n(\nb\n(\nan-element-of\nlist2\n)))\n(\nrequire\n(\nprime?\n(+\na\nb\n)))\n(\nlist\na\nb\n)))\nこの手続はただ単に問題を言い直したに過ぎなく、解法を指定したようには見\nえないかもしれません。それにもかかわらず、これは正規の非決定性プログラ\nムです。\n41\nここでの鍵となる考えは、非決定性言語における式は\n1\nつ以上の可能な値\nを持つことができるということです。例えば\nan-element-of\nは与えられたリス\nトのどの要素でも返すことが有り得ます。私達の非決定性プログラム評価機は\n自動的に可能な値を選択しその選択を追跡することで働きます。もし続く要件\nに合わなければ、評価機は異なる選択を試します。そして評価が成功するまで、\n41\n以前に数値が素数であるかをテストする手続\nprime?\nを定義しました。例え\nprime?\nが定義されていたとしても、\nprime-sum-pair\n手続は、\nSection 1.1.7\nの最初で説明した助\nけにならない\n“\n擬似\nLisp”\nによる平方根関数の定義の試みのように疑わしく見えるかも\nしれません。現実に、あれらの行に沿った平方根手続が実際に非決定性プログラムとし\nて定式化することができます。評価機に探索の仕組みを合併することで、どのようにし\nて回答を計算するかについての純粋な宣言型の記述と命令型の仕様の間の区別を侵食し\nていきます。私達は\nSection 4.4\nにてこの方向へとさらに進みます。\n441","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":467},{"id":"./test/fixtures/pdf/sicp.pdf:468","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"または選択肢が無くなるまで、新しい選択を試し続けます。遅延評価がプログ\nラマを値がどのように遅延化され強制されるかの詳細から解放されたのと同様\nに、非決定性プログラムの評価機はプログラマを選択がどのように行われるか\nの詳細から解放します。\n非決定性評価とストリーム処理により起こった時間の異なるイメージの対\n比は示唆的です。ストリーム処理は遅延評価を可能な答のストリームが組まれ\nた時間を実際のストリーム要素が生成された時間から分離します。評価機は全\nての可能な回答が私達の前に永遠の列の中に横たわっているというイリュージ\nョンを支えます。非決定性評価機では式は可能な世界の集合の調査を表現しま\nす。それぞれは選択の集合により判断されます。可能なせかいのいくつかは行\nき止まりへと導き、一方、他は役立つ値へと導きます。非決定性プログラム評\n価機は時間の分岐と私達のプログラムが異なる可能な実行履歴を持つというイ\nリュージョンを支えます。行き止まりに辿り着いた時には直前の選択地点に戻\nり、異なる分岐に従って進むことが可能です。\n以下で実装される非決定性プログラム評価機は\namb\n評価機と呼ばれます。そ\nれが\namb\nと呼ばれる新しい特別形式に基づくためです。上記の\nprime-sum-pair\nの定義を\namb\n評価機ドライバループにて\n(\nprime?\n,\nan-element-of\n,\nrequire\nと\n一緒に\n)\n型を付け、以下のように手続を実行することができます。\n;;; Amb-Eval input:\n(\nprime-sum-pair\n'\n(1 3 5 8)\n'\n(20 35 110))\n;;; Starting a new problem\n;;; Amb-Eval value:\n(3 20)\n返り値は評価機が条件に合う選択が行われるまで繰り返し各リストから要素を\n選択した後に取得されました。\nSection 4.3.1\nは\namb\nを紹介しそれがどのように非決定性を評価機の自動探\n索の仕組みを通してサポートするかについて説明します。\nSection 4.3.2\nは非決\n定性プログラムの例を与え、\nSection 4.3.3\nは\namb\nの実装方法の詳細を通常の\nScheme\n評価機を変更することで与えます。\n442","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":468},{"id":"./test/fixtures/pdf/sicp.pdf:469","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4.3.1\namb\nと検索\nScheme\nに非決定性を対応するよう拡張するために、\namb\nと呼ばれる新しい\n特別形式を導入します。\n42\n(\namb\n⟨\n푒\n1\n⟩\n⟨\n푒\n2\n⟩\n...\n⟨\n푒\n푛\n⟩\n)\n上の式は\n푛\n個の式\n⟨푒\n푖\n⟩\nの内\n1\nつの値を\n“ambiguously”(\n曖昧に\n)\n返します。例\nえば以下の式は\n(\nlist\n(\namb\n1 2 3) (\namb\n'a\n'b\n))\n以下の\n6\nつの値の可能性があります。\n(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)\n単一の選択を行う\namb\nは通常の\n(\n単一の\n)\n値を生成します。\n選択を行わない\namb\n—\n式\n(amb)\n—\nは受け入れられる値の無い式です。操作上、\n(amb)\nを評価された時に演算に対し\n“fail”(\n失敗\n)\nを起こさせると考えることが\nできます。演算は異常終了し、何の値も生成されません。この考えを用いて、あ\nる特定の述語式\np\nが真でなければならないことを以下のように表現可能です。\n(\ndefine\n(\nrequire\np\n) (\nif\n(\nnot\np\n) (\namb\n)))\namb\nと\nrequire\nを用いて上で使用された\nan-element-of\nを実装可能です。\n(\ndefine\n(\nan-element-of\nitems\n)\n(\nrequire\n(\nnot\n(\nnull?\nitems\n)))\n(\namb\n(\ncar\nitems\n) (\nan-element-of\n(\ncdr\nitems\n))))\nan-element-of\nはリストが空である場合には失敗します。そうでなければリス\nトの最初の要素か、リストの残りの要素から選択された要素を曖昧に返します。\n無限の範囲の選択も表現可能です。以下の手続は可能性としてある与えら\nれた\n푛\nに等しいか大きな任意の整数を返します。\n(\ndefine\n(\nan-integer-starting-from\nn\n)\n(\namb\nn\n(\nan-integer-starting-from\n(+\nn\n1))))\nこれはまるで\nSection 3.5.2\nで説明されたストリーム手続\nintegers-starting-\nfrom\nの様です。しかし重要な違いがあります。ストリーム処理は\n푛\nで始まる\n42\n非決定性プログラミングのための\namb\nの考えは\n1961\n年に最初に\nJohn McCarthy\nに\nより説明されました。\n(\nMcCarthy 1963\n参照\n)\n。\n443","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":469},{"id":"./test/fixtures/pdf/sicp.pdf:470","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"全ての整数の列を表すオブジェクトを返します。一方、\namb\n手続は単一の整数\nを返します。\n43\n抽象的に、\namb\n式を評価することが時間に対して分岐を起こさせ、演算は\n各分岐上にて式の可能な値の\n1\nつに上で続行するのだと想像することができま\nす。\namb\nが\nnondeterministic choice point\n(\n非決定性選択点\n)\nを表現すると言え\nます。もし私達が動的に獲得できる十分な数のプロセッサを持つ計算機を持っ\nているならば、探索を簡単な方法で実装できるでしょう。実行は\namb\n式に遭遇\nするまでは逐次的に行われます。遭遇した時点では多くのプロセッサが獲得さ\nれ選択により暗示された全ての並列実行を続けるために初期化されます。各プ\nロセッサは選択がそれしか無かったかのように逐次的に続行します。その処理\nは失敗に遭遇して停止するか、さらなる分岐が起こるか、完了するまで続けら\nれます。\n44\n一方で、もし私達が\n1\nつのプロセス\n(\nまたはいくつかの並行プロセス\n)\nしか\n実行できない計算機を持っている場合には逐次的に動作する代替法を考えねば\nなりません。\n1\nつの方法としては評価機を選択点に辿り着いた時に無作為に分\n岐を選択するよう変更することが考えられるでしょう。しかし無作為な選択は\n簡単に失敗する値へと導きます。評価機を何度も何度も実行し無作為な選択を\n行い失敗しない値を見つけることを期待するかもしれません。しかし全ての可\n能な実行パス\n(\n実行経路\n)\nを\nsystematically search\n(\n体系的探索\n)\nをしたほうがよ\nり良いです。私達がこの節で開発し働きかける\namb\n評価機は体系的探索を次の\nように実装します。評価機が\namb\nの適用に遭遇した場合に初期値として最初の\n選択肢を選択します。この選択それ自身がさらなる選択へと導きます。評価機\nは常に初期値として最初の選択肢を各選択点にて選択します。もし選択の結果\n43\n本当は非決定的に単一の選択を返すことと全ての選択を返すことの違いは私達の視\n点に幾分、依存します。値を使用するコードの視点からは非決定性による選択は単一の\n値を返します。コードを設計するプログラマの視点からは非決定性による選択は潜在的\nに全ての可能な値を返します。そして各値が個別に調査されるように演算は分岐するの\nです。\n44\nこれは絶望的に非効率だと異議を唱える人がいるかもしれません。この方法では簡\n単に規定された問題を解くのに数百万のプロセッサを必要とするかもしれません。そし\nてそれらの多くのプロセッサはほとんどの時間をアイドル状態\n(\n遊休状態\n)\nになるでしょ\nう。この異議は歴史の文脈で捕えられるべきです。メモリはとても高価な消費財だと考\nえられてきました。\n1964\n年にはメガバイトの\nRAM\nは\n$400,000\nの費用が掛かりました。\n現在では全ての\nPC\nが多数のメガバイトの\nRAM\nを積んでいます。そしてほとんどの時\n間でほとんどのメモリは利用されていません。大量生産された電子製品のコストを過小\n評価することは難しいことです。\n444","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":470},{"id":"./test/fixtures/pdf/sicp.pdf:471","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"が失敗となれば評価機は\nautomagically\n45\nに最も最近の選択に\nbacktracks\n(\nバッ\nクトラック\n、引き返す\n)\nし、次の選択肢を試行します。もしどこかの選択点にお\nいて、全ての選択肢を使用してしまえば、評価機は以前の選択点へと戻りそこか\nら再開します。この処理は\ndepth-first search\n(\n深さ優先探索\n)\nまたは\nchronological\nbacktracking\n(\nクロノロジカルバックトラック、\n年代順バックトラック\n)\nとして\n知られる探索戦略へと導きます。\n46\nドライバループ\namb\n評価機のドライバループはいくつかの普通ではない性質を持っていま\nす。これは式を読み最初の失敗ではない実行の値を上で示された\nprime-sum-\n45\nautomagically: “\n自動的に、しかし幾つかの理由で\n(\n典型的には複雑過ぎて、または\n酷すぎて、または恐らくさらにどうでも良すぎて\n)\n話者が説明する気にならない\n” (\nSteele\net al. 1983\n,\nRaymond 1993\n)\n46\n自動的な探索戦略のプログラミング言語への統合は長く功罪相半ばする歴史があり\nます。非決定性アルゴリズムが美しくプログラミング言語へと探索と自動的バックトラッ\nクと共に組込まれただろう最初の提案は\nRobert\nFloyd (1967)\nにより行われました。\nCarl\nHewitt (1969)\nは\nPlanner\nと呼ばれるプログラミング言語を発明しましたが、これは明示\n的に自動的なクロノロジカルバックトラックをサポートし、組込の深さ優先探索戦略を\n提供していました。\nSussman et al. (1971)\nはこの言語の部分集合である\nMicroPlanner\nを\n実装しました。これは問題解決とロボット計画の仕事の支持に使用されました。同様な\nアイデアが論理と定理証明から提起され、エディンバラとマルセイユにて洗練された言\n語\nProlog\nの起源へと導きました。\n(\nSection 4.4\nにて議論します\n)\n。自動探索に対する多く\nの不満の後に\nMcDermott and Sussman (1972)\nは\nConniver\nと呼ばれる言語を開発しま\nした。これはプログラマのコントロール下に探索戦略を置くための仕組みを含みました。\nしかしこれは扱い難く、\nSussman and Stallman 1975\nはもっと御しやすい取り組み方を\n電子回路向け記号分析の手法の研究の間に発見しました。彼等は事実を繋げる論理的依\n存性の追跡を基にした非クロノロジカルなバックトラック計画を開発しました。これは\ndependency-directed backtracking\n(\n依存型バックトラック\n)\nとして知られるようになった\n技術です。彼等の手法は複雑でしたが、合理的な効率の良いプログラムを生成しました。\n冗長な探索をほとんどしなかったためです。\nDoyle (1979)\nと\nMcAllester (1978; 1980)\nは\nStallman\nと\nSussman\nの手法を一般化し、明確にしました。そして探索を定式化するた\nめの新しいパラダイムを開発しました。これは今では\ntruth maintenance\n(\n真理維持\n)\nと\n呼ばれています。現代の問題解決システムは全て真理維持システムの何らかの形式を素\n地として使用しています。真理維持システムと真理維持を用いたアプリケーションを構\n築するための洗練された方法の議論については\nForbus and deKleer 1993\nを参照して下さ\nい。\nZabih et al. 1987\nは\nScheme\nに対する\namb\nを基にした非決定性拡張を説明していま\nす。これはこの節で説明されるインタプリタと同様です。しかしより高度な物です。そ\nれがクロノロジカルバックトラックではなく依存型バックトラックを使用しているため\nです。\nWinston 1992\nは両方の種類のバックトラックに対する入門を提供しています。\n445","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":471},{"id":"./test/fixtures/pdf/sicp.pdf:472","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"pair\nの例のように表示します。もし次の成功する実行の値を見たいのであれ\nば、インタプリタにバックトラックして二番目の失敗ではない実行を生成する\n試行を命令します。これはシンボル\ntry-again\nを入力することで伝えられま\nす。もし\ntry-again\nではない任意の式が与えられたなら、インタプリタは新し\nい問題を開始し、直前の問題の調査されていない選択肢を捨てます。以下にサ\nンプルの応答を示します。\n;;; Amb-Eval input:\n(\nprime-sum-pair\n'\n(1 3 5 8)\n'\n(20 35 110))\n;;; Starting a new problem\n;;; Amb-Eval value:\n(3 20)\n;;; Amb-Eval input:\ntry-again\n;;; Amb-Eval value:\n(3 110)\n;;; Amb-Eval input:\ntry-again\n;;; Amb-Eval value:\n(8 35)\n;;; Amb-Eval input:\ntry-again\n;;; There are no more values of\n(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))\n;;; Amb-Eval input:\n(\nprime-sum-pair\n'\n(19 27 30)\n'\n(11 36 58))\n;;; Starting a new problem\n;;; Amb-Eval value:\n(30 11)\nExercise 4.35:\n2\nつの与えられた境界値の間の整数を返す手続\nan-\ninteger-between\nを書け。これはピタゴラスの\n3\nつ組を求める手\n続を実装するのに使用できる。例えば与えられた範囲の間の整数\n446","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":472},{"id":"./test/fixtures/pdf/sicp.pdf:473","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"の三つ組\n(푖, 푗, 푘)\nで\n푖 ≤ 푗\nand\n푖\n2\n+ 푗\n2\n= 푘\n2\nの場合は以下の様に\nなる。\n(\ndefine\n(\na-pythagorean-triple-between\nlow\nhigh\n)\n(\nlet\n((\ni\n(\nan-integer-between\nlow\nhigh\n)))\n(\nlet\n((\nj\n(\nan-integer-between\ni\nhigh\n)))\n(\nlet\n((\nk\n(\nan-integer-between\nj\nhigh\n)))\n(\nrequire\n(= (+ (*\ni\ni\n) (*\nj\nj\n)) (*\nk\nk\n)))\n(\nlist\ni\nj\nk\n)))))\nExercise 4.36:\nExercise 3.69\nではどのように\n“\n全ての\n”\nピタゴラス\nの三つ組のストリームを探索対象の整数のサイズに上限無しで生\n成するかについて議論した。なぜ単純に\nan-inte-ger-between\nを\nExercise 4.35\nの手続内の\nan-integer-starting-from\nで置き換え\nることは、自由裁量なピタゴラスの三つ組を生成するのに適切で\nないのか、説明せよ。これを実際に達成する手続を書け。\n(\nすなわ\nち、原理上は\ntry-again\nを繰り返し入力することで全てピタゴラ\nスの三つ組を生成する手続を書け\n)\n。\nExercise 4.37:\nBen Bitdiddle\nは以下のピタゴラスの\n3\nつ組を生成\nする手法は\nExercise 4.35\nの手法に比べより効率的であると主張し\nた。彼は正しいだろうか\n? (\nヒント：探索しなければならない可能\n性の数を考えよ\n)\n(\ndefine\n(\na-pythagorean-triple-between\nlow\nhigh\n)\n(\nlet\n((\ni\n(\nan-integer-between\nlow\nhigh\n))\n(\nhsq\n(*\nhigh\nhigh\n)))\n(\nlet\n((\nj\n(\nan-integer-between\ni\nhigh\n)))\n(\nlet\n((\nksq\n(+ (*\ni\ni\n) (*\nj\nj\n))))\n(\nrequire\n(>=\nhsq\nksq\n))\n(\nlet\n((\nk\n(\nsqrt\nksq\n)))\n(\nrequire\n(\ninteger?\nk\n))\n(\nlist\ni\nj\nk\n))))))\n4.3.2\n非決定性プログラムの例\nSection 4.3.3\nは\namb\n評価機の実装を説明します。しかし最初にそれがどの\nように使用できるかについて、いくつかの例を与えます。非決定性プログラミ\n447","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":473},{"id":"./test/fixtures/pdf/sicp.pdf:474","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ングの利点は探索がどのように実行されるのかについての詳細を隠すことがで\nきることです。従って抽象の高いレベルにてプログラムを表現できます。\n論理パズル\n以下のパズル\n(\nDinesman 1968\nから拝借しました\n)\nは典型的な大きなクラス\nの簡単な論理パズルです。\nBaker, Cooper, Fletcher, Miller,\nそれに\nSmith\nは同じ\n5\n階しかな\nいアパートの異なる階に住んでいます。\nBaker\nは最上階には住ん\nでいません。\nCooper\nは最下階には住んでいません。\nFletcher\nは最\n上階にも最下階にも住んでいません。\nMiller\nは\nCooper\nよりも高い\n階に住んでいます。\nSmith\nは\nFletcher\nのすぐ隣の階には住んでい\nません。\nFletcher\nは\nCooper\nのすぐ隣の階には住んでいません。皆\nはどの階に住んでいるでしょうか\n?\n誰がどの階に住んでいるかを、全ての可能性を列挙し与えられた制約を与える\n簡単な方法で決定することができます。\n47\n(\ndefine\n(\nmultiple-dwelling\n)\n(\nlet\n((\nbaker\n(\namb\n1 2 3 4 5)) (\ncooper\n(\namb\n1 2 3 4 5))\n(\nfletcher\n(\namb\n1 2 3 4 5)) (\nmiller\n(\namb\n1 2 3 4 5))\n(\nsmith\n(\namb\n1 2 3 4 5)))\n(\nrequire\n(\ndistinct?\n(\nlist\nbaker\ncooper\nfletcher\nmiller\nsmith\n)))\n(\nrequire\n(\nnot\n(=\nbaker\n5)))\n(\nrequire\n(\nnot\n(=\ncooper\n1)))\n(\nrequire\n(\nnot\n(=\nfletcher\n5)))\n47\n私達のプログラムは以下の手続をリストの要素が識別可能であるか判断するために\n使用しています。\n(\ndefine\n(\ndistinct?\nitems\n)\n(\ncond\n((\nnull?\nitems\n)\ntrue\n)\n((\nnull?\n(\ncdr\nitems\n))\ntrue\n)\n((\nmember\n(\ncar\nitems\n) (\ncdr\nitems\n))\nfalse\n)\n(\nelse\n(\ndistinct?\n(\ncdr\nitems\n)))))\nmember\nは\nmemq\nと同様ですがこれは\neq?\nの代わりに\nequal?\nを等価性のテストに用いて\nいます。\n448","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":474},{"id":"./test/fixtures/pdf/sicp.pdf:475","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nrequire\n(\nnot\n(=\nfletcher\n1)))\n(\nrequire\n(>\nmiller\ncooper\n))\n(\nrequire\n(\nnot\n(= (\nabs\n(-\nsmith\nfletcher\n)) 1)))\n(\nrequire\n(\nnot\n(= (\nabs\n(-\nfletcher\ncooper\n)) 1)))\n(\nlist\n(\nlist\n'baker\nbaker\n)\n(\nlist\n'cooper\ncooper\n)\n(\nlist\n'fletcher\nfletcher\n) (\nlist\n'miller\nmiller\n)\n(\nlist\n'smith\nsmith\n))))\n式\n(multiple-dwelling)\nを評価すると結果を生成します。\n((\nbaker\n3) (\ncooper\n2) (\nfletcher\n4) (\nmiller\n5) (\nsmith\n1))\nこの簡単な手続はうまく行きますが、とても遅いです。\nExercise 4.39\nと\nExercise\n4.40\nはいくらかの可能な改善法について議論します。\nExercise 4.38:\nmultiple-dwelling\n手続を変更し、\nSmith\nと\nFletcher\nが隣接する階に住んでいないという要件を取り除く。この変更し\nたパズルにはいくつの解が存在するか\n?\nExercise 4.39:\nmultiple-dwelling\n手続内の制約の順は解に影響する\nだろうか\n?\n回答を見つけるのにかかる時間には影響を与えるだろ\nうか\n?\nもしそれが重要であると考えるのなら、制約の順を変える\nことで与えられる物から得られるより速いプログラムを実演せよ。\nもしそれが問題ではないと考えるのなら、あなたの考えを論ぜよ。\nExercise 4.40:\n複数の住居の問題において、人を階へと割り当てる\n方法は、\nrequirement\nの前と後で階の割り当てが区別可能な方法で\nいくつあるか\n?\n全ての人から階への可能な割り当てを生成してか\nらその次にそれらを排除するために\nbacktrack\nにまかせることは\n非常に非効率である。例えば制約のほとんどは一つか二つの人と\n階の変数を持ち、従って全ての人に対して階が選択される前に制\n約を与えることができる。この問題を先の制約により既に排除さ\nれたもの以外の可能性のみを生成することに基づいて解くずっと\n効率の良い非決定性手続を書き、実演せよ。\nExercise 4.41:\n複数住居パズルを解く通常の\nScheme\nプログラムを\n書け。\nExercise 4.42:\n次の\n“\n嘘つき\n”\nパズル\n(\nPhillips 1934\nから\n)\nを解け\n5\n人の女生徒が試験のために座っている。彼女達は、彼女等の両親\nが結果に過大な興味を見せていると考えている。従って彼女達は\n449","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":475},{"id":"./test/fixtures/pdf/sicp.pdf:476","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"次のことを合意した。それぞれの少女が\n1\nつの正しい文と嘘の文\nを作り、各家庭に試験についての手紙を書く。以下は彼女らの手\n紙の該当する一節である。\n•\nBetty: “Kitty\nが試験では二位だった。私だけが\n3\n位だった。\n”\n•\nEthel: “\n喜んで、私がトップ。\nJoan\nが\n2\n位だった。\n”\n•\nJoan: “\n私が\n3\n番。可哀想な\nEthel\nは最下位だった。\n”\n•\nKitty: “\n私が\n2\n番。\nMary\nが単独で\n4\n位。\n”\n•\nMary: “\n私が\n4\n位。トップは\nBetty\nが取ったわ。\n”\n実際にはどの順に\n5\n人の女の子は並べられるか\n?\nExercise 4.43:\namb\n評価機を用いて以下のパズルを解け\n48\nMary Ann Moore\nの父はヨットを持っており、彼の\n4\n人の友達、\nDowning\n大佐\n, Hall\nさん\n, Barnacle Hood\n卿\n, Dr. Parker\nもそれぞ\nれが持っていました。\n5\n人のそれぞれに一人の娘がおり、それぞれ\nが各自のヨットに他人の娘の名を取って付けていました。\nBarnacle\n卿のヨットは\nGabrielle\nで、\nMoore\nさんのは\nLorna\nです。\nHall\nさん\nのは\nRosalind\nです。\nDowning\n大佐の\nMelissa\nは\nBarnacle\n卿の娘の\n名を取って付けました。\nGabrielle\nの父のヨットは\nDr. Parker\nの娘\nからです。\nLorna\nの父は誰でしょう\n?\n効率良く実行されるプログラムを書くように努めること\n(\nExercise\n4.40\n参照\n)\n。また、もし\nMary Ann\nの家族名が\nMoore\nであることを\n伝えなければ、いくつの解が存在するだろうか\n?\nExercise 4.44:\nExercise 2.42\nはチェス盤に\n8\nつのクイーンをどの\n2\nつもお互いに攻撃することが無いように置く\n“8\nクイーンパズル\n”\nについて説明した。このパズルを解く非決定性プログラムを書け。\n自然言語の構文解析\n自然言語を入力として受け入れるよう設計されたプログラムは通常、その\n入力を\nparse\n(\nパース\n、\n構文解析\n)\nすることから始めます。つまり入力をある文\n48\nこれは\n1960\n年代に\nLitton Industries\nにより出版された\n“\n問題の多いレクリエーショ\nン\n”\nと呼ばれる小冊子から引用しました。\nKansas State Engineer\n著。\n450","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":476},{"id":"./test/fixtures/pdf/sicp.pdf:477","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"法構造に対して合わせることです。例えば冠詞と続く名詞、続く動詞から成る\n簡単な文、\n”The cat eats.“(\n猫は食べる\n)\nのような物を認識しようとしていると\nします。そのような分析を達成するためには個別の単語の品詞を判別できなけ\nればなりません。多種の単語を判別できるいくつかのリストから始めることが\nできるでしょう。\n49\n(\ndefine\nnouns\n'\n(\nnoun\nstudent\nprofessor\ncat\nclass\n))\n(\ndefine\nverbs\n'\n(\nverb\nstudies\nlectures\neats\nsleeps\n))\n(\ndefine\narticles\n'\n(\narticle\nthe\na\n))\nまた\ngrammar\n(\n文法\n)\nも必要です。つまり、文法上の要素がどのようにより簡単\nな要素から組み立てられるのかを説明するルールの集合です。とても簡単な文\n法は文は常に\n2\nつの要素\n—\n名詞句とそれに続く動詞\n—\nにより成ると規定する\nことができるかもしれません。そして名詞句は定冠詞とそれに続く名詞から成\nり立ちます。この文法を用いて、文\n“The cat eats.”\nは以下のようにパースされ\nます。\n(\nsentence\n(\nnoun-phrase\n(\narticle\nthe\n) (\nnoun\ncat\n))\n(\nverb\neats\n))\nそのようなパースを、手続を各文法上のルールに分割する簡単なプログラムを\n用いて生成することができます。文をパースするためには、それを構成する\n2\nつの要素を判別し、これらの\n2\nつの要素のリストをシンボル\nsentence\nのタグ\nを付けて返します。\n(\ndefine\n(\nparse-sentence\n)\n(\nlist\n'sentence\n(\nparse-noun-phrase\n)\n(\nparse-word\nverbs\n)))\n名詞句も同様に定冠詞とそれに続く名詞を見つけることでパースされます。\n(\ndefine\n(\nparse-noun-phrase\n)\n(\nlist\n'noun-phrase\n(\nparse-word\narticles\n)\n(\nparse-word\nnouns\n)))\n49\nここでは各リストの最初の要素はリストの残りの単語の品詞を示すという仕様を用\nいています。\n451","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":477},{"id":"./test/fixtures/pdf/sicp.pdf:478","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最も低いレベルでは、パースとは繰り返し次のパースされていない単語が必要\nとされる品詞のための単語のリストのメンバであるかをチェックすることだと\nまとめられます。これを実装するために、私達はグローバル変数\n*unparsed*\nを持ちます。これはまだパースされていない入力です。単語をチェックする各\n時点で\n*unparsed*\nが空ではないことを要求し、また指定されたリストの単語\nで始まることを要求します。もしそうであるならその単語を\n*unparsed*\nから\n削除し、その単語をその品詞\n(\nこれはリストの先頭に見つかります\n)\nと共に返し\nます。\n50\n(\ndefine\n(\nparse-word\nword-list\n)\n(\nrequire\n(\nnot\n(\nnull?\n*\nunparsed*\n)))\n(\nrequire\n(\nmemq\n(\ncar\n*\nunparsed*\n) (\ncdr\nword-list\n)))\n(\nlet\n((\nfound-word\n(\ncar\n*\nunparsed*\n)))\n(\nset!\n*\nunparsed*\n(\ncdr\n*\nunparsed*\n))\n(\nlist\n(\ncar\nword-list\n)\nfound-word\n)))\nパースを始めるために行わなければいけないこと全ては\n*unparsed*\nに入力全\n体を設定し、文のパースを試み、何も残っていないことをチェックすること\nです。\n(\ndefine\n*\nunparsed*\n'\n())\n(\ndefine\n(\nparse\ninput\n)\n(\nset!\n*\nunparsed*\ninput\n)\n(\nlet\n((\nsent\n(\nparse-sentence\n)))\n(\nrequire\n(\nnull?\n*\nunparsed*\n))\nsent\n))\nこれでパーザ\n(parser\n、パースを行うプログラム\n)\nを試し、簡単なテスト文に対\nしてうまく働くことを確認することができます。\n;;; Amb-Eval input:\n(\nparse\n'\n(\nthe\ncat\neats\n))\n;;; Starting a new problem\n;;; Amb-Eval value:\n(sentence (noun-phrase (article the) (noun cat)) (verb eats))\n50\nparse-word\nが\nparse\nされていない入力リストの変更するのに\nset!\nを用いているお\nおに注意して下さい。これをうまく行うためには、\namb\n評価機は\nset!\n命令の効果をバッ\nクトラックする時に取り消しできなければいけません。\n452","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":478},{"id":"./test/fixtures/pdf/sicp.pdf:479","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"amb\n評価機はここでとても役立ちます。\nrequire\nの助けを用いてパースする上\nでの制約を表現するのにとても便利なためです。しかし、自動的な探索とバッ\nクトラックが本当に効果を生むのはより複雑な文法について考えた時に、\n1\nつ\nの単位の分解方法に多数の選択肢が存在する場合です。\n私達の文法に前置詞を追加してみましょう。\n(\ndefine\nprepositions\n'\n(\nprep\nfor\nto\nin\nby\nwith\n))\nそして前置詞句\n(\n例えば\n“for the cat”(\n猫のために\n))\nを名詞句の前の前置詞とし\nて定義します。\n(\ndefine\n(\nparse-prepositional-phrase\n)\n(\nlist\n'prep-phrase\n(\nparse-word\nprepositions\n)\n(\nparse-noun-phrase\n)))\nこれで文は名詞句に動詞句が続くと定義でき、動詞句は動詞か、または前置詞\n句で拡張された動詞句となります。\n51\n(\ndefine\n(\nparse-sentence\n)\n(\nlist\n'sentence\n(\nparse-noun-phrase\n) (\nparse-verb-phrase\n)))\n(\ndefine\n(\nparse-verb-phrase\n)\n(\ndefine\n(\nmaybe-extend\nverb-phrase\n)\n(\namb\nverb-phrase\n(\nmaybe-extend\n(\nlist\n'verb-phrase\nverb-phrase\n(\nparse-prepositional-phrase\n)))))\n(\nmaybe-extend\n(\nparse-word\nverbs\n)))\nここまでを行っている間に、名詞句の定義に\n“a cat in the class”(\nクラスの猫\n)\nのような物を認めるよう詳細を詰めることができます。今まで名詞句と呼んで\nきた物はこれからはシンプルな名詞句と呼びます。そして名詞句はこれからシ\nンプルな名詞句か前置詞句で拡張した名詞句となります。\n(\ndefine\n(\nparse-simple-noun-phrase\n)\n(\nlist\n'simple-noun-phrase\n51\nこの定義が再帰的であることに注意して下さい。動詞には任意の数の前置詞句が続\nけられます。\n453","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":479},{"id":"./test/fixtures/pdf/sicp.pdf:480","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nparse-word\narticles\n)\n(\nparse-word\nnouns\n)))\n(\ndefine\n(\nparse-noun-phrase\n)\n(\ndefine\n(\nmaybe-extend\nnoun-phrase\n)\n(\namb\nnoun-phrase\n(\nmaybe-extend\n(\nlist\n'noun-phrase\nnoun-phrase\n(\nparse-prepositional-phrase\n)))))\n(\nmaybe-extend\n(\nparse-simple-noun-phrase\n)))\n私達の新しい文法はより複雑な文をパースできます。例えば、\n(\nparse\n'\n(\nthe\nstudent\nwith\nthe\ncat\nsleeps\nin\nthe\nclass\n))\n(\n猫と一緒にその生徒はクラスで寝ている\n)\nは以下を生成します。\n(\nsentence\n(\nnoun-phrase\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nstudent\n))\n(\nprep-phrase\n(\nprep\nwith\n)\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\ncat\n))))\n(\nverb-phrase\n(\nverb\nsleeps\n)\n(\nprep-phrase\n(\nprep\nin\n)\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nclass\n)))))\n与えられた入力が二つ以上の有効な分析結果を持つかもしれないことを確認し\nて下さい。文\n“The professor lectures to the student with the cat”\nは\nprofessor(\n教\n授\n)\nが猫と一緒に講義をしている場合と、学生が猫を持っている場合が有り得\nます。私達の非決定性プログラムは両方の可能性を見つけます。\n(\nparse\n'\n(\nthe\nprofessor\nlectures\nto\nthe\nstudent\nwith\nthe\ncat\n))\nは以下を生成します。\n(\nsentence\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nprofessor\n))\n454","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":480},{"id":"./test/fixtures/pdf/sicp.pdf:481","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nverb-phrase\n(\nverb-phrase\n(\nverb\nlectures\n)\n(\nprep-phrase\n(\nprep\nto\n)\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nstudent\n))))\n(\nprep-phrase\n(\nprep\nwith\n)\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\ncat\n)))))\n評価機にもう一度試行を命ずると以下を生じます。\n(\nsentence\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nprofessor\n))\n(\nverb-phrase\n(\nverb\nlectures\n)\n(\nprep-phrase\n(\nprep\nto\n)\n(\nnoun-phrase\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\nstudent\n))\n(\nprep-phrase\n(\nprep\nwith\n)\n(\nsimple-noun-phrase\n(\narticle\nthe\n) (\nnoun\ncat\n)))))))\nExercise 4.45:\n上で与えられた文法を用いて次の文は\n5\n通りにパー\nスできる。\n“The professor lectures to the student in the class with\nthe cat”\n。\n5\n通りの結果を与えてそれらの間の様々な意味の違いを\n説明せよ。\nExercise 4.46:\nSection 4.1\nと\nSection 4.2\nは評価機はどの順でオペラ\nンドが評価されるかを決定しない。我々は\namb\n評価機がそれらを\n左から右へと評価するのを見るだろう。なぜ我々のパーザはオペ\nランドが何らかの他の順で評価されたならうまく働かないのか説\n明せよ。\nExercise 4.47:\nLouis Reasoner\nは動詞句は動詞か前置詞句が続く\n動詞句であるのだから、手続\nparse-verb-phrase\nを以下のように\n(\nそして同様に名詞句に対しても\n)\n定義すればずっと簡単になるの\nではないかと提案した。\n455","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":481},{"id":"./test/fixtures/pdf/sicp.pdf:482","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nparse-verb-phrase\n)\n(\namb\n(\nparse-word\nverbs\n)\n(\nlist\n'verb-phrase\n(\nparse-verb-phrase\n)\n(\nparse-prepositional-phrase\n))))\nこれはうまく行くだろうか\n?\nこのプログラムの振舞はもし\namb\n内\nの式の順を置き換えたら変わるだろうか\n?\nExercise 4.48:\n上で与えられた文法をより複雑な文を取り扱うよう\nに拡張せよ。例えば、名詞句と動詞句を拡張し形容詞と福祉を含\nめる、または複合文を取り扱えるようできるだろう。\n52\nExercise 4.49:\nAlyssa P. Hacker\nはパースするよりも面白い文を生\n成することにより興味を持っている。彼女は手続\nparse-word\nを簡\n単に変更してそれが\n“\n入力文\n”\nを無視し、その代わりに常に成功し\nて適切な単語を生成するようにすれば、このパースのために構築\nしたプログラムを用いて代わりに生成を行えるのではないかと推\n測した。\nAlyssa\nの考えを実装せよ。そして生成された文の最初の\n半ダースかそこらを示せ。\n53\n4.3.3\nAmb\n評価機の実装\n通常の\nScheme\n式の評価機は値を返すか、永遠に停止しないか、またはエラ\nーを発します。非決定性\nScheme\nでは式の評価はそれに加えて探索が行き止ま\nりに帰結します。その場合には評価機は依然の選択点へバックトラックしなけ\nればなりません。非決定性\nScheme\nの解釈はこの特別な場合により複雑になり\nます。\n52\nこの種の文法は任意の複雑さに成り得ます。しかし現実の言語の理解を考える限り\nはただの玩具に過ぎません。現実の自然言語のコンピュータによる理解は構文解析と意\n味解釈の念入りな混合が要求されます。一方で、例えおもちゃのパーザでもプログラム\nのための柔軟な命令言語、例えば情報取得システム等をサポートするには実用的です。\nWinston 1992\nは計算機による自然言語理解への取り組みと共に簡単な文法の命令言語の\nアプリケーションについても議論しています。\n53\nAlyssa\nのアイデアはちゃんとうまく働きますが\n(\nそして驚くほど簡単ですが\n)\n、それ\nが生成する文は少しつまらないです。それらはこの言語の可能な文からとても面白い様\nには抽出はしません。実際に文法は多くの場所で高度に再帰し、\nAlyssa\nの技術はこれらの\n再帰の\n1\nつに\n“falls into”(\n陥り\n)\n、抜け出せなくなります。これに対処する方法は\nExercise\n4.50\nを参照して下さい。\n456","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":482},{"id":"./test/fixtures/pdf/sicp.pdf:483","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"私達は非決定性\nScheme\nのための\namb\n評価機を、\nSection 4.1.7\nの分析評価機\nを変更することで構築します。\n54\n分析評価機のように、式の評価は式の分析に\nより生成される実行手続を呼ぶことにより達成されます。通常の\nScheme\nの解\n釈と非決定性\nScheme\nの解釈との違いは完全に実行手続の中に存在します。\n手続と継続の実行\n通常の評価機の実行手続が\n1\nつの引数、実行の環境を取ることを思い出し\nて下さい。対照的に、\namb\n評価機の実行手続は\n3\nつの引数を取ります。環境と\ncontinuation procedures\n(\n継続手続\n)\nと呼ばれる\n2\nつの手続です。式の評価はこ\nれらの\n2\nつの継続の\n1\nつを呼ぶことで完了します。もし評価の結果が値に帰\n結するならば、\nsuccess continuation\n(\n成功継続\n)\nがその値と共に呼ばれます。も\nし評価が行き止まりの発見に帰結したのであれば、\nfailure continuation\n(\n失敗継\n続\n)\nが呼ばれます。適切な継続の構築と呼出が非決定性評価機のバックトラッ\nクが実装される仕組みです。\n値を受け取り計算を続行することが成功継続の仕事です。その値と共に、成\n功継続は別の失敗継続も渡されます。これはその後にもしその値の使用が行き\n止まりに導いたなら呼び出されます。\n非決定性処理の他の分岐を試すのは失敗継続の仕事です。非決定性言語の\n本質は式が選択肢の間の選択を表現するだろうという事実の中に存在します。\nそのような式の評価は例え前もってどの選択肢受け入れ可能な結果に導くか知\nらなくても指示された代替となる選択の一つを用いて続行しなければなりませ\nん。これを処理するためには、評価機は選択肢から\n1\nつを取り出しこの値を成\n功継続に渡します。この値と共に、評価機は後で異なる選択肢を選択するため\nに呼び出し可能な失敗継続を構築し、一緒に渡します。\n失敗は評価の間に引き起こされます。\n(\n言い換えれば失敗継続が呼ばれま\nす\n)\n。それはユーザプログラムが明示的に現在の一連の取り組みを拒絶した場\n合に起こります。\n(\n例えば、\nrequire\nの呼出は結果として\n(amb)\nが実行される\n場合があります。これは常に失敗する式です。\n—\nSection 4.3.1\n参照\n)\n。その時点\nで手中にある失敗継続が最も最近の選択点に他の選択肢を選択させます。もし\nもうその選択点にて考えられる他の選択肢が無い場合には、直前の選択点の失\n敗が引き起こされます。以下その繰り返しです。失敗継続はまた式の別の値を\n54\n私達は\nSection 4.2\nの遅延評価機を\nSection 4.1.1\nの通常のメタ循環評価機に対する変\n更として実装することを選択しました。対照的に、\nSection 4.1.7\nの分析評価機を\namb\n評\n価機の基にします。その評価機内の実行手続がバックトラックを実装するのに便利なフ\nレームワークを提供するためです。\n457","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":483},{"id":"./test/fixtures/pdf/sicp.pdf:484","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"見つけるためのドライバループによる\ntry-again\n要求への応答としても起動\nされます。\n加えて、もし副作用命令\n(\n変数への代入等\n)\nがある選択の結果としての分岐\n処理上で起こったならば、処理が行き止まりを見つけた時に、新しい選択を行\nう前にその副作用を取り消しする必要があるかもしれません。これは副作用命\n令に副作用を取り消し失敗を伝播させる失敗継続を生成させることで達成され\nます。\nまとめとして、失敗継続は以下により構築されます。\n•\namb\n式\n—\namb\n式により行われた現在の選択が行き止まりに導いた場合に\n別の選択を行う仕組みを提供します\n•\nトップレベルドライバ\n—\n選択肢が枯渇した時に失敗を報告する仕組みを\n提供します\n•\n代入\n—\n失敗に割り込み、バックトラックの間に代入を取り消します\n失敗は行き止まりに遭遇したその時のみ起動されます。これは以下の場合に起\nこります。\n•\nユーザプログラムが\n(amb)\nを実行した\n•\nユーザがトップレベルドライバにて\ntry-again\nを入力した\n失敗継続はまた失敗処理の間にも呼ばれます。\n•\n代入が副作用の取消を完了させることで失敗継続が作成された時に、そ\nれは割り込んだ失敗継続を、失敗を伝播させこの代入に導いた選択点に\n戻すために、またはトップレベルに戻すために呼びます。\n•\namb\nに対する失敗継続が選択肢を使い切った時、、失敗を直前の選択点か\nトップレベルに伝播させるために、\namb\nに対して元々与えられた失敗継\n続を呼び出します。\n評価機の構造\namb\n評価機に対する文法とデータの表現手続、また基本的な\nanalyze\n手続\nは、\nSection 4.1.7\nの評価機のそれらに等しい物です。しかし私達が追加の構文\n手続を\namb\nの特別形式を認識するために必要とすることが異なります。\n55\n55\n評価機は\nlet\nをサポートすると想定しています。\n(\nExercise 4.22\n参照\n)\n。私達はこれを\n非決定性プログラム内にて利用してきました。\n458","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":484},{"id":"./test/fixtures/pdf/sicp.pdf:485","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\namb?\nexp\n)\n(\ntagged-list?\nexp\n'amb\n))\n(\ndefine\n(\namb-choices\nexp\n) (\ncdr\nexp\n))\nanalyze\n内にこの特別形式を認識し、適切な実行手続を生成する呼出を追加し\nなければなりません。\n((\namb?\nexp\n) (\nanalyze-amb\nexp\n))\nトップレベル手続\nambeval\n(\nSection 4.1.7\nで与えられた\neval\nの版に似た物\n)\nは\n与えられた式を分析し、実行手続を与えられた環境に対し、\n2\nつの与えられた\n継続と一緒に適用しなければなりません。\n(\ndefine\n(\nambeval\nexp\nenv\nsucceed\nfail\n)\n((\nanalyze\nexp\n)\nenv\nsucceed\nfail\n))\n成功継続は\n2\n引数の手続です。\n2\n引数は得られたばかりの値とその値がその後\nに失敗へと導いたなら使用される別の失敗継続です。失敗継続は引数無しの手\n続です。そのため実行手続の一般的な形は以下のようになります。\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n;;\nsucceed\nis\n(lambda (value fail)\n...\n)\n;;\nfail\nis\n(lambda ()\n...\n)\n...\n)\n例えば、以下を実行すると、\n(\nambeval\n⟨\nexp\n⟩\nthe-global-environment\n(\nlambda\n(\nvalue\nfail\n)\nvalue\n)\n(\nlambda\n()\n'failed\n))\n与えられた式を評価し、式の値\n(\n評価が成功した場合\n)\nかシンボル\nfailed\n(\n評価\nが失敗した場合\n)\nを返します。以下で示されるドライバループ内での\nambeval\nの呼出はより多くの複雑な継続手続を使用します。これらはループを継続し\ntry-again\n要求をサポートします。\namb\nの複雑さの多くは実行手続がお互いを呼ぶに従い、継続をたらい回し\nにすることから来ています。以下のコードを通して読むに当って、それぞれの\n実行手続を\nSection 4.1.7\nで与えられた通常の評価機のための対応する手続と比\nべて下さい。\n459","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":485},{"id":"./test/fixtures/pdf/sicp.pdf:486","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"単純な式\n最も単純な種類の式に対する実行手続は本質的に通常の評価機に対するも\nのと同じです。ただし、継続を管理する必要があることが異なります。これら\nの実行手続は式の値と共に単純に成功し、渡された失敗継続をそのまま手渡し\nます。\n(\ndefine\n(\nanalyze-self-evaluating\nexp\n)\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nsucceed\nexp\nfail\n)))\n(\ndefine\n(\nanalyze-quoted\nexp\n)\n(\nlet\n((\nqval\n(\ntext-of-quotation\nexp\n)))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nsucceed\nqval\nfail\n))))\n(\ndefine\n(\nanalyze-variable\nexp\n)\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nsucceed\n(\nlookup-variable-value\nexp\nenv\n)\nfail\n)))\n(\ndefine\n(\nanalyze-lambda\nexp\n)\n(\nlet\n((\nvars\n(\nlambda-parameters\nexp\n))\n(\nbproc\n(\nanalyze-sequence\n(\nlambda-body\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nsucceed\n(\nmake-procedure\nvars\nbproc\nenv\n)\nfail\n))))\n変数の検索が常に\n‘\n成功\n’\nすることに注意して下さい。もし\nlookup-variable-\nvalue\nが変数を見つけるのに失敗した場合、それはいつも通りにエラーを発し\nます。そのような\n“\n失敗\n”\nはプログラムのバグ\n—\n未束縛な変数への参照\n—\nを示\nします。これは現在試行中の物の代わりに別の非決定性選択を試すことを示し\nてはいません。\n条件文と列\n条件文もまた通常の評価機と同様に取り扱われます。\nanalyze-if\nにより\n生成される実行手続は述語実行手続\npproc\nを成功継続と共に起動します。成\n功継続は述語の値が真であるかチェックし、結果部\n(consequent)\nか代替部\n(alternative)\nを実行します。もし\npproc\nの実行が失敗したなら\nif\n式に対する\n元の失敗継続が呼ばれます。\n460","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":486},{"id":"./test/fixtures/pdf/sicp.pdf:487","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nanalyze-if\nexp\n)\n(\nlet\n((\npproc\n(\nanalyze\n(\nif-predicate\nexp\n)))\n(\ncproc\n(\nanalyze\n(\nif-consequent\nexp\n)))\n(\naproc\n(\nanalyze\n(\nif-alternative\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\npproc\nenv\n;;\n述語を評価するための成功継続を置く\n;;\npred-value\nを得るため\n(\nlambda\n(\npred-value\nfail2\n)\n(\nif\n(\ntrue?\npred-value\n)\n(\ncproc\nenv\nsucceed\nfail2\n)\n(\naproc\nenv\nsucceed\nfail2\n)))\n;;\n述語を評価するための失敗継続\nfail\n))))\n列もまた以前の評価機と同様に取り扱われます。ただし継続を渡すために必要\nとされる内部手続\nsequentially\n内の企みが異なります。具体的には\na\nを実行\nし、次に\nb\nと順に行うために、\na\nを成功継続と共に呼び、成功継続が\nb\nを呼び\nます。\n(\ndefine\n(\nanalyze-sequence\nexps\n)\n(\ndefine\n(\nsequentially\na\nb\n)\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\na\nenv\n;;\na\nを呼ぶための成功継続\n(\nlambda\n(\na-value\nfail2\n)\n(\nb\nenv\nsucceed\nfail2\n))\n;;\na\nを呼ぶための失敗継続\nfail\n)))\n(\ndefine\n(\nloop\nfirst-proc\nrest-procs\n)\n(\nif\n(\nnull?\nrest-procs\n)\nfirst-proc\n(\nloop\n(\nsequentially\nfirst-proc\n(\ncar\nrest-procs\n))\n(\ncdr\nrest-procs\n))))\n(\nlet\n((\nprocs\n(\nmap\nanalyze\nexps\n)))\n(\nif\n(\nnull?\nprocs\n)\n461","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":487},{"id":"./test/fixtures/pdf/sicp.pdf:488","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nerror\n\"\nEmpty\nsequence\n:\nANALYZE\n\"\n))\n(\nloop\n(\ncar\nprocs\n) (\ncdr\nprocs\n))))\n定義と代入\n定義は継続を管理するために手間をかけなければいけない一例です。定義\nの値\n(definition-value)\nの式を実際に新しい値を定義する前に評価する必要があ\nるためです。これを達成するためには定義値実行手続\nvproc\nが環境、成功継続、\n失敗継続と共に呼ばれます。もし\nvproc\nの実行が成功したなら定義値のための\n値\nval\nを取得し、変数が定義され成功が伝播されます。\n(\ndefine\n(\nanalyze-definition\nexp\n)\n(\nlet\n((\nvar\n(\ndefinition-variable\nexp\n))\n(\nvproc\n(\nanalyze\n(\ndefinition-value\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nvproc\nenv\n(\nlambda\n(\nval\nfail2\n)\n(\ndefine-variable!\nvar\nval\nenv\n)\n(\nsucceed\n'ok\nfail2\n))\nfail\n))))\n代入はもっと面白いです。これは継続をたらい回しにするのではなく、本当に\n継続を使用する最初の場所です。代入のための実行手続は定義のためのものと\n同様に開始します。最初に変数に代入される新しい値を取得しようと試みます。\nもしこの\nvproc\nの評価が失敗したら代入は失敗します。\nしかし\nvproc\nが成功し代入を行なおうとした場合には、この計算の分岐が\n後に失敗する可能性について考えねばなりません。この場合には代入から外れ\nてバックトラックする必要があります。従ってこの代入をバックトラック処理\nの一部分として取消する準備をしなければなりません。\n56\nこれは\nvproc\nに\n(\n下でコメント\n“*1*”\nが記された\n)\n成功継続を与えること\nで達成されます。この成功継続は新しい値を代入し、結果として存在する前\nに、変数の古い値を保存します。代入値と共に渡された\n(\n下でコメント\n“*2*”\nが記された\n)\n失敗継続は失敗を続ける前に変数の古い値を再格納します。つま\nり、代入の成功は後の失敗に割り込む失敗継続を提供します。そうでなければ\n56\n定義の取消については心配しません。内部定義は走査されたことが想定可能なため\nです。\n(\nSection 4.1.6\n)\n462","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":488},{"id":"./test/fixtures/pdf/sicp.pdf:489","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"fail2\nを呼んでいたはずのどんな失敗もこの手続を代わりに呼ぶことで、実際\nに\nfail2\nを呼ぶ前に代入を取り消します。\n(\ndefine\n(\nanalyze-assignment\nexp\n)\n(\nlet\n((\nvar\n(\nassignment-variable\nexp\n))\n(\nvproc\n(\nanalyze\n(\nassignment-value\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nvproc\nenv\n(\nlambda\n(\nval\nfail2\n)\n; *1*\n(\nlet\n((\nold-value\n(\nlookup-variable-value\nvar\nenv\n)))\n(\nset-variable-value!\nvar\nval\nenv\n)\n(\nsucceed\n'ok\n(\nlambda\n()\n; *2*\n(\nset-variable-value!\nvar\nold-value\nenv\n)\n(\nfail2\n)))))\nfail\n))))\n手続の適用\n適用のための実行手続は新しいアイデアを含んではいません。ただし継続\nを管理する技術的な複雑さが異なります。この複雑さは\nanalyze-application\nの中でオペランドを評価するに従い成功と失敗の継続を追跡する必要があるた\nめに、浮上します。私達は通常の評価機の中の様に単純に\nmap\nを使うのでなく、\n手続\nget-args\nを用いてオペランドのリストを評価しています。\n(\ndefine\n(\nanalyze-application\nexp\n)\n(\nlet\n((\nfproc\n(\nanalyze\n(\noperator\nexp\n)))\n(\naprocs\n(\nmap\nanalyze\n(\noperands\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\nfproc\nenv\n(\nlambda\n(\nproc\nfail2\n)\n(\nget-args\naprocs\nenv\n(\nlambda\n(\nargs\nfail3\n)\n463","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":489},{"id":"./test/fixtures/pdf/sicp.pdf:490","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nexecute-application\nproc\nargs\nsucceed\nfail3\n))\nfail2\n))\nfail\n))))\nget-args\nの中では、どのようにして\naproc\n実行手続のリストを\ncdr\nで下り、そ\nして結果の\nargs\nのリストを全て\ncons\nするかについて注意して下さい。これは\nリスト中の全ての\naproc\nを、再帰的に\nget-args\nを呼ぶ成功継続と共に呼ぶこ\nとにより達成されます。これらの\nget-args\nに対する全ての再帰的呼出は、蓄\n積された引数のリストの上に新しく取得された引数を\ncons\nした値を返す成功\n継続を持っています。\n(\ndefine\n(\nget-args\naprocs\nenv\nsucceed\nfail\n)\n(\nif\n(\nnull?\naprocs\n)\n(\nsucceed\n'\n()\nfail\n)\n((\ncar\naprocs\n)\nenv\n;\n;\nこの\naproc\nのための成功継続\n(\nlambda\n(\narg\nfail2\n)\n(\nget-args\n(\ncdr\naprocs\n)\nenv\n;\n;\nget-args\nの再帰呼出のための\n;\n;\n成功継続\n(\nlambda\n(\nargs\nfail3\n)\n(\nsucceed\n(\ncons\narg\nargs\n)\nfail3\n))\nfail2\n))\nfail\n)))\nexe@-cute-application\nにより実行される実際の手続適用は通常の評価機に\n対する物と同じ方法にて達成されます。ただし継続の管理の必要が異なります。\n(\ndefine\n(\nexecute-application\nproc\nargs\nsucceed\nfail\n)\n(\ncond\n((\nprimitive-procedure?\nproc\n)\n(\nsucceed\n(\napply-primitive-procedure\nproc\nargs\n)\nfail\n))\n((\ncompound-procedure?\nproc\n)\n((\nprocedure-body\nproc\n)\n464","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":490},{"id":"./test/fixtures/pdf/sicp.pdf:491","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nextend-environment\n(\nprocedure-parameters\nproc\n)\nargs\n(\nprocedure-environment\nproc\n))\nsucceed\nfail\n))\n(\nelse\n(\nerror\n\"\nUnknown\nprocedure\ntype\n:\nEXECUTE-APPLICATION\n\"\nproc\n))))\namb\n式の評価\namb\nの特別形式は非決定性言語の鍵となる要素です。ここでは逐次翻訳処\n理の本質と継続を追跡する理由について学びます。\namb\nに対する実行手続はル\nープ\ntry-next\nを定義します。これは全ての\namb\n式の可能な値のために、全実\n行手続を通して実行します。各実行手続は次の実行手続を試す失敗継続と共に\n呼ばれます。試行する選択肢が無くなった時には、\namb\n式全体が失敗します。\n(\ndefine\n(\nanalyze-amb\nexp\n)\n(\nlet\n((\ncprocs\n(\nmap\nanalyze\n(\namb-choices\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\ndefine\n(\ntry-next\nchoices\n)\n(\nif\n(\nnull?\nchoices\n)\n(\nfail\n)\n((\ncar\nchoices\n)\nenv\nsucceed\n(\nlambda\n() (\ntry-next\n(\ncdr\nchoices\n))))))\n(\ntry-next\ncprocs\n))))\nドライバループ\namb\n評価機のドライバループは複雑です。ユーザに式の評価を再試行\n(try-\nagain)\nすることを可能にする仕組みのためです。ドライバは\ninternal-loop\nと\n呼ばれる手続を使用します。これは引数として手続\ntry-again\nを取ります。こ\nれの意図は\ntry-again\nの呼出は次のまだ試行されていない非決定性評価にお\n465","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":491},{"id":"./test/fixtures/pdf/sicp.pdf:492","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ける選択肢へ続けなければならないことです。\ninternal-loop\nはユーザのドラ\nイバループでの\ntry-again\nの入力への応答として\ntry-again\nを呼ぶか、また\nはそうでなければ\nambeval\nを呼ぶことにより新しい評価を開始します。\nambeval\nへのこの呼出のための失敗継続はユーザにもう値は残っていない\nと伝え、ドライバループを再起動する。\nambeval\nへの呼出のための成功継続はより微妙です。獲得した値を表示\nし、次に内部ループを再び起動します。起動には次の選択肢を試行可能な\ntry-\nagain\n手続を伴ないます。この\nnext-alternative\n手続は成功継続に二番目の\n引数として渡されます。通常はこの二番目の引数はもし現在の評価分岐が後に\n失敗場合に利用される失敗継続として考えます。今回の場合はしかし、評価を\n成功裏に完了しました。そのため\n“\n失敗\n”\nの代替分岐を追加の成功する評価を\n探すために起動することができます。\n(\ndefine\ninput-prompt\n\"\n;;;\nAmb-Eval\ninput\n:\n\"\n)\n(\ndefine\noutput-prompt\n\"\n;;;\nAmb-Eval\nvalue\n:\n\"\n)\n(\ndefine\n(\ndriver-loop\n)\n(\ndefine\n(\ninternal-loop\ntry-again\n)\n(\nprompt-for-input\ninput-prompt\n)\n(\nlet\n((\ninput\n(\nread\n)))\n(\nif\n(\neq?\ninput\n'try-again\n)\n(\ntry-again\n)\n(\nbegin\n(\nnewline\n)\n(\ndisplay\n\"\n;;;\nStarting\na\nnew\nproblem\n\"\n)\n(\nambeval\ninput\nthe-global-environment\n;\n;\nambeval\nsuccess\n(\nlambda\n(\nval\nnext-alternative\n)\n(\nannounce-output\noutput-prompt\n)\n(\nuser-print\nval\n)\n(\ninternal-loop\nnext-alternative\n))\n;\n;\nambeval\nfailure\n(\nlambda\n()\n(\nannounce-output\n\"\n;;;\nThere\nare\nno\nmore\nvalues\nof\n\"\n)\n(\nuser-print\ninput\n)\n466","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":492},{"id":"./test/fixtures/pdf/sicp.pdf:493","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndriver-loop\n)))))))\n(\ninternal-loop\n(\nlambda\n()\n(\nnewline\n)\n(\ndisplay\n\"\n;;;\nThere\nis\nno\ncurrent\nproblem\n\"\n)\n(\ndriver-loop\n))))\ninternal-loop\nの最初の呼出では現在、問題が無いと不服を述べ、ドライバル\nープを再開します。これはユーザが\ntry-again\nを入力し評価に進展が無い場合\nに起こる振舞です。\nExercise 4.50:\namb\nと似ているが、次の選択肢を左から右へでなく\nランダムな順で探索する新しい特別形式\nramb\nを実装せよ。\nExercise\n4.49\nにおける\nAlyssa\nの問題をどのように助けるか示せ。\nExercise 4.51:\n失敗時に取り消されない\npermanent-set!\nと呼ばれ\nる新しい種類の代入を実装せよ。例えば、以下の様に\n2\nつの区別\n可能な要素をリストから選択し、成功した選択に必要とした試行\nの数をカウントする。\n(\ndefine\ncount\n0)\n(\nlet\n((\nx\n(\nan-element-of\n'\n(\na\nb\nc\n)))\n(\ny\n(\nan-element-of\n'\n(\na\nb\nc\n))))\n(\npermanent-set!\ncount\n(+\ncount\n1))\n(\nrequire\n(\nnot\n(\neq?\nx\ny\n)))\n(\nlist\nx\ny\ncount\n))\n;;; Starting a new problem\n;;; Amb-Eval value:\n(a b 2)\n;;; Amb-Eval input:\ntry-again\n;;; Amb-Eval value:\n(a c 3)\nここで\npermanent-set!\nの代わりに\nset!\nを使ったらどんな値が表\n示されるだろうか\n?\nExercise 4.52:\nユーザに式の失敗を捕獲させることを可能にする新\nしいコンストラクタ\nif-fail\nを実装せよ。\nif-fail\nは\n2\nつの式を\n467","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":493},{"id":"./test/fixtures/pdf/sicp.pdf:494","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"取る。最初の式を通常通りに評価し評価が成功したら普通に戻る。\nしかし、もし評価が失敗したら\n2\nつ目の式の値が以下の例の様に\n返される。\n;;; Amb-Eval input:\n(\nif-fail\n(\nlet\n((\nx\n(\nan-element-of\n'\n(1 3 5))))\n(\nrequire\n(\neven?\nx\n))\nx\n)\n'all-odd\n)\n;;; Starting a new problem\n;;; Amb-Eval value:\nall-odd\n;;; Amb-Eval input:\n(\nif-fail\n(\nlet\n((\nx\n(\nan-element-of\n'\n(1 3 5 8))))\n(\nrequire\n(\neven?\nx\n))\nx\n)\n'all-odd\n)\n;;; Starting a new problem\n;;; Amb-Eval value:\n8\nExercise 4.53:\nExercise 4.51\nで説明した\npermanent-set!\nと\nExercise\n4.52\nの\nif-fail\nを用いて以下を評価した時どのような結果にな\nるか。\n(\nlet\n((\npairs\n'\n()))\n(\nif-fail\n(\nlet\n((\np\n(\nprime-sum-pair\n'\n(1 3 5 8)\n'\n(20 35 110))))\n(\npermanent-set!\npairs\n(\ncons\np\npairs\n))\n(\namb\n))\npairs\n))\nExercise 4.54:\nもし\nrequire\nが\namb\nを用いた通常の手続として実\n装できることに気付かなかった場合、ユーザにより非決定性プロ\nグラムの一部として定義されるために、それを特別形式として実\n468","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":494},{"id":"./test/fixtures/pdf/sicp.pdf:495","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"装する必要があったはずである。これは以下の構文手続を必要と\nしたであろう。\n(\ndefine\n(\nrequire?\nexp\n)\n(\ntagged-list?\nexp\n'require\n))\n(\ndefine\n(\nrequire-predicate\nexp\n)\n(\ncadr\nexp\n))\nそして\nanalyze\n内の呼出に新しい節が必要となった。\n((\nrequire?\nexp\n) (\nanalyze-require\nexp\n))\nまた\nrequire\n式を取り扱う手続\nanalyze-require\nも必要となっ\nた。以下の\nanalyze-require\nの定義を完成させよ。\n(\ndefine\n(\nanalyze-require\nexp\n)\n(\nlet\n((\npproc\n(\nanalyze\n(\nrequire-predicate\nexp\n))))\n(\nlambda\n(\nenv\nsucceed\nfail\n)\n(\npproc\nenv\n(\nlambda\n(\npred-value\nfail2\n)\n(\nif\n⟨\n??\n⟩\n⟨\n??\n⟩\n(\nsucceed\n'ok\nfail2\n)))\nfail\n))))\n4.4\n論理プログラミング\nChapter 1\nでは計算機科学は命令型\n(\nどうするか\n)\nの知識を扱い、一方、数学\nは宣言型\n(\n何であるか\n)\nの知識を扱うと強調しました。実際に、プログラミング\n言語はプログラマが特定の問題を解くために、段階的な手法を示す形式により、\n知識を表現することを要求します。一方、高級言語は言語の実装の一部として\nユーザを、指定された演算がどのように進められるかについての詳細から解放\nする、十分な量の方法論的知識を提供します。\nLisp\nを含む多くのプログラミング言語は数学上の関数の値の演算の周りに\n体系化されています。式指向の言語\n(\n例えば\nLisp\n、\nFortran\n、\nAlgol)\nは関数の値\nを記述する式がその値を求める手段としても解釈されるという\n“\n多義性\n”\nを十\n分に活用しています。このため、多くのプログラミング言語は単向性演算\n(\n明\n469","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":495},{"id":"./test/fixtures/pdf/sicp.pdf:496","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"確な入力と出力を持つ演算\n)\nに向けて強く偏っています。しかし、この偏りを\n緩和する完全に異なるプログラミング言語も存在します。そのような言語の例\nを\nSection 3.3.5\nで見ました。そこでは計算オブジェクトは数値的な制約でした。\n制約システムでは演算の向きと順はあまり明らかには指定されません。従って、\n演算の実行においてシステムはより詳細な\n“\n行い方\n”\nの知識を、通常の数値演\n算による場合よりも多く提供しなければなりません。しかし、これはユーザが\n命令型の知識を提供する責任から完全に解放されることは意味しません。同じ\n制約の集合を実装する制約ネットワークは数多く存在し、ユーザは数学的に等\n価なネットワークの中から特定の演算を指定するのに適切なネットワークを選\n択せねばなりません。\nSection 4.3\nの非決定性プログラム評価機もまたプログラミングとは一方向\n性関数のためのアルゴリズムを構築することであるという視点から離れていま\nす。非決定性言語においては、式は\n2\nつ以上の値を持つことができ、結果とし\nて演算とは単一の値の関数ではなく関係性を取り扱う物になります。論理プロ\nグラミングはプログラミングの関係性の視点と\nunification\n(\nユニフィケーショ\nン\n、単一化\n)\nと呼ばれる強力な種類の記号パターンマッチングとを組み合わせ\nることでこの考えを拡張します。\n57\nこの取り組み方は、うまく行く場合には、プログラムを書くのにとても強\n57\n論理プログラミングは自動定理証明の研究の長い歴史から成長しました。早期の定\n理証明プログラムはあまり目的を達成することができませんでした。可能な証明空間を\n網羅的に探索するためです。受け入れ可能な探索を行える打開策の主な物は\n1960\n年代早\n期の\nunification algorithm\n(\nユニフィケーションアルゴリズム\n)\nと\nresolution principle\n(\n導\n出原理\n)(\nRobinson 1965\n)\nの発見でした。例えば導出は\nGreen and Raphael (1968)\nにより\n(\nGreen 1969\nも参照\n)\n演繹的質問応答システムの基盤として使用されました。この時期の\n多くの間、研究者達は証明が存在するのであれば見つけられることが保証されたアルゴ\nリズムについて集中していました。そのようなアルゴリズムはコントロールして証明に\n向かわせることが難しいものでした。\nHewitt (1969)\nはプログラミング言語のコントロー\nル構造と論理操作システムとの結合の可能性を認識し、\nSection 4.3.1\n(\nFootnote 4.47\n)\nで\n述べられた自動探索の成果へと導きました。同時期に、マルセイユの\nColmerauer\nは自\n然言語を扱うルールベースシステム\n(\nColmerauer et al. 1973\n)\nにより同じ事を達成しま\nした。彼は\nProlog\nと呼ばれるプログラミング言語を開発しそれらのルールを表現しまし\nた。\nKowalski (1973; 1979)\nはエディンバラにて、\nProlog\nプログラムの実行は\n(\n線形ホー\nン節導出と呼ばれる証明のテクニックを用いて\n)\n定理証明として解釈できることを認め\nました。最後の\n2\nつの糸を縒り合わせることが論理プログラミング運動へと導きました。\n従って論理プログラミングの開発に対して功績を与えることにおいて、フランス人はマ\nルセイユ大学での\nProlog\nの起源を指摘することができ、一方、イギリス人はエディンバ\nラ大学の成果を強調することができます。\nmit\nの人々に言わせれば、論理プログラミング\nはこれらのグループにより、\nHewitt\nがその才能ある、しかし頑迷な博士論文にて何を伝\nえていたかを解き明かす試みにより開発されました。論理プログラミングの歴史につい\n470","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":496},{"id":"./test/fixtures/pdf/sicp.pdf:497","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"力な方法となります。その力の一部は単一の\n“\n何であるか\n”\nという事実が、異な\nる\n“\n行い方\n”\nの要素を持つかもしれないいくつかの異なる問題を解決するのに\n使用できるという事実から来ています。例として、\nappend\n命令について考えま\nしょう。これは\n2\nつのリストを引数として取り、それらの要素を結合して単一\nのリストを形成します。\nLisp\nのような手続型言語では\nappend\nを基本的なリス\nトコンストラクタ\ncons\nを用いて、\nSection 2.2.1\nで行ったように定義することが\nできました。\n(\ndefine\n(\nappend\nx\ny\n)\n(\nif\n(\nnull?\nx\n)\ny\n(\ncons\n(\ncar\nx\n) (\nappend\n(\ncdr\nx\n)\ny\n))))\nこの手続は以下の\n2\nつのルールにより\nLisp\nへと翻訳したと捕えることができ\nます。最初のルールは\n1\nつ目のリストが空である場合を扱い、\n2\nつ目のルール\nは空でないリスト、つまり\n2\nつの部分による\ncons\nの場合を扱います。\n•\n任意のリスト\ny\nに対し、空リストと\ny\nの\nappend\nは\ny\nを形成する。\n•\n任意の\nu\n,\nv\n,\ny\n,\nz\nに対し、\n(cons u v)\nと\ny\nの\nappend\nはもし\nv\nと\ny\nの\nappend\nが\nz\nを形成するならば\n(cons u z)\nを形成する。\n58\nappend\n手続を用いることで、私達は次のような質問に答えることができます。\n(a b)\nと\n(c d)\nの\nappend\nを求めよ。\nしかし同じ\n2\nつのルールがまた以下のような種類の質問に答えるためにも十分\nです。これらは手続では答えられません。\n(a b)\nと\nappend\nすると\n(a b c d)\nを生成するリスト\ny\nを求めよ。\nappend\nすると\n(a b c d)\nを生成する全ての\nx\nと\ny\nを求めよ。\n論理プログラミング言語ではプログラマは\nappend\n“\n手続\n”\nを上で与えられた\nappend\nに関する\n2\nつのルールを提示することにより記述します。\n“\n行い方\n”\nの\n知識は自動的にインタプリタにより提供されこの単一ペアのルールが\n3\nつ全て\nのタイプの\nappend\nに関する質問に対して答えることを可能にします。\n59\nては\nRobinson 1983\nを参照して下さい。\n58\nルールと手続の間の対応を見るためには、手続における\nx\n(\nx\nが空でない場合\n)\nをルー\nルの\n(cons u v)\nに対応させます。次にルールの\nz\nは\n(cdr x)\nと\ny\nの\nappend\nに対応し\nます。\n59\nこれは確かにユーザをどのように回答を求めるかという問題全体からは解放しませ\nん。\nappend\nの関係を形式化するための数学的に等価なルールは数多く存在します。それ\n471","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":497},{"id":"./test/fixtures/pdf/sicp.pdf:498","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"現代の論理プログラミング言語\n(\nここで私達が実装しているものを含めて\n)\nにはかなりの量の不足がそれらの一般的な\n“\n行い方\n”\nの手法について存在しま\nす。このことが偽の無限ループを引き起したり、他の望ましくない振舞へと導\nいてしまします。論理プログラミングは計算機科学において活発な研究領域で\nす。\n60\nこの章の最初では私達はインタプリタの実装技術を探求し\nLisp\nの様な言\n語のためのインタプリタに対して\n(\n実際に、任意の従来の言語に対して\n)\n本質\nである要素を説明しました。今から私達はこれらの考えを応用し論理プログ\nラミング言語のためのインタプリタについて議論します。この言語を\nquery\nlanguage\n(\nクエリ言語\n)\nと呼ぶことにします。言語で内で表現される、\nqueries\n(\nク\nエリ\n)\n、つまり質問を定式化することによりデータベースから情報を取得する\nことに対してとても便利なためです。クエリ言語は\nLisp\nと全く違うであるに\nも係らず、私達がここまで利用してきた同じ一般的なフレームワークを用いて\nこの言語を説明することがとても都合が良いことを理解するでしょう。このフ\nレームワークはプリミティブな要素の集合として、簡単な要素を組み合わせる\nことでより複雑な要素を作ることを可能にする組み合わせの手段と、複雑な要\n素を単純な概念の単位として見做すことを可能にする抽象化の手段とを一緒に\n用いました。論理プログラミング言語向けインタプリタは\nLisp\nのような言語\nのインタプリタよりも大幅に複雑です。それでも、私達のクエリ言語インタプ\nリタが\nSection 4.1\nのインタプリタ内にて見つけた多くの同じ要素を含むことを\n学ぶでしょう。具体的には式を方に従って分類する\n“eval”\nのパートが存在し、\nそして言語の抽象化の仕組み\n(Lisp\nの場合では手続であり、論理プログラミン\nグの場合ではルール\n)\nを実装する\n“apply”\nのパートが存在します。また、中心\nらのいくつかのみが任意の方向の演算に対する効果的な手段と成り得ます。付け加えて、\n時々、\n“\n何であるか\n”\nという情報は\n“\nどのように\n”\n回答を求めるかについて何の手掛かりも\n与えない場合があります。例えば\n푦\n2\n= 푥\nとなる\n푦\nを求める問題について考えてみて下さ\nい。\n60\n論理プログラミングへの興味は\n80\n年代早期に日本政府が論理プログラミング言語\nを実行するのに最適化されたとても速い計算機を構築することを狙った大望あるプロ\nジェクトを開始した時にピークを迎えました。そのような計算機のスピードは通常の\nFLOPS(FLoating-point Operations Per Second)\nでなく\nLIPS(Logical Inferences Per\nSecond)\nで計られます。プロジェクトはハードウェアとソフトウェアの開発において元々\nの計画通りに成功しましたが、国際的なコンピュータ業界は異なる方向へと向かいまし\nた。日本のプロジェクトの評価の概観については\nFeigenbaum and Shrobe 1993\nを参照し\nて下さい。論理プログラミングコミュニティもまた、\nSection 3.3.5\nの制約伝播システムで\n説明されたような数値値上の制約を取り扱う能力の様な単純なパターンマッチングでは\nない技術を基盤にしたリレーショナルプログラミングへと移行しました。\n472","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":498},{"id":"./test/fixtures/pdf/sicp.pdf:499","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"的な役割はフレームデータ構造により実装の中で演じられます。このフレーム\nデータ構造はシンボルとそれらに関連する値の間の対応を決定します。クエリ\n言語の実装の追加の面白い側面の\n1\nつは、\nChapter 3\nで紹介したストリームを\n大量に使用することです。\n4.4.1\n演繹的情報検索\n論理プログラミングは情報取得のためのデータベースに対するインターフ\nェイスの提供において秀でています。私達がこの章で実装するクエリ言語はこ\nのように使用されるよう設計されています。\nクエリシステムが何を行うかを説明するために、ボストン区域に存在する\n成長中のハイテク企業、\nMicroshaft\nの社員情報のデータベースを管理するため\nに、クエリシステムがどのように利用できるかについて示します。この言語は\nパターンにより示される社員情報へのアクセスを提供し、また論理的演繹法を\n行うための一般的なルールの利点をも得ることができます。\nサンプルデータベース\nMicroshaft\nの社員情報データベースは会社の全社員に関する\nassertions\n(\nア\nサーション\n、表明\n)\nを保持します。以下に常駐のコンピュータウィザード、\nBen\nBitdiddle\nに関する情報を挙げます。\n(\naddress\n(\nBitdiddle\nBen\n) (\nSlumerville\n(\nRidge\nRoad\n) 10))\n(\njob\n(\nBitdiddle\nBen\n) (\ncomputer\nwizard\n))\n(\nsalary\n(\nBitdiddle\nBen\n) 60000)\n各アサーションはリスト\n(\nこの場合\n3\nつ組\n)\nで、その要素はそれ自体がリストに\n成り得ます。\n常駐のウィザードとして、\nBen\nは会社のコンピュータ部門を管理し、二人の\nプログラマと一人の技術者を監督します。以下に部下に関する情報を挙げます。\n(\naddress\n(\nHacker\nAlyssa\nP\n) (\nCambridge\n(\nMass\nAve\n) 78))\n(\njob\n(\nHacker\nAlyssa\nP\n) (\ncomputer\nprogrammer\n))\n(\nsalary\n(\nHacker\nAlyssa\nP\n) 40000)\n(\nsupervisor\n(\nHacker\nAlyssa\nP\n) (\nBitdiddle\nBen\n))\n(\naddress\n(\nFect\nCy\nD\n) (\nCambridge\n(\nAmes\nStreet\n) 3))\n(\njob\n(\nFect\nCy\nD\n) (\ncomputer\nprogrammer\n))\n473","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":499},{"id":"./test/fixtures/pdf/sicp.pdf:500","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nsalary\n(\nFect\nCy\nD\n) 35000)\n(\nsupervisor\n(\nFect\nCy\nD\n) (\nBitdiddle\nBen\n))\n(\naddress\n(\nTweakit\nLem\nE\n) (\nBoston\n(\nBay\nState\nRoad\n) 22))\n(\njob\n(\nTweakit\nLem\nE\n) (\ncomputer\ntechnician\n))\n(\nsalary\n(\nTweakit\nLem\nE\n) 25000)\n(\nsupervisor\n(\nTweakit\nLem\nE\n) (\nBitdiddle\nBen\n))\nAlyssa\nに監督されているプログラマ見習いもいます。\n(\naddress\n(\nReasoner\nLouis\n) (\nSlumerville\n(\nPine\nTree\nRoad\n) 80))\n(\njob\n(\nReasoner\nLouis\n) (\ncomputer\nprogrammer\ntrainee\n))\n(\nsalary\n(\nReasoner\nLouis\n) 30000)\n(\nsupervisor\n(\nReasoner\nLouis\n) (\nHacker\nAlyssa\nP\n))\nこれらの人々全てはコンピュータ部門に属し、彼等の職位\n(job)\n記述の最初の\n項目である単語\ncomputer\nにより示されています。\nBen\nは高位の従業員です。彼の監督者は会社の有力者である彼自身です。\n(\nsupervisor\n(\nBitdiddle\nBen\n) (\nWarbucks\nOliver\n))\n(\naddress\n(\nWarbucks\nOliver\n) (\nSwellesley\n(\nTop\nHeap\nRoad\n)))\n(\njob\n(\nWarbucks\nOliver\n) (\nadministration\nbig\nwheel\n))\n(\nsalary\n(\nWarbucks\nOliver\n) 150000)\nコンピュータ部門が\nBen\nに監督されているのに加えて、会社には会計士長とそ\nのアシスタントから成る経理部門があります。\n(\naddress\n(\nScrooge\nEben\n) (\nWeston\n(\nShady\nLane\n) 10))\n(\njob\n(\nScrooge\nEben\n) (\naccounting\nchief\naccountant\n))\n(\nsalary\n(\nScrooge\nEben\n) 75000)\n(\nsupervisor\n(\nScrooge\nEben\n) (\nWarbucks\nOliver\n))\n(\naddress\n(\nCratchet\nRobert\n) (\nAllston\n(\nN\nHarvard\nStreet\n) 16))\n(\njob\n(\nCratchet\nRobert\n) (\naccounting\nscrivener\n))\n(\nsalary\n(\nCratchet\nRobert\n) 18000)\n(\nsupervisor\n(\nCratchet\nRobert\n) (\nScrooge\nEben\n))\nまた重役のための秘書もいます。\n(\naddress\n(\nAull\nDeWitt\n) (\nSlumerville\n(\nOnion\nSquare\n) 5))\n474","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":500},{"id":"./test/fixtures/pdf/sicp.pdf:501","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\njob\n(\nAull\nDeWitt\n) (\nadministration\nsecretary\n))\n(\nsalary\n(\nAull\nDeWitt\n) 25000)\n(\nsupervisor\n(\nAull\nDeWitt\n) (\nWarbucks\nOliver\n))\nデータベースはまたどの職種が他の職種を持つ人々により行われることができ\nるかに関するアサーションも含みます。例えばコンピュータウィザードはコン\nピュータプログラマとコンピュータ技術者の両方の職を行うことができます。\n(\ncan-do-job\n(\ncomputer\nwizard\n) (\ncomputer\nprogrammer\n))\n(\ncan-do-job\n(\ncomputer\nwizard\n) (\ncomputer\ntechnician\n))\nコンピュータプログラマは見習いを埋めることができるでしょう。\n(\ncan-do-job\n(\ncomputer\nprogrammer\n)\n(\ncomputer\nprogrammer\ntrainee\n))\nまた良く知られているように以下も言えます。\n(\ncan-do-job\n(\nadministration\nsecretary\n)\n(\nadministration\nbig\nwheel\n))\n単純なクエリ\nクエリ言語はユーザにシステムプロンプトに対する応答としてクエリを提\n示させることで、データベースから情報を取得することを許します。\n;;; Query input:\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))\nシステムは以下の項目を返します。\n;;; Query results:\n(\njob\n(\nHacker\nAlyssa\nP\n) (\ncomputer\nprogrammer\n))\n(\njob\n(\nFect\nCy\nD\n) (\ncomputer\nprogrammer\n))\n入力クエリはある種のパターンにマッチするデータベース内のエントリを探す\nことを指示します。この例では、パターンは\n3\nつの項目から成るエントリを指\n定しています。最初が文字シンボルの\njob\n、\n2\nつ目は任意の値に成り得て、\n3\n番\n目は文字のリスト\n(computer programmer)\nです。マッチングリスト内の\n2\nつ目\nの項目に成り得る\n“\n任意項\n”\nは\npattern variable\n(\nパターン変数\n)\n?x\nで指定されま\nす。パターン変数の一般的な形式はクエスチョンマークを前に置いた、変数の\n475","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":501},{"id":"./test/fixtures/pdf/sicp.pdf:502","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"名前として取られるシンボルです。以下では、なぜこのことが単に\n?\nを\n“\n任意\n”\nを表すパターンに置くのではなく、パターン変数のために名前を指定すること\nが便利であるかを学びます。システムは簡単なクエリに指定されたパターンに\nマッチするデータベース内の全てのエントリを表示することで応答します。\nパターンは複数の変数を持つことができます。例えば、以下のクエリ\n(\naddress\n?\nx\n?\ny\n)\nは全ての従業員の住所を並べます。\nパターンはクエリが単純にパターンがデータベース内のエントリであるか\nどうかを決定する場合には変数を持つことができません。もしそうであれば\n1\nつの一致が存在します。そうでなければ\n1\nつも一致は存在しません。\n同じパターン変数が\n1\nつのクエリ内に複数存在することができ、同じ\n“\n任\n意項\n”\nが各位置に現われなければいけないこと指定します。これがなぜ変数が\n名前を持つのかの理由です。例えば、\n(\nsupervisor\n?\nx\n?\nx\n)\n上のクエリは自分自身を監督する全ての人々を見つけます。\n(\nしかし私達のサン\nプルデータベース内のアサーションにはそのようなエントリがありません。\n)\n以下のクエリは、\n(\njob\n?\nx\n(\ncomputer\n?\ntype\n))\n3\nつ目の項目が二要素リストでありその\n1\nつ目の要素が\ncomputer\nである全て\nの職種エントリに適合します。\n(\njob\n(\nBitdiddle\nBen\n) (\ncomputer\nwizard\n))\n(\njob\n(\nHacker\nAlyssa\nP\n) (\ncomputer\nprogrammer\n))\n(\njob\n(\nFect\nCy\nD\n) (\ncomputer\nprogrammer\n))\n(\njob\n(\nTweakit\nLem\nE\n) (\ncomputer\ntechnician\n))\nこの同じパターンが以下にはマッチ\n“\nしません\n”\n。\n(\njob\n(\nReasoner\nLouis\n) (\ncomputer\nprogrammer\ntrainee\n))\nなぜならエントリの\n3\nつ目の項目が\n3\n要素のリストであり、パターンの\n3\nつ目\nの項目がそこは\n2\n要素でなければならないと指定しているためです。もし私達\nがパターンを変更し\n3\nつ目の項目が\ncomputer\nで始まる任意のリストでも良い\nようにしたければ、以下のように指定可能です。\n61\n61\nこれは\nExercise 2.20\nで紹介されたドット付き末尾記述を用いています。\n476","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":502},{"id":"./test/fixtures/pdf/sicp.pdf:503","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\njob\n?\nx\n(\ncomputer\n. ?\ntype\n))\n例えば、以下のクエリは、\n(\ncomputer\n. ?\ntype\n)\n次のデータに適合します。\n(\ncomputer\nprogrammer\ntrainee\n)\nこの時\n?type\nはリスト\n(programmer trainee)\nになります。これはまた次のデ\nータにも適合します。\n(\ncomputer\nprogrammer\n)\nこの時\n?type\nはリスト\n(programmer)\nになります。さらに以下のデータにも適\n合します。\n(\ncomputer\n)\nこの時\n?type\nは空リスト\n()\nです。\nクエリ言語の簡単なクエリの処理は以下のように説明できます。\n•\nシステムはクエリパターン内の変数に対する、パターンを満たす全ての\n割り当てを見つけます\n—\nつまり、パターン変数が値によりインスタンス\n化されるような\n(\n例示されるような\n)\n、つまり値により置き換えられるよ\nうな変数に対する値の全ての集合です。結果はデータベース内に存在し\nます。\n•\nシステムはクエリに対し、パターンを満たす変数割り当てと共に、クエ\nリパターンの全てのインスタンス\n(\n事例\n)\nを列挙することで応答します。\nもしパターンに変数が無い場合、クエリはそのパターンがデータベース内に存\n在するかどうかの決定に簡約されることに注意して下さい。もしそうならば、\n変数に何の値も割り当てない空割り当てがデータベースに対するそのパターン\nを満たします。\nExercise 4.55:\n以下の情報をデータベースから取り出す簡単なクエ\nリを与えよ。\n1.\nBen Bitdiddle\nにより監督される\n(supervisor)\n全ての人\n2.\n経理部門に属す全ての人の名前\n(name)\nと職種\n(job)\n3.\nSlumerville\nに済む全ての人の名前と住所\n(address)\n477","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":503},{"id":"./test/fixtures/pdf/sicp.pdf:504","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"複合クエリ\n単純なクエリはクエリ言語のプリミティブな命令を形成します。複雑な命\n令を形成するためには、クエリ言語は組み合わせの手段を提供します。クエリ\n言語を論理プログラミング言語と成す物の\n1\nつに組み合わせの手段が論理式\nを形成するのに用いられる組み合わせの手段に酷似することがあげられます。\nand\n,\nor\n,\nnot\nです。\n(\nここでは\nand\n,\nor\n,\nnot\nは\nLisp\nのプリミティブではありま\nせん。クエリ言語の組込命令です。\n)\nand\nを以下の様に用いて全てのコンピュータプログラマの住所を見つけること\nができます。\n(\nand\n(\njob\n?\nperson\n(\ncomputer\nprogrammer\n))\n(\naddress\n?\nperson\n?\nwhere\n))\n結果の出力は以下の通りです。\n(\nand\n(\njob\n(\nHacker\nAlyssa\nP\n) (\ncomputer\nprogrammer\n))\n(\naddress\n(\nHacker\nAlyssa\nP\n) (\nCambridge\n(\nMass\nAve\n) 78)))\n(\nand\n(\njob\n(\nFect\nCy\nD\n) (\ncomputer\nprogrammer\n))\n(\naddress\n(\nFect\nCy\nD\n) (\nCambridge\n(\nAmes\nStreet\n) 3)))\n一般的に、\n(\nand\n⟨\n푞푢푒푟푦\n1\n⟩\n⟨\n푞푢푒푟푦\n2\n⟩\n...\n⟨\n푞푢푒푟푦\n푛\n⟩\n)\n上の式はパターン変数に対する全ての値の集合が同時に\n⟨푞푢푒푟푦\n1\n⟩ ... ⟨푞푢푒푟푦\n푛\n⟩\nを満す時に満たされます。\n簡単にクエリに関しては、システムはクエリを満たすパターン変数への全ての\n割り当てを見つけることにより複合クエリを処理します。そしてそれらの値に\nよるクエリのインスタンスを表示します。\n複合クエリを構築する別の手段として\nor\nを通す方法があります。例えば、\n(\nor\n(\nsupervisor\n?\nx\n(\nBitdiddle\nBen\n))\n(\nsupervisor\n?\nx\n(\nHacker\nAlyssa\nP\n)))\n上の式は\nBen Bitdiddle\n、または\nAlyssa P. Hacker\nに監督される従業員全てを\n見つけます。\n(\nor\n(\nsupervisor\n(\nHacker\nAlyssa\nP\n) (\nBitdiddle\nBen\n))\n(\nsupervisor\n(\nHacker\nAlyssa\nP\n) (\nHacker\nAlyssa\nP\n)))\n(\nor\n(\nsupervisor\n(\nFect\nCy\nD\n) (\nBitdiddle\nBen\n))\n478","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":504},{"id":"./test/fixtures/pdf/sicp.pdf:505","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nsupervisor\n(\nFect\nCy\nD\n) (\nHacker\nAlyssa\nP\n)))\n(\nor\n(\nsupervisor\n(\nTweakit\nLem\nE\n) (\nBitdiddle\nBen\n))\n(\nsupervisor\n(\nTweakit\nLem\nE\n) (\nHacker\nAlyssa\nP\n)))\n(\nor\n(\nsupervisor\n(\nReasoner\nLouis\n) (\nBitdiddle\nBen\n))\n(\nsupervisor\n(\nReasoner\nLouis\n) (\nHacker\nAlyssa\nP\n)))\n一般的に、\n(\nor\n⟨\n푞푢푒푟푦\n1\n⟩\n⟨\n푞푢푒푟푦\n2\n⟩\n...\n⟨\n푞푢푒푟푦\n푛\n⟩\n)\n上の式はパターン変数に対する全ての値の集合が、\n⟨푞푢푒푟푦\n1\n⟩ ... ⟨푞푢푒푟푦\n푛\n⟩\nの内、\n少くとも\n1\nつを満たす場合に満たされます。\n複合クエリはまた\nnot\nを用いても形成できます。例えば、\n(\nand\n(\nsupervisor\n?\nx\n(\nBitdiddle\nBen\n))\n(\nnot\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))))\n上の式は\nBen Bitdiddle\nに監督されるが、コンピュータプログラマではない全\nての人を見つけます。一般的に、\n(\nnot\n⟨\n푞푢푒푟푦\n1\n⟩\n)\n上の式はパターン変数に対する全ての割り当てが\n⟨푞푢푒푟푦\n1\n⟩\nを満たさない場合\nに満たされます。\n62\n最後の組み合わせ形式は\nlisp-value\nと呼ばれます。\nlisp-value\nがパターン\nの最初の要素の時、次の要素は\n(\nインスタンス化された\n)\n残りの要素を引数とし\nて適用される\nLisp\nの述語であることを意味します。一般的に、\n(\nlisp-value\n⟨\npredicate\n⟩\n⟨\n푎푟푔\n1\n⟩\n...\n⟨\n푎푟푔\n푛\n⟩\n)\n上の式は\n⟨\npredicate\n⟩\nがパターン変数に対してインスタンス化された\n⟨푎푟푔\n1\n⟩ ...\n⟨푎푟푔\n푛\n⟩\nに適用された時の値が\ntrue\nになる場合の割り当てにより満たされます。\n(\nand\n(\nsalary\n?\nperson\n?\namount\n) (\nlisp-value\n> ?\namount\n30000))\nExercise 4.56:\n以下の情報を取得する複合クエリを定式化せよ。\na\nBen Bitdiddle\nに監督される全ての人の名前と住所を共に\n62\n実際にはこの\nnot\nの説明は簡単な場合に対してのみ有効です。本当の\nnot\nの振舞は\nより複雑です。\nnot\nの奇妙な点については節\nSection 4.4.2\nと\nSection 4.4.3\nにて調査しま\nす。\n479","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":505},{"id":"./test/fixtures/pdf/sicp.pdf:506","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"b\nBen Bitdiddle\nよりも給料\n(salary)\nが安い全ての人をその給\n料と\nBen Bitdiddle\nの給料と共に\nc\nコンピュータ部門ではない人に監督されている全ての人をそ\nの上司の名前と職種と共に\nルール\nプリミティブなクエリと複合クエリに加えて、クエリ言語はクエリを抽象\n化する手段を提供します。これらは\nrules\n(\nルール\n)\nにより提供されます。以下の\nルールは、\n(\nrule\n(\nlives-near\n?\nperson-1\n?\nperson-2\n)\n(\nand\n(\naddress\n?\nperson-1\n(?\ntown\n. ?\nrest-1\n))\n(\naddress\n?\nperson-2\n(?\ntown\n. ?\nrest-2\n))\n(\nnot\n(\nsame\n?\nperson-1\n?\nperson-2\n))))\n二人の人が同じ街に住んでいるのなら、お互いに近くに住んでいると指定して\nいます。最後の\nnot\n節はこのルールが全ての人がその人自身の近くに住んでい\nると言うことを防ぎます。\nsame\nリレーションはとても簡単なルールにより定\n義されます。\n63\n(\nrule\n(\nsame\n?\nx\n?\nx\n))\n以下のルールはある人が監督する人が同様に監督者である場合に組織内での\n“wheel”(\n重要人物\n)\nであると宣言します。\n(\nrule\n(\nwheel\n?\nperson\n)\n(\nand\n(\nsupervisor\n?\nmiddle-manager\n?\nperson\n)\n(\nsupervisor\n?\nx\n?\nmiddle-manager\n)))\nルールの一般的な形式は以下となります。\n63\n2\nつの物が同じであるようにするためには\nsame\nは必要ではないことに注意して下さ\nい。単に同じパターン変数をそれぞれに使用するだけです。実際に、最初から\n2\nつの物で\nなく\n1\nつの物しか持ちません。例として\nlives-near\nルールの\n?town\nや下記の\nwheel\nル\nールの\n?middle-manager\nを参照して下さい。\nsame\nは\n2\nつの物が異なることを強制する\n場合に便利です。例えば\nlives-near\nルールの\n?person-1\nと\n?person-2\nです。同じパター\nン変数をクエリの\n2\nつの部分に使うことは両方の場所に同じ値が現れることを強制しま\nすが、異なるパターン変数を用いることは異なる値が現れることを強制しません。\n(\n異な\nるパターン変数に割り当てられた値は同じにも違う値にも成り得ます。\n)\n480","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":506},{"id":"./test/fixtures/pdf/sicp.pdf:507","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nrule\n⟨\nconclusion\n⟩\n⟨\nbody\n⟩\n)\n⟨\nconclusion\n⟩\nがパターンであり\n⟨\nbody\n⟩\nが任意のクエリです。\n64\nルールは大きな\n(\n例え無限でも\n)\nアサーションの集合を表現するものとして考えることができま\nす。即ち、ルールのボディを満たす変数の割り当てを用いたルールの結果の全\nてのインスタンスです。簡単なクエリ\n(\nパターン\n)\nを説明した時、変数への割り\n当ては、インスタンス化されたパターンがデータベース内に存在する場合にパ\nターンが満たされると説明しました。しかし、パターンは明示的にアサーショ\nンとしてデータベース内に存在する必要はありません。ルールにより暗示され\nる暗黙的なアサーションに成り得ます。例えば、以下のクエリは、\n(\nlives-near\n?\nx\n(\nBitdiddle\nBen\n))\n次の結果を生みます。\n(\nlives-near\n(\nReasoner\nLouis\n) (\nBitdiddle\nBen\n))\n(\nlives-near\n(\nAull\nDeWitt\n) (\nBitdiddle\nBen\n))\nBen Bitdiddle\nの近くに住む全てのコンピュータプログラマを見つけるために\nは、以下のように質問することができます。\n(\nand\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))\n(\nlives-near\n?\nx\n(\nBitdiddle\nBen\n)))\n複合手続の場合と同様に、ルールは他のルールの一部分として\n(\n上記の\nlives-\nnear\nルールで見たように\n)\n使用可能です。または再帰的に定義することさえも\nできます。例として、以下のルールは、\n(\nrule\n(\noutranked-by\n?\nstaff-person\n?\nboss\n)\n(\nor\n(\nsupervisor\n?\nstaff-person\n?\nboss\n)\n(\nand\n(\nsupervisor\n?\nstaff-person\n?\nmiddle-manager\n)\n(\noutranked-by\n?\nmiddle-manager\n?\nboss\n))))\nもしボスがスタッフの上司であるか、\n(\n再帰的に\n)\nスタッフの上司よりボスが上\n役\n(outranked)\nであるならばボスはスタッフより地位が上であると言えます。\nExercise 4.57:\n人\n(person)\nその\n1\nが人その\n2\nを置き換えられると\nは人その\n1\nが人その\n2\nと同じ仕事をしているか、または第三者\n64\n私達は\nsame\nの様にボディの無いルールも認めます。またそのようなルールは、ルー\nルの結論\n(conclusion)\nが任意の変数の値により満たされたことを意味すると解釈します。\n481","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":507},{"id":"./test/fixtures/pdf/sicp.pdf:508","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(someone)\nが人その\n1\nと同じ仕事をしつつ、かつ人その\n2\nの仕事も\n行え、そして人その\n1\nと人その\n2\nが異なる人である場合であると\n述べるルールを定義せよ。そのルールを用いて以下の条件を見つ\nけるクエリを与えよ。\na\nCy D. Fect\nを置き換えられる全ての人\nb\n自分より給料の高い誰かを置き換えられる全ての人を二人の\n給料と一緒に。\nExercise 4.58:\nある人が自分が働いている同じ部署に上司\n(\n監督者\n)\nがいない場合にその人を\n“big shot”(\n有力者\n)\nであると述べるルー\nルを定義せよ。\nExercise 4.59:\nBen Bitdiddle\nはある会議を何度も欠席してしまっ\nた。彼の会議を忘れる癖は仕事を失う恐れがある。\nBen\nは何かし\nなければならないと決心した。彼は会社の週次ミーティング全て\nを\nMicroshaft\nデータベースに以下のアサーションとして加えた。\n(\nmeeting\naccounting\n(\nMonday\n9\nam\n))\n(\nmeeting\nadministration\n(\nMonday\n10\nam\n))\n(\nmeeting\ncomputer\n(\nWednesday\n3\npm\n))\n(\nmeeting\nadministration\n(\nFriday\n1\npm\n))\n各アサーションは部門の全体ミーティングのためのものだ。\nBen\nはまた全ての部門に渡る全社会議のエントリを追加した。会社の\n全従業員がこの会議に参加する。\n(\nmeeting\nwhole-company\n(\nWednesday\n4\npm\n))\na\n金曜の朝に、\nBen\nはその日の全ての会議をデータベースから\nクエリしたいと思った。彼のクエリはどのような物になるか\n?\nb\nAlyssa P. Hacker\nは感心しなかった。彼女は自分の名前を指\n定することで彼女の会議を尋ねることができればより便利に\nなるだろうと考えた。そのため彼女はある人の会議は全ての\nwhole-company\n(\n全社\n)\n会議に加えてその人の部門会議を全て\n含むと言うルールを設計した。\nAlyssa\nのルールのボディを埋\nめよ。\n482","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":508},{"id":"./test/fixtures/pdf/sicp.pdf:509","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nrule\n(\nmeeting-time\n?\nperson\n?\nday-and-time\n)\n⟨\nrule-body\n⟩\n)\nc\nAlyssa\nは水曜の朝に仕事場に到着し、その日に何の会議が\nあるかについて考えた。上記のルールを定義した上で、彼女\nのがこのことを見つけるためにはどのようなクエリを行うべ\nきか\n?\nExercise 4.60:\n以下のクエリを与えることにより、\n(\nlives-near\n?\nperson\n(\nHacker\nAlyssa\nP\n))\nAlyssa P. Hacker\nは仕事場に相乗りできる、彼女の近所に住む人を\n見つけることができる。一方で、お互いが近所に住んでいる全て\nの人々のペアを見つけたい場合には以下のクエリを用いる。\n(\nlives-near\n?\nperson-1\n?\nperson-2\n)\n彼女はお互いに近所に住んでいる人々の各ペアが二度づつ挙げら\nれていることに気付いた。例えば、\n(\nlives-near\n(\nHacker\nAlyssa\nP\n) (\nFect\nCy\nD\n))\n(\nlives-near\n(\nFect\nCy\nD\n) (\nHacker\nAlyssa\nP\n))\nなぜこれが起こるのか\n?\nお互いに近くに住んでいる人々のリスト\nを各ペアが一度しか現れないように見つける方法は存在するか\n?\n説明せよ。\nプログラムとしての論理\nルールを論理的意味合いの一種であると見做すことができます。もしパタ\nーン変数に対する値の割り当てがボディを満たす場合、それならば結論を満た\nします。必然的に、クエリ言語はルールを基にした\nlogical deductions\n(\n論理的推\n理\n)\nを実行する能力を有すると見做すことができます。例として、\nSection 4.4\nの\n始めに説明した\nappend\n命令について考えてみましょう。既に述べたように、\nappend\nは以下の\n2\nつのルールにて特徴づけられます。\n•\n任意のリスト\ny\nに対し、空リストと\ny\nの\nappend\nは\ny\nを形成する。\n•\n任意の\nu\n,\nv\n,\ny\n,\nz\nに対し、\n(cons u v)\nと\ny\nの\nappend\nはもし\nv\nと\nyappend\nが\nz\nを形成する場合、\n(cons u z)\nを形成する。\n483","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":509},{"id":"./test/fixtures/pdf/sicp.pdf:510","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これを私達のクエリ言語で表現するために、以下の関係に対する\n2\nつのルール\nを定義します。\n(\nappend-to-form\nx\ny\nz\n)\n上の関係は\n“\nx\nと\ny\nの\nappend\nは\nz\nを形成する\n”\nことを意味すると解釈できます。\n(\nrule\n(\nappend-to-form\n() ?\ny\n?\ny\n))\n(\nrule\n(\nappend-to-form\n(?\nu\n. ?\nv\n) ?\ny\n(?\nu\n. ?\nz\n))\n(\nappend-to-form\n?\nv\n?\ny\n?\nz\n))\n最初のルールにはボディがありません。これは結果部分が\n?y\nの任意の値を保\n持することを意味します。\n2\nつ目のルールがどのようにドット付き末尾記述を\nリストの\ncar\nと\ncdr\nに名前を付けるために使用しているかについて注意して下\nさい。\nこれら\n2\nつのルールを与えられることで、\n2\nつのリストに対する\nappend\nを\n求めるクエリを定式化することができます。\n;;; Query input:\n(\nappend-to-form\n(\na\nb\n) (\nc\nd\n) ?\nz\n)\n;;; Query results:\n(\nappend-to-form\n(\na\nb\n) (\nc\nd\n) (\na\nb\nc\nd\n))\nより印象的なのは、同じルールを\n“\n(a b)\nに対し\nappend\nしたら\n(a b c d)\nに\nなるリストは何\n”\nという質問に使用できることです。これは以下のように行わ\nれます。\n;;; Query input:\n(\nappend-to-form\n(\na\nb\n) ?\ny\n(\na\nb\nc\nd\n))\n;;; Query results:\n(\nappend-to-form\n(\na\nb\n) (\nc\nd\n) (\na\nb\nc\nd\n))\nappend\nすると\n(a b c d)\nを形成する全てのリストのペアを尋ねることも可能\nです。\n;;; Query input:\n(\nappend-to-form\n?\nx\n?\ny\n(\na\nb\nc\nd\n))\n;;; Query results:\n(\nappend-to-form\n() (\na\nb\nc\nd\n) (\na\nb\nc\nd\n))\n(\nappend-to-form\n(\na\n) (\nb\nc\nd\n) (\na\nb\nc\nd\n))\n(\nappend-to-form\n(\na\nb\n) (\nc\nd\n) (\na\nb\nc\nd\n))\n484","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":510},{"id":"./test/fixtures/pdf/sicp.pdf:511","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nappend-to-form\n(\na\nb\nc\n) (\nd\n) (\na\nb\nc\nd\n))\n(\nappend-to-form\n(\na\nb\nc\nd\n) () (\na\nb\nc\nd\n))\n上記のクエリに対する答を推論するルールを用いることにておいて、クエリシ\nステムはかなりの知性を示すように見えるかもしれません。実際には次の節で\n学ぶように、システムはルールをときほぐす明確なアルゴリズムに従っている\nに過ぎません。残念ながら、システムが\nappend\nの場合では見事な程うまく行\nきますが、一般的な手法はより複雑な場合に分解されるかもしれません。この\nことは\nSection 4.4.3\nで学びます。\nExercise 4.61:\n以下のルールはリストの直前の要素を見つける関係\nnext-to\nを実装する。\n(\nrule\n(?\nx\nnext-to\n?\ny\nin\n(?\nx\n?\ny\n. ?\nu\n)))\n(\nrule\n(?\nx\nnext-to\n?\ny\nin\n(?\nv\n. ?\nz\n))\n(?\nx\nnext-to\n?\ny\nin\n?\nz\n))\n以下のクエリの結果を答えよ。\n(?\nx\nnext-to\n?\ny\nin\n(1 (2 3) 4))\n(?\nx\nnext-to\n1\nin\n(2 1 3 1))\nExercise 4.62:\nExercise 2.17\nの\nlast-pair\n命令を実装するルールを\n定義せよ。これは空ではないリストの最後の要素を含むリストを\n返す。あなたのルールを\n(last-pair (3) ?x)\n,\n(last-pair (1 2\n3) ?x)\n,\n(last-pair (2 ?x) (3))\nのようなクエリにて確認せよ。\nあなたのルールは\n(last-pair ?x (3))\nの様なクエリに対し正し\nく動作するだろうか\n?\nExercise 4.63:\n以下のデータベース\n(\n創世記第\n4\n章を参照せよ\n)\nは\nAda\nの子孫の家系を\nCain\nを経由して\nAdam\nまで戻りながら辿っ\nている。\n(\nson\nAdam\nCain\n)\n(\nson\nCain\nEnoch\n)\n(\nson\nEnoch\nIrad\n)\n(\nson\nIrad\nMehujael\n)\n(\nson\nMehujael\nMethushael\n)\n(\nson\nMethushael\nLamech\n)\n(\nwife\nLamech\nAda\n)\n485","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":511},{"id":"./test/fixtures/pdf/sicp.pdf:512","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nson\nAda\nJabal\n)\n(\nson\nAda\nJubal\n)\n“\nもし\n푆\nが\n푓\nの息子であり、かつ、\n푓\nが\n퐺\nの息子ならば、\n푆\nは\n퐺\nの孫である\n”\nと\n“\nもし\n푊\nが\n푀\nの妻であり、かつ、\n푆\nが\n푊\nの息子\nならば、\n푆\nは\n푀\nの息子である\n”(\nこれは恐らく今日より聖書の時代\nにはより正確であっただろう\n)\nのルールを定式化せよ。これらはク\nエリシステムに対し\nCain\nの孫、\nLamech\nの息子、\nMethushael\nの孫\nを見つけることを可能にする。\n(\nより複雑な関係を推論するいくつ\nかのルールについては\nExercise 4.69\nを参照せよ。\n)\n4.4.2\nクエリシステムの働き方\nSection 4.4.4\nではクエリインタプリタを手続の集合として紹介します。この\n節では低レベルの実装上の詳細からは独立したシステムの一般的な構造につい\nて説明する概観を与えます。インタプリタの実装を説明した後に、私達はイン\nタプリタのいくつかの限界と記号論理学の演算とは異なるクエリ言語の論理演\n算のいくつかの微妙な行い方を理解できる位置に辿り着きます。\nクエリ評価機がクエリをデータベース内の事実とルールに対してマッチさ\nせるためにある種の探索を実行せねばならないことは明らかでしょう。これを\n行う\n1\nつの方法はクエリシステムを\nSection 4.3\nの\namb\n評価機を用いて非決定\n性プログラムとして実装することになります\n(\nExercise 4.78\n参照\n)\n。別の可能性\nにはストリームの助けを用いて探索を管理する方法があります。私達の実装は\nこの\n2\nつ目のアプローチに従います。\nクエリシステムは\n2\nつの中心となる演算、\npattern matching\n(\nパターンマッ\nチング\n)\nと\nunification\n(\nユニフィケーション\n、単一化\n)\nの周りに体系化されます。\n最初にパターンマッチングについて記述し、この演算がフレームのストリーム\nを用いた情報体系と共にどのように単純クエリと複合クエリの両方を実装可\n能にするのか説明します。次に私達はユニフィケーション、つまりルールを\n実装ために必要なパターンマッチングの一般化について議論します。最後に、\nSection 4.1\nで説明されたインタプリタのために\neval\nが式を分類する方法と同\n様の方法で、式を分類する手続を通してクエリインタプリタ全体がどのように\n組み合わされるかについて示します。\n486","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":512},{"id":"./test/fixtures/pdf/sicp.pdf:513","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"パターンマッチング\npattern matcher\n(\nパターンマッチャ\n)\nはあるデータが指定されたパターンに\n適合するかどうかを試すプログラムです。例えばデータリスト\n((a b) c (a\nb))\nはパターン\n(?x c ?x)\nに対しパターン変数\n?x\nが\n(a b)\nに束縛されること\nで適合します。同じデータリストがパターン\n(?x ?y ?z)\nに対し\n?x\nと\n?z\nの両者\nが\n(a b)\nに束縛され、\n?y\nが\nc\nに束縛されることで適合します。これはまたパタ\nーン\n((?x ?y) c (?x ?y))\nに対しても\n?x\nが\na\nに、\n?y\nが\nb\nに束縛されることで\n適合します。しかし、これはパターン\n(?x a ?y)\nには適合しません。このパタ\nーンが\n2\nつ目の要素がシンボル\na\nであるリストを指定しているためです。\nパターンマッチャはクエリシステムにより使用されます。クエリシステム\nは入力としてパターン、データ、\nframe\n(\nフレーム\n)\nを取ります。フレームはさ\nまざまなパターン変数に対する束縛を指定します。パターンマッチャはデータ\nがフレームに既に存在する束縛と一致する状態でパターンに適合するかどうか\nをチェックします。もしそうであれば、その適合により決定された任意の束縛\nを増やしたフレームを返します。そうでなければ、適合が失敗したことを示し\nます。\n例えば、パターン\n(?x ?y ?x)\nを用いて\n(a b a)\nに空のフレームを与えら\nれた場合に適合を行うと\n?x\nが\na\nに、\n?y\nが\nb\nに束縛されることを指定するフレ\nームを返します。同じパターン、同じデータで\n?y\nが\na\nに束縛されていると指定\nするフレームを用いて適合を行うと失敗します。同じパターン、同じデータで\n?y\nが\nb\nに束縛され\n?x\nが未束縛であるフレームを用いて適合を行えば与えられ\nたフレームに\n?x\nの\na\nへの束縛を増やした物が返されます。\nパターンマッチャはルールを含まない単純なクエリを処理するのに必要な\n仕組みの全てです。例えば、以下のクエリを処理する場合、\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))\nデータベース内の全てのアサーションを探索し、最初は空のフレームを考慮し\nてパターンに適合する物を選択します。探索を行った各適合に対して、適合\nにより返されたフレームを用いてパターンを\n?x\nの値と共にインスタンス化し\nます。\nフレームのストリーム\nフレームに対してパターンのテストを行うことはストリームの使用を通し\nて体系化されています。単一のフレームを与えられて、マッチング処理はデー\nタベースのエントリを\n1\nつづつ通して実行します。各データベースエントリに\n487","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":513},{"id":"./test/fixtures/pdf/sicp.pdf:514","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"対して、マッチャは適合が失敗したことを示す特別なシンボルか、フレームに\n対する拡張を生成します。全てのデータベースエントリに対する結果はストリ\nーム内に集められ、フィルタを通すことで失敗が取り除かれます。結果は与え\nられたフレームを適合を通すことでデータベース内のあるアサーションに拡張\nした全てのフレームのストリームです。\n65\n私達のシステムでは\nFigure 4.4\nで示されるように、クエリはフレームの入力\nストリームを取り、ストリーム内の各フレームに対して上記のマッチング処理\nを実行します。言い替えれば、入力ストリーム内の各フレームに対して、クエ\nリはデータベース内のアサーションに対する適合による、全てのフレームの拡\n張から成る新しいストリームを生成します。これらのストリームの全ては次に\n組み合わされて\n1\nつの大きなストリームを形成します。これは入力ストリーム\n内の各フレームの全ての可能な拡張を含んでいます。このストリームがクエリ\nの出力です。\n単純なクエリに答えるためにはクエリを単一の空フレームから成る入力ス\nトリームと共に用います。結果としての出力ストリームは空にフレームに対す\nる全ての拡張を含んでいます\n(\n言い換えれば、クエリに対する全ての答を含み\nます\n)\n。このフレームのストリームは次に、元々のクエリのパターンと各フレー\nム内の値でインスタンス化された変数のコピーのストリームを生成するのに利\n用されます。そしてこれが最終的に表示されるストリームです。\n複合クエリ\nフレームのストリーム実装の真に優雅な点は複合クエリを扱う時に明白に\nなります。複合クエリの処理は適合の結果が指定されたフレームに一致すると\nいう私達のマッチャが要求する能力を利用します。例えば、\n2\nつのクエリの\nand\nを取り扱う以下のようなクエリでは\n(\nand\n(\ncan-do-job\n?\nx\n(\ncomputer\nprogrammer\ntrainee\n))\n(\njob\n?\nperson\n?\nx\n))\n65\nマッチングは一般的にとても重いので、完全なマッチャをデータベースの全ての要\n素に対して適用することは防ぎたいと考えます。これは通常は高速で粗い適合と最終適\n合の部品に分解することで準備します。粗い適合はデータベースをフィルタし、最終適\n合のための候補の小さな集合を生成します。手間をかけて、粗い適合のいくつかの成果\nがデータベースが候補を選択したい時ではなく、構築された時に行えるようにデータベ\nースを事前に準備することができます。データベースの索引の仕組みの周りには莫大な\n技術が構築されています。私達の実装は\nSection 4.4.4\nで説明されているように、そのよう\nな最適化のあまり賢くはない形態を含んでいます。\n488","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":514},{"id":"./test/fixtures/pdf/sicp.pdf:515","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"input stream\nof frames\noutput stream of frames,\nfiltered and extended\nquery\n(job ?x ?y)\nstream of assertions\nfrom data base\nFigure 4.4:\nフレームのストリームを処理するクエリ\n(\n簡単に言えば、\n“\nコンピュータプログラマ見習いの職を行える全ての人を見つ\nけろ\n”)\nまず以下のパターンに適合する全てのエントリを見つけます。\n(\ncan-do-job\n?\nx\n(\ncomputer\nprogrammer\ntrainee\n))\nこれはフレームのストリームを生成します。各フレームは\n?x\nに対する束縛を含\nんでいます。次にストリーム内の各フレームに対し、与えられた\n?x\nに対する束\n縛に一致する様に、以下のパターンに適合する全てのエントリを探します。\n(\njob\n?\nperson\n?\nx\n)\nそのような適合のそれぞれは\n?x\nと\n?person\nに対する束縛を含むフレームを生\n成します。\n2\nつのクエリの\nand\nは\nFigure 4.5\nに示されるように、一連の\n2\nつのク\nエリのコンポーネントの組み合わせであると見做すことができます。最初のク\nエリフィルタを通過するフレームはフィルタをかけられ、\n2\nつ目のクエリにて\nさらに拡張されます。\nFigure 4.6\nは\n2\nつのクエリの\nor\nを\n2\nつのクエリコンポーネントの並列な組み合\nわせとして求めるための類似の手法を示しています。フレームの入力ストリー\nムは各クエリにより別々に拡張されます。\n2\nつの結果ストリームは次にマージ\nされ最終の出力ストリームを生成します。\nこの高いレベルの記述からでも複合クエリの処理が遅くなることがはっき\nりとわかります。例えば、クエリは各入力フレームに対して複数の出力ストリ\nームを生成するかもしれません。そして各クエリも同様です。最悪の場合に\nはクエリ数の指数関数となる多数のマッチングを実行しなければなりません\n489","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":515},{"id":"./test/fixtures/pdf/sicp.pdf:516","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(and A B)\ndata base\ninput stream\nof frames\noutput stream\nof frames\nA\nB\nFigure 4.5:\n2\nつのクエリの\nand\nの組合せはフレームのスト\nリーム上での連続した操作により生成される\n(\nExercise 4.76\n参照\n)\n。\n66\n単純なクエリのみを扱うシステムのほうがとても実用\n的ではありますが、複合クエリを扱うことは極めて難しいのです。\n67\nフレームのストリームの視点から、あるクエリの\nnot\nはクエリが満たされ\nる全てのフレームを取り除くフィルタとして働きます。例えば、以下のパター\nンを与えらえると、\n(\nnot\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n)))\n入力ストリームの各フレームに対して\n(job ?x (computer programmer))\nを満\nたす拡張フレームの生成を試みます。入力ストリームからそのような拡張が存\n在する全てのフレームを削除します。結果はフレーム中の\n?x\nの束縛が\n(job ?x\n(computer programmer))\nを満たさないフレームのみから成るストリームとな\nります。例えば以下のクエリの処理においては、\n(\nand\n(\nsupervisor\n?\nx\n?\ny\n)\n(\nnot\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))))\n最初の節は\n?x\nと\n?y\nに対する束縛を持つフレームを生成します。次に\nnot\n節は\nこれらから\n?x\nに対する束縛が\n?x\nがコンピュータプログラマであるという制約\n66\nしかし、この種の指数関数爆発は\nand\nクエリでは一般的ではありません。追加された\n条件が生成されるフレームの数を増やすのでなく、減らす傾向があるためです。\n67\n複合クエリをどのように効果的に扱うかに関連するデータベース管理システムの多\n数の文献が存在します。\n490","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":516},{"id":"./test/fixtures/pdf/sicp.pdf:517","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"merge\nA\nB\n(or A B)\ndata base\ninput stream\nof frames\noutput stream\nof frames\nFigure 4.6:\n2\nつのクエリの\ncodeor\nの組合せはフレームのス\nトリームを並列に操作しその結果をマージすることで生成\nされる\nを満たす全てのフレームを削除することでフィルタリングします。\n68\nlisp-value\n特別形式はフレームのストリーム上の同様なフィルタとして実\n装されます。ストリーム内の各フレームをパターン内の任意の変数をインスタ\nンス化するために用い、そして\nLisp\n手続を適用します。入力ストリームから述\n語が失敗する全てのフレームを削除します。\nユニフィケーション\nクエリ言語内のルールを扱うために、ルールの結果が与えられたクエリパ\nターンに適合するルールを見付けられねばなりません。ルールの結果はアサー\nションに似ていますが、変数を含められる所が異なります。そのためパターン\n68\nこの\nnot\nのフィルタ実装と、記号論理学における通常の意味での\nnot\nの間には微妙\nな違いが存在します。\nSection 4.4.3\nを参照して下さい。\n491","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":517},{"id":"./test/fixtures/pdf/sicp.pdf:518","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"マッチングの一般化\n—\nunification\n(\nユニフィケーション\n)\nと呼ばれます\n—\nを必\n要とし、その中で\n“\nパターン\n”\nと\n“\nデータ\n”\nの両方が変数を持ち得ます。\nユニファイアは\n2\nつの定数と変数を含むパターンを取り、\n2\nつのパターン\nを等しくする変数への値の割り当てが可能であるかどうかを決定します。もし\nそうであれば、これらの束縛を含むフレームを返します。例えば\n(?x a ?y)\nと\n(?y ?z a)\nのユニフィケーションは\n?x\n,\n?y\n,\n?z\nが全て\na\nに束縛されなければな\nらないフレームを指示します。一方で、\n(?x ?y a)\nと\n(?x b ?y)\nのユニフィケ\nーションは失敗します。\n2\nつのパターンを等しくできる\n?y\nの値が存在しないた\nめです。\n(\n両方のパターンの\n2\nつ目の要素が等しくなるためには\n?y\nは\nb\nになら\nなければなりません。しかし、\n3\n番目の要素が等しくなるためには\n?y\nが\na\nにな\nるしかありません\n)\n。クエリシステムで用いられるユニファイアはパターンマ\nッチャの様に、フレームを入力として取りこのフレームと一致するユニフィケ\nーションを実行します。\nユニフィケーションアルゴリズムはクエリシステムで最も技術的に難しい\n部分です。複雑なパターンを共なうため、ユニフィケーションの実行は演繹を\n必要とするように見えるかもしれません。例えば、\n(?x ?x)\nと\n((a ?y c) (a b\n?z))\nをユニフィケーションするためにはアルゴリズムは\n?x\nは\n(a b c)\nに、\n?y\nは\nb\nに、\n?z\nは\nc\nにならなければいけないことを推論しなければなりません。こ\nの処理はパターンコンポーネント間の等式の集合を解くこととして考えること\nができます。一般的には、これらは連立方程式であり、これを解くためには大\n量の操作が必要となるでしょう。\n69\n例えば、\n(?x ?x)\nと\n((a ?y c) (a b ?z))\nのユニフィケーションは以下の連立方程式を指定することだと考えられるでし\nょう。\n?\nx\n=  (\na\n?\ny\nc\n)\n?\nx\n=  (\na\nb\n?\nz\n)\nこれらの方程式は以下を暗示します。\n(\na\n?\ny\nc\n)  =  (\na\nb\n?\nz\n)\nこれは順に次を暗示します。\na\n=\na,\n?\ny\n=\nb,\nc\n=  ?\nz,\n69\n一方向のパターンマッチングでは、全てのパターン変数を含む等式は明白で未知数\n(\nパターン変数\n)\nについて既に解かれています。\n492","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":518},{"id":"./test/fixtures/pdf/sicp.pdf:519","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"従って以下の通りです。\n?\nx\n=  (\na\nb\nc\n)\nパターンマッチが成功する場合、全てのパターン変数は束縛され、それらに束\n縛される値は定数のみを持ちます。これはまたここまで見てきた全てのユニフ\nィケーションの例に対しても真です。しかし一般的に、ユニフィケーションが\n成功する場合には変数の値が完全には決定されるとは限りません。いくつかの\n変数は未束縛のままで、他は変数を含む値に束縛されます。\n(?x a)\nと\n((b ?y) ?z)\nのユニフィケーションについて考えます。\n?x = (b\n?y)\nであり\na = ?z\nであると推論できます。しかしそれ以上\n?x\nと\n?y\nについて解\nくことはできません。このユニフィケーションは失敗はしません。確かに\n2\nつ\nのパターンを\n?x\nと\n?y\nに値を割り当てることで等しくすることは可能なためで\nす。この適合が\n?y\nの取り得る値を全く限定しないため、結果フレームに\n?y\nの\n束縛は全く入りません。しかしこの適合は\n?x\nの値は限定します。\n?y\nがどのよ\nうな値を取っても、\n?x\nは必ず\n(b ?y)\nになります。従って\n?x\nの\n(b ?y)\nへの束\n縛はフレームへ入れられます。もし\n?y\nの値が\n(\nパターンマッチ、またはこのフ\nレームに一致する必要のあるユニフィケーションにより\n)\n後に決定されフレー\nムに追加されたなら、その前に束縛された\n?x\nはこの値を参照することになりま\nす。\n70\nルールの適用\nユニフィケーションはルールから推論を行わせるクエリシステムのコンポ\nーネントに対する鍵です。これがどのように達成されるかについて学ぶために\nは、ルールの適用を含むクエリの処理について考えてみましょう。例えば、以\n下について考えます。\n(\nlives-near\n?\nx\n(\nHacker\nAlyssa\nP\n))\nこのクエリを処理するためには、最初に通常の上で説明されたパターンマッチ\n手続を用いてこのパターンに適合するアサーションがデータベース内に存在す\nるかどうかを見ます。\n(\nこの場合には存在しません。私達のデータベースには誰\n70\nユニフィケーションについて考えるもう\n1\nつの方法は、二つの入力パターンの特殊化\nである最も一般的なパターンを生成するということです。言い換えれば、\n(?x a)\nと\n((b\n?y) ?z)\nのユニフィケーションは\n((b ?y) a)\nであり、上で議論した\n(?x a ?y)\nと\n(?y\n?z a)\nのユニフィケーションは\n(a a a)\nです。私達の実装に対しては、ユニフィケーシ\nョンの結果をパターンではなく、フレームとして考えたほうがより便利です。\n493","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":519},{"id":"./test/fixtures/pdf/sicp.pdf:520","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"が誰の近くに住んでいるかについての直接のアサーションが全く含まれていな\nいためです\n)\n。次のステップはクエリパターンと各ルールの結果とのユニフィ\nケーションを試みることです。このパターンは以下のルールの結果とユニフィ\nケーションすると、\n(\nrule\n(\nlives-near\n?\nperson-1\n?\nperson-2\n)\n(\nand\n(\naddress\n?\nperson-1\n(?\ntown\n. ?\nrest-1\n))\n(\naddress\n?\nperson-2\n(?\ntown\n. ?\nrest-2\n))\n(\nnot\n(\nsame\n?\nperson-1\n?\nperson-2\n))))\n結果としてフレームに\n?person-2\nが\n(Hacker Alyssa P)\nに束縛され、\n?x\nが\n(\n同\nじ値として\n)\n?person-1\nに束縛されなければならないことの指定が入ることを\n発見します。これで、このフレームに関連して、このルールのボディにより与え\nられた複合クエリを評価します。適合が成功すればこのフレームは\n?person-1\nに対する束縛を与えることで拡張され、その結果として\n?x\nの値も決定し、元々\nのクエリパターンをインスタンス化するのに利用することができます。\n一般的に、クエリ評価機は以下の手法を用いて、パターン変数に対する束\n縛を指定するフレーム内のクエリパターンを定めようとする時に、ルールを適\n用します。\n•\nクエリをルールの結論とユニフィケーションすることで\n(\n成功すれば\n)\n元\nのフレームの拡張を形成する\n•\n拡張されたフレームを参照しながら、ルールのボディにより形成された\nクエリを評価する\nこれがどれほど\nLisp\nの\neval\n/\napply\n評価機内での手続適用のための手法に似て\nいるかについて注意して下さい。\n•\n手続のパラメタをその引数に束縛することで元々の手続環境を拡張する\nフレームを形成する\n•\n拡張された環境を参照しながら、手続のボディにより形成された式を評\n価する\n2\nつの評価機の間の類似度は驚くべきことではありません手続定義が\nLisp\nにお\nける抽象化の手段であるように、ルール定義はクエリ言語の抽象化の手段です。\nそれぞれの場合において、適切な束縛を作成し、ルール、または手続のボディ\nをこれらの束縛を参照することで抽象化を巻き戻します。\n494","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":520},{"id":"./test/fixtures/pdf/sicp.pdf:521","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"単純なクエリ\n私達はこの節の始めにルールを欠いた単純なクエリをどのように評価する\nかについて学びました。今ではルールの適用の仕方も学んだため、単純なクエ\nリをルールとアサーションの両方を用いてどのように評価するかについても説\n明することができます。\nクエリパターンとフレームのストリームを与えられた時、入力ストリーム\n内の各フレームに対して\n2\nつのストリームを生成します。\n•\n(\nパターンマッチャを用いて\n)\nデータベース内の全てのアサーションに\n対してパターンの適合を行うことにより得られた拡張フレームのスト\nリーム\n•\n(\nユニファイアを用いて\n)\n全ての可能なルールを適用することにより得ら\nれた拡張フレームのストリーム\n71\nこれらの\n2\nつのストリームをアペンドすることにより、与えられたパターンを\n元のフレームに一致して満たすことができる全ての方法により成り立つストリ\nームを生成します。これらのストリーム\n(\n入力ストリームの各フレームに対し\nて\n1\nつ\n)\nはこれで全てが\n1\nつの巨大なストリームに接続されます。従ってこの\n巨大ストリームは元の入力ストリーム内の任意のフレームを与えられたパター\nンへの適合を生成するために拡張した全ての方法から成り立っています。\nクエリ評価機とドライバループ\n潜在的なマッチング操作の複雑さに係らず、システムは任意の言語のた\nめの評価機とそっくりに体系化されます。マッチング操作を統合する手続は\nqeval\nと呼ばれ、\nLisp\nの\neval\n手続の役割と同様な役割を演じます。\nqeval\nは\n入力としてクエリとフレームのストリームを取ります。その出力はフレーム\nのストリームであり、クエリパターンへの成功したマッチングに相応します。\nこれは\nFigure 4.4\nで示されるよう入力ストリームのいくつかを拡張しています。\neval\nと同様に、\nqeval\nは異なる型の式\n(\nクエリ\n)\nを分類し、それぞれに対する適\n切な手続を呼び出します。各特別形式\n(\nand\n,\nor\n,\nnot\n,\nlisp-value\n)\nに手続が存\n在し、また単純なクエリにも手続が存在します。\n71\nユニフィケーションはマッチングの一般化であるため、ユニファイアを用いて両方の\nストリームを生成することによりシステムを簡略化することができました。しかし、簡\n単な場合を単純なマッチャで取り扱うことはマッチング\n(\n適合\n)\nがどのように\n(\n本格的な\nユニフィケーションとは逆に\n)\nそれ自身の正しさにおいて便利であることを説明します。\n495","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":521},{"id":"./test/fixtures/pdf/sicp.pdf:522","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この章の他の評価機のための\ndriver-loop\n手続と同様のドライバループが\n端末からクエリを読み出します。各クエリに対して、ドライバループは\nqeval\nをそのクエリと\n1\nつの空フレームと共に呼び出します。これにより全ての可能\nな適合\n(\n全ての可能な空フレームに対する拡張\n)\nのストリームが生成されます。\n結果としてのストリームの各フレームに対して、ドライバループは元のクエリ\nをフレーム内で見つかった変数の値を用いてインスタンス化します。次にこの\nインスタンス化されたクエリのストリームは表示されます。\n72\nドライバはまた特別なコマンド\nassert!\nをチェックします。これは入力が\nクエリではなくデータベースに追加するアサーション、またはルールでること\nを示します。例えば、\n(\nassert!\n(\njob\n(\nBitdiddle\nBen\n)\n(\ncomputer\nwizard\n)))\n(\nassert!\n(\nrule\n(\nwheel\n?\nperson\n)\n(\nand\n(\nsupervisor\n?\nmiddle-manager\n?\nperson\n)\n(\nsupervisor\n?\nx\n?\nmiddle-manager\n))))\n4.4.3\n論理プログラミングは記号論理学なのか\n?\nクエリ言語内で使用される組み合わせの手段は最初は記号論理学の\nand\n,\nor\n,\nnot\n命令と同じに見えるかもしれません。実際にクエリ言語のルールの適\n用は、推論という、まともな手段を通して達成されます。\n73\nしかし、このクエ\nリ言語の記号論理学を用いた同定は実際には有効ではありません。クエリ言語\nが論理的な命題を手続的に解釈する\ncontrol structure\n(\n制御構造\n)\nを提供するた\nめです。私達は頻繁にこの制御構造を活用することができます。例えばプログ\nラマの監督者全てを見るけるためには以下の\n2\nつの論理的に等価な形式のどち\nらかをクエリとして策定することができます。\n72\n私達がフレームの\n(\nリストではなく\n)\nストリームを使う理由は、ルールの再帰的適用\nはクエリを満たす無限の数の値を生成することができるからです。ストリームに組込ま\nれた遅延化された評価がここでは重要です。システムは応答を\n1\nつづつそれらが生成さ\nれた順に、有限か無限の数の応答があるかに係らずに表示します。\n73\n推論の特定の手段がまともであるということは自明な主張ではありません。もし真\nとなる前提で開始したのであれば、真となる結論のみが導き出されることを証明しなけ\nればなりません。ルール適用で表現された推論の手法は\nmodus ponens\n(\n肯定式\n)\nという親\nしみある推論の手法であり、もし\n퐴\nが真でありかつ\nA implies B\n(A\nならば\nB)\nが真であ\nるならば、\n퐵\nは真であると結論づけることができます。\n496","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":522},{"id":"./test/fixtures/pdf/sicp.pdf:523","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nand\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n)) (\nsupervisor\n?\nx\n?\ny\n))\nまたは\n(\nand\n(\nsupervisor\n?\nx\n?\ny\n) (\njob\n?\nx\n(\ncomputer\nprogrammer\n)))\nもし会社に\n(\n通常の場合として\n)\nプログラマより多くの監督者が存在するので\nあれば、\n2\nつ目よりも最初の形式を用いたほうが良いです。なぜならデータベ\nースは\nand\nの最初の節により生成された中間結果\n(\nフレーム\n)\n全てに対して探\n索されねばならないためです。\n論理プログラミングの目的はプログラマに演算問題を\n2\nつの分離された問\n題、\n“\n何\n”\nが求めらるべきかと\n“\nどのように\n”\nこれが求められるべきかに分解す\nる技術を与えることです。これは記号論理学の命題の部分集合を選択すること\nで達成されます。これは人が演算したい対象全てを記述するのに十分に強く、\nけれども制御可能な手続的解釈を行うに十分に弱い物です。一方で、ここでの\n意図は論理プログラミング言語で指示されたプログラムは計算機により実行さ\nれ得る実効的なプログラムでなければなりません。制御\n(“\nどのように\n”\n演算す\nるか\n)\nは言語の評価順の使用に影響を受けます。私達は節の順と各節の中の下\n位目標の順とを操作し、演算が実効的、かつ効率的であると考えれられる順で\n行われるようにせねばなりません。\n私達のクエリ言語は単なるそのような手続的に解釈可能な記号論理学の部\n分集合であると見做すことができます。アサーションは単純な事実\n(\nアトミッ\nクな命題\n)\nを表現します。ルールはルールのボディが持つ複数の場合に対する、\nルールの結論が持つ推測の結果を表現します。ルールは自然な手続的解釈を持\nちます。ルールの結論を成立させるためには、ルールのボディを定めます。従\nって、ルールは演算を提示しています。しかし、ルールはまた記号論理学の命\n題であるとも見做すことができるため、同じ結果が全体的に記号論理学の中で\n働くことにより得られることを主張することで、論理プログラムにより遂行さ\nれた任意の\n“\n推論\n”\nを正当化することができます。\n74\n74\n私達はこの命題を以下に同意することで制限しなければなりません。\n“\n推論\n”\nが論理\nプログラムにより正当化されるに言及するにおいて、私達は演算が停止することを前提\nとしています。残念なことに、例えこの制限された命題もクエリ言語の私達の実装にお\nいては正しくありません。\n(\nそして同時に\nProlog\nのプログラムにとっても、そして他の\nほとんどの現在の論理プログラミング言語においてもこれは正しくありません\n)\n。原因は\n私達の\nnot\nと\nlisp-value\nの使用のためです。この先で議論するように、クエリ言語で実\n装された\nnot\nは常に記号論理学の\nnot\nと一致しません。そして\nlisp-value\nは複雑さを\n増します。私達は単純に\nnot\nと\nlisp-value\nを言語から削除し、プログラムを単純なク\nエリ\n,\nand\n,\nor\nのみを用いて書くことに同意することで、記号論理学と一致する言語を実\n497","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":523},{"id":"./test/fixtures/pdf/sicp.pdf:524","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"無限ループ\n論理プログラムの手続的な解釈の結果は絶望的に非効率なプログラムを一\n部の問題に対して構築することが有り得ることです。極端に非効率な場合には\nシステムは演繹を行う無限ループに落ち込んでしまいます。簡単な例として、\n縁組のデータベースを構築したと考えてみましょう。以下を含みます。\n(\nassert!\n(\nmarried\nMinnie\nMickey\n))\nここで以下を尋ねた場合、\n(\nmarried\nMickey\n?\nwho\n)\n応答は有りません。なぜならシステムはもし\n퐴\nが\n퐵\nに結婚した場合、\n퐵\nが\n퐴\nに結婚することになることを知らないためです。そのため以下のルールを宣言\nします。\n(\nassert!\n(\nrule\n(\nmarried\n?\nx\n?\ny\n) (\nmarried\n?\ny\n?\nx\n)))\nそして再び質問します。\n(\nmarried\nMickey\n?\nwho\n)\n残念ながら、これはシステムを無限ループに追いやります。以下のとおりです。\n•\nシステムは\nmarried\nルールが適用可能であることを見つけます。言い\n換えれば、ルールの結論\n(married ?x ?y)\nは成功裏にクエリパターン\n(married Mickey ?who)\nと単一化し、\n?x\nが\nMickey\nに、\n?y\nが\n?who\nに束\n縛されるフレームを生成します。\n•\n1\nつの答は直接データベース内のアサーションとして現れます\n:\n(married\nMinnie Mickey)\n•\nmarried\nルールもまた適用可能です。そのためインタプリタは再度ルー\nルのボディを評価し、今回は\n(married Mickey ?who)\nに等しくなります。\nこれでシステムは無限ループの中です。実際に、システムが簡単な答、\n(married\nMinnie Mickey)\nをループに入る前に見つけるかどうかは、システムがデータ\nベース内のアイテムをチェックする順に関連する実装上の詳細に依存します。\nこれは起こり得るループのとても単純な種類の例です。相互に関連するルール\n装することができます。しかし、これは言語の表現力を大きく制限してしまいます。論\n理プログラミングにおける主要な研究課題の\n1\nつは過度に表現力を犠牲にすることなく、\n記号論理学とより一致する方法を見つけることです。\n498","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":524},{"id":"./test/fixtures/pdf/sicp.pdf:525","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"の蓄積は予想することがより難しいループへと導きます。そしてループの出現\nは\nand\n内の節の順\n(\nExercise 4.64\n参照\n)\nか、またはシステムがクエリを処理する\n順に関連する低レベルの詳細に依存します。\n75\nnot\nの問題\nもう\n1\nつのクエリシステムの予測できない出来事は\nnot\nに関連します。\nSection 4.4.1\nのデータベースを受け取った時、以下の\n2\nつのクエリについて考\nえてみます。\n(\nand\n(\nsupervisor\n?\nx\n?\ny\n)\n(\nnot\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))))\n(\nand\n(\nnot\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n)))\n(\nsupervisor\n?\nx\n?\ny\n))\nこれらの\n2\nつのクエリは同じ結果を生成しません。最初のクエリはデータベー\nス中の\n(supervisor ?x ?y)\nに適合する全てのエントリを見つけ、次に結果の\nフレームから\n?x\nの値が\n(job ?x (computer programmer))\nを満たす物を削除\nします。\n2\nつ目のクエリは入力フレームから\n(job ?x (computer programmer))\nを満たす物を消すフィルタから開始します。入力フレームだけでは空であるた\nめ、データベースから\n(job ?x (computer programmer))\nを満たするパターン\nが存在するか確認します。通常はこの形式のエントリが存在するので、\nnot\n節\nは空のフレームを取り除き、空のフレームのストリームを返します。結果とし\nて、複合クエリ全体が空ストリームを返します。\n問題は\nnot\nの私達の実装は本当に変数の値上のフィルタとしての役目を果\nたすことを意図しています。もし\nnot\n節がいくつかの束縛されていない変数を\n持つフレームと処理された場合\n(\n上記の例における\n?x\nが行うように\n)\n、システム\n75\nこれは論理の問題ではなく、私達のインタプリタにより提供される手続的な解釈の\n問題です。ここでループに陥らないインタプリタを書くこともできました。例えばアサ\nーションとルールから導きだせる全ての証明を深さ優先探索でなく、幅優先探索で列挙\nすることもできました。しかし、そのようなシステムは私達のプログラムの中における\n推論の順序を活用することがより難しくなります。そのようなプログラムの中に洗練さ\nれた制御を構築する試みが\ndeKleer et al. 1977\nに説明されています。そのような深刻な制\n御上の問題に導かない別のテクニックとして、特定の種類のループの検知器のような特\n別な知識を組込むことがあります\n(\nExercise 4.67\n)\n。しかし、推論の実行において無限の\n小道を下ることから確実にシステムを防ぐ一般的な理論体系は有りません。\n“\n푃 (푥)\nが真\nであることを示すためには、\n푃 (푓(푥))\nが真であることを示せ\n”\nという様式の悪魔のルール\nをいくつかの適切に選択された関数\n푓\nに対して想像してみて下さい。\n499","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":525},{"id":"./test/fixtures/pdf/sicp.pdf:526","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"は予想外の結果を生成します。同様の問題が\nlisp-value\nの使用でも起こりま\nす。\nLisp\nの述語はその引数のいくつかが未束縛な場合働くことができません。\nExercise 4.77\nを参照して下さい。\nクエリ言語の\nnot\nが記号論理学の\nnot\nと異なるずっと深刻な部分がありま\nす。論理学では命題\n“not\n푃\n”\nを\n푃\nは真ではないことを意味すると解釈します。\nしかし、クエリシステムでは\n“not\n푃\n”\nは\n푃\nがデータベース内の知識から推論\n不可能であることを意味しています。例えば、\nSection 4.4.1\nの社員情報データ\nベースを与えられた場合、システムは幸いにも全ての種類の\nnot\n命令を推論す\nることができるでしょう。例えば\nBen Bitdiddle\nは野球のファンではない、外\nで雨は振っていない、\n2 + 2\nは\n4\nではないなどです。\n76\nExercise 4.64:\nLouis Reasoner\nは誤って\noutranked-by\nルール\n(\nSec-\ntion 4.4.1\n)\nをデータベースから削除してしまった。彼はこのこと\nに気付いた時、直ぐに再インストールした。残念なことに、彼はル\nールにわずかな変更を行い、以下のように入力した。\n(\nrule\n(\noutranked-by\n?\nstaff-person\n?\nboss\n)\n(\nor\n(\nsupervisor\n?\nstaff-person\n?\nboss\n)\n(\nand\n(\noutranked-by\n?\nmiddle-manager\n?\nboss\n)\n(\nsupervisor\n?\nstaff-person\n?\nmiddle-manager\n))))\nLouis\nがこの情報をシステムに入力して直ぐに、\nDeWitt Aull\nがや\nってきて\nBen Bitdiddle\nの上司は誰かを調べようとした。彼は以下\nのクエリを入力した。\n(\noutranked-by\n(\nBitdiddle\nBen\n) ?\nwho\n)\n回答を行った後、システムは無限ループへと陥った。何故である\nか、説明せよ。\nExercise 4.65:\n組織内での昇進の日を待ち望んでいる\nCy D. Fect\nは全ての重役を探すクエリを入力してみた\n(\nSection 4.4.1\nのルール\nwheel\nを用いた\n)\n。\n76\nクエリ\n(not (baseball-fan (Bitdiddle Ben)))\nについて考えてみましょう。シス\nテムはデータベースに\n(baseball-fan (Bitdiddle Ben))\nが無いことを知り、そのため\n空フレームはパターンを満たさず初期値のフレームのストリームから取り除かれません。\nクエリの結果は従って空フレームであり、これが入力クエリのインスタンス化に用いら\nれ、\n(not (baseball-fan (Bitdiddle Ben)))\nが生成されます。\n500","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":526},{"id":"./test/fixtures/pdf/sicp.pdf:527","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nwheel\n?\nwho\n)\n驚いたことにシステムは以下の内容を応答した。\n;;; Query results:\n(\nwheel\n(\nWarbucks\nOliver\n))\n(\nwheel\n(\nBitdiddle\nBen\n))\n(\nwheel\n(\nWarbucks\nOliver\n))\n(\nwheel\n(\nWarbucks\nOliver\n))\n(\nwheel\n(\nWarbucks\nOliver\n))\n何故、\nOliver Warbucks\nは\n4\n度表示されたのか\n?\nExercise 4.66:\nBen\nはクエリシステムを一般化し会社に関する統計\nを提供する。例えば、全てのコンピュータプログラマの給料の合\n計を求めるためには、以下のように入力することができるだろう。\n(\nsum\n?\namount\n(\nand\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n))\n(\nsalary\n?\nx\n?\namount\n)))\n全般に、\nBen\nの新しいシステムは以下の形式の式を可能にする。\n(\naccumulation-function\n⟨\nvariable\n⟩\n⟨\nquery pattern\n⟩\n)\nここで\naccumulation-function\nは\nsum\n,\naverage\n,\nまたは\nmaximum\nのような物である。\nBen\nはこれを実装するのは簡単なはずだと考\nえた。単純にクエリパターンを\nqeval\nに追加するだろう。これは\nフレームのストリームを生成するだろう。すると彼はこのストリ\nームを\nmap\n関数を通すことでストリーム内の各フレームから指定\nした変数の値を抽出し、結果の値のストリームを\naccumulation(\n集\n積\n)\n関数へと与えるだろう。\nBen\nが実装を完成し、丁度試験を行お\nうとした時に\nCy\nが依然として\nExercise 4.65\nの\nwheel\nクエリの結\n果に悩みながら歩いてきた。\nCy\nが\nBen\nにシステムの応答を見せた\n時、\nBen\nはうなってから\n“\nなんてこった。私の簡単な集積の仕組み\nは動かない\n!”\nと述べた。\nBen\nは何に気付いたのか\n?\nこの状況を救い出すため用いられる手\n段の要点を述べよ。\nExercise 4.67:\nクエリシステムにループ検知器をインストールし、\nテキストと\nExercise 4.64\nで説明されたような単純なループを防ぐ\n501","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":527},{"id":"./test/fixtures/pdf/sicp.pdf:528","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ための手段を工夫せよ。一般的なアイデアは、システムに現在の\n推論の連鎖のある種の履歴を管理させ、既に取り組んでいるクエ\nリの処理を始めないようにすることである。どのような種類の情\n報\n(\nパターンとフレーム\n)\nがこの履歴に含まれるか、そしてどのよ\nうに検査が行われるべきかについて説明せよ。\n(\nSection 4.4.4\nにお\nけるクエリシステムの実装の詳細を学んだ後に、あなたはシステ\nムを変更してループ検知器を入れたいと思うだろう\n)\n。\nExercise 4.68:\nExercise 2.18\nの\nreverse\n命令を実装するルールを定\n義せよ。これは与えられたリストの逆順で同じ要素を含むリスト\nを返す。\n(\nヒント：\nappend-to-form\nを使用せよ\n)\n。あなたのルール\nは\n(reverse (1 2 3) ?x)\nと\n(reverse ?x (1 2 3))\nの両方に回\n答することができるだろうか\n?\nExercise 4.69:\nExercise 4.63\nで策定したデータベースとルールか\nら始めて、孫の関係に\n“great”\nを追加するためのルールを工夫せ\nよ。これはシステムに対し\nIrad\nが\nAdam\nの\ngreat-grandson(\nひ孫\n)\nであること、また\nJabal\nと\nJubal\nが\ngreat-great-great-great-great-\ngrandsons(\nひひひひひ孫\n)\nであることを推論することを可能にしな\nければならない。\n(\nヒント：例えば\nIrad\nに関する事実を\n((great\ngrandson) Adam Irad)\nとして表現する。リストの終端が単語\ngrandson\nであるかを決定するルールを書け。これを用いて\n?rel\nが\ngrandson\nで終わるリストである場合に、関係\n((great . ?rel) ?x\n?y)\nを導き出すことが可能なルールを表現せよ\n)\n。あなたのルール\nを\n((great grandson) ?g ?ggs)\nと\n(?relationship Adam Irad)\nのようなクエリを用いて確認せよ。\n4.4.4\nクエリシステムの実装\nSection 4.4.2\nはどのようにクエリシステムが働くかについて説明した。ここ\nでは完全なシステムの実装を公開することにより詳細を知らせる。\n4.4.4.1\nドライバループとインスタンス化\nクエリシステムのためのドライバループは繰り返し入力式を読み込みます。\nもし式が追加されるべきルールかアサーションであるのならばその情報が追加\nされます。そうでなければ式はクエリであると見做されます。ドライバはこの\n502","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":528},{"id":"./test/fixtures/pdf/sicp.pdf:529","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"クエリを評価機\nqeval\nに単一の空のフレームから成る初期フレームストリーム\nと共に渡されます。評価の結果はクエリをデータベース内で見つかった変数の\n値で満たすことにより生成されたフレームのストリームです。これらのフレー\nムは、フレームのストリームにより提供された値を用いて変数がインスタンス\n化された元のクエリのコピーから成る新しいストリームを形成するのに用いら\nれます。そしてこの最終的なストリームが端末に表示されます。\n(\ndefine\ninput-prompt\n\"\n;;;\nQuery\ninput\n:\n\"\n)\n(\ndefine\noutput-prompt\n\"\n;;;\nQuery\nresults\n:\n\"\n)\n(\ndefine\n(\nquery-driver-loop\n)\n(\nprompt-for-input\ninput-prompt\n)\n(\nlet\n((\nq\n(\nquery-syntax-process\n(\nread\n))))\n(\ncond\n((\nassertion-to-be-added?\nq\n)\n(\nadd-rule-or-assertion!\n(\nadd-assertion-body\nq\n))\n(\nnewline\n)\n(\ndisplay\n\"\nAssertion\nadded\nto\ndata\nbase\n.\n\"\n)\n(\nquery-driver-loop\n))\n(\nelse\n(\nnewline\n)\n(\ndisplay\noutput-prompt\n)\n(\ndisplay-stream\n(\nstream-map\n(\nlambda\n(\nframe\n)\n(\ninstantiate\nq\nframe\n(\nlambda\n(\nv\nf\n)\n(\ncontract-question-mark\nv\n))))\n(\nqeval\nq\n(\nsingleton-stream\n'\n()))))\n(\nquery-driver-loop\n)))))\nここで、この章の他の評価機と同様に、クエリ言語の式に対して抽象構文を\n用います。式の構文の実装は述語\nassertion-to-be-added?\nとセレクタ\nadd-\nassertion-body\nを含めて、\nSection 4.4.4.7\nにて与えられます。\nadd-rule-or-\nassertion!\nは\nSection 4.4.4.5\nで定義されます。\n503","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":529},{"id":"./test/fixtures/pdf/sicp.pdf:530","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"入力式のどんな処理を行う前にも、ドライバループは処理をより効率的に\nする形式へと構文的に変換します。これはパターン変数の表現の変更を含みま\nす。クエリが初期化される時、未束縛である任意の変数は表示される前に入力\n時の表現に戻されます。これらの変換は\n2\nつの手続、\nquery-syntax-process\nと\ncontract-question-mark\nにより実行されます\n(\nSection 4.4.4.7\n)\n。\n式をインスタンス化するためにはまずコピーを行い、式中の全ての変数を\n与えられたフレーム内のそれらの値にて置き換えます。値はそれら自身がイン\nスタンス化されます。それらが変数を含む可能性があるためです\n(\n例えば、式\nの中の\n?x\nがユニフィケーションの結果として\n?y\nに束縛され、\n?y\nが同様に\n5\nに\n束縛されている場合\n)\n。変数がインスタンス化できない場合に取るべき行動は\n手続\ninstantiate\nの引数に渡されます。\n(\ndefine\n(\ninstantiate\nexp\nframe\nunbound-var-handler\n)\n(\ndefine\n(\ncopy\nexp\n)\n(\ncond\n((\nvar?\nexp\n)\n(\nlet\n((\nbinding\n(\nbinding-in-frame\nexp\nframe\n)))\n(\nif\nbinding\n(\ncopy\n(\nbinding-value\nbinding\n))\n(\nunbound-var-handler\nexp\nframe\n))))\n((\npair?\nexp\n)\n(\ncons\n(\ncopy\n(\ncar\nexp\n)) (\ncopy\n(\ncdr\nexp\n))))\n(\nelse\nexp\n)))\n(\ncopy\nexp\n))\n束縛を操作する手続は\nSection 4.4.4.8\nで定義されます。\n4.4.4.2\n評価機\nquery-driver-loop\nにより呼ばれる\nqeval\n手続はクエリシステムの基本的\nな評価機です。入力としてクエリとフレームのストリームを取り、拡張された\nフレームのストリームを返します。\nChapter 2\nで総称的な命令を実装したのと同\n様に、\nget\nと\nput\nを用いたデータ適従による呼出により特別形式を判別します。\n特別形式とは判別されない任意のクエリは単純なクエリと見做され\nsimple-\nquery\nにより処理されます。\n(\ndefine\n(\nqeval\nquery\nframe-stream\n)\n(\nlet\n((\nqproc\n(\nget\n(\ntype\nquery\n)\n'qeval\n)))\n(\nif\nqproc\n504","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":530},{"id":"./test/fixtures/pdf/sicp.pdf:531","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nqproc\n(\ncontents\nquery\n)\nframe-stream\n)\n(\nsimple-query\nquery\nframe-stream\n))))\ntype\nと\ncontents\nは\nSection 4.4.4.7\nで定義され、特別形式の抽象構文を実装し\nます。\n単純なクエリ\nsimple-query\n手続は単純なクエリを扱います。引数として単純なクエリ\n(\nパターン\n)\nをフレームのストリームと共に取り、クエリのデータベースへの適\n合全てにより各フレームを拡張することにより形成されたストリームを返し\nます。\n(\ndefine\n(\nsimple-query\nquery-pattern\nframe-stream\n)\n(\nstream-flatmap\n(\nlambda\n(\nframe\n)\n(\nstream-append-delayed\n(\nfind-assertions\nquery-pattern\nframe\n)\n(\ndelay\n(\napply-rules\nquery-pattern\nframe\n))))\nframe-stream\n))\n入力ストリーム中の各フレームに対し、\nfind-assertions\n(\nSection 4.4.4.3\n)\nを\n用いてデータベース内の全てのアサーションに対してパターンを適合し、拡張\nフレームのストリームを生成します。そして\napply-rules\n(\nSection 4.4.4.4\n)\nを\n用いて全ての可能なルールを適用し、拡張フレームのもう\n1\nつのストリーム\nを生成します。これらの\n2\nつのストリームは\n(\nstream-append-delayed\n(\nSection\n4.4.4.6\n)\nを用いて\n)\n接続され、与えられたパターンが元のフレームに一致して満\nたされることが可能な全ての手段でストリームを作ります\n(\nExercise 4.71\n参照\n)\n。\n個別の入力フレームに対するストリームは\nstream-flatmap\n(\nSection 4.4.4.6\n)\nを用いて接続され、元の入力ストリーム内の任意のフレームが与えられたパタ\nーンを用いて適合を生成するために拡張されることができる全ての手段によ\nり、\n1\nつの巨大なストリームが形成されます。\n複合クエリ\nand\nクエリは\nFigure 4.5\nにて説明されているように\nconjoin\n手続により扱わ\nれます。\nconjoin\nは入力として結合\n(conjuncts)\nとフレームのストリームを取\nり、拡張されたフレームのストリームを返します。最初に\nconjoin\nはフレーム\n505","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":531},{"id":"./test/fixtures/pdf/sicp.pdf:532","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"のストリームを処理し、結合内の最初のクエリを満たす全ての可能なフレーム\nの拡張のストリームを探します。次に、これを新しいフレームのストリームと\nして用いて、再帰的にクエリの残りに対して\nconjoin\nを適用します。\n(\ndefine\n(\nconjoin\nconjuncts\nframe-stream\n)\n(\nif\n(\nempty-conjunction?\nconjuncts\n)\nframe-stream\n(\nconjoin\n(\nrest-conjuncts\nconjuncts\n)\n(\nqeval\n(\nfirst-conjunct\nconjuncts\n)\nframe-stream\n))))\n以下の式は\n(\nput\n'and\n'qeval\nconjoin\n)\nqeval\nに対し、\nand\nの型に遭遇した場合に\nconjoin\nを呼び出すように設定し\nます。\nor\nクエリも同様に、\nFigure 4.6\nに示されるように扱われます。\nor\nの多様な選\n言肢に対する出力ストリームは別々に求められ、\nSection 4.4.4.6\nの\ninterleave-\ndelayed\n手続を用いて結合されます。\n(\nExercise 4.71\nと\nExercise 4.72\nを参照\n)\n(\ndefine\n(\ndisjoin\ndisjuncts\nframe-stream\n)\n(\nif\n(\nempty-disjunction?\ndisjuncts\n)\nthe-empty-stream\n(\ninterleave-delayed\n(\nqeval\n(\nfirst-disjunct\ndisjuncts\n)\nframe-stream\n)\n(\ndelay\n(\ndisjoin\n(\nrest-disjuncts\ndisjuncts\n)\nframe-stream\n)))))\n(\nput\n'or\n'qeval\ndisjoin\n)\n論理積\n(conjuncts)\nと論理和\n(disjuncts)\nの構文のための述語とセレクタは\nSection\n4.4.4.7\nで提供されます。\nフィルタ\nnot\nは\nSection 4.4.2\nにて概説された手法により扱われます。入力ストリーム\n内の各フレームを否定されたクエリを満たすように拡張することを試みます。\nそして拡張できない場合にのみ出力ストリームに与えられたフレームを含め\nます。\n506","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":532},{"id":"./test/fixtures/pdf/sicp.pdf:533","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nnegate\noperands\nframe-stream\n)\n(\nstream-flatmap\n(\nlambda\n(\nframe\n)\n(\nif\n(\nstream-null?\n(\nqeval\n(\nnegated-query\noperands\n)\n(\nsingleton-stream\nframe\n)))\n(\nsingleton-stream\nframe\n)\nthe-empty-stream\n))\nframe-stream\n))\n(\nput\n'not\n'qeval\nnegate\n)\nlisp-value\nは\nnot\nに似たフィルタです。ストリーム内の各フレームはパター\nン内の変数をインスタンス化するために用いられ、指定された述語が適用され、\n述語が偽を返したフレームは入力ストリームから取り除かれます。未束縛なパ\nターン変数が存在する場合には結果はエラーとなります。\n(\ndefine\n(\nlisp-value\ncall\nframe-stream\n)\n(\nstream-flatmap\n(\nlambda\n(\nframe\n)\n(\nif\n(\nexecute\n(\ninstantiate\ncall\nframe\n(\nlambda\n(\nv\nf\n)\n(\nerror\n\"\nUnknown\npat\nvar\n:\nLISP-VALUE\n\"\nv\n))))\n(\nsingleton-stream\nframe\n)\nthe-empty-stream\n))\nframe-stream\n))\n(\nput\n'lisp-value\n'qeval\nlisp-value\n)\nexecute\nは述語を引数に適用しますが、述語式を評価し適用する手続を得なけ\nればなりません。しかし引数は評価してはいけません。なぜならそれらは既に\n実際の引数であり、その\n(Lisp\nにおける\n)\n評価が引数を生成する式ではないた\nめです。\nexecute\nが基礎を成す\nLisp\nシステムの\neval\nと\napply\nを使用して実装\nされていることに注意して下さい。\n(\ndefine\n(\nexecute\nexp\n)\n507","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":533},{"id":"./test/fixtures/pdf/sicp.pdf:534","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\napply\n(\neval\n(\npredicate\nexp\n)\nuser-initial-environment\n)\n(\nargs\nexp\n)))\n特別形式\nalways-true\nはクエリに対し常に満たされた状態を与えます。これは\nその中身\n(\n通常は空\n)\nを無視し、単純に入力ストリームの全てのフレームを通\nします。\nalways-true\nは\nrule-body\nセレクタ\n(\nSection 4.4.4.7\n)\nにより利用され、\nボディ成しで定義されたルールに対しボディを提供します。\n(\n言い換えれば、そ\nの結果部分が常に満たされます。\n)\n(\ndefine\n(\nalways-true\nignore\nframe-stream\n)\nframe-stream\n)\n(\nput\n'always-true\n'qeval\nalways-true\n)\nnot\nと\nlisp-value\nの構文を定義するセレクタは\nSection 4.4.4.7\nで提供されます。\n4.4.4.3\nパターンマッチングによりアサーションを見つける\nfind-assertions\nは\nsimple-query\n(\nSection 4.4.4.2\n)\nにより呼ばれ、入力と\nしてパターンとフレームを取ります。フレームのストリームを返し、各フレー\nムは与えられた物を与えらえたパターンへのデータベースの適合により拡張さ\nれています。\nfetch-assertions\n(\nSection 4.4.4.5\n)\nを用いてデータベース内の全\nてのアサーションのストリームを得ます。これはパターンとフレームに対して\n適合するか確認されなければなりません。ここで\nfetch-assertions\nする理由\nは、私達は良く簡単なテストをここで適用するためです。このテストは適合を\n成功する候補のプールからデータベース内のエントリを数多く削減することが\nできます。システムは例え\nfetch-assertions\nを削除して単純にデータベース\n内の全てのアサーションのストリームを確認するだけでも動くでしょう。しか\nし演算は効率的ではなくなります。より多くのマッチャに対する呼出を行わね\nばならなくなるためです。\n(\ndefine\n(\nfind-assertions\npattern\nframe\n)\n(\nstream-flatmap\n(\nlambda\n(\ndatum\n)\n(\ncheck-an-assertion\ndatum\npattern\nframe\n))\n(\nfetch-assertions\npattern\nframe\n)))\ncheck-an-assertion\nは引数としてパターン、データオブジェクト\n(\nアサーショ\nン\n)\n、フレームを取り、拡張されたフレームを含む\n1\n要素のストリームか、適合\nを失敗した場合に\nthe-empty-stream\nを返します。\n508","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":534},{"id":"./test/fixtures/pdf/sicp.pdf:535","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ncheck-an-assertion\nassertion\nquery-pat\nquery-frame\n)\n(\nlet\n((\nmatch-result\n(\npattern-match\nquery-pat\nassertion\nquery-frame\n)))\n(\nif\n(\neq?\nmatch-result\n'failed\n)\nthe-empty-stream\n(\nsingleton-stream\nmatch-result\n))))\n基本的なパターンマッチャはシンボル\nfailed\nか、与えられたフレームの拡張\nを返します。マッチャの基本的な考えはパターンをデータに対して要素毎に確\n認し、パターン変数に対する束縛を集積します。もしパターンとデータオブジ\nェクトが同じであるなら、適合は成功しそこまで集積された束縛のフレームを\n返します。そうでなければ、もしパターンが変数ならば、変数をデータに対し\nて束縛することで現在のフレームを拡張することをフレーム内に既に存在する\n束縛に一致するまで行います。もしパターンとデータの両方がペアであるなら、\n(\n再帰的に\n)\nパターンの\ncar\nをデータの\ncar\nに対して適合を行いフレームを生\n成します。次にこのフレームの中でパターンの\ncdr\nをデータのに対して適合を\n行います。もしこれらの場合全てが当て嵌らない場合、適合は失敗し、シンボ\nル\nfailed\nを返します。\n(\ndefine\n(\npattern-match\npat\ndat\nframe\n)\n(\ncond\n((\neq?\nframe\n'failed\n)\n'failed\n)\n((\nequal?\npat\ndat\n)\nframe\n)\n((\nvar?\npat\n) (\nextend-if-consistent\npat\ndat\nframe\n))\n((\nand\n(\npair?\npat\n) (\npair?\ndat\n))\n(\npattern-match\n(\ncdr\npat\n)\n(\ncdr\ndat\n)\n(\npattern-match\n(\ncar\npat\n) (\ncar\ndat\n)\nframe\n)))\n(\nelse\n'failed\n)))\n次が、フレーム内に既に存在している束縛に一致するなら、新しい束縛を追加\nすることによりフレームを拡張する手続です。\n(\ndefine\n(\nextend-if-consistent\nvar\ndat\nframe\n)\n(\nlet\n((\nbinding\n(\nbinding-in-frame\nvar\nframe\n)))\n(\nif\nbinding\n(\npattern-match\n509","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":535},{"id":"./test/fixtures/pdf/sicp.pdf:536","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbinding-value\nbinding\n)\ndat\nframe\n)\n(\nextend\nvar\ndat\nframe\n))))\nもしフレーム内の変数に対する束縛が無い場合、単純に変数のデータに対する\n束縛を追加します。そうでなければこのフレーム内で、データをフレーム内の\n変数の値に対して適合を行います。もし格納されていた値が定数のみを持つな\nらば、つまり\nextend-if-consistent\nによりパターンマッチングの間に格納さ\nれたのであれば、適合は単純に格納されていた値と新しい値が同じであるかど\nうかを確認します。もしそうならば、フレームを変更せずに返します。そうで\nないならば、失敗を示す印を返します。しかし格納されたいた値は、それがユ\nニフィケーションの間に格納されたのであればパターン変数を含む場合があり\nます\n(\nSection 4.4.4.4\n参照\n)\n。格納されたパターンの新しいデータに対する再帰\n的な適合はこのパターン内の変数に対する束縛の追加、または確認を行います。\n例えば、\n?x\nが\n(f ?y)\nに束縛され\n?y\nが未束縛であるフレームを持っているとし\nましょう。そしてこのフレームを\n?x\nの\n(f b)\nへの束縛で拡大させたいとしま\nす。私達は\n?x\nを探し、それが\n(f ?y)\nに束縛されているのを見つけます。この\nことがこの同じフレームの中で提案された新しい値\n(f b)\nに対して\n(f ?y)\nを\n適合させることへと導きます。最終的に、この適合は\n?y\nから\nb\nへの束縛を追加\nすることによりこのフレームを拡張します。\n?x\nは\n(f ?y)\nへの束縛を維持しま\nす。格納されていた束縛を変更することはありません。また与えられた変数に\n対して複数の束縛を格納することもありません。\nextend-if-consistent\nにより使用される束縛を操作するための複数の手\n続は\nSection 4.4.4.8\nで定義されます。\n末尾ドット付きパターン\nパターンがドットとそれに続くパターン変数を含む場合、そのパターン変\n数はデータリストの\n(\n次の要素ではなく\n)\n残りに適合します。誰かが予想する\nように\nExercise 2.20\nにて説明されたドット付き末尾記述と同様です。私達が実\n装したばかりのパターンマッチャはドットを探しませんが、私達が望むとおり\nに振舞います。これは\nquery-driver-loop\nで用いられる\nLisp\nの\nread\nプリミ\nティブがクエリを読み込みリスト構造として表現する時にドットを特別な方法\nで扱うためです。\nread\nがドットを見た時、次の項目をリストの次の要素にするのではなく\n(\ncons\nの\ncar\nのこと、\ncdr\nはリストの残り\n)\n、リスト構造の\ncdr\nを次の項目にし\nます。例えば、パターン\n(computer ?type)\nに対する\nread\nにより生成される\nリスト構造は式\n(cons 'computer (cons '?type '()))\nを評価することによ\n510","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":536},{"id":"./test/fixtures/pdf/sicp.pdf:537","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"り構築されます。またパターン\n(computer . ?type)\nに対する場合は式\n(cons\n'computer '?type)\nを評価することにより構築されます。\n従って\npattern-match\nが再帰的にデータリストとドットを持つパターン\nの\ncar\nと\ncdr\nを比較するにつれ、最終的にはドットの後ろの変数\n(\nパターンの\ncdr\n)\nがデータリストの部分リストに対して適合され、そのリストに対してその\n変数が束縛されます。例えば、パターン\n(computer . ?type)\nを\n(programmer\ntrainee)\nに適合することは\n?type\nをリスト\n(programmer trainee)\nに適合さ\nせます。\n4.4.4.4\nルールとユニフィケーション\napply-rules\nは\nfind-assertions\nの類似のルールです\n(\nSection 4.4.4.3\n)\n。入\n力としてパターンとフレームを取り、データベースからルールを適用すること\nにより拡張フレームのストリームを形成します。\nstream-flatmap\nは\napply-a-\nrule\nを\n(\nfetch-rules\nにより選択された\n(\nSection 4.4.4.5\n))\n恐らく適用可能な\nルールのストリームに対し\nmap\nし、結果のフレームのストリーム群を結合し\nます。\n(\ndefine\n(\napply-rules\npattern\nframe\n)\n(\nstream-flatmap\n(\nlambda\n(\nrule\n)\n(\napply-a-rule\nrule\npattern\nframe\n))\n(\nfetch-rules\npattern\nframe\n)))\napply-a-rule\nは\nSection 4.4.2\nで概説された手法を用いてルールを適用します。\n最初にルールの結論を与えられたフレーム内のパターンとユニフィケーション\nを行うことで引数フレームを増大させます。これが成功したならこの新しいフ\nレーム内でルールのボディを評価します。\nしかしこの全てが起こる前に、プログラムはルール内の全ての変数を個別\nの新しい名前に変更します。この理由は異なるルールの適用に対する変数が御\n互いに混同されることを防ぐためです。例えば、もし\n2\nつのルールの両方が\n?x\nと名付けられた変数を用いる場合、それぞれが適用された時に\n?x\nに対する束縛\nをフレームに追加するかもしれません。これら\n2\nつの\n?x\nは御互いに関係があり\nません。そして私達は\n2\nつの束縛が一致するはずだと考えるように惑わされて\nはいけません。変数名を変えるのでなく、より賢い環境構造を工夫することも\nできるでしょう。しかし、私達がここで選択した改名による取り組み方は最も\n効率的ではないとしても、最も簡単です\n(\nExercise 4.79\n参照\n)\n。以下が\napply-a-\nrule\n手続です。\n511","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":537},{"id":"./test/fixtures/pdf/sicp.pdf:538","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\napply-a-rule\nrule\nquery-pattern\nquery-frame\n)\n(\nlet\n((\nclean-rule\n(\nrename-variables-in\nrule\n)))\n(\nlet\n((\nunify-result\n(\nunify-match\nquery-pattern\n(\nconclusion\nclean-rule\n)\nquery-frame\n)))\n(\nif\n(\neq?\nunify-result\n'failed\n)\nthe-empty-stream\n(\nqeval\n(\nrule-body\nclean-rule\n)\n(\nsingleton-stream\nunify-result\n))))))\nセレクタ\nrule-body\nと\nconclusion\nはルールの部分を抜き出します。これ\nは\nSection 4.4.4.7\nで定義されます。\n私達はユニークな\n(unique\n、独自の\n)\n識別子\n(\n例えば番号\n)\nを各ルールの適用\nに関連付けし、この識別子を元の変数名に接続することで、ユニークな変数名\nを生成します。例えば、もしルール適用識別子が\n7\nなら、ルール内の各\n?x\nを\n?x-\n7\nに、各\n?y\nを\n?y-7\nに変更するでしょう。\n(\nmake-new-variable\nと\nnew-rule-\napplication-id\nは\nSection 4.4.4.7\nの構文手続に含まれます。\n)\n(\ndefine\n(\nrename-variables-in\nrule\n)\n(\nlet\n((\nrule-application-id\n(\nnew-rule-application-id\n)))\n(\ndefine\n(\ntree-walk\nexp\n)\n(\ncond\n((\nvar?\nexp\n)\n(\nmake-new-variable\nexp\nrule-application-id\n))\n((\npair?\nexp\n)\n(\ncons\n(\ntree-walk\n(\ncar\nexp\n))\n(\ntree-walk\n(\ncdr\nexp\n))))\n(\nelse\nexp\n)))\n(\ntree-walk\nrule\n)))\nユニフィケーションアルゴリズムは手続として実装され、入力として\n2\nつのパ\nターンとフレームを取り、拡張されたフレームかシンボル\nfailed\nを返します。\nユニファイアはパターンマッチャに似ていますが、対照的であることが異なり\nます\n—\nつまり、変数が適合の両サイドに存在することが許されます。\nunify-\nmatch\nは基本的には\npattern-match\nと同じですが、\n(\n以下で\n“\n***\n”\nのマークを\n付けた\n)\n拡張コードの存在が異なります。これは適合の右側のオブジェクトが\n変数である場合を扱います。\n512","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":538},{"id":"./test/fixtures/pdf/sicp.pdf:539","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nunify-match\np1\np2\nframe\n)\n(\ncond\n((\neq?\nframe\n'failed\n)\n'failed\n)\n((\nequal?\np1\np2\n)\nframe\n)\n((\nvar?\np1\n) (\nextend-if-possible\np1\np2\nframe\n))\n((\nvar?\np2\n) (\nextend-if-possible\np2\np1\nframe\n))\n; ***\n((\nand\n(\npair?\np1\n) (\npair?\np2\n))\n(\nunify-match\n(\ncdr\np1\n)\n(\ncdr\np2\n)\n(\nunify-match\n(\ncar\np1\n)\n(\ncar\np2\n)\nframe\n)))\n(\nelse\n'failed\n)))\nユニフィケーションにおいては一方向マッチングのように、既存の束縛に一\n致する場合のみ提案されたフレームの拡張を受け入れたいです。手続\nextend-\nif-possible\nはユニフィケーションにおいて使用され、パターンマッチにて利\n用される\nextend-if-consistent\nと同じですが、下記のプログラムで\n“\n***\n”\nが\nマークされている、\n2\nつの特別なチェックが異なります。最初のケースでは、も\nし適合を試す変数が未束縛であり、かつそれに対して適合させようとしている\n値それ自体が\n(\n異なる\n)\n変数である場合に、その値が束縛されているかを確認す\nる必要があります。そしてもしそうであれば、その値を適合する必要がありま\nす。もし適合の両側が共に未束縛である場合、それぞれを御互いに束縛します。\n2\nつ目のチェックは変数を、変数を含むパターンに対して束縛する試みを\n取り扱います。そのような状況は変数が両方のパターン内で繰り返される場合\nに常に起こり得ます。例えば\n2\nつのパターン、\n(?x ?x)\nと\n(?y <\n?y\nを含む式\n>)\nを、\n?x\nと\n?y\nの両方が未束縛である場合のフレーム内にてユニフィケーション\nを行う場合について考えてみて下さい。最初の\n?x\nは\n?y\nに対して適合し、\n?x\nか\nら\n?y\nへの束縛を作成します。次に同じ\n?x\nが与えられた\n?y\nを含む式に対して適\n合されます。\n?x\nは既に\n?y\nに対して束縛されているため、これは結果として\n?y\nをその式に対して適合することになります。もし私達がユニファイアを\n2\nつの\nパターンを同じにするパターン変数に対する値の集合を見つけるものとして考\nえているなら、これらのパターンは\n?y\nが\n?y\nを含む式に等しいような\n?y\nを見付\nける命令を暗示します。そのような方程式を解く一般的な手法は存在しません\nので、私達はそのような束縛を却下します。このような場合が述語\ndepends-\non?\nにより認識されます。\n77\n77\n一般的に、\n?y\nを\n?y\nを含む式にユニフィケーションを行う場合には、方程式\n?y\n=\n<\nexpression involving\n?y\n>\nの不動点を見つけられなければなりません。偶に解が存在す\n513","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":539},{"id":"./test/fixtures/pdf/sicp.pdf:540","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"一方で、変数をそれ自体へ束縛する試みを拒否したくはありません。例と\nして、\n(?x ?x)\nと\n(?y ?y)\nのユニフィケーションについて考えてみましょう。\n二度目の\n?x\nを\n?y\nへ束縛する試行は\n?y\n(\n?x\nの新しい値\n)\nに対する\n?y\n(\n?x\nに格納さ\nれた値\n)\nに適合します。これは\nunify-match\nの\nequal?\n節により担当されます。\n(\ndefine\n(\nextend-if-possible\nvar\nval\nframe\n)\n(\nlet\n((\nbinding\n(\nbinding-in-frame\nvar\nframe\n)))\n(\ncond\n(\nbinding\n(\nunify-match\n(\nbinding-value\nbinding\n)\nval\nframe\n))\n((\nvar?\nval\n)\n; ***\n(\nlet\n((\nbinding\n(\nbinding-in-frame\nval\nframe\n)))\n(\nif\nbinding\n(\nunify-match\nvar\n(\nbinding-value\nbinding\n)\nframe\n)\n(\nextend\nvar\nval\nframe\n))))\nる式を構文的に形成することが可能です。例えば、\n?y\n=\n(f ?y)\nは不動点\n(f (f (f\n...\n)))\nを持つように見えます。これは式\n(f ?y)\nで始め、繰り返し\n?y\nを\n(f ?y)\nで置き換え\nることで生成できます。残念ながら全てのそのような方程式が意味のある不動点を持つ\nわけではありません。ここで浮かび上がる問題は数学で無限級数を扱う場合の問題と似\nています。例えば、私達は\n2\nが方程式\n푦 = 1 + 푦/2\nの解であることを知っています。式\n1 + 푦/2\nで始めて、繰り返し\n푦\nを\n1 + 푦/2\nで置き換えていくと以下の様になります。\n2 = 푦 = 1 +\n푦\n2\n= 1 +\n1\n2\n(1 +\n푦\n2\n) = 1 +\n1\n2\n+\n푦\n4\n= ... ,\nこれは以下の式へと導きます。\n2 = 1 +\n1\n2\n+\n1\n4\n+\n1\n8\n+ ... .\nしかし、もし同じ操作を式\n푦 = 1 + 2푦\nの解が\n-1\nであるという結果から始めると、\n−1 = 푦 = 1 + 2푦 = 1 + 2(1 + 2푦) = 1 + 2 + 4푦 = ... ,\nこれは以下の式へと導きます。\n−1 = 1 + 2 + 4 + 8 + ... .\nこれらの\n2\nつの等式を導き出した形式的な操作は同一であるにも係らず、最初の結果は\n無限級数に関して有効な正しい主張となりますが、\n2\nつ目はそうではありません。同様\nに、私達のユニフィケーションの結果に対して無計画に構文に従い構築された式はエラ\nーへと繋るでしょう。\n514","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":540},{"id":"./test/fixtures/pdf/sicp.pdf:541","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"((\ndepends-on?\nval\nvar\nframe\n)\n; ***\n'failed\n)\n(\nelse\n(\nextend\nvar\nval\nframe\n)))))\ndepends-on?\nはパターン変数の値であると提案された式がその変数に依存する\nかを確認します。これは現在のフレームと比較して行われなければなりません。\n式がテスト変数に依存する値を既に持つ変数の存在を含むかもしれないためで\nす。\ndepends-on?\nの構造は簡単な再帰木の探索であり、この中で必要な場合い\nつでも変数の値を置き換えます。\n(\ndefine\n(\ndepends-on?\nexp\nvar\nframe\n)\n(\ndefine\n(\ntree-walk\ne\n)\n(\ncond\n((\nvar?\ne\n)\n(\nif\n(\nequal?\nvar\ne\n)\ntrue\n(\nlet\n((\nb\n(\nbinding-in-frame\ne\nframe\n)))\n(\nif\nb\n(\ntree-walk\n(\nbinding-value\nb\n))\nfalse\n))))\n((\npair?\ne\n)\n(\nor\n(\ntree-walk\n(\ncar\ne\n))\n(\ntree-walk\n(\ncdr\ne\n))))\n(\nelse\nfalse\n)))\n(\ntree-walk\nexp\n))\n4.4.4.5\nデータベースの保守\n論理プログラミング言語の設計における重要な問題の\n1\nつは、与えられた\nパターンの確認においてできる限り少ないデータベースのエントリが検査され\nるように物事を準備することです。私達のシステムでは、全てのアサーション\nを\n1\nつの大きなストリームに格納することに加えて、\ncar\nが静的なシンボルで\nある全てのアサーションをそのシンボルで索引付けられたテーブル内の分離さ\nれたストリームに格納します。パターンに適合するかもしれないアサーション\nを取り出すためには、最初にパターンの\ncar\nが静的なシンボルであるかを確認\nします。もしそうならば、\n(\nマッチャを用いて確認するため\n)\n同じ\ncar\nを持つ全\nての格納されたアサーションを返します。もしパターンの\ncar\nが静的なシンボ\nルでない場合には、格納されたアサーションを全て返します。より賢い方法で\n515","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":541},{"id":"./test/fixtures/pdf/sicp.pdf:542","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"はフレーム内の情報も活用するか、パターンの\ncar\nが静的なシンボルでない場\n合にも最適化を行うことに挑むことができるでしょう。私達は検索作成の基準\n(\ncar\nを用いる、静的シンボルの場合のみを扱う\n)\nをこのプログラムの中に構築\nすることを避けました。その代わりに私達の基準を具現する述語とセレクタを\n呼び出します。\n(\ndefine\nTHE-ASSERTIONS\nthe-empty-stream\n)\n(\ndefine\n(\nfetch-assertions\npattern\nframe\n)\n(\nif\n(\nuse-index?\npattern\n)\n(\nget-indexed-assertions\npattern\n)\n(\nget-all-assertions\n)))\n(\ndefine\n(\nget-all-assertions\n)\nTHE-ASSERTIONS\n)\n(\ndefine\n(\nget-indexed-assertions\npattern\n)\n(\nget-stream\n(\nindex-key-of\npattern\n)\n'assertion-stream\n))\nget-stream\nはテーブル内のストリームを探し、そこに何にも格納されていな\nい場合には空ストリームを返します。\n(\ndefine\n(\nget-stream\nkey1\nkey2\n)\n(\nlet\n((\ns\n(\nget\nkey1\nkey2\n)))\n(\nif\ns\ns\nthe-empty-stream\n)))\nルールも同様にルールの結論の\ncar\nを用いて格納されます。しかしルールの結\n論は任意のパターンであるため、変数を含められることがアサーションとは異\nなります。\ncar\nが静的なシンボルであるパターンは結論が変数で始まるルール\nと、結論が同じ\ncar\nを持つルールにも適合できます。従って、\ncar\nが静的なシ\nンボルであるパターンに適合するかもしれないルールを取り出す場合、結論が\n変数で始まる全てのルールと、結論がそのパターンと同じ\ncar\nを持つルールを\n取り出します。この目的のために、結論が変数で始まる全てのルールをテーブ\nル内の分離されたストリームに、シンボル\n?\nで索引付けして格納します。\n(\ndefine\nTHE-RULES\nthe-empty-stream\n)\n(\ndefine\n(\nfetch-rules\npattern\nframe\n)\n(\nif\n(\nuse-index?\npattern\n)\n(\nget-indexed-rules\npattern\n)\n(\nget-all-rules\n)))\n(\ndefine\n(\nget-all-rules\n)\nTHE-RULES\n)\n(\ndefine\n(\nget-indexed-rules\npattern\n)\n(\nstream-append\n516","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":542},{"id":"./test/fixtures/pdf/sicp.pdf:543","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nget-stream\n(\nindex-key-of\npattern\n)\n'rule-stream\n)\n(\nget-stream\n'?\n'rule-stream\n)))\nadd-rule-or-assertion!\nは\nquery-driver-loop\nにより使用されアサーション\nとルールとデータベースに追加します。各アイテムは適切であればインデック\nスに格納され、データベース内の全てのアサーション、またはルールのストリ\nームに格納されます。\n(\ndefine\n(\nadd-rule-or-assertion!\nassertion\n)\n(\nif\n(\nrule?\nassertion\n)\n(\nadd-rule!\nassertion\n)\n(\nadd-assertion!\nassertion\n)))\n(\ndefine\n(\nadd-assertion!\nassertion\n)\n(\nstore-assertion-in-index\nassertion\n)\n(\nlet\n((\nold-assertions\nTHE-ASSERTIONS\n))\n(\nset!\nTHE-ASSERTIONS\n(\ncons-stream\nassertion\nold-assertions\n))\n'ok\n))\n(\ndefine\n(\nadd-rule!\nrule\n)\n(\nstore-rule-in-index\nrule\n)\n(\nlet\n((\nold-rules\nTHE-RULES\n))\n(\nset!\nTHE-RULES\n(\ncons-stream\nrule\nold-rules\n))\n'ok\n))\n実際にアサーション、またはルールを格納するためには、索引を付けられるか\nを確認します。もしそうであれば、適切なストリームに格納します。\n(\ndefine\n(\nstore-assertion-in-index\nassertion\n)\n(\nif\n(\nindexable?\nassertion\n)\n(\nlet\n((\nkey\n(\nindex-key-of\nassertion\n)))\n(\nlet\n((\ncurrent-assertion-stream\n(\nget-stream\nkey\n'assertion-stream\n)))\n(\nput\nkey\n'assertion-stream\n(\ncons-stream\nassertion\ncurrent-assertion-stream\n))))))\n(\ndefine\n(\nstore-rule-in-index\nrule\n)\n517","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":543},{"id":"./test/fixtures/pdf/sicp.pdf:544","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\npattern\n(\nconclusion\nrule\n)))\n(\nif\n(\nindexable?\npattern\n)\n(\nlet\n((\nkey\n(\nindex-key-of\npattern\n)))\n(\nlet\n((\ncurrent-rule-stream\n(\nget-stream\nkey\n'rule-stream\n)))\n(\nput\nkey\n'rule-stream\n(\ncons-stream\nrule\ncurrent-rule-stream\n)))))))\n以下の手続はデータベースのインデックス\n(\n索引\n)\nがどのように使用されかに\nついて定義します。パターン\n(\nアサーション、またはルールの結論\n)\nが変数、ま\nたは静的なシンボルで始まる場合にテーブルに格納されます。\n(\ndefine\n(\nindexable?\npat\n)\n(\nor\n(\nconstant-symbol?\n(\ncar\npat\n))\n(\nvar?\n(\ncar\npat\n))))\nパターンがその下に格納されるテーブル内のキーは\n(\n変数で始まる場合には\n)\n?\n、\nまたはパターンの始めの静的なシンボルです。\n(\ndefine\n(\nindex-key-of\npat\n)\n(\nlet\n((\nkey\n(\ncar\npat\n)))\n(\nif\n(\nvar?\nkey\n)\n'?\nkey\n)))\nインデックスはパターンが静的なシンボルで始まる場合、パターンにマッチす\nるかもしれないアイテムを取得するために利用されます。\n(\ndefine\n(\nuse-index?\npat\n) (\nconstant-symbol?\n(\ncar\npat\n)))\nExercise 4.70:\n手続\nadd-assertion!\nと\nadd-rule!\n内の\nlet\nの束\n縛の目的は何か\n?\n以下の\nadd-assertion!\nの実装の誤りは何か\n?\nヒ\nント：\nSection 3.5.2\nにおける\n1\nの無限ストリームの定義を思い出\nせ：\n(define ones (cons-stream 1 ones))\n(\ndefine\n(\nadd-assertion!\nassertion\n)\n(\nstore-assertion-in-index\nassertion\n)\n(\nset!\nTHE-ASSERTIONS\n(\ncons-stream\nassertion\nTHE-ASSERTIONS\n))\n'ok\n)\n518","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":544},{"id":"./test/fixtures/pdf/sicp.pdf:545","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4.4.4.6\nストリーム命令\nクエリシステムは\nChapter 3\nには存在しなかったいくつかのストリーム命令\nを用います。\nstream-append-delayed\nと\ninterleave-delayed\nは\nstream-append\nと\ninterleave\n(\nSection 3.5.3\n)\nと同じですが、それらが\n(\nSection 3.5.4\nの\nintegral\nの様に\n)\n遅延化された引数を取ることが異なります。これはいくつかの場合に\nおいてループを先送りします。\n(\nExercise 4.71\n参照\n)\n(\ndefine\n(\nstream-append-delayed\ns1\ndelayed-s2\n)\n(\nif\n(\nstream-null?\ns1\n)\n(\nforce\ndelayed-s2\n)\n(\ncons-stream\n(\nstream-car\ns1\n)\n(\nstream-append-delayed\n(\nstream-cdr\ns1\n)\ndelayed-s2\n))))\n(\ndefine\n(\ninterleave-delayed\ns1\ndelayed-s2\n)\n(\nif\n(\nstream-null?\ns1\n)\n(\nforce\ndelayed-s2\n)\n(\ncons-stream\n(\nstream-car\ns1\n)\n(\ninterleave-delayed\n(\nforce\ndelayed-s2\n)\n(\ndelay\n(\nstream-cdr\ns1\n))))))\nstream-flatmap\nはクエリ評価機を通して使用され手続をフレームのストリー\nム上に対して\nmap\nし、結果としての複数のフレームのストリームを接続し\nます。\nstream-flatmap\nは\nSection 2.2.3\nにて通常のリストのために導入された\nflatmap\n手続のストリーム向け類似品です。しかし通常の\nflatmap\nと異なり、\n単純にストリームを\nappend\nしていくのではなく、相互配置処理により蓄積し\nます。\n(\nExercise 4.72\nと\nExercise 4.73\n参照\n)\n(\ndefine\n(\nstream-flatmap\nproc\ns\n)\n(\nflatten-stream\n(\nstream-map\nproc\ns\n)))\n(\ndefine\n(\nflatten-stream\nstream\n)\n(\nif\n(\nstream-null?\nstream\n)\n519","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":545},{"id":"./test/fixtures/pdf/sicp.pdf:546","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"the-empty-stream\n(\ninterleave-delayed\n(\nstream-car\nstream\n)\n(\ndelay\n(\nflatten-stream\n(\nstream-cdr\nstream\n))))))\n評価機はまた以下の単純な手続を用いて単一要素から成るストリームを生成し\nます。\n(\ndefine\n(\nsingleton-stream\nx\n)\n(\ncons-stream\nx\nthe-empty-stream\n))\n4.4.4.7\nクエリ構文手続\nqeval\n(\nSection 4.4.4.2\n)\nにより用いられる\ntype\nと\ncontents\nは、特別形式\nがその\ncar\nに存在するシンボルにより判別されることを指示します。これら\nは\nSection 2.4.2\nの\ntype-tag\nと\ncontents\n手続と同じですが、エラーメッセージ\nが異なります。\n(\ndefine\n(\ntype\nexp\n)\n(\nif\n(\npair?\nexp\n)\n(\ncar\nexp\n)\n(\nerror\n\"\nUnknown\nexpression\nTYPE\n\"\nexp\n)))\n(\ndefine\n(\ncontents\nexp\n)\n(\nif\n(\npair?\nexp\n)\n(\ncdr\nexp\n)\n(\nerror\n\"\nUnknown\nexpression\nCONTENTS\n\"\nexp\n)))\n以下の手続は\nSection 4.4.4.1\nの\nquery-driver-loop\nにて使用されます。これは\nルールとアサーションがデータベースに\n(assert! <\nrule-or-assertion\n>)\nの\n形式の式により追加されることを指示します。\n(\ndefine\n(\nassertion-to-be-added?\nexp\n)\n(\neq?\n(\ntype\nexp\n)\n'assert!\n))\n(\ndefine\n(\nadd-assertion-body\nexp\n) (\ncar\n(\ncontents\nexp\n)))\n以下は特別形式\nand\n,\nor\n,\nnot\n,\nlisp-value\nのための構文定義です。\n(\nSection\n4.4.4.2\n)\n(\ndefine\n(\nempty-conjunction?\nexps\n) (\nnull?\nexps\n))\n(\ndefine\n(\nfirst-conjunct\nexps\n) (\ncar\nexps\n))\n520","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":546},{"id":"./test/fixtures/pdf/sicp.pdf:547","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nrest-conjuncts\nexps\n) (\ncdr\nexps\n))\n(\ndefine\n(\nempty-disjunction?\nexps\n) (\nnull?\nexps\n))\n(\ndefine\n(\nfirst-disjunct\nexps\n) (\ncar\nexps\n))\n(\ndefine\n(\nrest-disjuncts\nexps\n) (\ncdr\nexps\n))\n(\ndefine\n(\nnegated-query\nexps\n) (\ncar\nexps\n))\n(\ndefine\n(\npredicate\nexps\n) (\ncar\nexps\n))\n(\ndefine\n(\nargs\nexps\n) (\ncdr\nexps\n))\n以下の\n3\nつの手続はルールの構文を定義します。\n(\ndefine\n(\nrule?\nstatement\n)\n(\ntagged-list?\nstatement\n'rule\n))\n(\ndefine\n(\nconclusion\nrule\n) (\ncadr\nrule\n))\n(\ndefine\n(\nrule-body\nrule\n)\n(\nif\n(\nnull?\n(\ncddr\nrule\n))\n'\n(\nalways-true\n) (\ncaddr\nrule\n)))\nquery-driver-loop\n(\nSection 4.4.4.1\n)\nは\nquery-syntax-process\nを呼び、\n?symbol\nの形態を持つ式のパターン変数を内部形式\n(? symbol)\nに変形します。これは\n言ってみれば、\n(job ?x ?y)\nのようなパターンが実際には内部的にシステムに\nより\n(job (? x) (? y))\nと表現されているということです。これによりクエ\nリ処理の効率が良くなります。システムが式がパターン変数であるかを確認す\nるのにシンボルから文字を抽出する必要が無しに、式の\ncar\nがシンボル\n?\nであ\nるかどうかを確認することにより確認できることを意味するためです。構文変\n形は以下の手続により達成されます。\n78\n(\ndefine\n(\nquery-syntax-process\nexp\n)\n(\nmap-over-symbols\nexpand-question-mark\nexp\n))\n(\ndefine\n(\nmap-over-symbols\nproc\nexp\n)\n(\ncond\n((\npair?\nexp\n)\n(\ncons\n(\nmap-over-symbols\nproc\n(\ncar\nexp\n))\n(\nmap-over-symbols\nproc\n(\ncdr\nexp\n))))\n78\n多くの\nLisp\nシステムは通常の\nread\n手続を\nreader macro characters\n(\nリーダマクロキ\nャラクタ\n)\nを定義することにより変更し、そのような変形を実行させる能力をユーザにに\n与えています。クォートされた式は既にこのような取り扱われています。リーダーは評\n価機が式を見る前に自動的に\n'expression\nを\n(quote expression)\nに変形します。私達\nは同様に\n?expression\nが\n(? expression)\nに変形されるように準備することも可能でし\nた。しかし、明快さのために、私達はここに明示的に変形手続を含めました。\nexpand-question-mark\nと\ncontract-question-mark\nは名前に\nstring\nを持ついくつ\nかの手続を使用します。これらは\nScheme\nのプリミティブです。\n521","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":547},{"id":"./test/fixtures/pdf/sicp.pdf:548","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"((\nsymbol?\nexp\n) (\nproc\nexp\n))\n(\nelse\nexp\n)))\n(\ndefine\n(\nexpand-question-mark\nsymbol\n)\n(\nlet\n((\nchars\n(\nsymbol->string\nsymbol\n)))\n(\nif\n(\nstring=?\n(\nsubstring\nchars\n0 1)\n\"\n?\n\"\n)\n(\nlist\n'?\n(\nstring->symbol\n(\nsubstring\nchars\n1 (\nstring-length\nchars\n))))\nsymbol\n)))\n一旦、変数がこのように変形されれば、パターン内の変数は\n?\nで始まるリストで\nあり、静的なシンボル\n(\nデータベースの索引付けのために必要、\nSection 4.4.4.5\n)\nはただのシンボルです。\n(\ndefine\n(\nvar?\nexp\n) (\ntagged-list?\nexp\n'?\n))\n(\ndefine\n(\nconstant-symbol?\nexp\n) (\nsymbol?\nexp\n))\n他とは異なる変数がルールの適用の間に以下の手続を用いて構築されます\n(\nSection 4.4.4.4\n)\n。ルール適用のための独自識別子は数値であり、ルールが適用\nされる度にインクリメントされます。\n(\ndefine\nrule-counter\n0)\n(\ndefine\n(\nnew-rule-application-id\n)\n(\nset!\nrule-counter\n(+ 1\nrule-counter\n))\nrule-counter\n)\n(\ndefine\n(\nmake-new-variable\nvar\nrule-application-id\n)\n(\ncons\n'?\n(\ncons\nrule-application-id\n(\ncdr\nvar\n))))\nquery-driver-loop\nが回答を表示するためにクエリをインスタンス化する時、\n全ての未束縛のパターン変数を表示に適した形式に以下を用いて戻します。\n(\ndefine\n(\ncontract-question-mark\nvariable\n)\n(\nstring->symbol\n(\nstring-append\n\"\n?\n\"\n(\nif\n(\nnumber?\n(\ncadr\nvariable\n))\n(\nstring-append\n(\nsymbol->string\n(\ncaddr\nvariable\n))\n\"\n-\n\"\n(\nnumber->string\n(\ncadr\nvariable\n)))\n(\nsymbol->string\n(\ncadr\nvariable\n))))))\n522","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":548},{"id":"./test/fixtures/pdf/sicp.pdf:549","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4.4.4.8\nフレームと束縛\nフレームは変数と値のペアである束縛のリストとして表現されます。\n(\ndefine\n(\nmake-binding\nvariable\nvalue\n)\n(\ncons\nvariable\nvalue\n))\n(\ndefine\n(\nbinding-variable\nbinding\n) (\ncar\nbinding\n))\n(\ndefine\n(\nbinding-value\nbinding\n) (\ncdr\nbinding\n))\n(\ndefine\n(\nbinding-in-frame\nvariable\nframe\n)\n(\nassoc\nvariable\nframe\n))\n(\ndefine\n(\nextend\nvariable\nvalue\nframe\n)\n(\ncons\n(\nmake-binding\nvariable\nvalue\n)\nframe\n))\nExercise 4.71:\nLouis Reasoner\nはなぜ\nsimple-query\nと\ndisjoin\nの手続\n(\nSection\n4.4.4.2\n)\nは以下のような定義ではなく、明示的な\ndelay\n命令を用い\nて実装されたのか不思議だった。\n(\ndefine\n(\nsimple-query\nquery-pattern\nframe-stream\n)\n(\nstream-flatmap\n(\nlambda\n(\nframe\n)\n(\nstream-append\n(\nfind-assertions\nquery-pattern\nframe\n)\n(\napply-rules\nquery-pattern\nframe\n)))\nframe-stream\n))\n(\ndefine\n(\ndisjoin\ndisjuncts\nframe-stream\n)\n(\nif\n(\nempty-disjunction?\ndisjuncts\n)\nthe-empty-stream\n(\ninterleave\n(\nqeval\n(\nfirst-disjunct\ndisjuncts\n)\nframe-stream\n)\n(\ndisjoin\n(\nrest-disjuncts\ndisjuncts\n)\nframe-stream\n))))\nあなたはこれらのより簡単な定義を望まない振舞いへと導くクエ\nリの例を与えることができるか\n?\nExercise 4.72:\nなぜ\ndisjoin\nと\nstream-flatmap\nは単純にそれらを\nappend\nせずに相互配置するのか\n?\nなぜ相互配置のほうがより良\n523","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":549},{"id":"./test/fixtures/pdf/sicp.pdf:550","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"く働くのかを説明する例を与えよ。\n(\nヒント：なぜ私達は\nSection\n3.5.3\nにおいて\ninterleave\nを使用したのか\n?)\nExercise 4.73:\nなぜ\nflatten-stream\nは明示的に\ndelay\nを用いるの\nか\n?\n以下のように定義した場合に何が間違っているのか\n?\n(\ndefine\n(\nflatten-stream\nstream\n)\n(\nif\n(\nstream-null?\nstream\n)\nthe-empty-stream\n(\ninterleave\n(\nstream-car\nstream\n)\n(\nflatten-stream\n(\nstream-cdr\nstream\n)))))\nExercise 4.74:\nAlyssa P. Hacker\nはより簡単な版の\nstream-flatmap\nを\nnegate\n,\nlisp-value\n,\nfind-assertions\nの中で使用することを\n提案した。彼女はフレームのストリーム上に\nmap\nされる手続はこ\nれらの場合において常に空ストリームか、単一要素のストリーム\nを生成する。そのためこれらのストリームを接続する場合、相互\n配置する必要が無いと気付いた。\na\nAlyssa\nのプログラムに欠けている式を埋めよ。\n(\ndefine\n(\nsimple-stream-flatmap\nproc\ns\n)\n(\nsimple-flatten\n(\nstream-map\nproc\ns\n)))\n(\ndefine\n(\nsimple-flatten\nstream\n)\n(\nstream-map\n⟨\n??\n⟩\n(\nstream-filter\n⟨\n??\n⟩\nstream\n)))\nb\nクエリシステムの振舞はこのように変更した場合に変化する\nだろうか\n?\nExercise 4.75:\nクエリ言語に対して新しい特別形式\nunique\nを実装\nせよ。\nunique\nは正確にデータベース内の\n1\nつの項目が指定された\nクエリを満たす場合に成功しなければならない。例えば、\n(\nunique\n(\njob\n?\nx\n(\ncomputer\nwizard\n)))\n上の式は\n1\nつの項目のストリームを表示しなければならない。\n(\nunique\n(\njob\n(\nBitdiddle\nBen\n) (\ncomputer\nwizard\n)))\n524","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":550},{"id":"./test/fixtures/pdf/sicp.pdf:551","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Ben\nはただ\n1\n人のコンピュータウィザードであるためである。次に、\n(\nunique\n(\njob\n?\nx\n(\ncomputer\nprogrammer\n)))\n上は空ストリームを表示しなければならない。複数のコンピュー\nタプログラマが存在するためである。さらに、\n(\nand\n(\njob\n?\nx\n?\nj\n) (\nunique\n(\njob\n?\nanyone\n?\nj\n)))\n上はただ\n1\n人により埋められた役職とその人達を全て表示しなけ\nればならない。\nunique\nを実装するには\n2\nつの部分が存在する。\n1\nつ目はこの特\n別形式を扱う手続を書くことであり、\n2\nつ目は\nqeval\nにその手続\nを呼出させることである。\n2\nつ目の部分は自明だ。\nqeval\nはその\n呼出をデータ適従の方法に従うためである。もしあなたの手続が\nuniquely-asserted\nという名前であるなら、やらなければいけな\nいことは以下である。\n(\nput\n'unique\n'qeval\nuniquely-asserted\n)\nこれで\nqeval\nは型\n(\ncar\n)\nがシンボル\nunique\nである全てのクエリに\n対してこの手続を呼び出す。\n真の問題は手続\nuniquely-asserted\nを書くことである。これは入\n力として\nunique\nクエリの\ncontents\n(\ncdr\n)\nをフレームのストリー\nムと共に受け取る。ストリームの各フレームに対し、\nqeval\nを用い\nて与えられたクエリを満たすフレームの全ての拡張のストリーム\nを見つけなければならない。正確に\n1\nつのアイテムのみを持たな\nいストリームは全て取り除かれなければならない。残ったストリ\nームは\nunique\nクエリの結果である\n1\nつの巨大なストリームに蓄積\nするために戻されなければならない。これは特別形式\nnot\nの実装\nに似ている。\nあなたの実装を正確に\n1\n人だけを監督する全ての人々を並べるク\nエリを形成することによりテストせよ。\nExercise 4.76:\n一連のクエリの結合としての\nand\nの実装\n(\nFigure\n4.5\n)\nは洗練されているが非効率だ。\nand\nの\n2\nつ目のクエリの処理\nにおいて最初のクエリにより生成された各フレームに対してデー\nタベースを走査しなければならないためである。もしデータベー\nスが\n푛\n個の要素を持ち、典型的なクエリが\n푛\nに比例した数\n(\n仮に\n525","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":551},{"id":"./test/fixtures/pdf/sicp.pdf:552","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"푛/푘\n個\n)\nの出力フレームを生成する場合、最初のクエリにより生成\nされた各フレームに対するデータベースの走査は\n푛\n2\n/푘\nのパター\nンマッチャの呼出を必要とする。別の取り組み方としては\nand\nの\n2\nつの節を分離して処理し、矛盾のない出力フレームの全てのペア\nを探すことになるだろう。もし各クエリが\n푛/푘\n個の出力フレーム\nを生成するなら、これは\n푛\n2\n/푘\n2\n回の無矛盾テストを実行しなけれ\nばならないことを意味する。\n푘\nの係数が現在の手法で必要な適合\n数よりもより少ない。\nこの戦略を用いる\nand\nの実装を工夫せよ。入力として\n2\nつのフレ\nームを取り、両フレームの中の束縛が無矛盾であることを確認し\nなければならない。もしそうであるなら束縛の\n2\nつの集合をマー\nジするフレームを生成する。この操作はユニフィケーションに似\nている。\nExercise 4.77:\nSection 4.4.3\nにおいて\nnot\nと\nlisp-value\nがクエリ\n言語に対しもしこれらのフィルタリング命令が変数が束縛されて\nいないフレームに適用された場合に\n“\n間違った\n”\n回答を与えること\nがあることを学んだ。この欠陥を直す方法を工夫せよ。\n1\nつの考え\nはフィルタリングを\n“\n遅延\n”\nの様式で実行することだ。フレームに\n“\nプロミス\n”\nを追加することで十分な変数がその操作を可能にする\n場合にのみそれを果たすようにする。フィルタリングの実行は全\nての他の命令が実行を終えるまで待つことができる。しかし、効\n率のために生成される中間フレームの数を削減できるようフィル\nタリングをできるだけ早く実行したい。\nExercise 4.78:\nクエリ言語をストリーム処理ではなく非決定性プ\nログラムとして、\nSection 4.3\nの評価機を用いて実装されるように\n再設計せよ。この取り組み方においては、各クエリは\n(\n全ての回答\nのストリームではなく\n)\n単一の回答を生成し、ユーザは\ntry-again\nを入力することでより多くの回答を見ることができる。この節で\n構築した仕組みの多くは非決定性探索とバックトラックにより組\n込まれていることに気付かなければならない。しかし、新しいク\nエリ言語の振舞にここで実装されたものからわずかな違うことに\nも気付くだろう。この違いを説明する例を見つけることができる\nだろうか\n?\nExercise 4.79:\nSection 4.1\nで\nLisp\n評価機を実装した時に、どのよ\nうにローカル環境を使用して手続のパラメタ間の名前衝突を防ぐ\n526","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":552},{"id":"./test/fixtures/pdf/sicp.pdf:553","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"かについて学んだ。例えば以下を評価する場合において、\n(\ndefine\n(\nsquare\nx\n) (*\nx\nx\n))\n(\ndefine\n(\nsum-of-squares\nx\ny\n)\n(+ (\nsquare\nx\n) (\nsquare\ny\n)))\n(\nsum-of-squares\n3 4)\nsquare\nの\nx\nと\nsum-of-squares\nの\nx\nの間に混乱は無い。なぜなら\n各手続のボディをローカル変数のための束縛を含めるために特別\nに構築した環境の中で評価するからである。クエリシステムでは\nルール適用における名前衝突を避けるために異なる戦略を用いた。\nルールを適用する度に変数名を唯一であることを保証された新し\nい名前に変えている。\nLisp\n評価機に対する同様の戦略はローカル\nな環境を排除し、手続を適用する度に手続のボディの中の変数を\n改名することになるだろう。\nクエリ言語に対して改名でなく、環境を用いるルール適用手法を\n実装せよ。あなたの環境構造上に巨大システムを取り扱うために、\nクエリ言語内にブロック構造化された手続に同等なルールのよう\nな構成概念を作るために構築できるか確かめよ。これの何かを文\n脈中での推論を行う問題に、問題解決の手段として関連付けるこ\nとはできるだろうか\n? (\n例えば\n“\nもし\n푃\nが真であるとするならば、\n퐴\nと\n퐵\nを推論することができる\n”)\n。\n(\nこの問題には明確な回答やルールは存在しない。良い回答は恐ら\nく博士号の価値があるだろう。\n)\n527","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":553},{"id":"./test/fixtures/pdf/sicp.pdf:554","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5\nレジスタマシンによる演算\n私の目的は天の機械は神からの授かり物や生き物ではなく、時計\n仕掛のような物であることを示すことです。\n(\nそして時計が魂を持\nつと信ずる人はその理由をその仕事に対するメーカーの栄光に帰\nするでしょう。\n)\nそれはほとんど全ての多様な運動が最も単純な物\n質の力により引き起こされるとする限りにおいて、時計の全ての\n動作が\n1\nつの錘により引き起こされるのと全く同じように。\n—Johannes Kepler (Herwart von Hohenburg\nへの手紙\n, 1605)\n私達はこの本をプロセスを学ぶことと、プロセスを\nLisp\nで書かれた手続を用い\nて説明することにより始めました。これらの手続の意味を説明するために、い\nくつかの評価モデルを用いました。\nChapter 1\nの置換モデル、\nChapter 3\nの環境\nモデル、\nChapter 4\nのメタ循環評価機です。私達のメタ循環評価機の調査は特に\nLisp\nのような言語がどのように解釈されるのかについての謎の大部分を氷解さ\nせました。しかしメタ循環評価機ですらも重要な疑問を未知の状態に残します。\nLisp\nシステム中の制御の仕組みは明らかにしないためです。例えば、この評価\n機は部分式の評価がこの式の値を用いる式にどのようにその値を返すのかにつ\nいて説明しません。またこの評価機は、ある再帰関数が反復プロセス\n(\nつまり、\n定量的な記憶域で評価されるもの\n)\nを生成するのに対し、一方で他の再帰関数\nが再帰プロセスを生成することもまた説明しません。これらの疑問は未解決の\nままです。なぜならメタ循環評価機はそれ自身が\nLisp\nプログラムであり、それ\n528","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":554},{"id":"./test/fixtures/pdf/sicp.pdf:555","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"故に根底に存在する\nLisp\nシステムの制御構造を引き継ぐためです。より完全\nな\nLisp\n評価機の制御構造の説明を与えるためには、\nLisp\nそれ自身よりもより\nプリミティブなレベルについて取り組まねばなりません。\nこの章ではプロセスを旧来の計算機の個々の操作を用いて説明します。そ\nのような計算機、つまり\nregister machine\n(\nレジスタマシン\n)\nは\nregisters\n(\nレジス\nタ\n)\nと呼ばれる固定長の記憶要素の集合の中身を操作する\ninstructions\n(\n命令\n)\nを\n順に実行します。典型的なレジスタマシンの命令はプリミティブな操作をいく\nつかのレジスタの中身に対して適用し、その結果を他のレジスタに割り当てま\nす。レジスタマシンにより実行されるプロセスの私達の説明は伝統的な計算機\n向けの\n“\n機械語\n”\nにとても良く似ているでしょう。しかし、何らかの特定の計算\n機の機械語に注力する代わりに、私達はいくつかの\nLisp\n手続を調査し、各手続\nを実行するための特定のレジスタマシンを設計します。従って私達はこの目的\nに機械語のコンピュータプログラマではなく、ハードウェアアーキテクトの視\n点から取り組みます。レジスタマシンの設計において、私達は再帰のような重\n要なプログラミング構造を実装するための仕組みを開発します。またレジスタ\nマシンの設計を記述するための言語も与えます。\nSection 5.2\nではこれらの記述\nを用いて設計したマシンをシミュレートする\nLisp\nプログラムを実装します。\n私達のレジスタマシンのプリミティブな命令の多くはとても簡単です。例\nえばある命令は\n2\nつのレジスタから取得した数値を足し、結果を生成して\n3\nつ\n目のレジスタに格納します。そのような命令は簡単に記述されたハードウェア\nにより実行されることができます。しかし、リスト構造を取り扱うためにはメ\nモリ操作命令\ncar\n,\ncdr\n,\ncons\nもまた使用します。これは複雑なストレージ\n(\n記\n憶領域\n)\n獲得の仕組みを必要とします。\nSection 5.3\nでより初歩的な命令を用い\nてのそれらの実装について学びます。\nSection 5.4\nではレジスタマシンによる簡単な手続の形式化についての経験\nを貯めた後に、\nSection 4.1\nのメタ循環評価機により説明されたアルゴリズムを\n実行するマシンを設計します。これが\nScheme\nがどのように解釈されるのかに\nついての私達の理解のギャップを、評価機の制御の仕組みに対する明確なモデ\nルを与えることにより、埋めることでしょう。\nSection 5.5\nでは\nScheme\nプログ\nラムを評価機のレジスタマシンのレジスタと命令を用いて直接実行可能な一連\nの命令に変換する簡単なコンパイラについて学びます。\n529","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":555},{"id":"./test/fixtures/pdf/sicp.pdf:556","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5.1\nレジスタマシンの設計\nレジスタマシンを設計するためには、その\ndata paths\n(\nデータパス\n)(\nレジス\nタと命令\n)\nとこれらの命令を順序付ける\ncontroller\n(\nコントローラ\n)\nを設計する必\n要があります。簡単なレジスタマシンの設計を説明するために、\n2\nつの整数の\n最大公約数\n(\ngcd\n)\nを求めるために使用したユークリッドのアルゴリズムを検討\nしましょう。\nSection 1.2.5\nで学んだように、ユークリッドのアルゴリズムは反\n復プロセスにて以下の手続にて指定されるように実行されることができます。\n(\ndefine\n(\ngcd\na\nb\n)\n(\nif\n(=\nb\n0)\na\n(\ngcd\nb\n(\nremainder\na\nb\n))))\nこのアルゴリズムを実行する機械は\n2\nつの数値、\n푎\nと\n푏\nを追跡しなければいけ\nません。そうすることでこれらの数値がそれらの名前と共に\n2\nつのレジスタに\n格納されることが推測できます。必要とされる基本的な命令はレジスタ\nb\nの値\nが\n0\nであるかどうかを確認し、レジスタ\na\nの中身をレジスタ\nb\nの中身で割った\n余りを求めます。剰余の命令は複雑な処理ですが、当座は剰余を求めるプリミ\nティブな手法が存在すると仮定します。\ngcd\nアルゴリズムの各サイクルにおい\nて、レジスタ\na\nの中身はレジスタ\nb\nの中身で置き換えられ、レジスタ\nb\nの中身\nは\na\nの古い中身を\nb\nの古い中身で割った場合の余りで置き換えられなければ\nなりません。もしこれらの置換が同時に行われれば便利でしょう。しかし私達\nのレジスタマシンのモデルではただ\n1\nつのレジスタのみが各ステップで新しい\n値を割り当てられることができます。置換を達成するためには、私達の機械は\n3\nつ目の\n“temporary”(\n一時的な\n)\nレジスタを使用します。これを\nt\nと呼びます。\n(\n最初に剰余は\nt\nに置かれます。次に\nb\nの中身が\na\nに置かれます。最後に\nt\nに\n格納されている剰余が\nb\nに置かれます。\n)\nこの機械のレジスタと命令を\nFigure 5.1\nに示されるデータパス図を用いて\n説明することができます。この図では、レジスタ\n(\na\n,\nb\n,\nt\n)\nは長方形で表現され\nます。値をレジスタに割り当てる方向は\nX\nが頭の後ろにあり、データの元から\nレジスタを指す矢印により示されます。\nX\nは押された時に元の値が指定された\nレジスタに\n“flow”\nする\n(\n流れる\n)\nボタンだと考えることができます。各ボタン\nの横にあるラベルはそのボタンを参照するのに使われる名前です。この名前は\n自由で、かつ記憶を助ける値を持つことを選択することができます。\n(\n例えば、\na<-b\nはボタンを押すとレジスタ\nb\nの中身を\na\nに割り当てることを意味します\n)\n。\nレジスタに対するデータ元は別のレジスタであることも可能で\n(\na<-b\nの代入の\n530","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":556},{"id":"./test/fixtures/pdf/sicp.pdf:557","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a\nb\nt\nrem\na←b\nt←r\nb←t\n0\n=\nFigure 5.1:\ngcd\nマシンのデータパス\nように\n)\n、また\n(\nt<-r\nの代入のように\n)\n命令の結果や、定数\n(\n変更できない組込\nの値、データパス図では定数を持つ三角形で表現される\n)\nにもなり得ます。\n定数とレジスタの中身から値を求める命令はデータパス図では命令に対する名\n前を持つ台形により表現されます。例えば\nFigure 5.1\nで\nrem\nと印された箱はそ\nれに取り付けられたレジスタ\na\nと\nb\nの中身の剰余を求める命令を表します。ボ\nタンの無い矢印は入力レジスタと定数から箱へと指し、別の矢印は命令の出力\n値からレジスタへと接続しています。テストはそのテストを表す名前を持つ円\nで表現されます。例えば、私達の\ngcd\nマシンはレジスタ\nb\nの中身がゼロであ\nるかをテストする命令を持ちます。テストはまたその入力レジスタと定数から\nの矢印を持ちます。しかし出力の矢印を持ちません。その値はデータパスでな\nくコントローラにより使用されます。全体としては、データパス図は機械にと\nって必要とされるレジスタと命令と、それらがどのように接続されるべきかを\n示しています。もし私達が矢印を配線に、\nX\nボタンをスイッチだと見れば、デ\nータパス図は電子部品から構築することができる機械の配線図にとても似てい\nます。\nデータパスに対し実際に\ngcd\nを求めるためには、複数のボタンが正しい順\n序で押される必要があります。私達はこの順序を\nFigure 5.2\nで図示されるコン\nトローラ図を用いて説明します。コントローラ図の要素はデータパスのコンポ\nーネントがどのように操作されるべきかであるかを示します。コントローラ図\nの長方形の箱は押されるべきデータパスのボタンを判別します。そして矢印は\nあるステップから次への順を示します。図の中のひし形は選択を表現します。\nひし形内で確認されたデータパスのテストの値に依存し、\n2\nつの順路矢印の\n1\n531","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":557},{"id":"./test/fixtures/pdf/sicp.pdf:558","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"start\nno\ndone\nyes\n=\nt←r\na←b\nb←t\nFigure 5.2:\ngcd\nマシンのコントローラ\nつに従います。私達はコントローラを物質的なアナロジーを用いて解釈するこ\nとができます。この図をビー玉が転がっている迷路だと考えるのです。ビー玉\nが箱に転がり込んだ時に、箱により名付けられたデータパスボタンを押します。\nビー玉が\n(\nb\n= 0\nのテストのような\n)\n決断点に転がり込んだ時には、示されたテ\nストの結果により決定された道に乗りその点を去ります。これらをもとに、デ\nータパスとコントローラは完全に\ngcd\nを求めるための機械を説明します。私達\nはコントローラ\n(\n転がるビー玉\n)\nを\nstart\nと印された地点から、レジスタ\na\nと\nb\nに数値を置いてから開始します。コントローラが\ndone\nに辿り着いた時、\ngcd\nの値はレジスタ\na\nの中に見つかります。\nExercise 5.1:\n以下の手続で指定される反復アルゴリズムを用いて\n階乗を求めるレジスタマシンを設計せよ。このマシンに対するデ\nータパスとコントローラの図を描け。\n(\ndefine\n(\nfactorial\nn\n)\n(\ndefine\n(\niter\nproduct\ncounter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\niter\n(*\ncounter\nproduct\n)\n(+\ncounter\n1))))\n(\niter\n1 1))\n532","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":558},{"id":"./test/fixtures/pdf/sicp.pdf:559","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5.1.1\nレジスタマシンを記述するための言語\nデータパスとコントローラの図は\ngcd\nの様な簡単な機械を表現するには適\n切です。しかしそれらは\nLisp\nインタプリタのような大きな機械を記述するには\n扱いにくい物です。複雑な機械を扱うことを可能にするために、私達はテキス\nト形式でデータパスとコントローラの図により与えられる全ての情報を表現す\nる言語を作成することにします。まずは直接図を写し取る表記法から始めます。\n機械のデータパスをレジスタと命令を記述することにより定義します。レ\nジスタを記述するために、それに名前を与え、それに対する代入をコントロー\nルするボタンを指定します。これらのボタン全てに名前を与え、ボタンのコン\nトロールの下にレジスタに入れられるデータの代入元を指定します。\n(\n代入元\nはレジスタ、定数、または命令です\n)\n。命令を記述するために、それに名前を与\nえ、その入力\n(\nレジスタ、または定数\n)\nを指定します。\n機械のコントローラを\ninstructions\n(\n命令\n)\nの列として、その列の\nentry\npoints\n(\nエントリポイント\n、入口\n)\nを特定する\nlabels\n(\nラベル\n)\nと共に定義します。\n•\nレジスタに値を割り当てるために押すデータパスボタンの名前。\n(\nこれは\nコントローラ図の箱に対応する\n)\n•\ntest\n(\nテスト\n)\n命令、特定のテストを実行する。\n•\n直前のテストの結果に基づくコントローララベルにより示された地点へ\nの条件分岐\n(\nbranch\n命令\n)\n。\n(\nテストと分岐は共にコントローラ図のひし\n形に対応する\n)\n。もしテストが偽であれば、コントローラは命令列の次の\n命令へと続ける。そうでなければ、コントローラはラベルの次の命令か\nら続ける。\n•\n無条件分岐\n(\ngoto\n命令\n)\nは実行を続ける地点にコントローララベルを名\n付ける\n機械はコントローラの命令列の初めから開始し、列の終わりに辿り付いた時に\n実行を停止する。ただし分岐が制御の流れを変更した場合、命令はそれが並べ\nられた順に向かい実行される。\nFigure 5.3:\n↓\nA specification of the\ngcd\nmachine.\n(\ndata-paths\n(\nregisters\n((\nname\na\n)\n(\nbuttons\n((\nname\na<-b\n) (\nsource\n(\nregister\nb\n)))))\n((\nname\nb\n)\n533","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":559},{"id":"./test/fixtures/pdf/sicp.pdf:560","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbuttons\n((\nname\nb<-t\n) (\nsource\n(\nregister\nt\n)))))\n((\nname\nt\n)\n(\nbuttons\n((\nname\nt<-r\n) (\nsource\n(\noperation\nrem\n))))))\n(\noperations\n((\nname\nrem\n) (\ninputs\n(\nregister\na\n) (\nregister\nb\n)))\n((\nname\n=) (\ninputs\n(\nregister\nb\n) (\nconstant\n0)))))\n(\ncontroller\ntest-b\n; label\n(\ntest\n=)\n; test\n(\nbranch\n(\nlabel\ngcd-done\n))\n; conditional branch\n(\nt<-r\n)\n; button push\n(\na<-b\n)\n; button push\n(\nb<-t\n)\n; button push\n(\ngoto\n(\nlabel\ntest-b\n))\n; unconditional branch\ngcd-done\n)\n; label\nFigure 5.3\nはこの方法で記述された\ngcd\nマシンを示します。この例はこれらの\n記述の一般性を暗示しているに過ぎません。\ngcd\nマシンはとても単純な場合で\nあるからです。各レジスタはたった\n1\nつのボタンしか持たず、各ボタンとテス\nトはコントローラによりただ\n1\n度しか利用されていません。\n残念なことに、このような記述を読むことは難しいことです。コントロー\nラの命令を理解するためには、常にボタンの名前と命令の名前の定義に戻らね\nばならず、またボタンが何をするのか理解するためには命令の名前の定義を参\n照する必要があるでしょう。従って私達はこの表記法を変形し、データパスと\nコントローラの記述からの情報を組み合わせることで全てを一緒に見られるよ\nうにします。\n記述のこの形式を得るために、自由裁量なボタンと命令の名前をそれらの\n振舞の定義により置き換えます。つまり、\n(\nコントローラの中で\n)“\nボタン\nt<-r\nを押せ\n”\nと言い、別に\n(\nデータパスの中で\n)“\nボタン\nt<-r\nは\nrem\n命令の値をレジ\nスタ\nt\nに代入\n”\nと\n“\nrem\n命令の入力はレジスタ\na\nと\nb\nの中身\n”\nと言う代わりに、\nこれからは\n(\nコントローラの中で\n)“\nレジスタ\na\nと\nb\nの中身上での\nrem\n命令の値\nをレジスタ\nt\nに代入するボタンを押せ\n”\nと言うことにします。同様に、\n(\nコント\nローラの中で\n)“\n=\nテストを実行せよ\n”\nと言い、別に\n(\nデータパスの中で\n)“\n=\nテス\nトはレジスタ\nb\nの中身と定数\n0\nの上で動作する\n”\nと言う代わりに、これからは\n“\n=\nテストをレジスタ\nb\nの中と定数\n0\nの上で実行せよ\n”\nと言います。データパス\nの記述は省略し、コントローラの命令列のみを残します。従って、\ngcd\nマシン\n534","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":560},{"id":"./test/fixtures/pdf/sicp.pdf:561","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"は以下のように記述されます。\n(\ncontroller\ntest-b\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\ngcd-done\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ntest-b\n))\ngcd-done\n)\nこの記述の形式は\nFigure 5.3\nで説明されたものよりも読み易いでしょう。しか\nし同時に欠点も持ちます。\n•\n大きな機械に対してはより冗長である。データパス要素の複雑な記述が\nその要素がコントローラ命令列内で触れられる度に繰り返されるため。\n(\nこれは\ngcd\nの例では問題にならない。命令とボタンのそれぞれがただ\n1\n度しか使用されないため\n)\n。さらに、データパス記述の繰り返しが実際の\n機械のデータパス構造を分かりにくくする。大きな機械にとっていくつ\nのレジスタ、命令、ボタンが存在し、それらがどのように相互接続され\nているのかは自明では無い。\n•\n機械の定義内のコントローラの命令は\nLisp\n式の様に見えるため、それら\nが自由裁量な\nLisp\n式ではないことを簡単に忘れてしまう。それらは正\n式な機械の命令のみを記述できる。例えば、命令は直接には定数とレジ\nスタの中身のみに対して操作ができる。他の命令の結果に対してはでき\nない。\nこれらの欠点にも係らず、私達はこのレジスタマシンの言語をこの章を通して\n使用します。データパスの要素と接続を理解することよりもコントローラを理\n解することにより関係していくためです。しかし、私達はデータパスの設計は\n実際の機械の設計において、とても重要であることを肝に命じておかねばなり\nません。\nExercise 5.2:\nレジスタマシン言語を用いて\nExercise 5.1\nの反復階乗\n機械を記述せよ。\n535","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":561},{"id":"./test/fixtures/pdf/sicp.pdf:562","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":" (controller\n  gcd-loop\n    (assign a (op read))\n    (assign b (op read))\n  test-b\n    (test (op =) \n          (reg b) \n          (const 0))\n    (branch (label gcd-done))\n    (assign t \n            (op rem) \n            (reg a) \n            (reg b))\n    (assign a (reg b))\n    (assign b (reg t))\n    (goto (label test-b))\n  gcd-done\n    (perform (op print) \n             (reg a))\n    (goto (label gcd-loop)))\nread\na\nb\nt\nrem\na←b\nt←r\nb←t\n0\n=\nprint\na←rd\nb←rd\nP\nFigure 5.4:\n入力を読み込み結果を表示する\ngcd\nマシン\nアクション\ngcd\nマシンを変更して、\ngcd\nが欲しい数値を入力し、端末に答が表示され\nるようにしてみましょう。私達は読み込みや表示ができる機械をどのように作\nるかについては議論しません。しかし\n(\n私達が\nScheme\nにて\nread\nと\ndisplay\nを\n使う時に行うように\n)\nそれらがプリミティブな命令として既に存在すると仮定\nします。\n1\nread\nは私達が使用してきた、その中でレジスタに格納することができる値を生\n成する命令のような物です。しかし\nread\nは入力をどのレジスタからも取得し\nません。その値は私達が設計している機械の外側の部品で起こる何かに依存し\nています。私達は私達の機械の命令にそのようは振舞を持つことを許します。\n従って\nread\nの使用を描き、記述することを他の任意の値を求める命令と全く\n1\nこの仮定は多量の複雑さを言い繕っています。通常、\nLisp\nシステムの実装の大きな\n部分が読み込みと表示を可能にすることに関してささげられています。\n536","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":562},{"id":"./test/fixtures/pdf/sicp.pdf:563","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"同様に行います。\n一方で、\nprint\nは私達が使用してきた命令とは基本的な意味において異な\nります。これはレジスタに格納できる出力の値を生成しません。この種の命令\nは\naction\n(\nアクション\n)\nとして参照することにします。データパス図ではアクシ\nョンは値を求める命令と同じように、アクションの名前を含む台形として表現\nします。矢印は任意の入力\n(\nレジスタ、または定数\n)\nからアクションの箱へと指\nします。またボタンをアクションと関連付けることもします。ボタンを押すと\nアクションが起こります。コントローラにアクションボタンを押させるために、\nperform\n(\nパフォーム、実行\n)\nと呼ばれる新しい種類の命令を用います。従って\nレジスタ\na\nの中身を表示するアクションはコントローラの命令列の中でその命\n令により表現されます。\n(\nperform\n(\nop\nprint\n) (\nreg\na\n))\nFigure 5.4\nは新しい\ngcd\nマシンのデータパスとコントローラを示しています。\n回答を表示した後にマシンをストップさせる代わりに、再開させています。そ\nのため数値のペアを読み込み、それらの\ngcd\nを計算し、結果を表示することを\n繰り返します。この構造は\nChapter 4\nのインタプリタにて使用したドライバル\nープに似ています。\n5.1.2\n機械設計における抽象化\n私達はこれから頻繁に、実際には複雑な\n“\nプリミティブな\n”\n命令を含む機械\nを定義します。例えば\nSection 5.4\nと\nSection 5.5\nでは\nScheme\nの環境の操作をプ\nリミティブとして扱います。そのような抽象化はそれにより機械の部品の詳細\nを無視することを可能にし、設計の他の側面に集中することを可能にするため\n有益です。しかし、私達が数多くの複雑さを敷物の下に隠してしまった事実は\n機械設計が非現実的であることを意味しません。私達は常に複雑な\n“\nプリミテ\nィブ\n”\nをより簡単なプリミティブな命令で置き換えることができます。\ngcd\nマシンについて考えます。マシンはレジスタ\na\nと\nb\nの中身の剰余を求\nめる、結果をレジスタ\nt\nに割り当てる命令を持ちます。もし\ngcd\nマシンをプ\nリミティブな剰余命令を使用すること無しに構築したい場合、より単純な命令、\n例えば引き算を用いてどのように剰余を求めるのかを指定しなければなりませ\nん。実際に、この方法で剰余を見つける\nScheme\nの手続を描くことができます。\n(\ndefine\n(\nremainder\nn\nd\n)\n(\nif\n(<\nn\nd\n)\nn\n(\nremainder\n(-\nn\nd\n)\nd\n)))\n537","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":563},{"id":"./test/fixtures/pdf/sicp.pdf:564","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"従って\ngcd\nマシンのデータパス内の剰余命令を引き算命令と比較テストで\n置き換えることができます。\nFigure 5.5\nは緻密化されたマシンのデータパスと\nコントローラを示します。\ngcd\nコントローラ定義内の以下の命令は、\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\nFigure 5.6\nに示されるように、ループを含む一連の命令により置き換えること\nができます。\nFigure 5.6:\n↓\nFigure 5.5\nの\ngcd\nマシンのコントローラの命令列\n(\ncontroller\ntest-b\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\ngcd-done\n))\n(\nassign\nt\n(\nreg\na\n))\nrem-loop\n(\ntest\n(\nop\n<) (\nreg\nt\n) (\nreg\nb\n))\n(\nbranch\n(\nlabel\nrem-done\n))\n(\nassign\nt\n(\nop\n-) (\nreg\nt\n) (\nreg\nb\n))\n(\ngoto\n(\nlabel\nrem-loop\n))\nrem-done\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ntest-b\n))\ngcd-done\n)\nExercise 5.3:\n平方根を求める機械を\nSection 1.1.7\nで説明されたよ\nうにニュートン法を用いて設計せよ。\n(\ndefine\n(\nsqrt\nx\n)\n(\ndefine\n(\ngood-enough?\nguess\n)\n(< (\nabs\n(- (\nsquare\nguess\n)\nx\n)) 0.001))\n(\ndefine\n(\nimprove\nguess\n)\n(\naverage\nguess\n(/\nx\nguess\n)))\n(\ndefine\n(\nsqrt-iter\nguess\n)\n(\nif\n(\ngood-enough?\nguess\n)\nguess\n(\nsqrt-iter\n(\nimprove\nguess\n))))\n(\nsqrt-iter\n1.0))\n538","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":564},{"id":"./test/fixtures/pdf/sicp.pdf:565","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a←b\nt←a\nb←t\nt←d\na\nb\nt\n--\n<\n0\n=\n=\nstart\nyes\ndone\nno\n<\nno\nyes\nt←a\na←b\nb←t\nt←d\nFigure 5.5:\n精緻な\ngcd\nマシンのデータパスとコントローラ\n539","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":565},{"id":"./test/fixtures/pdf/sicp.pdf:566","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"good-enough?\nと\nimprove\n命令はプリミティブとして存在すると\nして始めよ。次にこれらを算術演算子を用いてどのように展開す\nるか示せ。\nsqrt\nマシン設計の各版をデータパス図を描き、レジス\nタマシンのコントローラ定義を記述することで説明せよ。\n5.1.3\nサブルーチン\n演算を実行する機械を設計する時、私達は良くコンポーネントを複製する\nのではなく、演算の異なる部品により共有されるコンポーネントを準備するこ\nとを好みます。\n2\nつの\ngcd\n演算を含む機械についえ考えてみましょう。\n1\nつは\nレジスタ\na\nと\nb\nの中身の\ngcd\nを求め、もう\n1\nつはレジスタ\nc\nと\nd\nの\ngcd\nを求\nめます。私達はまずプリミティブな\ngcd\n命令を持つと仮定することから始め、\n次に\n2\nつの\ngcd\nのインスタンスをよりプリミティブな命令を用いて展開するで\nしょう。\nFigure 5.7\nは結果としての機械のデータパスの\ngcd\nの部分を、それら\nが機械の残りの部分にどのように接続されていかを除いて示しています。この\n図はまた機械のコントローラシーケンス\n(\n命令列\n)\nの対応する部分も示してい\nます。\nこの機械は\n2\nつの剰余命令の箱と\n2\nつの等値テストの箱を持っています。もし\n複製されたコンポーネントが剰余の箱のように複雑なら、これは機械を構築す\nるのに経済的な方法ではありません。私達はより大きな機械の演算に影響を与\nえないように与えられた場合に、同じコンポーネントを両方の\ngcd\n演算に用\nいることでデータパスコンポーネントの複製を防ぎます。もしレジスタ\na\nと\nb\nの値がコントローラが\ngcd-2\nに取り掛かっている時に必要無いのであれば\n(\nま\nたはもしこれらの値が安全のために他のレジスタに移動しておくことができる\nのならば\n)\n、機械を変更し、レジスタ\nc\nと\nd\nでなく、レジスタ\na\nと\nb\nを\n2\nつ目\nの\ngcd\nを\n1\nつ目と同じに求めるおおができます。もしこれを行うなら、\nFigure\n5.8\nに示されるコントローラシーケンスを得ます。\n540","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":566},{"id":"./test/fixtures/pdf/sicp.pdf:567","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"gcd-1\n (test (op =) (reg b) (const 0))\n (branch (label after-gcd-1))\n (assign t (op rem) (reg a) (reg b))\n (assign a (reg b))\n (assign b (reg t))\n (goto (label gcd-1))\nafter-gcd-1\na\nb\nt\nrem\na←b\nt←r\nb←t\n0\n=\ngcd-2\n (test (op =) (reg d) (const 0))\n (branch (label after-gcd-2))\n (assign s (op rem) (reg c) (reg d))\n (assign c (reg d))\n (assign d (reg s))\n (goto (label gcd-2))\nafter-gcd-2\nc\nd\ns\nrem\nc←d\ns←r\nd←s\n0\n=\nFigure 5.7:\n2\nつの\ngcd\n演算を持つ機械のデータパスとコン\nトローラシーケンスの一部\nFigure 5.8:\n↓\n2\nつの異なる\ngcd\n演算に対して同じデータパスコン\nポーネントを使用する機械のコントローラシーケンスの一部\ngcd-1\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\nafter-gcd-1\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ngcd-1\n))\nafter-gcd-1\n...\ngcd-2\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n541","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":567},{"id":"./test/fixtures/pdf/sicp.pdf:568","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbranch\n(\nlabel\nafter-gcd-2\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ngcd-2\n))\nafter-gcd-2\n私達はデータパスコンポーネントの複製を削除しました。\n(\nそうすることでデ\nータパスは\nFigure 5.1\nの状態に戻りました\n)\n。しかしコントローラは今ではそれ\nらのエントリポイントのラベルのみが異なる\n2\nつの\ngcd\nシーケンスを持ちま\nす。これら\n2\nつのシーケンスを\n1\nつのシーケンス\n—\ngcd\nsubroutine\n(\nサブルーチ\nン\n)—\nへの分岐により置き換えたほうが良くなるでしょう。サブルーチンの終\nわりにメインの命令列の正しい場所へと戻ります。これを次のように達成する\nことができます。\ngcd\nに分岐する前に、\n(0\nか\n1\nのような\n)\n識別するための値を\n特別なレジスタ、\ncontinue\nに置きます。\nFigure 5.9\nは結果としてのコントロー\nラシーケンスの関連する部分を示しています。これはただ\n1\nつの\ngcd\n命令列の\nコピーを含みます。\nFigure 5.9:\n↓\nFigure 5.8\nでコントローラシーケンスの重複を防ぐた\nめ\ncontinue\nレジスタを用いる\ngcd\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\ngcd-done\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ngcd\n))\ngcd-done\n(\ntest\n(\nop\n=) (\nreg\ncontinue\n) (\nconst\n0))\n(\nbranch\n(\nlabel\nafter-gcd-1\n))\n(\ngoto\n(\nlabel\nafter-gcd-2\n))\n...\n;;\ngcd\nを必要とする場所からその場所へと分岐する前に\n;;\nレジスタ\ncontinue\nに\n0\nを置く\n(\nassign\ncontinue\n(\nconst\n0))\n(\ngoto\n(\nlabel\ngcd\n))\n542","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":568},{"id":"./test/fixtures/pdf/sicp.pdf:569","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"after-gcd-1\n...\n;;\ngcd\nの二度目の使用の前にはレジスタ\ncontinue\nに\n1\nを置く\n(\nassign\ncontinue\n(\nconst\n1))\n(\ngoto\n(\nlabel\ngcd\n))\nafter-gcd-2\nこれは小さな問題に対応するのに妥当な取り組み方です。しかしもし数多くの\ngcd\n演算がコントローラシーケンスの中にある場合には困ったことになりそう\nです。\ngcd\nサブルーチンの後に実行をどこで続けるかを決定するために、デー\nタパス内のテストとコントローラ内に分岐命令が\ngcd\nを置く全ての場所に対\nして必要となるでしょう。サブルーチンを実装するためのより強力な手法は、\ncontinue\nレジスタにサブルーチンが終了した時に実行が続行しなければなら\nない場所のコントローラシーケンス内のエントリポイントのラベルを持たせる\nことです。この戦略の実装にはレジスタマシンのデータパスとコントローラの\n間に新しい種類のコネクションが必要です。ラベルの値をレジスタから取得し\n指定されたエントリポイントから実行を再開するのに使用できるような方法の\nため、レジスタにコントローラシーケンス内のラベルを代入するための方法が\n必要です。\nこの能力を反映するために、レジスタマシン言語の\nassign\n命令を拡張し、\nレジスタに値としてラベルをコントローラシーケンスから\n(\n特別な種類の中身\nとして\n)\n代入することを許可する拡張を行います。また\ngoto\n命令にも静的ラ\nベルにより記述されたエントリポイントのみでなく、レジスタの中により表\nされたエントリポイントから実行を続行することを許可する拡張を行います。\nこれらの新しい構造物を用いることで、\ncontinue\nレジスタ内に格納された場\n所に分岐することにより、\ngcd\nサブルーチンを停止することができます。これ\nは\nFigure 5.10\nに示されたコントローラシーケンスへと導きます。\nFigure 5.10:\n↓\nAssigning labels to the\ncontinue\nregister simplifies\nand generalizes the strategy shown in\nFigure 5.9\n.\ngcd\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\ngcd-done\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n543","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":569},{"id":"./test/fixtures/pdf/sicp.pdf:570","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ngcd\n))\ngcd-done\n(\ngoto\n(\nreg\ncontinue\n))\n...\n;;\ngcd\nを呼ぶ前に、\ncontinue\nに\ngcd\nが戻るべきラベルを代入しま\nす\n(\nassign\ncontinue\n(\nlabel\nafter-gcd-1\n))\n(\ngoto\n(\nlabel\ngcd\n))\nafter-gcd-1\n...\n;;\n異なる継続を持つ\n2\nつ目の\ngcd\n呼出\n(\nassign\ncontinue\n(\nlabel\nafter-gcd-2\n))\n(\ngoto\n(\nlabel\ngcd\n))\nafter-gcd-2\n複数のサブルーチンを持つマシンは複数の継続レジスタ\n(\n例えば\ngcd-continue\n,\nfactorial-continue\n)\nを用いるか、または全てのサブルーチンが単一の\ncontinue\nレジスタを共有することができるでしょう。共有はより経済的ですが、別のサ\nブルーチン\n(\nsub2\n)\nを呼び出すサブルーチン\n(\nsub1\n)\nを持っていないか注意しな\nければなりません。\nsub1\nが\ncontinue\nの中身を何か他のレジスタに、\ncontinue\nを\nsub2\nの呼出のために設定する前に保存しなければ、\nsub1\nは完了した時点で\nどこに行けば良いのか知ることができません。次の節で開発される再帰を扱\nう仕組みはこの入れ子のサブルーチン呼出の問題にもより良い解法を提供し\nます。\n5.1.4\n再帰実装にスタックを使用する\nここまでに説明されたアイデアを用いて、そのプロセスの各状態変数に対\n応するレジスタを持つレジスタマシンを指定することにより、任意の反復プロ\nセスを実装することができます。この機械はレジスタの中身を変更しながら、\n繰り返しコントローラのループを、ある停止条件が満たされるまで実行します。\nコントローラシーケンスの各地点において、\n(\n反復プロセスの状態を表現する\n)\n機械の状態はレジスタの状態\n(\n状態変数の値\n)\nにより完全に決定されます。\nしかし、再帰プロセスを実装する場合には追加の仕組みを必要とします。以\n下の階乗を求めるための再帰手法について考えましょう。これは\nSection 1.2.1\nで\n544","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":570},{"id":"./test/fixtures/pdf/sicp.pdf:571","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"最初に調査しました。\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (* (\nfactorial\n(-\nn\n1))\nn\n)))\nこの手続から見てとれるように、\n푛!\nの演算は\n(푛 − 1)!\nの演算を必要とします。\n私達の\ngcd\nは以下の手続からモデル化されていますが、\n(\ndefine\n(\ngcd\na\nb\n)\n(\nif\n(=\nb\n0)\na\n(\ngcd\nb\n(\nremainder\na\nb\n))))\n同様に別の\ngcd\nを求める必要があります。しかし、元の演算から新しい\nGCD\n演算へと簡約する\nGCD\n手続と、部分問題として別の階乗を求める必要がある\nfactorial\nの間には重要な違いがあります。\ngcd\nにおいては新しい\ngcd\n演算\nに対する答は元の問題の答です。次の\ngcd\nを求めるためには、単純に新しい引\n数を\ngcd\nマシンの入力レジスタに置き、機械のデータパスを同じコントローラ\nシーケンスを実行することにより再利用します。機械が最後の\ngcd\n問題を解く\nことを完了した時には、演算全体を完了したことになります。\n階乗の場合\n(\nまたは任意の再帰プロセス\n)\nにおいては新しい階乗の部分問題\nの回答は元の問題の回答ではありません。\n(푛 − 1)!\nに対して得られた値は最終\n回答を得るために\n푛\nで乗算しなければなりません。もし\ngcd\nの設計を真似し、\n階乗の部分問題をレジスタ\nn\nをデクリメント\n(1\n引く\n)\nし、階乗マシンに戻るこ\nのより解決したいとしても、その結果に乗算を行う有効な古い\nn\nの値は既に存\n在しません。従って部分問題上で働くための\n2\nつ目の階乗マシンが必要です。\nこの\n2\nつ目の階乗の演算はそれ自身が階乗の部分問題を持ち、それは\n3\nつ目の\n階乗マシンを必要とし、以下繰り返されます。各階乗マシンがその中に別の階\n乗マシンを持つため、総計の機械は同様な機械の無限の入れ子を含み、従って\n固定長の有限数な部品から構築することはできません。\nそれにもかかわらず、もし機械の各入れ子のインスタンスが同じコンポーネン\nトを使用するように準備ができれば階乗プロセスをレジスタマシンとして実\n装できます。具体的に言えば、\n푛!\nを求める機械は\n(푛 − 1)!\nを求める部分問題、\n(푛 − 2)!\nの部分問題、以下繰り返しの仕事に同じコンポーネントを使用せねば\nなりません。これはもっともらしく見えます。例え階乗プロセスが同じ機械の\nコピーの未束縛の数値が演算を実行するのに必要だと指図したとしても、これ\nらのコピーのただ\n1\nつが一度に有効になる必要があるためです。この機械が再\n帰の部分問題に遭遇した時に、メインの問題上の仕事を中断し、同じ物理部品\nを部分問題上の仕事に再利用し、そして中断した演算を続けることが可能です。\n部分問題の中では、レジスタの中身はメインの問題の中の物と異なります。\n(\nこの場合にはレジスタ\nn\nはデクリメントされます\n)\n。中断された演算を続ける\n545","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":571},{"id":"./test/fixtures/pdf/sicp.pdf:572","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"after-\nfact\nfact-\ndone\n(controller\n   (assign continue (label fact-done))   ;set up final return address\n fact-loop\n   (test (op =) (reg n) (const 1))\n   (branch (label base-case))\n   ;; Set up for the recursive call by saving n and continue.\n   ;; Set up continue so that the computation will continue\n   ;; at after-fact when the subroutine returns.\n   (save continue)\n   (save n)\n   (assign n (op -) (reg n) (const 1))\n   (assign continue (label after-fact))\n   (goto (label fact-loop))\n after-fact\n   (restore n)\n   (restore continue)\n   (assign val (op *) (reg n) (reg val))  ;val now contains n(n - 1)!\n   (goto (reg continue))                  ;return to caller\n base-case\n   (assign val (const 1))                 ;base case: 1! = 1\n   (goto (reg continue))                  ;return to caller\n fact-done)\n1\n=\nval\nn\nstack\ncontinue\n*\n--\nsn\nrn\nscrc\ncontroller\nFigure 5.11:\n再帰階乗マシン\n546","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":572},{"id":"./test/fixtures/pdf/sicp.pdf:573","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ことを可能にするために、機械は部分問題が解決した後に必要となる全てのレ\nジスタの中身を保存しなければなりません。そうすることで、中断した演算を\n続ける時にこれらの値が再格納されることができます。階乗の場合には、デク\nリメントされたレジスタ\nn\nの階乗の演算が完了した時に再格納されるように\nn\nの古い値を保存します。\n2\n予測可能な限界が入れ子の再帰呼出の深さには存在しないため、任意の数\nのレジスタ値を保存する必要があるでしょう。これらの値は保存された順の逆\n順に再格納されねばなりません。入れ子の再帰では突入する最後の部分問題が\n最初に完了するためです。このことが\nstack\n(\nスタック\n)\n、つまり\n“last in, first\nout”(LIFO,\n後入れ先出し\n)\nデータ構造をレジスタ値の保存への使用することを\n指示しています。レジスタマシン言語を拡張し、\n2\nつの種類の命令を追加する\nことでスタックを含めることができます。値はスタックに\nsave\n命令を用いて\n置かれて、\nrestore\n命令を用いてスタックから再格納されます。スタック上に\n一連の値が\nsave\nされた後に、連続した\nrestore\nがこれらの値を逆順に取り出\nします。\n3\nスタックの助けを借りることで階乗マシンの各階乗部分問題のために、デ\nータパスの単一のコピーを再利用することができます。同様なデータパスを操\n作するコントローラシーケンスの再利用についても同様の設計上の問題が存在\nします。階乗演算を再実行するためには\n,\nコントローラは単純には最初に反復\nプロセスのようにループバックすることはできません。\n(푛 − 1)!\nを解いた後に\nは機械は依然としてその結果と\n푛\nを掛ける必要があるためです。コントローラ\nは\n푛!\nの演算を中断し、部分問題\n(푛 − 1)!\nを解き、そして\n푛!\nの演算を続けなけ\nればなりません。階乗演算のこの見方は\nSection 5.1.3\nで説明されたサブルーチ\nンの仕組みの使用を推奨しており、これはコントローラにレジスタ\ncontinue\nを使用させて部分問題を解く列の一部へと移動し、そしてメイン問題を中止し\nた場所から続行します。このようにして\ncontinue\nレジスタに格納されたエン\nトリポイントに帰る階乗のサブルーチンを作ることができます。各サブルーチ\nン呼出の周りでは、\ncontinue\nを\nn\nレジスタに行うのと同じように保存し再格\n納します。階乗演算の各\n“\nレベル\n”\nが同じ\ncontinue\nレジスタを利用するためで\n2\n古い\nn\nを保存する必要は無いと主張する人がいるかもしれません。デクリメントし、\n部分問題を解決した後に、単純に古い値を回復するためにインクリメントすることがで\nきると思われるでしょう。例えこの戦略が階乗に対しては働いたとしても、それは一般\n的にはうまく行きません。レジスタの古い値が常に新しい値から求められるとは限らな\nいためです。\n3\nSection 5.3\nにおいて\n,\nよりプリミティブな命令を用いてどのようにスタックを実装す\nるかについて学びます。\n547","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":573},{"id":"./test/fixtures/pdf/sicp.pdf:574","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"す。つまり、階乗サブルーチンはそれが自分自身を部分問題として呼び出す時\nに、新しい値を\ncontinue\nに設定しなければいけません。しかし部分問題を解\nくために呼び出した場所に戻るために古い値が必要となるのです。\nFigure 5.11\nは再帰\nfactorial\n手続を実装する機械のためのデータパスとコ\nントローラを示しています。この機械はスタックと\n3\nつのレジスタ、\nn\n,\nval\n,\ncontinue\nを持ちます。データパス図を単純化するために、レジスタ代入ボタン\nには名前を付けず、スタック命令ボタン\n(\nレジスタを保存する\nsc\nと\nsn\n、レジ\nスタに戻す\nrc\nと\nrn\n)\nのみに付けています。機械を運用するには、レジスタ\nn\nに\n階乗を求めたい数を入れ、それから機械を開始します。機械が\nfact-done\nに辿\nり着いた時に演算は完了し、答はレジスタ\nval\nに見つかります。コントローラ\nシーケンスでは\nn\nと\ncontinue\nが各再帰呼出の前に保存され、その呼出から戻\nる時に再格納されます。呼出からの復帰は\ncontinue\nに格納された場所に分岐\nすることにより達成されます。\ncontinue\nは機械が開始した時に最後の復帰が\nfact-done\nに向かうように初期化されます。階乗演算の結果を持つ\nval\nレジス\nタは再帰呼出の前に保存されません。\nval\nの古い中身はサブルーチンから復帰\n後には役に立たないためです。部分問題により生成された新しい値のみが必要\nとされます。\n例え原理上は階乗演算が無限の機械を必要とするとしても、\nFigure 5.11\nの\n機械は実際には限りが無いかもしれないスタックを除けば有限です。しかし、\nスタックのどんな特定の物理実装も有限のサイズを持ち、このことが機械によ\nり扱うことが可能な再帰呼出の深さを制限します。この階乗の実装は再帰アル\nゴリズムをスタックで容量が増加された通常のレジスタマシンとして実現する\nための一般的な戦略を説明します。再帰部分問題に遭遇した時にはその現在の\n値が部分問題が解決された後に必要とされるレジスタをスタック上に保存しま\nす。次に再帰部分問題を解決し、保存されたレジスタを戻してメイン問題の実\n行を続行します。\ncontinue\nレジスタは常に保存されなければなりません。保存\nする必要の有るレジスタが他に存在するかどうかは機械に依存します。全ての\n再帰演算が部分問題の解決の間に変更されるレジスタの元の値を必要とはしな\nいためです。\n(\nExercise 5.4\n参照\n)\n。\n二重再帰\nより複雑な再帰プロセス、\nSection 1.2.2\nで紹介したフィボナッチ数の木再帰\n演算について調査してみましょう。\n(\ndefine\n(\nfib\nn\n)\n(\nif\n(<\nn\n2)\n548","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":574},{"id":"./test/fixtures/pdf/sicp.pdf:575","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"n\n(+ (\nfib\n(-\nn\n1)) (\nfib\n(-\nn\n2)))))\n階乗と同じ様に、再帰フィボナッチ演算をレジスタマシンとしてレジスタ\nn\n,\nval\n,\ncontinue\nと用いて実装することができます。この機械は階乗のものより\nも、より複雑です。コントローラシーケンスの中に二箇所の再帰呼出の実行が\n必要な箇所が存在するためです。一度目は\n퐹 푖푏(푛 − 1)\nを求めるために、二度\n目は\n퐹 푖푏(푛 − 2)\nを求めるためです。これらの各呼出に準備するために、後に\nその値が必要となるレジスタを保存し、レジスタ\nn\nに再帰的に求める\n(\n푛 − 1\nまたは\n푛 − 2\n)\n必要のあるフィボナッチ数を設定します。そして\ncontinue\nに戻\nり先のメインシーケンスのエントリポイント\n(\nそれぞれ\nafterfib-n-1\nまたは\nafterfib-n-2\n)\nを割り当てます。そうしたら\nfib-loop\nへと飛びます。再帰呼\n出から帰る時には、回答は\nval\nの中にあります。\nFigure 5.12\nはこの機械のため\nのコントローラシーケンスを示しています。\nFigure 5.12:\n↓\nController for a machine to compute Fibonacci num-\nbers.\n(\ncontroller\n(\nassign\ncontinue\n(\nlabel\nfib-done\n))\nfib-loop\n(\ntest\n(\nop\n<) (\nreg\nn\n) (\nconst\n2))\n(\nbranch\n(\nlabel\nimmediate-answer\n))\n;; Fib\n(푛 − 1)\nを求める準備\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nafterfib-n-1\n))\n(\nsave\nn\n)\n;\nn\nの古い値を保存\n(\nassign\nn\n(\nop\n-) (\nreg\nn\n) (\nconst\n1))\n;\nn\nを\nn-1\nで\n上書き\n(\ngoto\n(\nlabel\nfib-loop\n))\n;\n再帰呼出の実行\nafterfib-n-1\n;\nリターン時に\n,\nval\nが\nFib\n(푛 − 1)\nを持つ\n(\nrestore\nn\n)\n(\nrestore\ncontinue\n)\n;; Fib\n(푛 − 2)\nを求める準備\n(\nassign\nn\n(\nop\n-) (\nreg\nn\n) (\nconst\n2))\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nafterfib-n-2\n))\n(\nsave\nval\n)\n; Fib\n(푛 − 1)\nを保存\n549","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":575},{"id":"./test/fixtures/pdf/sicp.pdf:576","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ngoto\n(\nlabel\nfib-loop\n))\nafterfib-n-2\n;\nリターン時に\n,\nval\nが\nFib\n(푛 − 2)\nを持つ\n(\nassign\nn\n(\nreg\nval\n))\n;\nn\nがここで\nFib\n(푛 − 2)\nを持\nつ\n(\nrestore\nval\n)\n;\nval\nがここで\nFib\n(푛 − 1)\nを\n持つ\n(\nrestore\ncontinue\n)\n(\nassign\nval\n; Fib\n(푛 − 1)\n+ Fib\n(푛 − 2)\n(\nop\n+) (\nreg\nval\n) (\nreg\nn\n))\n(\ngoto\n(\nreg\ncontinue\n))\n;\n呼び出しから戻る\n,\n答は\nval\nの中にある\nimmediate-answer\n(\nassign\nval\n(\nreg\nn\n))\n;\n基底の場合\n: Fib\n(푛) = 푛\n(\ngoto\n(\nreg\ncontinue\n))\nfib-done\n)\nExercise 5.4:\n次の手続のそれぞれを実装するレジスタマシンを指\n定せよ。各マシンに対して、コントローラ命令列を書き、データパ\nスを示す図を描け。\na\n再帰指数計算\n(\ndefine\n(\nexpt\nb\nn\n)\n(\nif\n(=\nn\n0)\n1\n(*\nb\n(\nexpt\nb\n(-\nn\n1)))))\nb\n反復指数計算\n(\ndefine\n(\nexpt\nb\nn\n)\n(\ndefine\n(\nexpt-iter\ncounter\nproduct\n)\n(\nif\n(=\ncounter\n0)\nproduct\n(\nexpt-iter\n(-\ncounter\n1)\n(*\nb\nproduct\n))))\n(\nexpt-iter\nn\n1))\n550","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":576},{"id":"./test/fixtures/pdf/sicp.pdf:577","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 5.5:\n階乗とフィボナッチの機械をいくつかの非自明な入\n力を用いて手動でシミュレートせよ。\n(\n少なくとも\n1\n回の再帰呼出\nを必要とする\n)\n。実行中の各重要な地点におけるスタックの中身を\n示せ。\nExercise 5.6:\nBen Bitdiddle\nはフィボナッチマシンのコントローラ\nシーケンスが余分な\nsave\nと\nrestore\nを持ち、より速いマシンを作\nるために取り除くことができることに気付いた。これらの命令は\nどこにあるか\n?\n5.1.5\n命令の要約\n私達のレジスタマシン言語のコントローラ命令は以下の形式の内\n1\nつを持\nち、各\n⟨푖푛푝푢푡\n푖\n⟩\nは\n(reg<\nregister-name\n>)\nか\n(const <\nconstant-value\n>)\nの\n何れかです。これらの命令は\nSection 5.1.1\nで導入されました。\n(\nassign\n⟨\nregister-name\n⟩\n(\nreg\n⟨\nregister-name\n⟩\n))\n(\nassign\n⟨\nregister-name\n⟩\n(\nconst\n⟨\nconstant-value\n⟩\n))\n(\nassign\n⟨\nregister-name\n⟩\n(\nop\n⟨\noperation-name\n⟩\n)\n⟨\n푖푛푝푢푡\n1\n⟩\n...\n⟨\n푖푛푝푢푡\n푛\n⟩\n)\n(\nperform\n(\nop\n⟨\noperation-name\n⟩\n)\n⟨\n푖푛푝푢푡\n1\n⟩\n...\n⟨\n푖푛푝푢푡\n푛\n⟩\n)\n(\ntest\n(\nop\n⟨\noperation-name\n⟩\n)\n⟨\n푖푛푝푢푡\n1\n⟩\n...\n⟨\n푖푛푝푢푡\n푛\n⟩\n)\n(\nbranch\n(\nlabel\n⟨\nlabel-name\n⟩\n))\n(\ngoto\n(\nlabel\n⟨\nlabel-name\n⟩\n))\nレジスタを用いてラベルを保存することは\nSection 5.1.3\nで導入されました。\n(\nassign\n⟨\nregister-name\n⟩\n(\nlabel\n⟨\nlabel-name\n⟩\n))\n(\ngoto\n(\nreg\n⟨\nregister-name\n⟩\n))\nスタックを使用する命令は\nSection 5.1.4\nで導入されました。\n(\nsave\n⟨\nregister-name\n⟩\n)\n(\nrestore\n⟨\nregister-name\n⟩\n)\nここまでで見た\n⟨\nconstant-value\n⟩\nの種類は数値のみです。しかし後程、文字列、\nシンボル、それにリストを使用します。\n(\nconst\n\"\nabc\n\"\n)\nは文字列\n\"\nabc\n\"\n,\n551","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":577},{"id":"./test/fixtures/pdf/sicp.pdf:578","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nconst\nabc\n)\nはシンボル\nabc,\n(\nconst\n(\na\nb\nc\n))\nはリスト\n(\na\nb\nc\n),\n(\nconst\n())\nは空リスト\n5.2\nレジスタマシンシミュレータ\nレジスタマシンの設計を良く理解するために、私達は設計した機械を期待\n通りに実行されるか確認するためにテストをする必要があります。設計のテス\nトを行う\n1\nつの方法として\nExercise 5.5\nと同様にコントローラの命令を手動で\nシミュレートする方法があります。しかしこれは簡単な機械を除いてとんでも\nなく退屈な方法です。この節ではレジスタマシン言語で記述された機械のため\nのシミュレータを構築します。このシミュレータは\n4\nつのインターフェイス手\n続を持つ\nScheme\nのプログラムです。\n1\nつ目はレジスタマシンの記述をマシン\nのモデルを構築するために利用します\n(\nデータ構造の部品がシミュレートされ\nるマシンの部品に対応します\n)\n。残りの\n3\nつがモデルを操作することにより機\n械のシミュレーションを可能にします。\n(\nmake-machine\n⟨\nregister-names\n⟩\n⟨\noperations\n⟩\n⟨\ncontroller\n⟩\n)\n与えられたレジスタ、命令、コントローラを持つ機械のモデルを\n構築し、返します。\n(\nset-register-contents!\n⟨\nmachine-model\n⟩\n⟨\nregister-name\n⟩\n⟨\nvalue\n⟩\n)\n与えられた機械でシミュレートされるレジスタに値を格納します。\n(\nget-register-contents\n⟨\nmachine-model\n⟩\n⟨\nregister-name\n⟩\n)\n与えられた機械のシミュレートされるレジスタの中身を返す。\n(\nstart\n⟨\nmachine-model\n⟩\n)\n与えられた機械の実行をシミュレートする。コントローラシーケ\nンスの最初から開始し、シーケンスの最後に辿り着いた時に停止\nする。\n552","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":578},{"id":"./test/fixtures/pdf/sicp.pdf:579","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これらの手続がどのように利用されるかの例として、\nSection 5.1.1\nの\ngcd\nマシ\nンのモデルとなる\ngcd-machine\nを以下のように定義します。\n(\ndefine\ngcd-machine\n(\nmake-machine\n'\n(\na\nb\nt\n)\n(\nlist\n(\nlist\n'rem\nremainder\n) (\nlist\n'=\n=))\n'\n(\ntest-b\n(\ntest\n(\nop\n=) (\nreg\nb\n) (\nconst\n0))\n(\nbranch\n(\nlabel\ngcd-done\n))\n(\nassign\nt\n(\nop\nrem\n) (\nreg\na\n) (\nreg\nb\n))\n(\nassign\na\n(\nreg\nb\n))\n(\nassign\nb\n(\nreg\nt\n))\n(\ngoto\n(\nlabel\ntest-b\n))\ngcd-done\n)))\nmake-machine\nに対する最初の引数はレジスタ名のリストです。次の引数は各\n命令名とその命令を実装する\nScheme\n手続\n(\nつまり、同じ入力値を与えられて\n同じ出力値を生成します\n)\nをペアにするテーブル\n(2\n要素リストのリスト\n)\nです。\n最後の引数は\nSection 5.1\nにあるようにラベルと機械の命令\n(\n機械語\n)\nのリストと\nしてのコントローラを指定します。\nこの機械を用いて\ngcd\nを求めるために、入力レジスタを設定し、機械を開\n始し、シミュレーションが停止した時に結果を検査します。\n(\nset-register-contents!\ngcd-machine\n'a\n206)\ndone\n(\nset-register-contents!\ngcd-machine\n'b\n40)\ndone\n(\nstart\ngcd-machine\n)\ndone\n(\nget-register-contents\ngcd-machine\n'a\n)\n2\nこの演算は\nScheme\nで書かれた\ngcd\n手続よりもとても遅く実行します。なぜな\nら\nassign\nのような低レベルの機械語をより複雑な命令によりシミュレートす\nるためです。\nExercise 5.7:\nシミュレータを用いて\nExercise 5.4\nで自分で設計した\n機械をテストせよ。\n553","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":579},{"id":"./test/fixtures/pdf/sicp.pdf:580","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5.2.1\nマシンモデル\nmake-machine\nにて生成された機械のモデルは\nChapter 3\nで開発されたメッ\nセージパッシングの技術を用いた局所状態を持つ手続として表現されていま\nす。このモデルを構築するために、\nmake-machine\nは手続\nmake-new-machine\nを\n呼び全てのレジスタマシンに対して共通なマシンモデルの部品を構築すること\nから始めます。\nmake-new-machine\nにより構築されるこの基本的な機械のモデ\nルは本質的にはいくつかのレジスタとスタックと、コントローラ命令を\n1\nつず\nつ処理する実行の仕組みを一緒にしたコンテナです。\nmake-machine\nは次にこの基本的なモデルを\n(\nそれに対してメッセージを送\nることで\n)\n拡張し、レジスタ、命令、定義される特定の機械のコントローラ\nを含めます。最初に新しい機械の中に与えられた各レジスタ名に対するレジ\nスタを獲得し、指定された命令をその機械にインストール\n(\n導入\n)\nします。次\nに\nassembler\n(\nアセンブラ\n)(\n下記の\nSection 5.2.2\nで説明されます\n)\nを用いてコン\nトローラリストを新しい機械に対する命令に変換し、これらを機械の命令列と\nしてインストールします。\nmake-machine\nはその値として変更された機械のモ\nデルを返します。\n(\ndefine\n(\nmake-machine\nregister-names\nops\ncontroller-text\n)\n(\nlet\n((\nmachine\n(\nmake-new-machine\n)))\n(\nfor-each\n(\nlambda\n(\nregister-name\n)\n((\nmachine\n'allocate-register\n)\nregister-name\n))\nregister-names\n)\n((\nmachine\n'install-operations\n)\nops\n)\n((\nmachine\n'install-instruction-sequence\n)\n(\nassemble\ncontroller-text\nmachine\n))\nmachine\n))\nレジスタ\nレジスタは\nChapter 3\nの様に局所状態を持つ手続として表現されます。手続\nmake-register\nはアクセスと変更が可能な値を持つレジスタを作成します。\n(\ndefine\n(\nmake-register\nname\n)\n(\nlet\n((\ncontents\n'*unassigned*\n))\n(\ndefine\n(\ndispatch\nmessage\n)\n554","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":580},{"id":"./test/fixtures/pdf/sicp.pdf:581","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncond\n((\neq?\nmessage\n'get\n)\ncontents\n)\n((\neq?\nmessage\n'set\n)\n(\nlambda\n(\nvalue\n) (\nset!\ncontents\nvalue\n)))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nREGISTER\n\"\nmessage\n))))\ndispatch\n))\n以下の手続はレジスタにアクセスするために使用されます。\n(\ndefine\n(\nget-contents\nregister\n) (\nregister\n'get\n))\n(\ndefine\n(\nset-contents!\nregister\nvalue\n)\n((\nregister\n'set\n)\nvalue\n))\nスタック\nスタックもまた局所状態を持つ手続として表現されます。手続\nmake-stack\nは局所状態がスタック上のアイテム\n(\n項目\n)\nのリストから成るスタックを作成\nします。スタックはスタック上にアイテムを\npush\nとスタックから最上位のア\nイテムを取り去りそれを返す\npop\n、スタックを空に初期化する\ninitialize\nの\nリクエストを受け付けます。\n(\ndefine\n(\nmake-stack\n)\n(\nlet\n((\ns\n'\n()))\n(\ndefine\n(\npush\nx\n) (\nset!\ns\n(\ncons\nx\ns\n)))\n(\ndefine\n(\npop\n)\n(\nif\n(\nnull?\ns\n)\n(\nerror\n\"\nEmpty\nstack\n:\nPOP\n\"\n)\n(\nlet\n((\ntop\n(\ncar\ns\n)))\n(\nset!\ns\n(\ncdr\ns\n))\ntop\n)))\n(\ndefine\n(\ninitialize\n)\n(\nset!\ns\n'\n())\n'done\n)\n(\ndefine\n(\ndispatch\nmessage\n)\n(\ncond\n((\neq?\nmessage\n'push\n)\npush\n)\n((\neq?\nmessage\n'pop\n) (\npop\n))\n((\neq?\nmessage\n'initialize\n) (\ninitialize\n))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nSTACK\n\"\n555","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":581},{"id":"./test/fixtures/pdf/sicp.pdf:582","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"message\n))))\ndispatch\n))\n以下の手続はスタックへのアクセスに使用されます。\n(\ndefine\n(\npop\nstack\n) (\nstack\n'pop\n))\n(\ndefine\n(\npush\nstack\nvalue\n) ((\nstack\n'push\n)\nvalue\n))\n基本的な機械\nFigure 5.13\nに示す\nmake-new-machine\n手続は局所状態がスタック、初期値\nが空の命令列、初期値がスタックを初期化する命令を持つ命令のリスト、初期\n値として\n2\nつのレジスタ\nflag\n(\nフラグ\n)\nと\npc\n(“program counter”\n、プログラム\nカウンタ\n)\nを持つ\nregister table\n(\nレジスタテーブル\n)\nから成り立ちます。内部手\n続\nlookup-register\nはテーブル内のレジスタを探します。\nflag\nレジスタはシミュレートされる機械にて分岐をコントロールするため\nに使用されます。\ntest\n命令は\nflag\nの中身にテストの結果\n(\n真、または、偽\n)\nを\n設定します。\nbranch\n命令は分岐するかしないかを\nflag\nの中身を調査して決定\nします。\npc\nレジスタは機械が実行する命令の順序付けを決定します。この順序付け\nは内部手続\nexecute\nにより実装されています。シミュレーションモデルでは各\n機械命令は\ninstruction execution procedure\n(\n命令実行手続\n)\nと呼ばれる引数無し\nの手続を含むデータ構造であり、この手続を呼ぶことにより命令の実行をシミ\nュレートします。シミュレーションが実行されるにつれ、\npc\nは次に実行される\n命令から始まる命令列の地点を指します。\nexecute\nはその命令を得て、それを\n命令実行手続を呼ぶことにより実行し、このサイクルを実行する命令が無くな\nるまで\n(\nすなわち、\npc\nが命令列の最後を指すまで\n)\n繰り返します。\n556","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":582},{"id":"./test/fixtures/pdf/sicp.pdf:583","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 5.13:\n↓\n基本の機械モデルを実装する\nmake-new-machine\n手続\n(\ndefine\n(\nmake-new-machine\n)\n(\nlet\n((\npc\n(\nmake-register\n'pc\n))\n(\nflag\n(\nmake-register\n'flag\n))\n(\nstack\n(\nmake-stack\n))\n(\nthe-instruction-sequence\n'\n()))\n(\nlet\n((\nthe-ops\n(\nlist\n(\nlist\n'initialize-stack\n(\nlambda\n() (\nstack\n'initialize\n)))))\n(\nregister-table\n(\nlist\n(\nlist\n'pc\npc\n) (\nlist\n'flag\nflag\n))))\n(\ndefine\n(\nallocate-register\nname\n)\n(\nif\n(\nassoc\nname\nregister-table\n)\n(\nerror\n\"\nMultiply\ndefined\nregister\n:\n\"\nname\n)\n(\nset!\nregister-table\n(\ncons\n(\nlist\nname\n(\nmake-register\nname\n))\nregister-table\n)))\n'register-allocated\n)\n(\ndefine\n(\nlookup-register\nname\n)\n(\nlet\n((\nval\n(\nassoc\nname\nregister-table\n)))\n(\nif\nval\n(\ncadr\nval\n)\n(\nerror\n\"\nUnknown\nregister\n:\n\"\nname\n))))\n(\ndefine\n(\nexecute\n)\n(\nlet\n((\ninsts\n(\nget-contents\npc\n)))\n(\nif\n(\nnull?\ninsts\n)\n'done\n(\nbegin\n((\ninstruction-execution-proc\n(\ncar\ninsts\n)))\n(\nexecute\n)))))\n(\ndefine\n(\ndispatch\nmessage\n)\n(\ncond\n((\neq?\nmessage\n'start\n)\n(\nset-contents!\npc\nthe-instruction-sequence\n)\n(\nexecute\n))\n((\neq?\nmessage\n'install-instruction-sequence\n)\n(\nlambda\n(\nseq\n)\n557","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":583},{"id":"./test/fixtures/pdf/sicp.pdf:584","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nset!\nthe-instruction-sequence\nseq\n)))\n((\neq?\nmessage\n'allocate-register\n)\nallocate-register\n)\n((\neq?\nmessage\n'get-register\n)\nlookup-register\n)\n((\neq?\nmessage\n'install-operations\n)\n(\nlambda\n(\nops\n)\n(\nset!\nthe-ops\n(\nappend\nthe-ops\nops\n))))\n((\neq?\nmessage\n'stack\n)\nstack\n)\n((\neq?\nmessage\n'operations\n)\nthe-ops\n)\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nMACHINE\n\"\nmessage\n))))\ndispatch\n)))\n工程の一部として、各命令の実行手続は\npc\nを変更し次に実行される命令を指\nすようにします。\nbranch\nと\ngoto\n命令は\npc\nを変更し新しい行き先を指すよう\nにします。全ての他の命令は単純に\npc\nを進めて列の次の命令を指すようにし\nます。各\nexecute\nの呼出が\nexecute\nを再び呼び出すことに中止して下さい。こ\nれはしかし無限ループにはなりません。命令実行手続の実行は\npc\nの中身を変\n更するためです。\nmake-new-machine\nは\ndispatch\n手続を返します。これは内部の状態にアク\nセスするメッセージパッシングを実装します。機械の開始は\npc\nに命令列の最\n初を設定し、\nexecute\nを呼ぶことにより達成されることに注意して下さい。\n利便性のために、機械の\nstart\n命令の代替となる手続のインターフェイス\nを提供します。同様に、レジスタの中身の設定、試験の手続も\nSection 5.2\nの最\n初にて指示されたように提供します。\n(\ndefine\n(\nstart\nmachine\n) (\nmachine\n'start\n))\n(\ndefine\n(\nget-register-contents\nmachine\nregister-name\n)\n(\nget-contents\n(\nget-register\nmachine\nregister-name\n)))\n(\ndefine\n(\nset-register-contents!\nmachine\nregister-name\nvalue\n)\n(\nset-contents!\n(\nget-register\nmachine\nregister-name\n)\nvalue\n)\n'done\n)\nこれらの手続\n(\nと\nSection 5.2.2\nと\nSection 5.2.3\nの多くの手続\n)\nは以下を用いて与\nえられた機械とレジスタ名のレジスタを探します。\n558","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":584},{"id":"./test/fixtures/pdf/sicp.pdf:585","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nget-register\nmachine\nreg-name\n)\n((\nmachine\n'get-register\n)\nreg-name\n))\n5.2.2\nアセンブラ\nアセンブラはコントローラの機械のための式の列を対応する機械の命令の\nリストへと変形します。各命令はその実行手続を持ちます。概して、アセンブ\nラは\nChapter 4\nで学習した評価機にとても似ています。入力言語が存在し\n(\nこの\n場合にはレジスタマシン言語\n)\n、言語の式の各型に対して適切なアクションを\n実行しなければなりません。\n各命令のための実行手続を生成する技術は\nSection 4.1.7\nで実行時に実行か\nら分析を分離することで高速化するために用いたのものと同じです。\nChapter\n4\nで学んだように、\nScheme\nの式の多くの実用的な分析は変数の実際の値を知ら\nなくとも実行することができました。ここでも同様に、レジスタマシン言語の\n式の多くの実用的な分析が実際の機械のレジスタの値を知ることなしに実行す\nることができます。例えばレジスタへの参照をレジスタオブジェクトへのポイ\nンタにより置き換えたり、ラベルをラベルが指定する命令列内の地点へのポイ\nンタで置き換えることができます。\nアセンブラが命令実行手続を生成する前に、全てのテーブルが何を参照す\nるのか知っておく必要がります。そのためコントローラテキストを走査し命令\nからラベルを分離することから始めます。アセンブラがテキストを走査するに\nつれ、命令のリストと各ラベルをそのリスト内部を指すポインタと関連付ける\nテーブルの両方を構築します。そうしたらアセンブラは命令リストを各命令に\n対する実行手続を挿入することで増補します。\nassemble\n手続はアセンブラに対する主な入口です。コントローラテキス\nトとマシンモデルを引数として取り、モデルに格納するべき命令列を返しま\nす。\nassemble\nは\nextract-labels\nを呼び初期命令リストと与えられたコント\nローラテキストからラベルテーブルを構築します。\nextract-labels\nの\n2\nつ目\nの引数はこれらの結果を処理するために呼ばれるべきものです。この手続は\nupdate-insts!\nを用いて命令実行手続を再生し、それらを命令リストの中に挿\n入し、変更されたリストを返します。\n(\ndefine\n(\nassemble\ncontroller-text\nmachine\n)\n(\nextract-labels\ncontroller-text\n(\nlambda\n(\ninsts\nlabels\n)\n559","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":585},{"id":"./test/fixtures/pdf/sicp.pdf:586","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nupdate-insts!\ninsts\nlabels\nmachine\n)\ninsts\n)))\nextract-labels\nは引数としてリスト\ntext\n(\nコントローラ命令式の列\n)\nと\nreceive\n手続を取ります。\nreceive\nは\n2\nつの値と共に呼び出されます。\n(1)\n命令データ\n構造のリスト\ninsts\nはそれぞれが\ntext\nからの命令を含みます。\n(2)\nテーブル\nlabels\nは\ntext\nからの各ラベルとそのラベルが指定するリスト\ninsts\n内の位置\nとを関連付けします。\n(\ndefine\n(\nextract-labels\ntext\nreceive\n)\n(\nif\n(\nnull?\ntext\n)\n(\nreceive\n'\n()\n'\n())\n(\nextract-labels\n(\ncdr\ntext\n)\n(\nlambda\n(\ninsts\nlabels\n)\n(\nlet\n((\nnext-inst\n(\ncar\ntext\n)))\n(\nif\n(\nsymbol?\nnext-inst\n)\n(\nreceive\ninsts\n(\ncons\n(\nmake-label-entry\nnext-inst\ninsts\n)\nlabels\n))\n(\nreceive\n(\ncons\n(\nmake-instruction\nnext-inst\n)\ninsts\n)\nlabels\n)))))))\nextract-labels\nは連続して\ntext\nの要素を走査し、\ninsts\nと\nlabels\nを集積す\nることで働きます。もし要素がシンボル\n(\n従ってラベル\n)\nなら適切なエントリ\nが\nlabels\nテーブルに追加されます。そうでなければその要素は\ninsts\nリスト\n上に集積されます。\n4\n4\nreceive\n手続をここで使用するのは\nextract-labels\nを得て、効率的に\n2\nつの値、\nlabels\nと\ninsts\nをそれを保持する複合データ構造を明示的に作ること無しに返すため\nの方法です。代替となる、明示的に値のペアを返す実装は以下の通りです。\n(\ndefine\n(\nextract-labels\ntext\n)\n(\nif\n(\nnull?\ntext\n)\n(\ncons\n'\n()\n'\n())\n(\nlet\n((\nresult\n(\nextract-labels\n(\ncdr\ntext\n))))\n(\nlet\n((\ninsts\n(\ncar\nresult\n)) (\nlabels\n(\ncdr\nresult\n)))\n(\nlet\n((\nnext-inst\n(\ncar\ntext\n)))\n560","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":586},{"id":"./test/fixtures/pdf/sicp.pdf:587","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"update-insts!\nは命令リストを変更します。これは初期値としては命令の\nテキストのみを含みますが、対応する実行手続を含むようになります。\n(\ndefine\n(\nupdate-insts!\ninsts\nlabels\nmachine\n)\n(\nlet\n((\npc\n(\nget-register\nmachine\n'pc\n))\n(\nflag\n(\nget-register\nmachine\n'flag\n))\n(\nstack\n(\nmachine\n'stack\n))\n(\nops\n(\nmachine\n'operations\n)))\n(\nfor-each\n(\nlambda\n(\ninst\n)\n(\nset-instruction-execution-proc!\ninst\n(\nmake-execution-procedure\n(\ninstruction-text\ninst\n)\nlabels\nmachine\npc\nflag\nstack\nops\n)))\ninsts\n)))\nマシン語データ構造は単純に命令テキストと対応する実行手続のペアを作りま\nす。実行手続は\nextract-labels\nが命令を構築した時にはまだ存在せず、後に\nupdate-insts!\nにより挿入されます。\n(\ndefine\n(\nmake-instruction\ntext\n) (\ncons\ntext\n'\n()))\n(\nif\n(\nsymbol?\nnext-inst\n)\n(\ncons\ninsts\n(\ncons\n(\nmake-label-entry\nnext-inst\ninsts\n)\nlabels\n))\n(\ncons\n(\ncons\n(\nmake-instruction\nnext-inst\n)\ninsts\n)\nlabels\n)))))))\nこれは\nassemble\nにより以下のように呼び出されます。\n(\ndefine\n(\nassemble\ncontroller-text\nmachine\n)\n(\nlet\n((\nresult\n(\nextract-labels\ncontroller-text\n)))\n(\nlet\n((\ninsts\n(\ncar\nresult\n)) (\nlabels\n(\ncdr\nresult\n)))\n(\nupdate-insts!\ninsts\nlabels\nmachine\n)\ninsts\n)))\nreceive\nの使用は複数の値を返す洗練された手法の実演、または単純にプログラミング\n上のトリックを見せ付けるための言い訳として考えることができます。\nreceive\nのよう\nな次に実行されるべき手続引数は\n“\n継続\n”\nと呼ばれます。\nSection 4.3.3\nで私達が継続を\namb\n評価機のバックトラック制御構造の実装に用いたのを思い出して下さい。\n561","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":587},{"id":"./test/fixtures/pdf/sicp.pdf:588","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ninstruction-text\ninst\n) (\ncar\ninst\n))\n(\ndefine\n(\ninstruction-execution-proc\ninst\n) (\ncdr\ninst\n))\n(\ndefine\n(\nset-instruction-execution-proc!\ninst\nproc\n)\n(\nset-cdr!\ninst\nproc\n))\n命令テキストはシミュレータでは使用されません。しかし、デバッグのために\n手元に置いておくと便利です。\n(\nExercise 5.16\n参照\n)\nラベルテーブルの要素はペアです。\n(\ndefine\n(\nmake-label-entry\nlabel-name\ninsts\n)\n(\ncons\nlabel-name\ninsts\n))\nテーブル内の要素は以下により検索されます。\n(\ndefine\n(\nlookup-label\nlabels\nlabel-name\n)\n(\nlet\n((\nval\n(\nassoc\nlabel-name\nlabels\n)))\n(\nif\nval\n(\ncdr\nval\n)\n(\nerror\n\"\nUndefined\nlabel\n:\nASSEMBLE\n\"\nlabel-name\n))))\nExercise 5.8:\n以下のレジスタマシンのコードは曖昧である。ラベ\nル\nhere\nが複数回、定義されているためである。\nstart\n(\ngoto\n(\nlabel\nhere\n))\nhere\n(\nassign\na\n(\nconst\n3))\n(\ngoto\n(\nlabel\nthere\n))\nhere\n(\nassign\na\n(\nconst\n4))\n(\ngoto\n(\nlabel\nthere\n))\nthere\nシミュレータが書かれているままの状態で、レジスタ\na\nの中身はコ\nントローラが\nthere\nに辿り着いた時に何になるか\n?\n手続\nextract-\nlabels\nを変更し、同じラベル名が\n2\nつの異なる地点を指し示すの\nに使用された場合にエラーを発するようにせよ。\n562","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":588},{"id":"./test/fixtures/pdf/sicp.pdf:589","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5.2.3\n各命令に対する実行手続の生成\nアセンブラは命令の実行手続を生成するために\nmake-execution-procedure\nを呼びます。\nSection 4.1.7\nの評価機の\nanalyze\n手続と同様に、これは適切な実\n行手続を生成するために命令の型に従い呼出を行います。\n(\ndefine\n(\nmake-execution-procedure\ninst\nlabels\nmachine\npc\nflag\nstack\nops\n)\n(\ncond\n((\neq?\n(\ncar\ninst\n)\n'assign\n)\n(\nmake-assign\ninst\nmachine\nlabels\nops\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'test\n)\n(\nmake-test\ninst\nmachine\nlabels\nops\nflag\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'branch\n)\n(\nmake-branch\ninst\nmachine\nlabels\nflag\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'goto\n)\n(\nmake-goto\ninst\nmachine\nlabels\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'save\n)\n(\nmake-save\ninst\nmachine\nstack\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'restore\n)\n(\nmake-restore\ninst\nmachine\nstack\npc\n))\n((\neq?\n(\ncar\ninst\n)\n'perform\n)\n(\nmake-perform\ninst\nmachine\nlabels\nops\npc\n))\n(\nelse\n(\nerror\n\"\nUnknown\ninstruction\ntype\n:\nASSEMBLE\n\"\ninst\n))))\nレジスタマシンの言語の命令の各型に対し、適切な実行手続を構築する生成器\nが存在します。これらの手続の詳細がレジスタマシン言語の構文と個別の命令\nの意味の両方を決定します。データ抽象化を用いることで全体的な実行の仕\n組みからレジスタマシンの式の詳細な構文を分離しています。これは\nSection\n4.1.2\nで評価機に対して行ったのと同様で、構文手続を用いて命令の部分を抽出\nし、分類することによります。\nassign\n命令\nmake-assign\n手続は\nassign\n命令を扱います。\n(\ndefine\n(\nmake-assign\ninst\nmachine\nlabels\noperations\npc\n)\n563","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":589},{"id":"./test/fixtures/pdf/sicp.pdf:590","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\ntarget\n(\nget-register\nmachine\n(\nassign-reg-name\ninst\n)))\n(\nvalue-exp\n(\nassign-value-exp\ninst\n)))\n(\nlet\n((\nvalue-proc\n(\nif\n(\noperation-exp?\nvalue-exp\n)\n(\nmake-operation-exp\nvalue-exp\nmachine\nlabels\noperations\n)\n(\nmake-primitive-exp\n(\ncar\nvalue-exp\n)\nmachine\nlabels\n))))\n(\nlambda\n()\n;\nassign\nに対する実行手続\n(\nset-contents!\ntarget\n(\nvalue-proc\n))\n(\nadvance-pc\npc\n)))))\nmake-assign\nはターゲットとなるレジスタ名\n(\n命令の\n2\nつ目の要素\n)\nと値の式\n(\n命令を構成するリストの残りの部分\n)\nを\nassign\n命令からセレクタを用いて抽\n出します。\n(\ndefine\n(\nassign-reg-name\nassign-instruction\n)\n(\ncadr\nassign-instruction\n))\n(\ndefine\n(\nassign-value-exp\nassign-instruction\n)\n(\ncddr\nassign-instruction\n))\nレジスタ名が\nget-register\nを用いて検索され目的のレジスタオブジェクトを\n生成します。値の式はもし値が命令の結果であるのなら\nmake-operation-exp\nに渡され、そうでなければ\nmake-primitive-exp\nに渡されます。これらの手続\n(\n以下に示されます\n)\nは値の式を構文解析しその値に対する実行手続を生成しま\nす。これは引数無しの手続で\nvalue-proc\nと呼ばれ、シミュレーションの間に\nレジスタに代入される実際の値を生成するために評価されます。レジスタ名の\n検索と値の式の構文解析の仕事はただ一度、アセンブリ時\n(\nアセンブラ実行時\n)\nに実行されることに注意して下さい。その命令がシミュレートされる度に毎回\nではありません。この仕事量の削減こそが私達が実行手続を使用する理由です。\nそしてこれが直接\nSection 4.1.7\nの評価機において、実行からプログラム分析を\n分離することにより仕事量の削減を得たことに対応します。\nmake-assign\nにより返される結果は\nassign\n命令のための実行手続です。こ\nの手続が\n(\nマシンモデルの\nexecute\n手続により\n)\n呼ばれた時に、\nvalue-proc\n手\n続を実行することにより得られた結果を目的のレジスタの中身に設定します。\nその次に\npc\nを以下の手続を実行することにより次の命令へと進めます。\n564","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":590},{"id":"./test/fixtures/pdf/sicp.pdf:591","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nadvance-pc\npc\n)\n(\nset-contents!\npc\n(\ncdr\n(\nget-contents\npc\n))))\nadvance-pc\nは\nbranch\nと\ngoto\nを除く全ての命令に対する通常の終わりです。\nTest\n,\nbranch\n,\ngoto\n命令\nmake-test\nは\ntest\n命令を同様な方法で扱います。これはテストされる条件\nを指定する式を抽出し、それに対する実行手続を生成します。シミュレーショ\nン時に、条件のための手続が呼ばれ、その結果が\nflag\nレジスタに割り当てら\nれ、\npc\nが進められます。\n(\ndefine\n(\nmake-test\ninst\nmachine\nlabels\noperations\nflag\npc\n)\n(\nlet\n((\ncondition\n(\ntest-condition\ninst\n)))\n(\nif\n(\noperation-exp?\ncondition\n)\n(\nlet\n((\ncondition-proc\n(\nmake-operation-exp\ncondition\nmachine\nlabels\noperations\n)))\n(\nlambda\n()\n(\nset-contents!\nflag\n(\ncondition-proc\n))\n(\nadvance-pc\npc\n)))\n(\nerror\n\"\nBad\nTEST\ninstruction\n:\nASSEMBLE\n\"\ninst\n))))\n(\ndefine\n(\ntest-condition\ntest-instruction\n)\n(\ncdr\ntest-instruction\n))\nbranch\n命令のための実行手続は\nflag\nレジスタの中身をチェックし、\npc\nの中身\nに分岐の目的地を設定するか\n(\n分岐が選択された場合\n)\n、または単に\npc\nを進め\nます\n(\n分岐が選択されなかった場合\n)\n。\nbranch\n命令内で指定された目的値はラ\nベルでなければならず、\nmake-branch\n手続がこのことを強制することに注意し\nて下さい。またラベルはアセンブリ時に検索され、\nbranch\n命令がシミュレート\nされる時に毎回検索される訳ではないことにも注意して下さい。\n(\ndefine\n(\nmake-branch\ninst\nmachine\nlabels\nflag\npc\n)\n(\nlet\n((\ndest\n(\nbranch-dest\ninst\n)))\n(\nif\n(\nlabel-exp?\ndest\n)\n(\nlet\n((\ninsts\n(\nlookup-label\n565","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":591},{"id":"./test/fixtures/pdf/sicp.pdf:592","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"labels\n(\nlabel-exp-label\ndest\n))))\n(\nlambda\n()\n(\nif\n(\nget-contents\nflag\n)\n(\nset-contents!\npc\ninsts\n)\n(\nadvance-pc\npc\n))))\n(\nerror\n\"\nBad\nBRANCH\ninstruction\n:\nASSEMBLE\n\"\ninst\n))))\n(\ndefine\n(\nbranch-dest\nbranch-instruction\n)\n(\ncadr\nbranch-instruction\n))\ngoto\n命令は\nbranch\nに似ていますが、目的地がラベルか、またはレジスタによ\nり指定されることが異なります。また条件分岐ではありません。\npc\nは常に新し\nい目的地に設定されます。\n(\ndefine\n(\nmake-goto\ninst\nmachine\nlabels\npc\n)\n(\nlet\n((\ndest\n(\ngoto-dest\ninst\n)))\n(\ncond\n((\nlabel-exp?\ndest\n)\n(\nlet\n((\ninsts\n(\nlookup-label\nlabels\n(\nlabel-exp-label\ndest\n))))\n(\nlambda\n() (\nset-contents!\npc\ninsts\n))))\n((\nregister-exp?\ndest\n)\n(\nlet\n((\nreg\n(\nget-register\nmachine\n(\nregister-exp-reg\ndest\n))))\n(\nlambda\n()\n(\nset-contents!\npc\n(\nget-contents\nreg\n)))))\n(\nelse\n(\nerror\n\"\nBad\nGOTO\ninstruction\n:\nASSEMBLE\n\"\ninst\n)))))\n(\ndefine\n(\ngoto-dest\ngoto-instruction\n)\n(\ncadr\ngoto-instruction\n))\n他の命令\nスタック命令の\nsave\nと\nrestore\nは単純にスタックを指定したレジスタと\n共に用いて、\npc\nを進めます。\n566","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":592},{"id":"./test/fixtures/pdf/sicp.pdf:593","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nmake-save\ninst\nmachine\nstack\npc\n)\n(\nlet\n((\nreg\n(\nget-register\nmachine\n(\nstack-inst-reg-name\ninst\n))))\n(\nlambda\n()\n(\npush\nstack\n(\nget-contents\nreg\n))\n(\nadvance-pc\npc\n))))\n(\ndefine\n(\nmake-restore\ninst\nmachine\nstack\npc\n)\n(\nlet\n((\nreg\n(\nget-register\nmachine\n(\nstack-inst-reg-name\ninst\n))))\n(\nlambda\n()\n(\nset-contents!\nreg\n(\npop\nstack\n))\n(\nadvance-pc\npc\n))))\n(\ndefine\n(\nstack-inst-reg-name\nstack-instruction\n)\n(\ncadr\nstack-instruction\n))\nmake-perform\nで扱われる最後の命令型は実行されるべきアクションのための\n実行手続を生成します。シミュレーション時にこのアクション手続が実行され\npc\nは進められます。\n(\ndefine\n(\nmake-perform\ninst\nmachine\nlabels\noperations\npc\n)\n(\nlet\n((\naction\n(\nperform-action\ninst\n)))\n(\nif\n(\noperation-exp?\naction\n)\n(\nlet\n((\naction-proc\n(\nmake-operation-exp\naction\nmachine\nlabels\noperations\n)))\n(\nlambda\n() (\naction-proc\n) (\nadvance-pc\npc\n)))\n(\nerror\n\"\nBad\nPERFORM\ninstruction\n:\nASSEMBLE\n\"\ninst\n))))\n(\ndefine\n(\nperform-action\ninst\n) (\ncdr\ninst\n))\n部分式の実行手続\nreg\n,\nlabel\n,\nまたは\nconst\n式の値はレジスタへの代入\n(\nmake-assign\n)\nのた\nめ、または演算命令の入力\n(\n下記の\nmake-operation-exp\n)\nのために必要になる\nかもしれません。以下の手続はこれらの式のための値をシミュレーションの間\nに生成するための実行手続を生成します。\n(\ndefine\n(\nmake-primitive-exp\nexp\nmachine\nlabels\n)\n567","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":593},{"id":"./test/fixtures/pdf/sicp.pdf:594","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncond\n((\nconstant-exp?\nexp\n)\n(\nlet\n((\nc\n(\nconstant-exp-value\nexp\n)))\n(\nlambda\n()\nc\n)))\n((\nlabel-exp?\nexp\n)\n(\nlet\n((\ninsts\n(\nlookup-label\nlabels\n(\nlabel-exp-label\nexp\n))))\n(\nlambda\n()\ninsts\n)))\n((\nregister-exp?\nexp\n)\n(\nlet\n((\nr\n(\nget-register\nmachine\n(\nregister-exp-reg\nexp\n))))\n(\nlambda\n() (\nget-contents\nr\n))))\n(\nelse\n(\nerror\n\"\nUnknown\nexpression\ntype\n:\nASSEMBLE\n\"\nexp\n))))\nreg\n,\nlabel\n,\nconst\n式の構文は以下により決定されます。\n(\ndefine\n(\nregister-exp?\nexp\n) (\ntagged-list?\nexp\n'reg\n))\n(\ndefine\n(\nregister-exp-reg\nexp\n) (\ncadr\nexp\n))\n(\ndefine\n(\nconstant-exp?\nexp\n) (\ntagged-list?\nexp\n'const\n))\n(\ndefine\n(\nconstant-exp-value\nexp\n) (\ncadr\nexp\n))\n(\ndefine\n(\nlabel-exp?\nexp\n) (\ntagged-list?\nexp\n'label\n))\n(\ndefine\n(\nlabel-exp-label\nexp\n) (\ncadr\nexp\n))\nassign\n,\nperform\n,\ntest\n命令は\n(\nop\n式により指定される\n)\n機械の演算命令の\n(\nreg\nと\nconst\n式により指定される\n)\nいくつかのオペランドへの適用を含むかもしれ\nません。以下の手続は\n“\n演算命令式\n”—\n命令からの演算命令とオペランドの式を\n含むリスト\n—\nに対する実行手続を生成します。\n(\ndefine\n(\nmake-operation-exp\nexp\nmachine\nlabels\noperations\n)\n(\nlet\n((\nop\n(\nlookup-prim\n(\noperation-exp-op\nexp\n)\noperations\n))\n(\naprocs\n(\nmap\n(\nlambda\n(\ne\n)\n(\nmake-primitive-exp\ne\nmachine\nlabels\n))\n(\noperation-exp-operands\nexp\n))))\n(\nlambda\n()\n(\napply\nop\n(\nmap\n(\nlambda\n(\np\n) (\np\n))\naprocs\n)))))\n568","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":594},{"id":"./test/fixtures/pdf/sicp.pdf:595","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"演算命令式の構文は以下により決定されます。\n(\ndefine\n(\noperation-exp?\nexp\n)\n(\nand\n(\npair?\nexp\n) (\ntagged-list?\n(\ncar\nexp\n)\n'op\n)))\n(\ndefine\n(\noperation-exp-op\noperation-exp\n)\n(\ncadr\n(\ncar\noperation-exp\n)))\n(\ndefine\n(\noperation-exp-operands\noperation-exp\n)\n(\ncdr\noperation-exp\n))\n演算命令式の処理が\nSection 4.1.7\nの評価機において各オペランドに対して実行\n手続を生成したことにおいて\nanalyze-application\n手続による手続の適用の\n処理にとても似ていることに注意して下さい。シミュレーション時に、オペラ\nンド手続を呼び、結果となる値に対して演算をシミュレートする\nScheme\n手続\nを適用します。シミュレーション手続は演算命令の名前を機械の演算命令テー\nブルから検索することで見つかります。\n(\ndefine\n(\nlookup-prim\nsymbol\noperations\n)\n(\nlet\n((\nval\n(\nassoc\nsymbol\noperations\n)))\n(\nif\nval\n(\ncadr\nval\n)\n(\nerror\n\"\nUnknown\noperation\n:\nASSEMBLE\n\"\nsymbol\n))))\nExercise 5.9:\n上記の機械の演算命令の取扱はそれらにラベル、定\n数、レジスタの中身上での演算を可能にする。式を処理する手続\nを変更し、演算命令がレジスタと定数のみに対して使用できるよ\nうな条件を強制するようにせよ。\nExercise 5.10:\nレジスタマシンの命令に新しい構文を設計し、シミ\nュレータを変更してその新しい構文を使用せよ。シミュレータの\n内、この節の構文手続以外を変更せずにあなたの新しい構文を実\n装することができるだろうか\n?\nExercise 5.11:\nSection 5.1.4\nで\nsave\nと\nrestore\nを導入した時、以\n下の順の様に最後に保存した物ではないレジスタに戻した場合に\n何が起こるのかは指定しなかった。\n(\nsave\ny\n)  (\nsave\nx\n)  (\nrestore\ny\n)\nrestore\nの意味に対してはいくつかの妥当な可能性が存在する。\n569","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":595},{"id":"./test/fixtures/pdf/sicp.pdf:596","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a\n(restore y)\nはスタック上に最後に保存された値を、どのレ\nジスタからその値が来たのか関係無しに\ny\nに入れる。これが\n私達のシミュレータの振舞である。この振舞の利点の活用法\nを示すため、\nSection 5.1.4\nのフィボナッチマシンから\n1\nつ命\n令を削減して見せよ。\n(\nFigure 5.12\n)\nb\n(restore y)\nはスタック上に最後に保存された値を\ny\nに入れ\nる。しかしその値が\ny\nから保存された場合のみである。そう\nでなければエラーを発する。シミュレータを変更してこのよ\nうに振る舞うようにせよ。\nsave\nを変更してスタック上に値と\n共にレジスタ名を保存しなければならない。\nc\n(restore y)\nは\ny\nの後に他のどのレジスタが保存され、取り\n出されていなくても最後に\ny\nから保存した値を\ny\nに入れる。\nシミュレータをこのように振る舞うように変更せよ。分離さ\nれたスタックを各レジスタに関連付けする必要がある。また\ninitialize-stack\n命令に全てのレジスタのスタックを初期\n化させなければならない。\nExercise 5.12:\nシミュレータは与えられたコントローラと共に機械\nを実装するために必要とされるデータパスを決定することを手助\nけするために利用することが可能である。アセンブラを拡張し以\n下の情報をマシンモデルに格納せよ。\n•\n全ての命令のリストを重複を削除し、命令の型でソートする\n(\nassign\n,\ngoto\n等\n)\n•\nエントリポイントを持つのに使用されたレジスタの\n(\n重複の\n無い\n)\nリスト。\n(\nこれらは\ngoto\n命令で参照されたレジスタで\nある\n)\n•\nsave\nまたは\nrestore\nされたレジスタの\n(\n重複の無い\n)\nリスト\n•\n各レジスタに対し、代入元の\n(\n重複の無い\n)\nリスト。\n(\n例\nえば\nFigure 5.11\nの階乗マシンのレジスタ\nval\nの入力元は\n(const 1)\nと\n((op *) (reg n) (reg val))\n).\nメッセージパッシングの機械へのインターフェイスを拡張し、こ\nの新しい情報へのアクセスを提供せよ。あなたの分析器をテスト\nするために\nFigure 5.12\nのフィボナッチマシンを定義し、構築され\nたリストを試験せよ。\n570","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":596},{"id":"./test/fixtures/pdf/sicp.pdf:597","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 5.13:\nシミュレータを変更することで、\nmake-machine\nに\n対する引数としてレジスタのリストを要求するのではなく、コン\nトローラシーケンスを使用して機械がどんなレジスタを持つのか\n決定するようにせよ。\nmake-machine\nの中でレジスタを事前に獲得\nしておく代わりに、命令のアセンブリ時の間に初めて現れた時に\n1\nつづつレジスタを獲得するようにせよ。\n5.2.4\n機械のパフォーマンスの監視\nシミュレーションは提案された機械設計の正しさを確認するためだけでは\nなく、機械のパフォーマンスを計るためにも便利です。例えば、私達のシミュ\nレータに演算中に使用されるスタック命令の数を計る\n“\nメーター\n”\nを導入する\nことができます。これを行うためには、シミュレーションを行うスタックを変\n更しスタック上にレジスタが保存された回数とスタックが到達した最大の深さ\nを追跡するにし、スタックのインターフェイスにメッセージを追加し以下のよ\nうに統計を表示するようにします。また\nmake-new-machine\n内の\nthe-ops\nを以\n下の様に初期化することで、基本的なマシンモデルにスタックの統計を表示す\nる命令を追加します。\n(\nlist\n(\nlist\n'initialize-stack\n(\nlambda\n() (\nstack\n'initialize\n)))\n(\nlist\n'print-stack-statistics\n(\nlambda\n() (\nstack\n'print-statistics\n))))\n以下が新しい版の\nmake-stack\nです。\n(\ndefine\n(\nmake-stack\n)\n(\nlet\n((\ns\n'\n())\n(\nnumber-pushes\n0)\n(\nmax-depth\n0)\n(\ncurrent-depth\n0))\n(\ndefine\n(\npush\nx\n)\n(\nset!\ns\n(\ncons\nx\ns\n))\n(\nset!\nnumber-pushes\n(+ 1\nnumber-pushes\n))\n(\nset!\ncurrent-depth\n(+ 1\ncurrent-depth\n))\n(\nset!\nmax-depth\n(\nmax\ncurrent-depth\nmax-depth\n)))\n(\ndefine\n(\npop\n)\n(\nif\n(\nnull?\ns\n)\n571","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":597},{"id":"./test/fixtures/pdf/sicp.pdf:598","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nerror\n\"\nEmpty\nstack\n:\nPOP\n\"\n)\n(\nlet\n((\ntop\n(\ncar\ns\n)))\n(\nset!\ns\n(\ncdr\ns\n))\n(\nset!\ncurrent-depth\n(-\ncurrent-depth\n1))\ntop\n)))\n(\ndefine\n(\ninitialize\n)\n(\nset!\ns\n'\n())\n(\nset!\nnumber-pushes\n0)\n(\nset!\nmax-depth\n0)\n(\nset!\ncurrent-depth\n0)\n'done\n)\n(\ndefine\n(\nprint-statistics\n)\n(\nnewline\n)\n(\ndisplay\n(\nlist\n'total-pushes\n'=\nnumber-pushes\n'maximum-depth\n'=\nmax-depth\n)))\n(\ndefine\n(\ndispatch\nmessage\n)\n(\ncond\n((\neq?\nmessage\n'push\n)\npush\n)\n((\neq?\nmessage\n'pop\n) (\npop\n))\n((\neq?\nmessage\n'initialize\n) (\ninitialize\n))\n((\neq?\nmessage\n'print-statistics\n)\n(\nprint-statistics\n))\n(\nelse\n(\nerror\n\"\nUnknown\nrequest\n:\nSTACK\n\"\nmessage\n))))\ndispatch\n))\nExercise 5.15\nから\nExercise 5.19\nはレジスタマシンシミュレータに追加できる他\nの便利な監視とデバッグの機能を説明します。\nExercise 5.14:\nFigure 5.11\nで示された階乗マシンを用いて様々な小\nさな値\n푛\nに対する\n푛!\nの演算に必要とされる\npush\nの数とスタック\nの最大深さを計れ。データから任意\n푛 > 1\nに対する\n푛!\nを求めるの\nに使用された\npush\n命令の総数とスタックの最大深度に対する\n푛\nを用いた方程式を決定せよ。それぞれが\n푛\nの線形関数であり、従\nって\n2\nつの定数により決定されることに注意せよ。統計が表示さ\nれるために、階乗マシンをスタックを初期化する命令と統計を表\n示する命令を拡張しなければならない。また機械を変更すること\nで\n푛\nに対する値を繰り返し読み込み、階乗を求め、結果を表示でき\n572","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":598},{"id":"./test/fixtures/pdf/sicp.pdf:599","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"るようにしたいと思うかもしれないだろう\n(\n我々が\nFigure 5.4\n)\nで\n丁度\ngcd\nマシンに対して行ったように\n)\n。そうすることで繰り返し\nget-register-contents\n,\nset-register-contents!\n,\nstart\nを起動\nする必要が無くなる。\nExercise 5.15:\nレジスタマシンのシミュレータに\ninstruction count-\ning\n(\n命令数カウンタ\n)\nを追加せよ。これはマシンモデルに対して実\n行された命令数を追跡させる。マシンモデルのインターフェイス\nを拡張し、命令カウンタの値を表示する物とカウンタをゼロにリ\nセットする新しいメッセージを受け入れるようにせよ。\nExercise 5.16:\nシミュレータを拡張し\ninstruction tracing\n(\n命令トレ\nーサ\n)\nを追加せよ。これは各命令が実行される前に、シミュレー\nタが命令のテキストを表示する。マシンモデルに対しトレーサを\non/off\nする\ntrace-on\nと\ntrace-off\nメッセージを受け入れるよう\nにせよ。\nExercise 5.17:\nExercise 5.16\nの命令トレーサを拡張し命令を表示す\nる前にシミュレータがコントローラシーケンス内でその命令の直\n前のラベル表示するにせよ。命令数カウンタ\n(\nExercise 5.15\n)\nに干\n渉しない方法で行うように注意すること。シミュレータに必要な\nラベル情報を維持するようにすることが必要だろう。\nExercise 5.18:\nSection 5.2.1\nの\nmake-register\n手続を変更し、レジ\nスタをトレース可能にせよ。レジスタがトレースの\non\n、\noff\nを行う\nメッセージを受け入れなければならない。レジスタがトレースさ\nれている時、そのレジスタに対する代入はレジスタの名前、レジ\nスタの古い値、代入される新しい値が表示されること。マシンモ\nデルへのインターフェイスを拡張し指定された機械のレジスタに\n対するトレーサの\non\n、\noff\nを可能にせよ。\nExercise 5.19:\nAlyssa P. Hacker\nはシミュレータ内に\nbreakpoint\n(\nブ\nレイクポイント\n)\nの機能を欲しいと思った。それにより彼女の機械\n設計を手助けするためである。あなたが彼女のためにこの機能を\n導入するために雇用された。彼女はコントローラシーケンス内で\nシミュレータが停止する場所を指定し、機械の状態を調査するこ\nとができるようにして欲しかった。あなたは以下の手続を実装し\nようとしている。\n(\nset-breakpoint\n⟨\nmachine\n⟩\n⟨\nlabel\n⟩\n⟨\nn\n⟩\n)\n573","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":599},{"id":"./test/fixtures/pdf/sicp.pdf:600","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これは与えられたラベルの後ろの\n푛\n番目の命令の直前にブレイク\nポイントを設定する。例えば、\n(\nset-breakpoint\ngcd-machine\n'test-b\n4)\n上の式はブレイクポイントを\ngcd-machine\nのレジスタ\na\nへの代入\nの直前にブレイクポイントを導入する。シミュレータがブレイクポ\nイントに到達する時、ラベルとブレークポイントのオフセットを表\n示し、命令の実行を停止しなければなりません。すると\nAlyssa\nは\nget-register-contents\nと\nset-register-contents!\nを用いてシ\nミュレートされている機械の状態を操作することが可能になる。次\nに彼女は以下を入力することで実行を続行できなければならない。\n(\nproceed-machine\n⟨\nmachine\n⟩\n)\nまた特定のブレイクポイントを以下を用いて削除できなければな\nらない。\n(\ncancel-breakpoint\n⟨\nmachine\n⟩\n⟨\nlabel\n⟩\n⟨\nn\n⟩\n)\nまたは全てのブレイクポイントを削除するためには以下を用いる。\n(\ncancel-all-breakpoints\n⟨\nmachine\n⟩\n)\n5.3\n記憶域の割当とガベージコレクション\nSection 5.4\nではレジスタマシンとしての\nScheme\n評価機をどのように実装\nするかを示します。議論を簡易化するために、私達のレジスタマシンは\nlist-\nstructured memory\n(\nリスト構造メモリ\n)\nを供えていると仮定します。この機械\nではリスト構造のデータを操作する命令はプリミティブです。そのようなメモ\nリが存在するという仮定は\nScheme\nインタプリタの制御の仕組みに集中する場\n合には有用な抽象化です。しかしこれは現在のコンピュータの実際のプリミテ\nィブなデータ操作の現実の光景を反映してはいません。\nLisp\nシステムがどのよ\nうに動作するかのより完全な理解を得るためには、リスト構造がどのように旧\n来のコンピュータのメモリに互換性のある方法で表現されるかについて調査し\nなければなりません。\nリスト構造の実装には\n2\nつの考慮点が存在します。\n1\nつは純粋に表現上の問\n題です。\nLisp\nのペアによる\n“\n箱とポインタ\n”\n構造をストレージと典型的なコン\n574","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":600},{"id":"./test/fixtures/pdf/sicp.pdf:601","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ピュータのメモリのアドレス指定能力を用いてどのように表現するか。\n2\nつ目\nの問題は演算が進行するにつれてのメモリ管理に関係します。\nLisp\nシステムの\n動作は決定的に、継続して新しいデータオブジェクトを作る能力に依存してい\nます。これらは逐次実行される\nLisp\n手続により明示的に作成されるオブジェク\nトと同様に、インタプリタ自身により作成される環境や引数リストのような構\n造も含みます。持続的な新しいデータオブジェクトの作成は無限の容量でかつ、\n高速にアドレス指定できるメモリを持つコンピュータ上では問題を起こさな\nいでしょうが、コンピュータのメモリは有限な量しかありません\n(\n残念なこと\nに\n)\n。\nLisp\nシステムは従って無限のメモリという空想をサポートする\nautomatic\nstorage allocation\n(\n自動記憶域割当\n)\nの設備を提供します。データオブジェクト\nが既に必要でなくなった時に、それに割り当てられたメモリは自動的にリサイ\nクルされ新しく構築されるデータオブジェクトに利用されます。そのような自\n動的な記憶域割当を提供する多様な技術が存在します。この節で私達が議論す\nる手法は\ngarbage collection\n(\nガベージコレクション\n、ゴミ拾い\n)\nと呼ばれます。\n5.3.1\nベクタとしてのメモリ\n伝統的なコンピュータのメモリは小さな部屋の配列だと考えることができ\nます。各部屋は情報の一片を入れることができます。各部屋は\naddress\n(\nアドレ\nス\n)\nまたは\nlocation\n(\n位置\n)\nと呼ばれる個有の名前を持ちます。典型的なメモリ\nシステムは\n2\nつのプリミティブな命令を提供します。\n1\nつは指定された位置に\n格納されたデータを取り出し、もう\n1\nつは指定された位置に新しいデータを割\nり当てます。メモリアドレスはある部屋の集合にシーケンシャル\n(\n順\n)\nなアクセ\nスをサポートするためにインクリメントすることができます。より一般的には、\n多くの重要なデータの操作はメモリアドレスをデータして扱うことを要求しま\nす。このデータはメモリ上の位置に格納でき、機械のレジスタ上で操作できな\nければいけません。リスト構造の表現はそのような\naddress arithmetic\n(\nアドレ\nス演算\n)\nの一つの応用です。\nコンピュータメモリをモデル化するためには、\nvector\n(\nベクタ\n)\nと呼ばれる\n新しい種類のデータ構造を用います。抽象的には、ベクタは複合データオブジ\nェクトであり、その個別の要素が整数の索引を用いて、索引から独立した時間\n量でアクセスすることができます。\n5\nメモリ操作を説明するために、ベクタを\n扱うための\n2\nつのプリミティブな\nScheme\n手続を使用します。\n5\nメモリを項目のリストとして表現することはできます。しかし、アクセス時間はその\n場合、索引から独立しません。リストの\n푛\n番目の要素へのアクセスが\n푛 − 1\n回の\ncdr\n命\n令を必要とするためです。\n575","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":601},{"id":"./test/fixtures/pdf/sicp.pdf:602","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"•\n(vector-ref <\nvector\n> <\nn\n>)\nはベクタの\n푛\n番目の要素を返す。\n•\n(vector-set! <\nvector\n> <\nn\n> <\nvalue\n>)\nはベクタの\n푛\n番目の要素に指定\nされた値を設定する。\n例えば、\nv\nがベクタであるならば、\n(vector-ref v 5)\nはベクタ\nv\nの\n5\n番目の項\n目を取得し、\n(vector-set! v 5 7)\nはベクタ\nv\nの\n5\n番目の項目の値を\n7\nに変更\nします。\n6\nコンピュータメモリに対して、このアクセスはアドレス演算を用い\nて、メモリ内のベクタの開始位置を指定する\nbase address\n(\nベース\n(\n基底\n)\nアド\nレス\n)\nとベクタの特定の項目のオフセットを指定する\nindex\n(\nインデックス\n、索\n引\n)\nを組み合わせることで実装することができます。\nLisp\nデータの表現\nベクタを用いてリスト構造メモリに対する基本的なペア構造を実装するこ\nとができます。コンピュータメモリが\n2\nつのベクタに分割されている所を想像\nしてみましょう。\nthe-cars\nと\nthe-cdrs\nです。私達は次のようにリスト構造を\n表現します。ペアに対するポイントは\n2\nつのベクタへの索引です。ペアの\ncar\nは\nthe-cars\nに指定した索引を用いた項目です。そしてペアの\ncdr\nは指定され\nた索引を用いた\nthe-cdrs\nの項目です。またペア以外のオブジェクト\n(\n例えば\n数値やシンボル\n)\nに対する表現とデータの種類をお互いに見分けるための手法\nも必要になります。これを達成する方法は多数存在しますが、しかしそれらは\n全て\ntyped pointers\n(\n型付きポインタ\n)\nの使用へと帰します。これはつまり、\n“\nポ\nインタ\n”\nの概念を拡張しデータの型の情報を含めることです。\n7\nデータの型は\nシステムにペアのポインタ\n(“\nペア\n”\nデータ型とメモリベクタを指す索引から成\nり立つ\n)\nを他の種類のデータへのポインタ\n(\n何らかの他のデータ型とその型を\n表現するために利用された何かにより成り立つ\n)\nを見分けることを可能にしま\nす。\n2\nつのデータオブジェクトはそれらのポインタが全く同じである場合に同\nじ\n(\neq?\n)\nだと判断されます。\n8\nFigure 5.14\nはこの手法を用いてリスト\n((1 2) 3\n6\n完全にするには、ベクタを構築する\nmake-vector\n命令を指定するべきです。しかし、\n現在のアプリケーションではベクタをコンピュータメモリの固定区域をモデル化するた\nめにのみ使用します。\n7\nこれは正確に\nChapter 2\nで紹介したジェネリック\n(\n総称\n)\nな命令を扱うための\n“\nタグ\n付きデータ\n”\nと同じ考えです。ここではしかし、データの型はリストの使用を通して構築\nされるのでなく、プリミティブな機械レベルにて含まれます。\n8\n型情報は\nLisp\nシステムが実装される機械の詳細に依存して多様な方法でエンコード\n(encode\n、符号化\n)\nされるでしょう。\nLisp\nプログラムの実行効率はこの選択がどれだけ明\n確に行われたかに強く依存します。しかし良い選択のための一般的な設計ルールを形式\n576","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":602},{"id":"./test/fixtures/pdf/sicp.pdf:603","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"4)\nを表現する場合を図示しています。その箱とポインタ図もまた示されてい\nます。私達は文字接頭辞をデータ型情報を示すために使用しています。従って、\nペアに対する索引\n5\nを伴なうポインタは\np5\nと示されます。空リストはポイン\nタ\ne0\nで示されます。そして数値\n4\nへのポインタは\nn4\nとして示されます。箱と\nポインタ図において各ペアの左隅にペアの\ncar\nと\ncdr\nがどこに格納されるかを\n指定するベクタの索引を表示しました。\n数値へのポインタ、例えば\nn4\nは数値データを示す型と実際の数値\n4\nの表現\nから成り立つでしょう。\n9\n単一のポインタのために獲得された固定長のメモリ\nの中で表現されるには大き過ぎる数値を扱うためには、独特な\nbignum\n(\nビッグ\nナンバー\n)\nデータ型を使うことができるでしょう。このためのポインタは格納\nされる数値の部分が格納されるリストを指定します。\n10\nシンボルはその表示内容を形成する文字の列を指定する型付きポインタとして\n表現されることができるでしょう。この列は\nLisp\nの\nreader\nにより、最初に入\n力の中の文字列に出くわした時に構築されます。\n2\nつのシンボルのインスタン\nスが\neq?\nにより\n“\n同じ\n”\nシンボルであると認識されて欲しいことと、\neq?\nにポイ\nンタの等価性のための簡単なテストになって欲しいことから、もし\nreader\nが\n同じ文字列を\n2\n回見た場合、\n(\n同じ文字列に対する\n)\n同じポインタを両方の出現\nに対して表現するために利用することを保証しなければなりません。これを達\n成するためには、\nreader\nは伝統的に\nobarray\n(\nオブジェクト配列\n)\nと呼ばれる出\n会った全てのシンボルの表を管理します。\nreader\nが文字列に遭遇しシンボルを\n構築しようとする時、\nobarray\nをチェックし同じ文字列を以前に見ていないか\n確認します。もし初見であれば、文字列を用いて新しいシンボル\n(\n新しい文字\n列に対する型付きポインタ\n)\nを構築し、このポインタを\nobarray\nに挿入します。\n化することは難しいことです。型付きポインタを実装する最も簡単な方法は固定長のビ\nット集合を各ポインタの中でデータ型をエンコードする\ntype field\n(\n型フィールド\n)\nとする\n様に割り当てしておくことです。そのような表現を設計するにおいて解決すべき重要な\n問題は次を含みます。いくつの型ビットが必要とされるか\n?\nベクタの索引の長さはどれ\nだけ必要か\n?\nどれだけ効率良くプリミティブな機械語命令がポインタの型フィールドの\n操作に使用できるか\n?\n型フィールドを効率良く扱うための特別なハードウェアを含む機\n械は\ntagged architectures\n(\nタグアーキテクチャ\n)\nを持つと言われます。\n9\nこの数値の表現上の決断はポインタの等価性をテストする\neq?\nが数値の等値性の試\n験に使用できるかどうかを決定します。もしポインタが数値それ自身を含む場合、等し\nい数値は同じポインタを持ちます。しかしもしポインタが数値が格納される位置の索引\nを持つ場合、私達が同じ数を複数の位置に格納しないことに注意しない場合に限り等し\nい数値が同じポインタになることが保証されます。\n10\nこれは丁度数値を数字の列として書くのに似ています。ただし各\n“\n桁\n”\nが\n0\nから単一\nのポインタに格納できる最大の数の間になることが異なります。\n577","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":603},{"id":"./test/fixtures/pdf/sicp.pdf:604","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"0  1  2  3  4  5\n6  7  8 ...\nIndex\nthe-cars\nthe-cdrs\np5 n3   n4 n1   n2\n...\np2 p4   e0 p7   e0\n...\n((1 2) 3 4)\n1\n2\n4\n5\n7\n4\n1\n2\n3\nFigure 5.14:\nリスト\n((1 2) 3 4)\nの\n“\n箱とポインタ\n”\nとメモ\nリベクタの表現\nもし\nreader\nが既にその文字列を見ていれば、\nobarray\nに格納されているシンボ\nルのポインタを返します。この文字列を一意なポインタで置き換える処理はシ\nンボルの\ninterning\n(\n抑留\n)\nと呼ばれます。\nプリミティブなリスト命令の実装\n上記の表現の構想を与えられた時に、レジスタマシンの各\n“\nプリミティ\nブ\n”\nなリスト命令を複数のプリミティブなベクタ命令で置き換えることができ\nます。\n2\nつのレジスタ\nthe-cars\nと\nthe-cdrs\nを用いてメモリベクタを特定し、\nvector-ref\nと\nvector-set!\nがプリミティブな命令として有効であると仮定し\nます。またポインタ上の演算命令\n(\n例えばポインタをインクリメントする、ペ\nアのポインタを用いてベクタを索引付けする、または\n2\nつの数値を足す\n)\nは型\n付きポインタの索引部分しか利用しません。\n例えば、次の命令をサポートするレジスタマシンをその下の条件の下で作成す\nることができます。\n(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nop\ncar\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n578","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":604},{"id":"./test/fixtures/pdf/sicp.pdf:605","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nop\ncdr\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n上の命令のそれぞれに対しこれらが実装されているとします。\n(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nop\nvector-ref\n) (\nreg\nthe-cars\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nop\nvector-ref\n) (\nreg\nthe-cdrs\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n以下の命令は、\n(\nperform\n(\nop\nset-car!\n) (\nreg\n⟨\n푟푒푔\n1\n⟩\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n(\nperform\n(\nop\nset-cdr!\n) (\nreg\n⟨\n푟푒푔\n1\n⟩\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n次のように実装されます。\n(\nperform\n(\nop\nvector-set!\n) (\nreg\nthe-cars\n) (\nreg\n⟨\n푟푒푔\n1\n⟩\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n(\nperform\n(\nop\nvector-set!\n) (\nreg\nthe-cdrs\n) (\nreg\n⟨\n푟푒푔\n1\n⟩\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\ncons\nは未使用の索引を割り当て、\ncons\nの引数を\nthe-cars\nと\nthe-cdrs\nの中で\n索引付けられたベクタの位置に格納します。私達は特別なレジスタ、\nfree\nが存\n在し、常に次に使用可能な索引を持つペアポインタを保つと仮定します。そし\nてそのポインタの索引部分をインクリメントすることで次の空き位置を探すこ\nとができます。\n11\n例えば、以下の命令は\n(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nop\ncons\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n) (\nreg\n⟨\n푟푒푔\n3\n⟩\n))\n次の一連のベクタ命令として実装されます。\n12\n(\nperform\n(\nop\nvector-set!\n) (\nreg\nthe-cars\n) (\nreg\nfree\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n))\n(\nperform\n(\nop\nvector-set!\n) (\nreg\nthe-cdrs\n) (\nreg\nfree\n) (\nreg\n⟨\n푟푒푔\n3\n⟩\n))\n(\nassign\n⟨\n푟푒푔\n1\n⟩\n(\nreg\nfree\n))\n(\nassign\nfree\n(\nop\n+) (\nreg\nfree\n) (\nconst\n1))\n11\n空きの記憶域を探す他の方法も存在します。例えば、全ての未使用のペアをリンクし\nて\nfree list\n(\n空きリスト\n)\nにすることもできたでしょう。私達の空き位置は連続的\n(\n従って\nポインタをインクリメントすることでアクセス可能であるため\n)\nです。なぜなら私達が圧\n縮\nGC\nを用いているためです。また\nSection 5.3.2\nも参照して下さい。\n12\nこれは本質的に\nSection 3.3.1\nで説明した\nset-car!\nと\nset-cdr!\nを用いた\ncons\nの実\n装です。その実装内で使用された命令\nget-new-pair\nはここでは\nfree\nポインタにより実\n現されています。\n579","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":605},{"id":"./test/fixtures/pdf/sicp.pdf:606","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"以下の\neq?\n命令は\n(\nop\neq?\n) (\nreg\n⟨\n푟푒푔\n1\n⟩\n) (\nreg\n⟨\n푟푒푔\n2\n⟩\n)\n単純にレジスタ内の全ての項目の等価性をテストします。そして\npair?\n,\nnull?\n,\nsymbol?\n,\nnumber?\n等のような述語は型フィールドのみを確認する必要があり\nます。\nスタックの実装\n私達のレジスタマシンはスタックを用いますが、ここでは特に特別なこと\nを行う必要がありません。スタックはリストを用いてモデル化することができ\nるためです。スタックは保存した値のリストとすることができ、特別なレジス\nタ\nthe-stack\nにより指し示されます。従って\n(save <\nreg\n>)\nは以下のように実\n装することができます。\n(\nassign\nthe-stack\n(\nop\ncons\n) (\nreg\n⟨\nreg\n⟩\n) (\nreg\nthe-stack\n))\n同様に、\n(restore <\nreg\n>)\nは次のように実装することができます。\n(\nassign\n⟨\nreg\n⟩\n(\nop\ncar\n) (\nreg\nthe-stack\n))\n(\nassign\nthe-stack\n(\nop\ncdr\n) (\nreg\nthe-stack\n))\nそして\n(perform (op initialize-stack))\nは以下のように実装することがで\nきます。\n(\nassign\nthe-stack\n(\nconst\n()))\nこれらの命令は上で与えられたベクタ命令を用いてさらに伸展されます。しか\nし、伝統的な計算機アーキテクチャにおいてはスタックを別のベクタとして割\nり当てることは通常は好都合です。そうすれば、スタックに\npush\nや\npop\nを行\nうことはベクタに対する索引をインクリメント、デクリメントすることにより\n達成することができます。\nExercise 5.20:\n以下の式から生成されるリスト構造の表現と\n(\nFig-\nure 5.14\nにあるような\n)\nメモリ\n-\nベクタ表現の箱とポインタ図を\n描け。\n(\ndefine\nx\n(\ncons\n1 2))\n(\ndefine\ny\n(\nlist\nx\nx\n))\n580","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":606},{"id":"./test/fixtures/pdf/sicp.pdf:607","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ただし、\nfree\nポインタの初期値は\np1\nとする。\nfree\nの最終的な値\nは何か\n?\nどんなポインタが\nx\nと\ny\nの値を表現するか\n?\nExercise 5.21:\n以下の手続のためのレジスタマシンを実装せよ。リ\nスト構造のメモリ命令は機械のプリミティブとして使用可能だと\n仮定せよ。\na\n再帰\ncount-leaves\n:\n(\ndefine\n(\ncount-leaves\ntree\n)\n(\ncond\n((\nnull?\ntree\n) 0)\n((\nnot\n(\npair?\ntree\n)) 1)\n(\nelse\n(+ (\ncount-leaves\n(\ncar\ntree\n))\n(\ncount-leaves\n(\ncdr\ntree\n))))))\nb\n明示的なカウンタを用いた再帰\ncount-leaves\n(\ndefine\n(\ncount-leaves\ntree\n)\n(\ndefine\n(\ncount-iter\ntree\nn\n)\n(\ncond\n((\nnull?\ntree\n)\nn\n)\n((\nnot\n(\npair?\ntree\n)) (+\nn\n1))\n(\nelse\n(\ncount-iter\n(\ncdr\ntree\n)\n(\ncount-iter\n(\ncar\ntree\n)\nn\n)))))\n(\ncount-iter\ntree\n0))\nExercise 5.22:\nSection 3.3.1\nの\nExercise 3.12\nは\n2\nつのリストを接続\nし\n1\nつの新しいリストを形成する\nappend\n手続と、\n2\nつのリストを\n一緒に繋ぎ合わせる\nappend!\n手続を紹介した。これらの手続それ\nぞれを実装するレジスタマシンを設計せよ。リスト構造のメモリ\n命令はプリミティブな命令として使用可能と前提せよ。\n5.3.2\n無限のメモリの幻想を維持する\nSection 5.3.1\nで概観した表現手法はリスト構造の実装上の問題を解決しま\nしたが、無限の容量のメモリを持っている場合という条件付きでした。実際の\nコンピュータではいつかは新しいペアを構築するための空き容量を使い切って\n581","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":607},{"id":"./test/fixtures/pdf/sicp.pdf:608","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"しまいます。\n13\nしかし、典型的な演算により生成されるペアの多くは中間結果\nを保つためだけに使用されます。これらの結果がアクセスされた後には、それ\nらのペアはもう必要ありません。それらは\ngarbage\n(\nゴミ\n)\nです。例えば、以下の\n演算は\n(\naccumulate\n+ 0 (\nfilter\nodd?\n(\nenumerate-interval\n0\nn\n)))\n2\nつのリストを構築します。\nenumaration(\n列挙\n)\nと列挙をフィルタリングした\n結果です。\naccumulation(\n集積\n)\nが完了した時に、これらのリストはもう必要あ\nりません。そして割り当てられたメモリは返還要求できます。もし全てのゴミ\nを定期的に回収する準備を行えるのであれば、そしてもしこれが新しいペアを\n構築するのと大体同じ比率でメモリをリサイクルすることになれば、無限の容\n量のメモリが存在するという錯覚を維持することができます。\nペアをリサイクルするためには、どの割り当てられたペアが必要でない\nか\n(\nそれらの中身がその後将来の演算に影響しないという意味で\n)\n決定する\n方法を持たねばなりません。これを達成するために調査する手法は\ngarbage\ncollection\n(\nガベージコレクション\n、\nGC)\nとして知られています。ガベージコレ\nクションは\nLisp\nの逐次実行における任意の時点で、将来の演算に影響を与え\nることができるオブジェクトは現状で機械のレジスタ内に存在するポインタに\nより辿り着くことができるオブジェクトのみであるという観察結果に基いてい\nます。\n14\nそのようにアクセスできないどのメモリセルもリサイクルして良いで\nしょう。\nガベージコレクションを実行する方法は数多く存在します。ここで調査す\nる手法は\nstop-and-copy\nと呼ばれます。基本的な考えはメモリを\n2\nつに割りま\nす。\n“\nワーキングメモリ\n”\nと\n“\n空きメモリ\n”\nです。\ncons\nがペアを構築する時、ワ\nーキングメモリに割り当てます。ワーキングメモリに空きが無い時、ワーキン\n13\nこれはいつかは正しくはなくなるかもしれません。なぜならメモリが十分に大きく\nなればコンピュータの生存時間の間には空きメモリを使い切ることは不可能になるかも\nしれないからです。例えば一年は\n3 ⋅ 10\n13\nマイクロ秒ですから、もし\n1\nマイクロ秒に\n1\n回\ncons\nを行うのであれば、\n30\n年間はメモリを使い切ることのないコンピュータを構築\nするのには約\n10\n15\nセルのメモリを必要とします。それだけのメモリは今日の標準では\n話にならない程大きく見えますが、しかし物理的に不可能ではありません。一方で、プ\nロセッサはより速くなりつつあり未来のコンピュータは数多くのプロセッサを並列に単\n一のメモリ上で作動するかもしれません。従って私達の前提よりもよい早くメモリを使\nい切ることが可能かもしれません。\n14\nここではスタックは\nSection 5.3.1\nで説明されたリストとして表現されていると仮定\nしています。そのためスタック上の項目はスタックレジスタ内のポインタを通してアク\nセスすることができます。\n582","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":608},{"id":"./test/fixtures/pdf/sicp.pdf:609","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"グメモリ内の使い道のある全てのペアを探し出し、これらをフリーメモリ内の\n連続した位置にコピーすることでガベージコレクションを実行します。\n(\n使い\n道のあるペアは機械のレジスタから始めて、全ての\ncar\nと\ncdr\nのポインタを追\n跡することにより探し出します\n)\n。ゴミはコピーしないため、推定上、新しい\nペアを割り当てるための利用できる追加の空きメモリが存在するはずです。加\nえて、ワーキングメモリ内の全てが必要ありません。その中の使い道のあるペ\nアはコピーされています。従ってワーキングメモリと空きメモリの役割を交換\nすれば、処理を続けることができます。新しいペアは新しいワーキングメモリ\n(\n空きメモリだった物\n)\nの中に割り当てられます。これがいっぱいになったなら、\n使い道のあるペアを新しい空きメモリ\n(\nワーキングメモリだったもの\n)\nの中に\nコピーできます。\n15\nstop-and-copy\nガベージコレクタの実装\n今から私達はレジスタマシン言語を用いて\nstop-and-copy\nアルゴリズムを\nより詳細に記述します。私達は\nroot\nと呼ばれるレジスタが存在し、ある構造体\nへのポインタを保持し、そのポインタから最終的には全てのアクセス可能なデ\n15\nこの考えは\nMinsky(\nミンスキー\n)\nにより発明され、\nmit\n研究所の電子工学ラボの\nPDP-1\nに対する\nLisp\nの実装の一部として実装されました。\nFenichel and Yochelson\n(1969)\nにより\nMultics\n時分割システムの\nLisp\n実装で使用するために、さらに開発が進め\nられました。後に、\nBaker (1978)\nはこの手法の\n“\nリアルタイム\n”\n版を開発しました。こ\nれはガベージコレクションの間に演算を停止する必要がありません。\nBaker\nの考えは\nHewitt, Lieberman, Moon\nにより拡張され\n(\nLieberman and Hewitt 1983\n参照\n)\n、ある構\n造は\nvolatile(\n揮発性\n)\nであり、別の構造はより永続的であるといった事実を活用する様に\nなりました。\n一般に利用される代替的なガベージコレクションの技術は\nmark-sweep\n(\nマークアンド\nスイープ\n)\nの手法です。これは回帰のレジスタからアクセス可能な全ての構造の追跡と辿\nり着く各ペアへのマーキングから成り立ちます。次に全てのメモリを走査し、マークの\n無い全てのメモリはゴミとして\n“\n掃き出し\n”\n、再使用可能とされます。マークアンドスイ\nープの十分な議論は\nAllen 1978\nの中に見つけられます。\nMinsky-Fenichel-Yochelson\nアルゴリズムは巨大なメモリシステムに対する使用にお\nける支配的なアルゴリズムです。メモリの使い道のある部分のみを調査するためです。こ\nれはスイープの段階で全てのメモリを確認しなければならない\nmark-and-sweep\nとは対\n照的です。\nstop-and-copy\nの\n2\nつ目の強みは\ncompacting\n(\n圧縮\n)\nガベージコレクタである\nことです。つまり、ガベージコレクションの段階の終わりには使い道のあるデータは連\n続したメモリ位置に移動され、全てのゴミペアは圧縮の仮定で外に出されます。このこ\nとが仮想メモリを使用する機械におけるパフォーマンス上の考慮において非常に重要と\n成り得ます。仮想メモリを使用する機械は広範囲に分離されたメモリアドレスへのアク\nセスに余計なページング処理が必要となるかもしれません。\n583","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":609},{"id":"./test/fixtures/pdf/sicp.pdf:610","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ータを指し示すことができるという前提を行います。これはガベージコレクシ\nョンを行う直前に全てのレジスタの中身を事前に割り当てられたリストに格納\nし、\nroot\nにより指し示させることで準備が行えます。\n16\n私達はまた現在のワ\nーキングメモリに加えて、使い道のあるデータをコピーできる空きメモリが存\n在すると前提します。現在のワーキングメモリはベースアドレスが\nthe-cars\nと\nthe-cdrs\nと呼ばれるレジスタに格納されるベクタから成り立ち、そして空\nきメモリは同様に\nnew-cars\nと\nnew-cdrs\nと呼ばれるレジスタに格納されます。\nガベージコレクションは現在のワーキングメモリ内の空きセルが枯渇した\n時に引き起こされます。それはつまり、\ncons\n命令が\nfree\nポインタをメモリベ\nクタの終端を越えてインクリメントしようとした時です。ガベージコレクショ\nンの処理が完了した時、\nroot\nポインタは新しいメモリの中を指し示し、\nroot\nからアクセス可能な全てのオブジェクトは新しいメモリに移動されています。\nそして\nfree\nポインタは新しいメモリ内の新しいペアを割り当てられる次の位\n置を示します。加えて、ワーキングメモリと新しいメモリの役割が交換されま\nす。新しいペアは\nfree\nにより指し示される位置から始まる新しいメモリ内に\n構築され、\n(\n以前の\n)\nワーキングメモリは次のガベージコレクションに対する新\nしいメモリとして使用可能となります。\nFigure 5.15\nはガベージコレクション直\n前、直後のメモリの割り振りを示します。\nガベージコレクション処理の状態は\n2\nつのポインタを管理することによりコン\nトロールされています。\nfree\nと\nscan\nです。これらは新しいメモリの開始位置\nを指し示すように初期化されます。アルゴリズムは\nroot\nにより指し示される\nペアの新しいメモリの開始位置への再配置から開始されます。ペアはコピーさ\nれ、\nroot\nポインタは新しい位置を指すように調整されます。そして\nfree\nポイ\nンタがインクリメントされます。併せて、ペアの古い位置はその中身が移動さ\nれたことを示すマークが付けられます。このマーキングは次のように行われま\nす。\ncar\nの位置にはこれが既に移動されたオブジェクトであることを示す特別\nなタグを置きます。\n(\nそのようなオブジェクトは伝統的に\nbroken heart\n(\n失恋\n)\nと\n呼ばれます。\n)\n17\ncdr\nの位置には\nforwarding address\n(\n転送先\n)\nを置きます。これ\nはオブジェクトの移動先の位置を指し示します。\nroot\nの再配置の後に、ガベージコレクタは基本となるサイクルに入ります。\nアルゴリズムの各ステップにおいて、\nscan\nポインタ\n(\n初期値として再配置後の\nroot\nを指す\n)\nは、新しいメモリに移動されたがその\ncar\nと\ncdr\nのポインタが依\n16\nこのレジスタのリストは記憶域割当システムのレジスタ\n—\nroot\n,\nthe-cars\n,\nthe-\ncdrs\n,\nそれにこの節で紹介される他のレジスタは含みません。\n17\nbroken heart\nという用語は\nDavid Cressey\nにより作られました。彼は\n1970\n年代初期\nの間に\nmit\nで開発された\nLisp\nの方言、\nMDL\nのためにガベージコレクタを書きました。\n584","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":610},{"id":"./test/fixtures/pdf/sicp.pdf:611","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"free\nfree\nJust before garbage collection\nmixture of useful data and garbage\nfree memory\nJust aer garbage collection\ndiscarded memory\nuseful data\nfree area\nworking\nmemory\nfree\nmemory\nnew\nfree\nmemory\nnew\nworking\nmemory\nthe-cars\nthe-cdrs\nthe-cars\nthe-cdrs\nnew-cars\nnew-cdrs\nnew-cars\nnew-cdrs\nFigure 5.15:\nガベージコレクションプロセスによるメモリ\nの再構成\n585","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":611},{"id":"./test/fixtures/pdf/sicp.pdf:612","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"然として古いメモリ内のオブジェクトを参照しているペアを指します。これら\nのオブジェクトはそれぞれが再配置され、\nscan\nポインタはインクリメントさ\nれます。オブジェクト\n(\n例えば走査しているペアの\ncar\nポインタにより指され\nたオブジェクト\n)\nを再配置するためにはそのオブジェクトが既に移動されてい\nないかを\n(\nそのオブジェクトの\ncar\nの位置内に\nbroken-heart\nタグが存在するこ\nにより示されていないか\n)\n確認します。もしオブジェクトがまだ移動されてい\nなければ、それを\nfree\nにより示される位置にコピーし、\nfree\nを更新し、オブ\nジェクトの古い位置に\nbroken-heart\nを設定し、そのオブジェクトへのポインタ\nを\n(\nこの礼では、走査しているペアの\ncar\nポインタを\n)\n更新し、新しい位置を指\nすようにします。もしオブジェクトが既に移動されている場合には、\n(broken\nheart\nの\ncdr\nの位置に見つかる\n)\nその移動先は走査中のペアのポインタに置き\n換えられます。最終的には、\nscan\nポインタが\nfree\nポインタを追い越す時点ま\nで、全てのアクセス可能なオブジェクトは移動され、精査されます。そして処\n理は停止します。\nstop-and-copy\nアルゴリズムをレジスタマシンの命令列として記述するこ\nとができます。オブジェクトの再配置の基本的なステップは\nrelocate-old-\nresult-in-new\nと呼ばれるサブルーチンにて達成されます。このサブルーチン\nはその引数として再配置するオブジェクトのポインタを\nold\nという名のレジス\nタから取得します。これは指定されたオブジェクトを再配置し、\n(\n処理の間に\nfree\nをインクリメントし\n)\n、再配置されたオブジェクトを指すポインタを\nnew\nと呼ばれるレジスタに入れます。そして\nrelocate-continue\nレジスタに格納\nされたエントリポイントへ分岐することで帰ります。ガベージコレクションを\n始めるために、このサブルーチンを起動して、\nfree\nと\nscan\nを初期化した後に\nroot\nポインタを再配置します。\nroot\nの再配置が完了した時に、\nnew\nポインタを\n新しい\nroot\nとして導入し、ガベージコレクタのメインループに入ります。\nbegin-garbage-collection\n(\nassign\nfree\n(\nconst\n0))\n(\nassign\nscan\n(\nconst\n0))\n(\nassign\nold\n(\nreg\nroot\n))\n(\nassign\nrelocate-continue\n(\nlabel\nreassign-root\n))\n(\ngoto\n(\nlabel\nrelocate-old-result-in-new\n))\nreassign-root\n(\nassign\nroot\n(\nreg\nnew\n))\n(\ngoto\n(\nlabel\ngc-loop\n))\nガベージコレクタのメインループでは走査すべきオブジェクトが残っているの\n586","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":612},{"id":"./test/fixtures/pdf/sicp.pdf:613","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"か決定しなければなりません。これを\nscan\nポインタが\nfree\nポインタと一致\nするかどうかを試験することで行います。もしポインタが等しければ、全ての\nアクセス可能なオブジェクトの再配置は完了し、\ngc-flip\nへと分岐します。こ\nこは後片付けを行い、割り込みが行われた演算を継続します。もしまだ走査す\nべきペアが残っているのであれば、再配置\n(relocate)\nのサブルーチンを呼び出\nし次のペアの\ncar\nを\n(\nold\n内の\ncar\nポインタを配置することで\n)\n再配置します。\nrelocate-continue\nレジスタの設定によりサブルーチンは\ncar\nポインタを更\n新するために帰ります。\ngc-loop\n(\ntest\n(\nop\n=) (\nreg\nscan\n) (\nreg\nfree\n))\n(\nbranch\n(\nlabel\ngc-flip\n))\n(\nassign\nold\n(\nop\nvector-ref\n) (\nreg\nnew-cars\n) (\nreg\nscan\n))\n(\nassign\nrelocate-continue\n(\nlabel\nupdate-car\n))\n(\ngoto\n(\nlabel\nrelocate-old-result-in-new\n))\nupdate-car\nにて、精査しているペアの\ncar\nポインタを変更します。次にペア\nの\ncdr\nを再配置するために向かいます。再配置が完了すると\nupdate-cdr\nに帰\nってきます。再配置と\ncdr\nの更新の後に、そのペアの精査を完了しメインルー\nプを継続します。\nupdate-car\n(\nperform\n(\nop\nvector-set!\n)\n(\nreg\nnew-cars\n)\n(\nreg\nscan\n)\n(\nreg\nnew\n))\n(\nassign\nold\n(\nop\nvector-ref\n) (\nreg\nnew-cdrs\n) (\nreg\nscan\n))\n(\nassign\nrelocate-continue\n(\nlabel\nupdate-cdr\n))\n(\ngoto\n(\nlabel\nrelocate-old-result-in-new\n))\nupdate-cdr\n(\nperform\n(\nop\nvector-set!\n)\n(\nreg\nnew-cdrs\n)\n(\nreg\nscan\n)\n(\nreg\nnew\n))\n(\nassign\nscan\n(\nop\n+) (\nreg\nscan\n) (\nconst\n1))\n(\ngoto\n(\nlabel\ngc-loop\n))\n587","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":613},{"id":"./test/fixtures/pdf/sicp.pdf:614","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"サブルーチン\nrelocate-old-result-in-new\nはオブジェクトを次のように再配\n置します。もし\n(\nold\nにより指し示される\n)\n再配置すべきオブジェクトがペア\nでないなら、そのオブジェクトへの同じポインタを変更無しで\n(\nnew\nの中で\n)\n返します。\n(\n例えば、\ncar\nが数値の\n4\nであるペアを精査しているとします。も\nし\nSection 5.3.1\nにて説明されているように\nn4\nで\ncar\nを表現するのなら、\n“\n再配\n置された\n”\ncar\nのポインタも依然として\nn4\nであって欲しいと願うはずです\n)\n。そ\nうでなければ、再配置を実行しなければなりません。もしペアの再配置すべき\ncar\nの位置に\nbroken-heart\nタグを持つのならば、そのペアは実際には既に移動\nされています。従って\n(broken-heart\nの\ncdr\nの位置から\n)\n移動先を取得し、これ\nを\nnew\nに入れて返します。もし\nold\n内のポインタがまだ移動されていないペア\nを指す場合、そのペアを\n(\nfree\nが指し示す\n)\n新しいメモリの最初の空きセルに移\n動させ、\nbroken-heart\nタグと移動先を元の位置に格納することで\nbroken-heart\nを設定します。\nrelocate-old-result-in-new\nはレジスタ\noldcr\nを用いて\nold\nにより指し示されるオブジェクトの\ncar\nまたは\ncdr\nを保持します。\n18\nrelocate-old-result-in-new\n(\ntest\n(\nop\npointer-to-pair?\n) (\nreg\nold\n))\n(\nbranch\n(\nlabel\npair\n))\n(\nassign\nnew\n(\nreg\nold\n))\n(\ngoto\n(\nreg\nrelocate-continue\n))\npair\n(\nassign\noldcr\n(\nop\nvector-ref\n) (\nreg\nthe-cars\n) (\nreg\nold\n))\n(\ntest\n(\nop\nbroken-heart?\n) (\nreg\noldcr\n))\n(\nbranch\n(\nlabel\nalready-moved\n))\n(\nassign\nnew\n(\nreg\nfree\n))\n;\nペアの新しい位置\n;;\nfree\nポインタを更新する\n(\nassign\nfree\n(\nop\n+) (\nreg\nfree\n) (\nconst\n1))\n;;\ncar\nと\ncdr\nを新しいメモリにコピーする\n.\n(\nperform\n(\nop\nvector-set!\n)\n(\nreg\nnew-cars\n) (\nreg\nnew\n) (\nreg\noldcr\n))\n(\nassign\noldcr\n(\nop\nvector-ref\n) (\nreg\nthe-cdrs\n) (\nreg\nold\n))\n18\nガベージコレクタは低レベルの述語\npointer-to-pair?\nをリスト構造\npair?\n命令の\n代わりに使用します。実際のシステムでは様々な物がガベージコレクションの目的のた\nめにペアとして扱われるためです。例えば、\nieee\n標準に準拠する\nScheme\nシステムでは\n手続オブジェクトは特別な種類の\n“\nペア\n”\nとして実装されても良くこれは述語\npair?\nは\n満たしません。シミュレーションの目的には、\npointer-to-pair?\nは\npair?\nとして実装で\nきます。\n588","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":614},{"id":"./test/fixtures/pdf/sicp.pdf:615","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nperform\n(\nop\nvector-set!\n)\n(\nreg\nnew-cdrs\n) (\nreg\nnew\n) (\nreg\noldcr\n))\n;;\nブロークンハートの構築\n(\nperform\n(\nop\nvector-set!\n)\n(\nreg\nthe-cars\n) (\nreg\nold\n) (\nconst\nbroken-heart\n))\n(\nperform\n(\nop\nvector-set!\n) (\nreg\nthe-cdrs\n) (\nreg\nold\n) (\nreg\nnew\n))\n(\ngoto\n(\nreg\nrelocate-continue\n))\nalready-moved\n(\nassign\nnew\n(\nop\nvector-ref\n) (\nreg\nthe-cdrs\n) (\nreg\nold\n))\n(\ngoto\n(\nreg\nrelocate-continue\n))\nガベージコレクション処理の最後に、メモリの新旧の役割をポインタを交換\nすることにより交代します。\nthe-cars\nと\nnew-cars\n、そして\nthe-cdrs\nを\nnew-\ncdrs\nを交換します。これで次回メモリが枯渇した時にもう一度ガベージコレ\nクションを行う準備ができます。\ngc-flip\n(\nassign\ntemp\n(\nreg\nthe-cdrs\n))\n(\nassign\nthe-cdrs\n(\nreg\nnew-cdrs\n))\n(\nassign\nnew-cdrs\n(\nreg\ntemp\n))\n(\nassign\ntemp\n(\nreg\nthe-cars\n))\n(\nassign\nthe-cars\n(\nreg\nnew-cars\n))\n(\nassign\nnew-cars\n(\nreg\ntemp\n))\n5.4\n明示的制御評価機\nSection 5.1\nでは簡単な\nScheme\nプログラムをどのようにレジスタマシンの\n記述に変形するかについて学びました。ここではこの変形をより複雑なプログ\nラム上で実行します。\nSection 4.1.1\n–\nSection 4.1.4\nのメタ循環評価機です。メタ循\n環評価機は\nScheme\nインタプリタの振舞が手続\neval\nと\napply\nと用いてどのよ\nうに説明できるかを示しました。この節で開発する\nexplicit-control evaluator\n(\n明\n示的制御評価機\n)\nは評価過程にて使用される潜在的な手続呼出と引数受け渡し\nの仕組みがレジスタとスタックの命令を用いてどのように説明できるかを示し\nます。付け加えて、明示的制御評価機は\nScheme\nインタプリタの実装としての\n役割を果たすことができ、従来の計算機の生来の機械語ととてもそっくりな言\n589","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":615},{"id":"./test/fixtures/pdf/sicp.pdf:616","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Figure 5.16:\nScheme\n評価機のシリコンチップ実装\n語で書かれています。この評価機は\nSection 5.2\nのレジスタマシンシミュレータ\nにより実行することができます。あるいは、\nScheme\n評価機の機械語実装を構\n築するための開始点として使用することができます。または\nScheme\nの式を評\n価するための特殊用途の機械にすら使用できるでしょう。\nFigure 5.16\nはそのよ\nうなハードウェア実装を示しています。\nScheme\nの評価機として働くシリコン\nチップです。このチップの設計者はこの節の中で説明される評価機に似たレジ\nスタマシンに対するデータパスとコントローラの仕様から開始しました。そし\nて\nIC(integrated-circuit\n、統合回路\n)\nを構築するための設計自動化プログラムを\n使用しました。\n19\n19\nこのチップとその設計手法についてのより多くの情報については\nBatali et al. 1982\nを\n参照して下さい。\n590","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":616},{"id":"./test/fixtures/pdf/sicp.pdf:617","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"レジスタと命令\n明示的制御評価機の設計では、私達のレジスタマシンで使用される命令を\n指定しなければなりません。私達は\nquoted?\nや\nmake-procedure\nのような手続\nを用いることで抽象構文を用いたメタ循環評価機を説明しました。レジスタマ\nシンの実装においてはこれらの手続を初歩的なリスト構造メモリの命令列に展\n開することができました。そしてこれらの命令を私達のレジスタマシン上に実\n装しました。しかし、これは私達の評価機の基本的な構造をその詳細によりわ\nかりにくくしながら、とても長くしてしまいます。その表現を明快にするため\nに、レジスタマシンのプリミティブな命令として\nSection 4.1.2\nで与えられた構\n文手続と環境を表現するための手続、それに\nSection 4.1.3\nと\nSection 4.1.4\nで与\nえられた実行時データを含めることにします。低レベルのマシン語でプログラ\nミングできる、またはハードウェアにて実装できる評価機の完全な仕様化を行\nうために、\nSection 5.3\nで説明したリスト構造の実装を用いてこれらの命令をよ\nり基本的な命令により置き換えることができるでしょう。\n私達の\nScheme\n評価機レジスタマシンはスタックと\n7\nつのレジスタを含み\nます。\nexp\n,\nenv\n,\nval\n,\ncontinue\n,\nproc\n,\nargl\n,\nunev\nです。\nexp\nは評価される式の\n保持に仕様され、\nenv\nは評価がその中で実行される環境を持ちます。評価の終\nわりには、\nval\nが指定された環境における式の評価により得られた値を保持し\nます。\ncontinue\nレジスタは\nSection 5.1.4\nで説明されたように再帰の実装に用い\nられます。\n(\n評価機はそれ自身を再帰的に呼び出す必要があります。式の評価は\nその部分式の評価を必要とするためです\n)\n。レジスタ\nproc\n,\nargl\n,\nunev\nは組み\n合わせの評価に用いられます。\n私達はデータパス図を評価機のレジスタと命令がどのように接続されてい\nるかを示すために提供はしません。また機械の命令の完全なリストの提供も行\nないません。これらは評価機のコントローラに暗黙的に存在し、コントローラ\nの詳細が与えられます。\n5.4.1\n明示制御評価機の核\n評価機の中心的な要素は\neval-dispatch\nで始まる命令列です。これは\nSection\n4.1.1\nで説明されたメタ循環評価機の\neval\n手続に対応します。コントローラが\neval-dispatch\nから開始する時、\nexp\nにより指定された式を、\nenv\nにより指定\nされた環境にて評価します。評価が完了した時には、コントローラは\ncontinue\nに格納されたエントリポイントに飛びます。その時、\nval\nレジスタが式の値を\n保持しています。メタ循環の\neval\nと同様に、\neval-dispatch\nの構造は評価さ\n591","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":617},{"id":"./test/fixtures/pdf/sicp.pdf:618","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"れる式の構文型上の事例分析です。\n20\neval-dispatch\n(\ntest\n(\nop\nself-evaluating?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-self-eval\n))\n(\ntest\n(\nop\nvariable?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-variable\n))\n(\ntest\n(\nop\nquoted?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-quoted\n))\n(\ntest\n(\nop\nassignment?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-assignment\n))\n(\ntest\n(\nop\ndefinition?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-definition\n))\n(\ntest\n(\nop\nif?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-if\n))\n(\ntest\n(\nop\nlambda?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-lambda\n))\n(\ntest\n(\nop\nbegin?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-begin\n))\n(\ntest\n(\nop\napplication?\n) (\nreg\nexp\n))\n(\nbranch\n(\nlabel\nev-application\n))\n(\ngoto\n(\nlabel\nunknown-expression-type\n))\n単純な式の評価\n数値と文字列\n(\nこれらは自己評価です\n)\n、変数、クォーテーション、そして\nlambda\n式は評価するべき部分式がありません。これらのために、評価機は単純\nに正しい値を\nval\nレジスタに配置し、\ncontinue\nにより指定されたエントリポ\nイントから実行を継続します。単純な式の評価は以下のコントローラのコード\nにより実行されます。\n20\n私達のコントローラにおいては、ディスパッチ\n(dispatch\n、割り振り\n)\nは\ntest\nと\nbranch\nの命令列として書かれています。代替法として、データ適従スタイルで書くこと\nもできるでしょう\n(\nそして実際のシステムは恐らくそうされているでしょう\n)\n。連続した\nテストの実行の必要を防ぎ、新しい式の型の定義を用意にするためです。\nLisp\nを実行す\nるように設計された機械は恐らく\ndispatch-on-type\n命令を含むことでしょう。これは\nそのようなデータに従った割り振りを効率的に実行します。\n592","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":618},{"id":"./test/fixtures/pdf/sicp.pdf:619","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ev-self-eval\n(\nassign\nval\n(\nreg\nexp\n))\n(\ngoto\n(\nreg\ncontinue\n))\nev-variable\n(\nassign\nval\n(\nop\nlookup-variable-value\n) (\nreg\nexp\n) (\nreg\nenv\n))\n(\ngoto\n(\nreg\ncontinue\n))\nev-quoted\n(\nassign\nval\n(\nop\ntext-of-quotation\n) (\nreg\nexp\n))\n(\ngoto\n(\nreg\ncontinue\n))\nev-lambda\n(\nassign\nunev\n(\nop\nlambda-parameters\n) (\nreg\nexp\n))\n(\nassign\nexp\n(\nop\nlambda-body\n) (\nreg\nexp\n))\n(\nassign\nval\n(\nop\nmake-procedure\n)\n(\nreg\nunev\n) (\nreg\nexp\n) (\nreg\nenv\n))\n(\ngoto\n(\nreg\ncontinue\n))\nev-lambda\nがどのように\nunev\nと\nexp\nレジスタを用いてラムダ式のパラメタと\nボディを保持し、\nenv\nの中の環境と共に\nmake-procedure\n命令に引き渡される\nのか観察して下さい。\n手続適用の評価\n手続の適用はオペレータとオペランドを含む組み合わせにより指定します。\nオペレータはその値が手続となる部分式であり、オペランドはその値が引数と\nなる部分式で、その引数に対して手続が適用されねばなりません。メタ循環の\neval\nは適用をそれ自身を再帰的に呼び出すことで扱い、組み合わせの各要素\nを評価し、そして結果を\napply\nに渡します。これが実際の手続適用を実行しま\nす。明示的制御評価機も同じことを行います。これらの再帰呼出は\ngoto\n命令\nと共に、スタックを使用して再帰呼出から戻った時に再格納されるようにレジ\nスタを保存することで実装されます。各呼出の前にどのレジスタが保存されな\nければならないのかの確認に注意をしなければなりません。\n(\nなぜならこれら\nの値が後で必要になるからです\n)\n。\n21\n21\nこれは重要ですが、アルゴリズムを\nLisp\nの様な手続型の言語からレジスタマシン\nの言語へ翻訳する場合において微妙な点です。必要な物だけを保存することの代替法と\nして、各再帰呼出の前に全てのレジスタ\n(\nval\nを除く\n)\nを保存することもできます。これ\nは\nframed-stack\n(\nスタックフレーム\n)\nの統制と呼ばれます。これはうまく行きますがしか\n593","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":619},{"id":"./test/fixtures/pdf/sicp.pdf:620","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"適用の評価はオペレータを評価し手続を生成することから開始します。手\n続は後に評価されたオペランドに適用されます。オペレータを評価するため\nには、それを\nexp\nレジスタに移動させ、\neval-dispatch\nへ飛びます。\nenv\nレジ\nスタ内の環境は既にその中でオペレータを評価するために適切な物になって\nいますが、それでも\nenv\nを保存します。オペランドの評価にも必要なためで\nす。またオペランドを\nunev\nの中に展開し、スタック上にこれを保存します。\ncontinue\nに対し\neval-dispatch\nがオペレータの評価が完了した後に\nev-appl-\ndid-operator\nにて\nresume(\n再開\n)\nできるように設定します。しかし、最初に\ncontinue\nの古い値は保存します。これがコントローラに対し適用後にどこか\nら続行するのかを告げるためです。\nev-application\n(\nsave\ncontinue\n)\n(\nsave\nenv\n)\n(\nassign\nunev\n(\nop\noperands\n) (\nreg\nexp\n))\n(\nsave\nunev\n)\n(\nassign\nexp\n(\nop\noperator\n) (\nreg\nexp\n))\n(\nassign\ncontinue\n(\nlabel\nev-appl-did-operator\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nオペレータ部分式の評価からの帰還すると、組み合わせのオペランドの評価と、\n結果としての引数を\nargl\nに保持されるリストの中への蓄積へと進みます。最\n初に未評価のオペランドと環境を戻します。\nargl\nを空リストに初期化します。\nそして\nproc\nレジスタにオペレータの評価により生成された手続を割り当てま\nす。もしオペランドが無ければ、直接\napply-dispatch\nへと進みます。そうで\nなければ、\nproc\nをスタックに保存し引数評価ループを開始します。\n22\nし必要以上のレジスタを保存します。このことはスタック命令が高価であるというシス\nテム内の懸念点に成り得ます。後に使用される必要のないレジスタの保存はまた使用価\n値の無いデータを手放さないことにも成り得ます。これはそうでなければガベージコレ\nクションされ、再使用されるために領域が解法されたはずです。\n22\nSection 4.1.3\nの評価機データ構造の手続に以下の\n2\nつの手続を引数リストの操作の\nために追加します。\n(\ndefine\n(\nempty-arglist\n)\n'\n())\n(\ndefine\n(\nadjoin-arg\narg\narglist\n) (\nappend\narglist\n(\nlist\narg\n)))\nまた追加の構文手続を使用して組み合わせの最後のオペランドであるかのテストを行\nいます。\n(\ndefine\n(\nlast-operand?\nops\n) (\nnull?\n(\ncdr\nops\n)))\n594","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":620},{"id":"./test/fixtures/pdf/sicp.pdf:621","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ev-appl-did-operator\n(\nrestore\nunev\n)\n; the operands\n(\nrestore\nenv\n)\n(\nassign\nargl\n(\nop\nempty-arglist\n))\n(\nassign\nproc\n(\nreg\nval\n))\n; the operator\n(\ntest\n(\nop\nno-operands?\n) (\nreg\nunev\n))\n(\nbranch\n(\nlabel\napply-dispatch\n))\n(\nsave\nproc\n)\n引数評価ループの各サイクルは\nunev\nの中のリストからオペランドを評価し、そ\nの結果を\nargl\nの中に蓄積します。オペランドを評価するために、それを\nexp\nレ\nジスタの中に入れ、実行が引数蓄積段階から再開できるよう\ncontinue\nを\n設定\nした後に\neval-dispatch\nに飛びます。しかし、最初に私達はそれまでに\n(\nargl\nに保持されている\n)\n蓄積された引数、環境\n(\nenv\nに維持\n)\n、評価されていない残り\nのオペランド\n(\nunev\nが保持\n)\nを保存します。最後のオペランドの評価は特別な\n場合として扱われ\nev-appl-last-arg\nにより取り扱われます。\nev-appl-operand-loop\n(\nsave\nargl\n)\n(\nassign\nexp\n(\nop\nfirst-operand\n) (\nreg\nunev\n))\n(\ntest\n(\nop\nlast-operand?\n) (\nreg\nunev\n))\n(\nbranch\n(\nlabel\nev-appl-last-arg\n))\n(\nsave\nenv\n)\n(\nsave\nunev\n)\n(\nassign\ncontinue\n(\nlabel\nev-appl-accumulate-arg\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nオペランドが評価された時に、その値は\nargl\nにて保持されるリストの中に蓄\n積されます。そのオペランドはその後\nunev\n中の未評価オペランドのリストか\nら消され、引数評価が続行されます。\nev-appl-accumulate-arg\n(\nrestore\nunev\n)\n(\nrestore\nenv\n)\n(\nrestore\nargl\n)\n(\nassign\nargl\n(\nop\nadjoin-arg\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\nassign\nunev\n(\nop\nrest-operands\n) (\nreg\nunev\n))\n595","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":621},{"id":"./test/fixtures/pdf/sicp.pdf:622","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ngoto\n(\nlabel\nev-appl-operand-loop\n))\n最後の引数の評価は異なる扱いを受けます。環境や未評価のオペランドのリス\nトを\neval-dispatch\nに飛ぶ前に保存する必要がありません。最後のオペラン\nドが評価された後にそれらは必要が無いためです。従って評価から特別なエン\nトリポイント\nev-appl-accum-last-arg\nに帰ります。これは引数リストを戻し、\n新しい引数を蓄積し、保存された手続を戻し、適用を実行するために飛びます。\n23\nev-appl-last-arg\n(\nassign\ncontinue\n(\nlabel\nev-appl-accum-last-arg\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nev-appl-accum-last-arg\n(\nrestore\nargl\n)\n(\nassign\nargl\n(\nop\nadjoin-arg\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\nrestore\nproc\n)\n(\ngoto\n(\nlabel\napply-dispatch\n))\n引数評価ループの詳細はインタプリタが組み合わせのオペランドを評価する順\nを決定します。\n(\n例えば、左から右や右から左\n—\nExercise 3.8\n参照\n)\n。この順はメ\nタ循環評価機では決定されません。メタ循環評価機はその制御構造をその基礎\nを成し実装を行う\nScheme\nから継承します。\n24\n(\nev-appl-operand-loop\n内で一\n連のオペランドを\nunev\nから抽出するために使用された\n)\nfirst-operand\nセレ\nクタは\ncar\nとして実装され、\nrest-operands\nは\ncdr\nとして実装され、明示的制\n御評価機は組み合わせのオペランドを左から右への順で評価します。\n手続適用\nエントリポイント\napply-dispatch\nはメタ循環評価機の\napply\n手続に対応\nします。\napply-dispatch\nに到達する時に、\nproc\nレジスタは適用するための手\n23\n最後のオペランドの処理の特別な最適化は\nevlis tail recursion\n(\nエブリス末尾再帰\n)\nとして知られています\n(\nWand 1980\n参照\n)\n。最初のオペランドも特別な場合とすれば、私\n達は引数評価ループをいくらかより効率的良くできたでしょう。これは\nargl\nの初期化\nを最初のオペランドの評価の後まで延期することができ、この場合に\nargl\nを保存する\nことを防げたでしょう。\nSection 5.5\nのコンパイラはこの最適化を実行します。\n(\nSection\n5.5.3\nの\nconstruct-arglist\n手続と比較して下さい。\n)\n24\nメタ循環評価機のオペランドの評価順は\nSection 4.1.1\nの手続\nlist-of-values\n内の\ncons\nへの引数の評価順により決定されます\n(\nExercise 4.1\n参照\n)\n。\n596","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":622},{"id":"./test/fixtures/pdf/sicp.pdf:623","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"続を持ち、\nargl\nは適用するべき評価された引数のリストを持ちます。\n(\n元々は\neval-dispatch\nに渡され、\nev-application\nで保存された\n)\ncontinue\nの保存さ\nれた値は手続適用の結果と共に帰る場所を伝えますが、スタック上に存在しま\nす。適用が完了した時に、コントローラは保存された\ncontinue\nにより指示さ\nれたエントリポイントへ、\nval\n内の適用の結果と共に移動します。メタ循環の\napply\nと同様に、考慮すべき\n2\nつの場合が存在します。適用すべき手続はプリ\nミティブであるか、または複合手続であるかです。\napply-dispatch\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-apply\n))\n(\ntest\n(\nop\ncompound-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\ncompound-apply\n))\n(\ngoto\n(\nlabel\nunknown-procedure-type\n))\n各プリミティブは引数を\nargl\nから取得し、その結果を\nval\n内に置くように実\n装されていると想定されます。機械がどのようにプリミティブを扱うかを指定\nするためには、それぞれのプリミティブを実装するための一連のコントローラ\n命令を提供しなければならず、\nproc\nの中身により判別されたプリミティブのた\nめの命令への割り振りを行うように\nprimitive-apply\nを準備しなければなり\nません。私達はプリミティブの詳細ではなく、評価処理の構造に興味があるた\nめ、それらの代わりに単に\napply-primitive-procedure\nを使用します。これは\nproc\n内の手続を\nargl\n内の引数に対して適用します。\nSection 5.2\nのシミュレー\nタを用いて評価機のシミュレーションを行う目的のために、私達は手続\napply-\nprimitive-procedure\nを使用します。これは根底にある\nScheme\nシステムを適\n用を実行するために呼び出します。私達が\nSection 4.1.4\nのメタ循環評価機で行\nったのと全く同じです。プリミティブの適用の値を計算した後に、\ncontinue\nを\n戻して指定されたエントリポイントに飛びます。\nprimitive-apply\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\n(\nrestore\ncontinue\n)\n(\ngoto\n(\nreg\ncontinue\n))\n複合手続を適用するためには、メタ循環評価機と全く同様に進行します。手続\nのパラメタを引数に束縛するフレームを構築し、このフレームを用いて手続に\n597","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":623},{"id":"./test/fixtures/pdf/sicp.pdf:624","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"より運ばれた環境を拡張し、この拡張環境の中で手続のボディを形成する式の\n列を評価します。\nSection 5.4.2\nで説明される\nev-sequence\nは列の評価を取り扱\nいます。\ncompound-apply\n(\nassign\nunev\n(\nop\nprocedure-parameters\n) (\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nprocedure-environment\n) (\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nextend-environment\n)\n(\nreg\nunev\n) (\nreg\nargl\n) (\nreg\nenv\n))\n(\nassign\nunev\n(\nop\nprocedure-body\n) (\nreg\nproc\n))\n(\ngoto\n(\nlabel\nev-sequence\n))\ncompound-apply\nは\nenv\nレジスタが新しい値を割り当てられるインタプリタ内\nで唯一の場所です。メタ循環評価機と同様に、新しい環境は手続により運ば\nれた環境から引数リストと対応する束縛される変数のリストと共に構築され\nます。\n5.4.2\n列の評価と末尾再帰\n明示的制御評価機の\nev-sequence\nの部分はメタ循環評価機の\neval-sequence\n手続と同等です。手続のボディ内の式、または明示的な\nbegin\n式内の列を取り\n扱います。\n明示的な\nbegin\n式は\nunev\n内に評価されるべき式の列を配置し、\ncontinue\nをスタック上に保存し、\nev-sequence\nに飛ぶことで評価されます。\nev-begin\n(\nassign\nunev\n(\nop\nbegin-actions\n) (\nreg\nexp\n))\n(\nsave\ncontinue\n)\n(\ngoto\n(\nlabel\nev-sequence\n))\n手続のボディ内の暗黙的な列は\ncompound-apply\nから\nev-sequence\nへと飛ぶこ\nとで扱われます。この時点で\ncontinue\nは既に\nev-application\nで保存され、ス\nタック上に存在します。\nev-sequence\nと\nev-sequence-continue\nのエントリポイントはループを形\n成し、連続して列内の各式を評価します。未評価の式のリストは\nunev\nに保持\nされています。各式の評価の前に、列内にさらなる評価すべき式が存在しない\nかどうか確認します。もしそうであれば、\n(\nunev\nに保持された\n)\n未評価の式の残\nりと、\n(\nenv\nに保持された\n)\n式の残りが評価される環境を保存し、その式を評価\n598","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":624},{"id":"./test/fixtures/pdf/sicp.pdf:625","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"するために\neval-dispatch\nを呼びます。\n2\nつの保存されたレジスタはこの評価\nからの帰還時に\nev-sequence-continue\nにて戻されます。\n列内の最後の式は\nev-sequence-last-exp\nにて異なる取扱を行います。こ\nの後には評価すべき式は無いため、\nunev\nと\nenv\nを\neval-dispatch\nに行く前に\n保存する必要はありません。列全体の値は最後の式の値であるため、最後の式\nの評価の後にスタック上に現時点で保存されている\n(\nev-application\nまたは\nev-begin\nにて保存された\n)\nエントリポイントから続行すること以外に必要なこ\nとはありません。\ncontinue\nを設定して\neval-dispatch\nからここに帰るように\n準備し、次にスタックから\ncontinue\nの値を戻してそのエントリポイントから\n続行するのではなく、\neval-dispatch\nへ行く前にスタックから\ncontinue\nを戻\nします。そうすることで\neval-dispatch\nは式を評価した後にそのエントリポイ\nントから続行します。\nev-sequence\n(\nassign\nexp\n(\nop\nfirst-exp\n) (\nreg\nunev\n))\n(\ntest\n(\nop\nlast-exp?\n) (\nreg\nunev\n))\n(\nbranch\n(\nlabel\nev-sequence-last-exp\n))\n(\nsave\nunev\n)\n(\nsave\nenv\n)\n(\nassign\ncontinue\n(\nlabel\nev-sequence-continue\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nev-sequence-continue\n(\nrestore\nenv\n)\n(\nrestore\nunev\n)\n(\nassign\nunev\n(\nop\nrest-exps\n) (\nreg\nunev\n))\n(\ngoto\n(\nlabel\nev-sequence\n))\nev-sequence-last-exp\n(\nrestore\ncontinue\n)\n(\ngoto\n(\nlabel\neval-dispatch\n))\n末尾再帰\nChapter 1\nにて以下のような手続により記述されるプロセスは、\n(\ndefine\n(\nsqrt-iter\nguess\nx\n)\n(\nif\n(\ngood-enough?\nguess\nx\n)\nguess\n599","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":625},{"id":"./test/fixtures/pdf/sicp.pdf:626","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nsqrt-iter\n(\nimprove\nguess\nx\n)\nx\n)))\n反復プロセスだと述べました。例えこの手続が構文的に\n(\nそれ自身の単語の定\n義において\n)\n再帰であっても、論理的には評価機にとって、\n1\nつの\nsqrt-iter\nの呼出から次の呼出への横断において情報を保存する必要がありません。\n25\nsqrt-iter\nのような手続を、手続がそれ自身を呼び出すことを続けるに従い記\n憶域を増加させる必要無しに実行することが可能な評価機は、\ntail-recursive\n(\n末\n尾再帰\n)\n評価機と呼ばれます。\nChapter 4\nのメタ循環評価機の実装は評価機が末\n尾再帰であるかどうかを指定しませんでした。その評価機が状態を保存するた\nめの仕組みをその基礎に横たわる\nScheme\nから継承していたためです。しかし\n明示的制御評価機と用いる場合、私達は評価の過程を追跡し、いつ手続呼出が\n正味の情報集積をスタック上に引き起すのかを確認することができます。\n私達の評価機は末尾再帰です。なぜなら列の最後の式を評価するために、ス\nタック上に何の情報も保存すること無く\neval-dispatch\nへと直接飛びます。従\nって、列の最後の式\n—\n例えもしそれが手続呼出であっても\n(\nsqrt-iter\nのよう\nに、手続のボディの最後の式が\nif\n式であっても、\nsqrt-iter\nへの呼出へと簡約\nされます\n)—\nの評価がスタック上に何の情報の蓄積も起こしません。\n26\nもしこの場合に情報を保存する必要が無いという事実を活用することを考\nえなかった場合、列内の全ての式を同じように取り扱うように\neval-sequence\nを実装していたことでしょう。レジスタの保存、式の評価、レジスタを戻すた\nめに帰る、これらを全ての式が評価されるまで繰り返したことでしょう。\n27\nev-sequence\n(\ntest\n(\nop\nno-more-exps?\n) (\nreg\nunev\n))\n25\nSection 5.1\nにてそのようなプロセスをどのようにスタックを持たないレジスタマシ\nンにて実装するのかを学びました。プロセスの状態は固定長のレジスタ集合に格納され\nます。\n26\nこの\nev-sequence\nにおける末尾再帰の実装は多くのコンパイラで使用されている良\nく知られた最適化の技術の一種です。手続呼出で終了する手続のコンパイルでは、呼出\nを呼び出された手続のエントリポイントへのジャンプで置き換えることができます。こ\nの節で行ったように、この戦略をインタプリタの中に構築することは言語の至る所に均\n一に最適化を提供します。\n27\nWe can define\nno-more-exps?\nas follows:\nno-more-exps?\nを以下のように定義することができます。\n(\ndefine\n(\nno-more-exps?\nseq\n) (\nnull?\nseq\n))\n600","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":626},{"id":"./test/fixtures/pdf/sicp.pdf:627","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbranch\n(\nlabel\nev-sequence-end\n))\n(\nassign\nexp\n(\nop\nfirst-exp\n) (\nreg\nunev\n))\n(\nsave\nunev\n)\n(\nsave\nenv\n)\n(\nassign\ncontinue\n(\nlabel\nev-sequence-continue\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nev-sequence-continue\n(\nrestore\nenv\n)\n(\nrestore\nunev\n)\n(\nassign\nunev\n(\nop\nrest-exps\n) (\nreg\nunev\n))\n(\ngoto\n(\nlabel\nev-sequence\n))\nev-sequence-end\n(\nrestore\ncontinue\n)\n(\ngoto\n(\nreg\ncontinue\n))\n恐らくこれは列の評価のための以前のコードに対する軽微な変更のように見え\nるでしょう。唯一の違いは保存と再格納のサイクルを他と同様に列の最後の式\nでも通すことです。インタプリタは依然としてどの式に対しても同じ値を与え\nます。しかし、この変更は末尾再帰の実装に対しては致命的です。なぜなら、\nこれで私達は列の最後の式の評価の後にも\n(\n使用価値の無い\n)\nレジスタの保存\nを戻すために帰らねばなりません。これらの余分な保存は入れ子の手続の呼出\nの間で蓄積されます。その結果として、\nsqrt-iter\nのようなプロセスは一定容\n量を必要とするのでなく、繰り返しの回数に比例する記憶域を必要とします。\nこの違いは重大事に成り得ます。例えば、末尾再帰を用いれば、無限ループは\n手続呼出の仕組みだけを用いて表現できます。\n(\ndefine\n(\ncount\nn\n)\n(\nnewline\n) (\ndisplay\nn\n) (\ncount\n(+\nn\n1)))\n末尾再帰が無ければ、そのような手続はいつかはスタック領域を使いつくしま\nす。そして真に反復を表現することは手続呼出以外の何らかの制御の仕組みを\n必要とします。\n5.4.3\n条件文、代入、定義\nメタ循環評価機と同様に、特別な形式は選択的に式の部分部分を評価する\nことで取り扱われます。\nif\n式に対しては、述語を評価して、その値を元に、結\n果部\n(consequent)\nと代替部\n(alternative)\nのどちらを評価するか決定します。\n601","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":627},{"id":"./test/fixtures/pdf/sicp.pdf:628","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"述語を評価する前に、\nif\n式自身を保存します。そうすることで後に結果部\nか代替部を抽出することができます。また後に結果部か代替部を評価するため\n必要となるので環境を保存します。そして後に\nif\nの値を待っている式の評価\nに戻るために必要なため\ncontinue\nも保存します。\nev-if\n(\nsave\nexp\n)\n;\n後のため式を保存する\n(\nsave\nenv\n)\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nev-if-decide\n))\n(\nassign\nexp\n(\nop\nif-predicate\n) (\nreg\nexp\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\n;\n述語を評価する\n述語の評価から戻る時、真か偽であるかをテストし、結果に依り\neval-dispatch\nに飛ぶ前に\nexp\nに結果部か代替部を配置します。\nenv\nと\ncontinue\nをここで戻\nすことが\neval-dispatch\nに正しい環境を持たせ、正しい場所から継続し\nif\n式\nの値を受けとるように設定していることに注意して下さい。\nev-if-decide\n(\nrestore\ncontinue\n)\n(\nrestore\nenv\n)\n(\nrestore\nexp\n)\n(\ntest\n(\nop\ntrue?\n) (\nreg\nval\n))\n(\nbranch\n(\nlabel\nev-if-consequent\n))\nev-if-alternative\n(\nassign\nexp\n(\nop\nif-alternative\n) (\nreg\nexp\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nev-if-consequent\n(\nassign\nexp\n(\nop\nif-consequent\n) (\nreg\nexp\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\n代入と定義\n代入と定義は\nev-assignment\nにより扱われます。ここには\neval-dispatch\nから代入式が\nexp\nの中にある状態で到達します。\nev-assignment\nの最初のコー\nドは式の部分の値を評価し、次に新しい値を環境に導入します。\nSet-variable-\nvalue!\nが機械語命令として必要可能であると前提します。\n602","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":628},{"id":"./test/fixtures/pdf/sicp.pdf:629","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ev-assignment\n(\nassign\nunev\n(\nop\nassignment-variable\n) (\nreg\nexp\n))\n(\nsave\nunev\n)\n;\n後のため変数を保存\n(\nassign\nexp\n(\nop\nassignment-value\n) (\nreg\nexp\n))\n(\nsave\nenv\n)\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nev-assignment-1\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\n;\n代入値を評価する\nev-assignment-1\n(\nrestore\ncontinue\n)\n(\nrestore\nenv\n)\n(\nrestore\nunev\n)\n(\nperform\n(\nop\nset-variable-value!\n) (\nreg\nunev\n) (\nreg\nval\n) (\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\n(\ngoto\n(\nreg\ncontinue\n))\n定義も同様に扱われます。\nev-definition\n(\nassign\nunev\n(\nop\ndefinition-variable\n) (\nreg\nexp\n))\n(\nsave\nunev\n)\n;\n変数を後のため保存\n(\nassign\nexp\n(\nop\ndefinition-value\n) (\nreg\nexp\n))\n(\nsave\nenv\n)\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nev-definition-1\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\n;\n定義値を評価する\nev-definition-1\n(\nrestore\ncontinue\n)\n(\nrestore\nenv\n)\n(\nrestore\nunev\n)\n(\nperform\n(\nop\ndefine-variable!\n) (\nreg\nunev\n) (\nreg\nval\n) (\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\n(\ngoto\n(\nreg\ncontinue\n))\nExercise 5.23:\n評価機を拡張し、\ncond\n,\nlet\n,\n等の派生式を取り扱う\nようにせよ\n(\nSection 4.1.2\n)\n。\ncond->if\nの様な構文変換器が機械語\n603","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":629},{"id":"./test/fixtures/pdf/sicp.pdf:630","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"命令として使用可能と前提して\n“\nインチキ\n”\nしても良い。\n28\nExercise 5.24:\ncond\nを新しい基本的な特別形式として\nif\nに簡約す\nること無しに実装せよ。連続する\ncond\n節の述語を真になるものを\n見つけるまでテストするループを構築する必要がある。次に\nev-\nsequence\nを使用してその節のアクションを評価する。\nExercise 5.25:\n評価機を変更し、\nSection 4.2\nの遅延評価機を基にし\nた正規順評価を使用するようにせよ。\n5.4.4\n評価機を実行する\n明示的制御評価機の実装と共に、私達は\nChapter 1\nから始まった開発の終わ\nりにやってきました。ここまで私達は引き続きより的確な評価過程のモデルを\n探求してきました。比較的、略式な置換モデルから開始し、次にこれを\nChapter\n3\nで環境モデルに拡張しました。これは状態と変更を扱うことを可能にしまし\nた。\nChapter 4\nのメタ循環評価機では\nScheme\n自身を式の評価の間に構築され\nる、より明確な環境構造のための言語として使用しました。ここでは、レジス\nタマシンを用いてメモリ管理、引数渡し、制御のための評価機の仕組みについ\nてつぶさに見てきました。それぞれの新しいレベルの説明にて、直前の、明確\nさで劣る評価処理の見ることはできない曖昧さに関して問題を提起し、解決す\nる必要がありました。明示的制御評価機の振舞を理解するために、そのシミュ\nレーションを行い、パフォーマンスを監視することができます。\n私達の評価機にドライバループを導入します。これは\nSection 4.1.4\nの\ndriver-loop\n手続の役割を果たします。この評価機は繰り返しプロンプト\nを表示し、式を読み込み、\neval-dispatch\nへ飛ぶことで式を評価し、結果を表\n示します。以下の命令は明示的制御評価機のコントローラシーケンスの開始を\n形づくります。\n29\n28\nこれは本当はインチキではありません。実際のゼロからの実装においても、\nScheme\nを解釈する明示的制御評価機を用いて\ncond->if\nのようなソースレベル変換を実行前の\n構文フェーズにて実行するでしょう。\n29\nここでは\nread\nと多様な表示命令がプリミティブな機械語命令として使用可能である\nと前提します。このことは私達のシミュレーションには便利ですが、実際には完全に非\n現実的です。これらは本当はかなり複雑な命令です。実際には、それらは単一の文字を端\n末との間で双方向に転送するような低レベルの入出力命令を用いて実装されるでしょう。\nget-global-environment\n命令をサポートするためには以下を定義します。\n(\ndefine\nthe-global-environment\n(\nsetup-environment\n))\n604","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":630},{"id":"./test/fixtures/pdf/sicp.pdf:631","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"read-eval-print-loop\n(\nperform\n(\nop\ninitialize-stack\n))\n(\nperform\n(\nop\nprompt-for-input\n) (\nconst\n\"\n;;\nEC-Eval\ninput\n:\n\"\n))\n(\nassign\nexp\n(\nop\nread\n))\n(\nassign\nenv\n(\nop\nget-global-environment\n))\n(\nassign\ncontinue\n(\nlabel\nprint-result\n))\n(\ngoto\n(\nlabel\neval-dispatch\n))\nprint-result\n(\nperform\n(\nop\nannounce-output\n) (\nconst\n\"\n;;\nEC-Eval\nvalue\n:\n\"\n))\n(\nperform\n(\nop\nuser-print\n) (\nreg\nval\n))\n(\ngoto\n(\nlabel\nread-eval-print-loop\n))\n手続の中で\n(\napply-dispatch\nで指摘される\n“\n未知の手続型エラー\n”\nの様な\n)\nエ\nラーに遭遇した時、エラーメッセージを表示し、ドライバループへと戻ります。\n30\nunknown-expression-type\n(\nassign\nval\n(\nconst\nunknown-expression-type-error\n))\n(\ngoto\n(\nlabel\nsignal-error\n))\nunknown-procedure-type\n(\nrestore\ncontinue\n)\n; clean up stack (from\napply-dispatch\n)\n(\nassign\nval\n(\nconst\nunknown-procedure-type-error\n))\n(\ngoto\n(\nlabel\nsignal-error\n))\nsignal-error\n(\nperform\n(\nop\nuser-print\n) (\nreg\nval\n))\n(\ngoto\n(\nlabel\nread-eval-print-loop\n))\nシミュレーションの目的のために、ドライバループを通る度にスタックを初期\n化します。\n(\n未定義変数の様な\n)\nエラーが評価を割り込みした後には空でない可\n能性があるためです。\n31\n(\ndefine\n(\nget-global-environment\n)\nthe-global-environment\n)\n30\nインタプリタに取り扱って欲しいと願うかもしれない他のエラーも存在します。し\nかしこれらはあまり単純ではありません。\nExercise 5.30\nを参照して下さい。\n31\nスタックの初期化をエラーの後にのみ行うことも可能でしょう。しかしドライバル\nープの中で行うことは評価機のパフォーマンスを監視するために便利です。この先で説\n明されます。\n605","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":631},{"id":"./test/fixtures/pdf/sicp.pdf:632","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Section 5.4.1\nから\nSection 5.4.4\nの間のコードの断片を組合せれば、\nSection\n5.2\nのレジスタマシンシミュレータを用いて実行することができる評価機の機\n械モデルを作ることができます。\n(\ndefine\neceval\n(\nmake-machine\n'\n(\nexp\nenv\nval\nproc\nargl\ncontinue\nunev\n)\neceval-operations\n'\n(\nread-eval-print-loop\n⟨\nentire machine controller as given above\n⟩\n)))\n評価機によりプリミティブとして使用される命令をシミュレートするための\nScheme\n手続を定義しなければなりません。これらは\nSection 4.1\nでメタ循環評\n価機のために使用したものと同じ手続と、\nSection 5.4\nの至る所の脚注にて定義\nされたいくつかの追加の物があります。\n(\ndefine\neceval-operations\n(\nlist\n(\nlist\n'self-evaluating?\nself-evaluating\n)\n⟨\ncomplete list of operations for eceval machine\n⟩\n))\n最後に、グローバル環境を初期化し、評価機を実行します。\n(\ndefine\nthe-global-environment\n(\nsetup-environment\n))\n(\nstart\neceval\n)\n;;; EC-Eval input:\n(\ndefine\n(\nappend\nx\ny\n)\n(\nif\n(\nnull?\nx\n)\ny\n(\ncons\n(\ncar\nx\n) (\nappend\n(\ncdr\nx\n)\ny\n))))\n;;; EC-Eval value:\nok\n;;; EC-Eval input:\n(\nappend\n'\n(\na\nb\nc\n)\n'\n(\nd\ne\nf\n))\n;;; EC-Eval value:\n(a b c d e f)\nもちろん、この方法の式の評価は\nScheme\nに直接入力した場合よりもずっと長\nくかかります。複数レベルのシミュレーションが関与するためです。式は明示\n的制御評価器の機械により評価されます。これは\nScheme\nプログラムによりシ\nミュレートされ、\nScheme\nプログラム自身は\nScheme\nインタプリタにより評価\nされています。\n606","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":632},{"id":"./test/fixtures/pdf/sicp.pdf:633","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"評価機のパフォーマンスの監視\nシミュレーションは評価器の実装を案内するのに強力なツールです。シミ\nュレーションはレジスタマシンの設計の多様性を探求することだけでなく、シ\nミュレートされた評価器のパフォーマンスを観察することも簡単にします。例\nえば、パフォーマンスにおける\n1\nつの重要な要因はどれだけ効率良く評価機が\nスタックを使用するかがあります。スタック利用上の統計を集めるシミュレー\nタの版を用いて評価機のレジスタマシンを設計することと、評価機の\nprint-\nresult\nエントリポイントに統計を表示する命令を追加することでにより、様々\nな式を評価するのに必要とされるスタック命令の数を観察することができます\n(\nSection 5.2.4\n)\n。\nprint-result\n(\nperform\n(\nop\nprint-stack-statistics\n))\n;\n追加された命令\n(\nperform\n(\nop\nannounce-output\n) (\nconst\n\"\n;;;\nEC-Eval\nvalue\n:\n\"\n))\n...\n;\n以前と同じ\n評価機との応答はこれで以下のように見えます。\n;;; EC-Eval input:\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (* (\nfactorial\n(-\nn\n1))\nn\n)))\n(total-pushes = 3 maximum-depth = 3)\n;;; EC-Eval value:\nok\n;;; EC-Eval input:\n(\nfactorial\n5)\n(total-pushes = 144 maximum-depth = 28)\n;;; EC-Eval value:\n120\n評価機のドライバループが全ての応答の開始にスタックを再度初期化すること\nに注意して下さい。それにより表示された統計は直前の式の評価のために使用\nされたスタック命令のみを参照します。\nExercise 5.26:\n監視付きのスタックを用いて評価機\n(\nSection 5.4.2\n)\nの末尾再帰の特性を調査せよ。評価機を開始し、\nSection 1.2.1\nの反\n復\nfactorial\n手続を定義せよ。\n607","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":633},{"id":"./test/fixtures/pdf/sicp.pdf:634","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nfactorial\nn\n)\n(\ndefine\n(\niter\nproduct\ncounter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\niter\n(*\ncounter\nproduct\n) (+\ncounter\n1))))\n(\niter\n1 1))\n手続をいくつかの\n푛\nの小さな値で実行せよ。これらの値に対する\n푛!\nを求めるのに必要な最大スタック深度と\npush\nの数を記録せよ。\na\n푛!\nを評価するために必要な最大深度が\n푛\nから独立している\nことを発見するだろう。この深さは何か\n?\nb\nあなたのデータから任意の\n푛 ≥ 1\nに対して\n푛!\nを評価するの\nに使用される\npush\n命令の総数を求める\n푛\nの方程式を求めよ。\n使用される命令数は\n푛\nの線形関数であり、従って\n2\nつの定数\nから決定されることに注意せよ。\nExercise 5.27:\nExercise 5.26\nとの比較として、以下の階乗を再帰的\nに求める手続の振舞を調査せよ。\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1)\n1\n(* (\nfactorial\n(-\nn\n1))\nn\n)))\nこの手続を監視付きのスタックを用いて実行し、任意の\n푛 ≥ 1\nに\n対して\n푛!\nを評価するために使用される、スタックの最大深度とプ\nッシュの総数を\n푛\nの関数として求めよ。\n(\n再び、これらの関数は線\n形になる\n)\n。あなたの経験を以下の表に適切な\n푛\nの式を埋めること\nでまとめよ。\n最大深度\npush\nの総数\n再帰\n階乗\n反復\n階乗\n最大深度は演算の実行において評価機により使用された記憶域の\n量の尺度である。\npush\nの総数は必要な時間に良く関連している。\n608","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":634},{"id":"./test/fixtures/pdf/sicp.pdf:635","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Exercise 5.28:\nSection 5.4.2\nにて説明されているように\neval-\nsequence\nを変えることで評価機の定義を変更し、評価機がも\nはや末尾再帰ではないようにせよ。\nExercise 5.26\nと\nExercise 5.27\nの\n実験を再実行し、\nfactorial\n手続の両版が今では必要とされる記\n憶域がそれらの入力に対し線形に増加することを実演せよ。\nExercise 5.29:\n木再帰フィボナッチ数の演算におけるスタック命令\nを監視せよ。\n(\ndefine\n(\nfib\nn\n)\n(\nif\n(<\nn\n2)\nn\n(+ (\nfib\n(-\nn\n1)) (\nfib\n(-\nn\n2)))))\na\n푛 ≥ 2\nに対して\n퐹 푖푏(푛)\nを求まる場合に必要なスタックの最\n大深度に対する\n푛\nの方程式を与えよ。ヒント：\nSection 1.2.2\nに\nおいて私達はこの処理により使用される記憶域は\n푛\nに対し線\n形に増加することを議論した。\nb\n푛 ≥ 2\nに対して\n퐹 푖푏(푛)\nを求めるのに使用された\npush\nの総\n数に対する方程式を与えよ。\n(\n費やされた時間に良く関連す\nる\n)push\nの総数は\n푛\nの指数関数的に増加することを見付けな\nければならない。ヒント：\n푆(푛)\nを\n퐹 푖푏(푛)\nを求めるのに使用\nされた\npush\nの総数とせよ。\n푆(푛 − 1)\n,\n푆(푛 − 2)\n,\nそれにある\n固定の\n“\nオーバヘッド\n”\nとして\n푛\nから独立した定数\n푘\nを用い\nて\n푆(푛)\nを表現する方程式が存在することを主張することが\nできるはずだ。方程式を与えて、\n푘\nが何であるかを述べよ。次\nに\n푆(푛)\nが\n푎 ⋅ 퐹 푖푏(푛 + 1) + 푏\nとして表現できることを示し、\n푎\nと\n푏\nの値を与えよ。\nExercise 5.30:\n私達の評価機は現在は\n2\nつの種類のエラー\n—\n未知\nの型の式と未知の型の手続\n—\nのみを発しキャッチする。他のエラ\nーは評価機の\nREPL\nから抜けてしまう。評価機をレジスタマシン\nシミュレータを用いて実行した時に、これらのエラーはその下に\n横たわる\nScheme\nシステムによりキャッチされるこれはユーザプ\nログラムがエラーを発生させた時にコンピュータが強制終了する\nのと同様である。\n32\n本物のエラーシステムを働かせることは大き\n32\n残念ながら、\nC\n言語のような従来のコンパイラベース言語システムにおいてはこ\nれが普通の状況です。\nunix\n(tm)\nではシステムは\n“\nコア\n(core)\nをダンプ\n(dump)”\nし、\n609","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":635},{"id":"./test/fixtures/pdf/sicp.pdf:636","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"なプロジェクトである。しかし、ここで何が関与しているのかを\n理解する努力には大きな価値がある。\na\n未定義の変数にアクセスを試すような評価プロセスで発生す\nるエラーは\nlookup\n命令を変更し識別可能な状態コードを返\nすように変更することで捕まえることができるだろう。状態\nコードは全てのユーザ変数が取り得ない値でなければならな\nい。評価機はこの状態コードに対しテストを行い、\nsignal-\nerror\nに飛ぶために必要なことを行う。評価機の中でそのよ\nうな変更が必要な全ての箇所を見つけ修正せよ。これはとて\nも大変な作業だ。\nb\nゼロで割ることやシンボルから\ncar\nを抽出するような試行\nにより、プリミティブな手続の適用上で発せられるエラーの\n取り扱いの問題はずっと酷い物だ。専門的に記述された高品\n質なシステムにおいては、プリミティブの適用全てはプリミ\nティブの一部として安全性が確認されている。例えば全ての\ncar\nの呼出は最初に引数がペアであるかを確認する。もし引\n数がペアでなければ、適用は区別可能な状態コードを評価機\nに返す。すると評価機は失敗を報告する。私達はこれを私達\nのレジスタマシンシミュレータに全てのプリミティブ手続の\n適用性チェックを行い適切な識別可能な状態コードを失敗時\nに返すようにすることで手筈を整えることができるだろう。\nすると評価機の\nprimitive-apply\nコードが状態コードをチ\nェックし必要なら\nsignal-error\nへ飛ぶことができる。この\n構造を構築し、働くようにせよ。これは巨大なプロジェクト\nである。\n5.5\nコンパイル\nSection 5.4\nの明示的制御評価機はコントローラが\nScheme\nプログラムを解\n釈するレジスタマシンです。この節では\nScheme\nプログラムをコントローラが\ndos\n/Windows(tm)\nでは\ncatatonic(\n硬まる、フリーズ\n)\nします。\nMacintosh(tm)\nは\n—\nもし\nラッキーな場合は\n—\n爆発する爆弾の絵を表示しコンピュータをリブートするよう提案し\nます。\n610","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":636},{"id":"./test/fixtures/pdf/sicp.pdf:637","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Scheme\nインタプリタではないレジスタマシン上にてどのように実行するのか\nについて学びます。\n明示的制御評価機械は普遍的です。\nScheme\nで記述できるどんな演算プロセ\nスも実行できます。評価機のコントローラは望んだ演算を実行するためのデー\nタパスの使用を調整します。従って、評価機のデータパスは普遍的です。適切\nなコントローラを与えられた場合に、私達が望む任意の演算を実行するのに十\n分です。\n33\n商業上の汎用なコンピュータはレジスタと効率的で便利なデータパスの普\n遍的な集合を構成する命令の周りに構築されるレジスタマシンです。汎用目的\nの機械は私達がここまで使用しているようなレジスタマシン言語のためのイン\nタプリタです。この言語は機械の\nnative language\n(\nネイティブ言語\n)\n、または単\n純に\nmachine language\n(\n機械語\n)\nと呼ばれます。機械語で記述されたプログラム\nはその機械のデータパスを用いた命令列です。例えば、明示的制御評価機の命\n令列は専門のインタプリタマシンのためのコントローラではなく、汎用目的の\nコンピュータのための機械語プログラムだと考えることができます。\n2\nつの共通な戦略が高水準の言語とレジスタマシンの言語の間のギャップ\nを橋渡しします。明示的制御評価機は逐次翻訳\n(interpretation)\n上の戦略を説\n明します。機械のネイティブ言語で書かれたインタプリタは、評価を実行する\n機械のネイティブ言語とは異なっても良いある言語\n(\nsource language\n(\nソース言\n語\n))\nで書かれたプログラムを実行するように機械を構成します。ソース言語の\nプリミティブ手続は与えられた機械のネイティブ言語により記述されたサブル\nーチンのライブラリとして実装されます。\n(\nsource program\n(\nソースプログラム\n)\nと呼ばれる\n)\n逐次翻訳するプログラムはデータ構造として表現されます。イン\nタプリタはこのデータ構造を横断し、ソースプログラムを分析します。それを\n行うにつれ、ソースプログラムの意図された振舞を適切なプリミティブのサブ\nルーチンをライブラリから呼ぶことによりシミュレートします。\nこの節では、\ncompilation\n(\nコンパイル\n)\nという代替的な戦略を探求します。\n与えられたソース言語と機械に対するコンパイラはソースプログラムを機械の\nネイティブ言語で書かれた\n(\nobject program\n(\nオブジェクトプログラム\n)\nと呼ば\nれる\n)\n等価なプログラムに翻訳します。この節で実装するコンパイラは\nScheme\nで書かれたプログラムを明示的制御評価機のデータパスを用いて実行される命\n33\nこれは理論的な発言です。この評価機のデータパスが一般的なコンピュータのため\nに特に便利な、または効率的なデータパスの集合であると主張している訳ではありませ\nん。例えば、これらは高いパフォーマンスの浮動小数点演算や、激しくビットベクタを\n操作する演算の実装にはあまり向いていません。\n611","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":637},{"id":"./test/fixtures/pdf/sicp.pdf:638","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"令列へと翻訳します。\n34\n逐次翻訳と比べた時、コンパイルはプログラム実行の効率性において大き\nな向上を与えられます。このことは下記にてコンパイラの概観において説明し\nて行きます。一方で、インタプリタはより強力な環境を対話式のプログラム開\n発とデバッグのために提供します。実行するソースプログラムが実行時にも試\n験し、変更するために使用可能なためです。それに加えて、プリミティブのラ\nイブラリ全体が存在し、新しいプログラムがデバッグの間に構築し、追加する\nことができることも挙げられます。\nコンパイルと逐次翻訳の相補的な利点の視点において、最新のプログラム\n開発環境は入り交じった戦略を追求しています。\nLisp\nインタプリタは一般的\nに逐次翻訳された手続とコンパイルされた手続がお互いを呼びだせるように\n構築されています。これはプログラマがデバッグすることを想定されているこ\nれらのプログラムの部品をコンパイルすることを可能にします。従ってコンパ\nイルの効率上の利点を得ながら、プログラムのそれらの部品に対して対話式開\n発とデバッグの流動的な、実行の解釈的なモードを維持することもできます。\nSection 5.5.7\nにおいて、コンパイラを実装した後にはインタプリタとどのよう\nに接続して統合的なインタプリタ・コンパイラ開発システムを生成するかを示\nします。\nコンパイラの概要\n私達のコンパイラは私達のインタプリタに両者のその構造と実行する機能\nにおいてとても良く似ています。従って、コンパイラにより式の解析のために\n使用される仕組みはインタプリタにて使用されたものと同様になります。さら\nに、コンパイルされたコードと逐次翻訳されたコードの接続を簡単にするため\nに、インタプリタと同じレジスタ使用法の仕様に従うコードを生成する様にコ\nンパイラを設計します。環境は\nenv\nレジスタに保持され、引数リストは\nargl\nに蓄積され、適用される手続は\nproc\nに入り、手続はそれらの回答を\nval\nに入\nれて戻り、手続が戻らなければいけない位置は\ncontinue\nに維持されます。一\n34\n実際には、コンパイルされたコードをを実行する機械はインタプリタマシンよりも\nより単純に成り得ます。\nexp\nと\nunev\nのレジスタを使用しないためです。これらを使用\nするインタプリタは未評価の式の部分を保持します。しかしコンパイラを用いる場合に\nは、これらの式はレジスタマシンが実行するコンパイルされたコードの中に組込まれま\nす。同じ理由により、式の構文を扱う機械語命令を必要としません。しかしコンパイル\nされたコードは明示的制御評価機械では存在しなかったいくつかの追加の\n(\nコンパイル\nされた手続オブジェクトを表現するための\n)\n機械語命令を使用します。\n612","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":638},{"id":"./test/fixtures/pdf/sicp.pdf:639","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"般的に、コンパイラはソースプログラムをインタプリタが同じソースプログラ\nムを評価する場合に行うのと本質的に同じレジスタ命令を実行するオブジェク\nトプログラムに翻訳します。\nこの説明ではとても基本的なコンパイラを実装するための戦略を提案しま\nす。式をインタプリタと同じ方法で横断します。インタプリタが式の評価で実\n行するだろうレジスタ命令に遭遇したら、その命令を実行はしませんがその代\nわりに列に蓄積します。結果としての命令列はオブジェクトコードになります。\n逐次翻訳に対するコンパイルの効率上の利点を注意して下さい。インタプリタ\nが式、例えば\n(f 84 96)\nを評価する度に、式の分類\n(\n手続の適用であるかを見\n出す\n)\nとオペランドリストの終端の検査\n(2\nつのオペランドが残っているかを見\n出す\n)\nを行います。コンパイラを用いる場合、式は命令列がコンパイル時に生成\nされた時に一度しか解析されません。コンパイラにより生成されたオブジェク\nトコードはオペレータと\n2\nつのオペランドを評価する命令しか含んでおらず、\n引数リストを組み立て、\n(\nproc\n内の\n)\n手続を\n(\nargl\n内の\n)\nその引数に適用します。\nこれは\nSection 4.1.7\nの解析評価機で実装したものと同じ種類の最適化です。\nしかし、コンパイルされたコード中で効率を良くするためのさらなる機会が存\n在します。インタプリタが実行するにしたがって、インタプリタは言語の任意\nの式に必ず当てはまる過程を追います。対照的に、与えられたコンパイル済み\nコードの断片はある特定の式を実行することを意味します。これは例えばスタ\nックを用いてレジスタを保存する場合等に大きな違いを生みます。インタプリ\nタが式を評価する時には、任意の偶発性に対して準備をしなければなりません。\n部分式を評価する前に、インタプリタは後で必要となる全てのレジスタを保存\nします。部分式が無原則な評価を要求するかもしれないためです。一方、コン\nパイラは処理対象の特定の式の構造を利用して不必要なスタック命令を回避す\nるコードを生成することができます。\nその一例として、組み合わせ\n(f 84 96)\nについて考えてみます。インタプ\nリタが組み合わせのオペレータを評価する前に、値が後で必要になるオペラン\nドと環境を持つレジスタを保存することでこの評価のための準備を行います。\n次にインタプリタはオペレータを評価してその結果を\nval\nに取得し、保存した\nレジスタを戻し、最後に結果を\nval\nから\nproc\nに移します。しかし、私達が評\n価しているこの式では、オペレータがシンボルの\nf\nであり、その評価は機械語\nの\nlookup-variable-value\nにて達成され、これはどのレジスタの値も変化さ\nせません。この節で実装するコンパイラはこの事実を活用し、オペレータをこ\nの命令を使用して評価するコードを生成します。\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\nf\n)\n613","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":639},{"id":"./test/fixtures/pdf/sicp.pdf:640","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nreg\nenv\n))\nこのコードは不必要な保存と復元を回避するだけでなく、\nlookup\nの値を直接\nproc\nに割り当てます。一方でインタプリタは結果を\nval\nの中に取得し、その後\nに\nproc\nへと移します。\nコンパイラはまた環境へのアクセスを最適化することができます。コード\nを解析した後に、コンパイラは多くの場合において、どのフレームの中に特定\nの変数が位置するかを知り、\nlookup-variable-value\nによる検索を実行するの\nではなしに、直接アクセスすることができます。そのような変数のアクセスを\nどのように実装するかについての議論は\nSection 5.5.6\nにて行います。\n5.5.1\nコンパイラの構造\nSection 4.1.7\nにおいて、私達は元のメタ循環インタプリタを変更して分析を\n実行から分離しました。各式を分析して環境を引数として取り必要とされる命\n令を実行する実行手続を生成しました。私達のコンパイラでは、本質的には同\nじ分析を行います。しかし、実行手続を生成する代わりに、私達のレジスタマ\nシンにより実行される命令列を生成します。\n手続\ncompile\nはコンパイラ内でのトップレベルの割り振りです。これ\nは\nSection 4.1.1\nの\neval\n手続、\nSection 4.1.7\nの\nanalyze\n手続、そして\nSection 5.4.1\nの\n明示的制御評価機のエントリポイント\neval-dispatch\nに対応します。コンパ\nイラはインタプリタと同様に、\nSection 4.1.2\nにおける式の構文手続を用います。\n35\ncompile\nはコンパイルされる式の構文の型の事例分析を実行します。各式の\n型に対し、特別な\ncode generator\n(\nコード生成器\n)\nを割り振ります。\n(\ndefine\n(\ncompile\nexp\ntarget\nlinkage\n)\n(\ncond\n((\nself-evaluating?\nexp\n)\n(\ncompile-self-evaluating\nexp\ntarget\nlinkage\n))\n((\nquoted?\nexp\n) (\ncompile-quoted\nexp\ntarget\nlinkage\n))\n((\nvariable?\nexp\n)\n(\ncompile-variable\nexp\ntarget\nlinkage\n))\n((\nassignment?\nexp\n)\n35\nしかし、私達のコンパイラが\nScheme\nプログラムであり、式を操作するためにそれが\n用いる構文手続がメタ循環評価機により仕様される実際の\nScheme\n手続であることに注\n意して下さい。一方で、明示的制御評価機では等価な構文命令がレジスタマシンに対す\nる命令として使用可能であると前提しました。\n(\nもちろん、\nScheme\nでレジスタマシンを\nシミュレートした時には、実際の\nScheme\nの手続を使用しました。\n)\n614","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":640},{"id":"./test/fixtures/pdf/sicp.pdf:641","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncompile-assignment\nexp\ntarget\nlinkage\n))\n((\ndefinition?\nexp\n)\n(\ncompile-definition\nexp\ntarget\nlinkage\n))\n((\nif?\nexp\n) (\ncompile-if\nexp\ntarget\nlinkage\n))\n((\nlambda?\nexp\n) (\ncompile-lambda\nexp\ntarget\nlinkage\n))\n((\nbegin?\nexp\n)\n(\ncompile-sequence\n(\nbegin-actions\nexp\n)\ntarget\nlinkage\n))\n((\ncond?\nexp\n)\n(\ncompile\n(\ncond->if\nexp\n)\ntarget\nlinkage\n))\n((\napplication?\nexp\n)\n(\ncompile-application\nexp\ntarget\nlinkage\n))\n(\nelse\n(\nerror\n\"\nUnknown\nexpression\ntype\n:\nCOMPILE\n\"\nexp\n))))\nターゲットとリンク記述子\ncompile\nとそれが呼ぶコード生成器はコンパイル対象の式に加えて\n2\nつの\n引数を取ります。コンパイルされたコードがその中で式の値を返すレジスタを\n指定する\ntarget\n(\nターゲット\n)\nと実行が完了した時に、式のコンパイルの結果と\nしてのコードがどのように続けるべきかを説明する\nlinkage descriptor\n(\nリンク\n記述子\n)\nです。リンク記述子はコードが以下の\n3\nつの内\n1\nつを行うよう要求す\nることができます。\n•\n列の次の命令を続ける\n(\nこれはリンク記述子\nnext\nにより指定されます\n)\n•\nコンパイルしている手続から戻る\n(\nこれはリンク記述子\nreturn\nにより指\n定されます\n)\n•\n名前付きエントリポイントへ飛ぶ\n(\nこれはリンク記述子として指定した\nラベルを用いて指定します\n)\n例えば、式\n5\n(\nこれは自己評価型\n)\nをターゲットをレジスタ\nval\n、リンク記述子\nを\nnext\nでコンパイルする時、以下の命令を生成しなければなりません。\n(\nassign\nval\n(\nconst\n5))\n同じ式をリンク記述子\nreturn\nでコンパイルする時には以下の命令を生成しな\nければなりません。\n615","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":641},{"id":"./test/fixtures/pdf/sicp.pdf:642","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\nval\n(\nconst\n5))\n(\ngoto\n(\nreg\ncontinue\n))\n最初の場合には、実行は列内の次の命令と共に続行します。\n2\nつ目の場合には、\n手続呼出から戻ります。両者の場合において、式の値はターゲットレジスタ\nval\nに配置されます。\n命令列とスタックの使用法\n各コード生成器は式のために生成したオブジェクトコードを含む\ninstruction\nsequence\n(\n命令列\n)\nを返します。複合式に対するコード生成は部分式のためのよ\nり単純なコード生成器からの出力を組み合わせることにより達成されます。こ\nれは複合式の評価が部分式を評価することにより達成されるのと同じです。\n命令列を組み合わせる最も単純な手法は\nappend-instruction-sequences\nという手続です。これは引数として順に実行されるべき任意の数の命令列を取\nり、それらを接続し、組み合わされた列を返します。つまり、もし\n⟨푠푒푞\n1\n⟩\nと\n⟨푠푒푞\n2\n⟩\nが命令列であるならば、以下の評価は、\n(\nappend-instruction-sequences\n⟨\n푠푒푞\n1\n⟩\n⟨\n푠푒푞\n2\n⟩\n)\n次の列を生成します。\n⟨\n푠푒푞\n1\n⟩\n⟨\n푠푒푞\n2\n⟩\nレジスタが保存される必要がある度に、コンパイラのコード生成器は\npreserving\nを使用します。これは命令列を組み立てるための、より芸が細かい手法です。\npreserving\nは\n3\nつの引数を取ります。レジスタの集合と\n2\nつの命令列です。\nこれは列をレジスタ集合内の各レジスタの中身が、\n2\nつ目の列の実行に必要\nならば、最初の列の実行の間は維持\n(preserve)\nされるような方法で接続しま\nす。言い換えれば、もし最初の命令列がレジスタを変更し、\n2\nつ目の列が実際\nにそのレジスタの元の中身を必要とするならば、\npreserving\nは列を接続する\n前に最初の列をそのレジスタの\nsave\nと\nrestore\nで包みます。そうでなければ、\npreserving\nは単純に接続した命令列を返します。従って、例えば\n(preserving\n(list\n⟨푟푒푔\n1\n⟩   ⟨푟푒푔\n2\n⟩\n)\n⟨푠푒푔\n1\n⟩   ⟨푠푒푔\n2\n⟩\n)\nは、\n⟨푠푒푞\n1\n⟩\nと\n⟨푠푒푞\n2\n⟩\nがどのように\n⟨푟푒푔\n1\n⟩\nと\n⟨푟푒푔\n2\n⟩\nを使用するかに依存して以下の\n4\nつの命令列の内\n1\nつを生成\nします。\n616","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":642},{"id":"./test/fixtures/pdf/sicp.pdf:643","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"⟨푠푒푞\n1\n⟩\n(save\n⟨푟푒푔\n1\n⟩\n)\n(save\n⟨푟푒푔\n2\n⟩\n)\n(save\n⟨푟푒푔\n2\n⟩\n)\n⟨푠푒푞\n2\n⟩\n⟨푠푒푞\n1\n⟩\n⟨푠푒푞\n1\n⟩\n(save\n⟨푟푒푔\n1\n⟩\n)\n(restore\n⟨푟푒푔\n1\n⟩\n)\n(restore\n⟨푟푒푔\n2\n⟩\n)\n⟨푠푒푞\n1\n⟩\n⟨푠푒푞\n2\n⟩\n⟨푠푒푞\n2\n⟩\n(restore\n⟨푟푒푔\n1\n⟩\n)\n(restore\n⟨푟푒푔\n2\n⟩\n)\n⟨푠푒푞\n2\n⟩\npreserving\nを用いて命令列を組み立てることにより、コンパイラは不必要な\nスタック命令を回避することが可能になります。これはまた\nsave\nと\nrestore\nの命令を\npreserving\n手続の中で生成するか、しないかの詳細を分離し、個別\nのコード生成器それぞれを書く場合に浮かび上がる考慮点から隔離します。実\n際に\nsave\nと\nrestore\nの命令は明示的にはコード生成器により生成されること\nはありません。\n原理上は、命令列を単純に命令のリストとして表現できるでしょう。\nappend-\ninstruction-sequences\nはそうすると命令列の組み立てを通常のリストの\nappend\nにて行うことができます。するとしかし、\npreserving\nは複雑な命令に\nなります。それが各命令列に対し、レジスタをどのように使用するかの分析を\n行わなければならないためです。また複雑であると同様に\npreserving\nが非効\n率にもなります。各命令列の引数をも分析しなければならなくなるためです。\n例えこれらの列自身が\npreserving\nの呼出により構築されていて、それらの部\n品が既に分析されていてもです。そのような分析の繰り返しを防ぐために、各\n命令列とそのレジスタ使用に関する情報とを結び付けます。基本的な命令列を\n構築する時に、私達はこの情報を明示的に与えます。そして命令列を接続する\n手続は列の組み合わせのために、レジスタ使用の情報を構成部品である列に結\nび付けられた情報から引き出します。\n命令列は\n3\nつの情報を持ちます。\n•\n命令列内の命令が実行される前に初期化しなければならないレジスタ\n集合\n(\nこれらのレジスタは命令列により\nneeded\n(\n必要とされる\n)\nと述べら\nれる\n)\n•\n列内の命令によりその値が変更されるレジスタ集合\n•\n列内の実際の命令\n(\nstatements\n(\n命令文\n)\nとも呼ばれる\n)\n命令列をその\n3\nつの部品として表現します。命令列のコンストラクタは従って\n以下のようになります。\n617","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":643},{"id":"./test/fixtures/pdf/sicp.pdf:644","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\nmake-instruction-sequence\nneeds\nmodifies\nstatements\n)\n(\nlist\nneeds\nmodifies\nstatements\n))\n喩えば、現在の環境内で変数\nx\nの値を探し、その結果を\nval\nに割り当てて戻る\n2\nつの命令の列はレジスタ\nenv\nと\ncontinue\nが初期化される必要があり、そし\nてレジスタ\nval\nを変更します。この列は従って以下のように構築されます。\n(\nmake-instruction-sequence\n'\n(\nenv\ncontinue\n)\n'\n(\nval\n)\n'\n((\nassign\nval\n(\nop\nlookup-variable-value\n) (\nconst\nx\n) (\nreg\nenv\n))\n(\ngoto\n(\nreg\ncontinue\n))))\n時々、命令文が無い命令列を構築する必要があります。\n(\ndefine\n(\nempty-instruction-sequence\n)\n(\nmake-instruction-sequence\n'\n()\n'\n()\n'\n()))\n命令列を組み立てる手続は\nSection 5.5.4\nに示します。\nExercise 5.31:\n手続適用を評価する場合において、明示的制御評価\n機は常にオペレータの評価の周りで\nenv\nレジスタの保存と復元を\n行う。また各オペランドの評価の評価の周りでも\n(\n最後の\n1\nつを除\nいて\n)\nenv\nの保存と復元を行う。そえいオペランド列の評価の周り\nでは\nproc\nの保存と復元を行う。以下の各組み合わせに対し、これ\nらの\nsave\nと\nrestore\n命令のどれが余分であり、従ってコンパイラ\nの\npreserving\nの仕組みにより削減できるかを述べよ。\n(\nf\n'x\n'y\n)\n((\nf\n)\n'x\n'y\n)\n(\nf\n(\ng\n'x\n)\ny\n)\n(\nf\n(\ng\n'x\n)\n'y\n)\nExercise 5.32:\npreserving\nの仕組みを用いた場合、コンパイラは\n組み合わせのオペレータの評価の周りでオペレータがシンボルの\n場合に\nenv\nの保存と復元を削減することができる。またそのよう\nな最適化を評価機の中に構築することもできるだろう。実際に、\nSection 5.4\nの明示的制御評価機は既に似たような最適化をオペラ\n618","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":644},{"id":"./test/fixtures/pdf/sicp.pdf:645","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ンドの無い組み合わせを特別な場合として扱うことで実行して\nいる。\na\n明示的制御評価機を拡張しオペレータがシンボルである組\nみ合わせを別のクラスの式として認識するようにせよ。そし\nてこの事実をそのような式の評価において活用するように\nせよ。\nb\nAlyssa P. Hacker\nは評価機を拡張し、組込むことができる全\nてのコンパイラの最適化をより多くの特別な場合として認識\nすることで、コンパイルの利点全体を無くすことができると\n提案した。あなたはこの考えをどう思うか\n?\n5.5.2\n式のコンパイル\nこの節と次の節では、\ncompile\n手続が割り振るコード生成器を実装します。\nリンクコードのコンパイル\n一般的に、各コード生成器の出力は手続\ncompile-linkage\nにより生成され\nた、要求されたリンク記述子を実装した命令で終わります。もしリンク記述子\nが\nreturn\nなら、命令\n(goto (reg continue))\nを生成せねばなりません。これ\nは\ncontinue\nレジスタを必要とし、他のレジスタを変更はしません。もしリン\nク記述子が\nnext\nなら、何の追加の命令も必要ありません。さもなければ、リ\nンク記述子はラベルであり、そのラベルへの\ngoto\nを生成します。この命令は\nレジスタを必要とせず、変更もしません。\n36\n36\nこの手続は\nbackquote\n(\nバッククォート\n、または\nquasiquote\n(\n擬似クォート\n))\nと呼ばれ\nる\nLisp\nの機能を使用します。これはリストを構築するのに便利です。リストの前にバッ\nククォート記号を置くことはクォートすることにとても似ていますが、リスト内のカン\nマで合図された物全てを評価することが異なります。\n例えば、もし\nlinkage\nの値がシンボル\nbranch25\nの場合、以下の式は\n`((\ngoto\n(\nlabel\n,\nlinkage\n)))\n次のリストとして評価されます。\n((\ngoto\n(\nlabel\nbranch25\n)))\n同様に、もし\nx\nの値がリスト\n(a b c)\nならば、以下の式は\n`(1 2 ,(\ncar\nx\n))\n619","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":645},{"id":"./test/fixtures/pdf/sicp.pdf:646","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ncompile-linkage\nlinkage\n)\n(\ncond\n((\neq?\nlinkage\n'return\n)\n(\nmake-instruction-sequence\n'\n(\ncontinue\n)\n'\n()\n'\n((\ngoto\n(\nreg\ncontinue\n)))))\n((\neq?\nlinkage\n'next\n)\n(\nempty-instruction-sequence\n))\n(\nelse\n(\nmake-instruction-sequence\n'\n()\n'\n()\n`((\ngoto\n(\nlabel\n,\nlinkage\n)))))))\nリンクのコードが命令列に対し\npreserving\nにより\ncontinue\nレジスタを維持\nしながら追加されます。リンク記述子\nreturn\nが\ncontinue\nレジスタを必要とす\nるためです。もし与えられた命令列が\ncontinue\nを変更し、リンクのコードが\nそれを必要とする場合、\ncontinue\nは保存と復元が行われます。\n(\ndefine\n(\nend-with-linkage\nlinkage\ninstruction-sequence\n)\n(\npreserving\n'\n(\ncontinue\n)\ninstruction-sequence\n(\ncompile-linkage\nlinkage\n)))\n単純な式のコンパイル\n自己評価型式、クォート、変数に対するコード生成器は必要な値をターゲ\nットのレジスタに割り当てリンク記述子により指示されたように進める命令列\nを構築します。\n(\ndefine\n(\ncompile-self-evaluating\nexp\ntarget\nlinkage\n)\n(\nend-with-linkage\nlinkage\n(\nmake-instruction-sequence\n'\n() (\nlist\ntarget\n)\n`((\nassign\n,\ntarget\n(\nconst\n,\nexp\n))))))\n(\ndefine\n(\ncompile-quoted\nexp\ntarget\nlinkage\n)\n(\nend-with-linkage\nlinkage\n(\nmake-instruction-sequence\n'\n() (\nlist\ntarget\n)\n次のリストとして評価されます。\n(1 2\na\n)\n620","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":646},{"id":"./test/fixtures/pdf/sicp.pdf:647","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"`((\nassign\n,\ntarget\n(\nconst\n,(\ntext-of-quotation\nexp\n)))))))\n(\ndefine\n(\ncompile-variable\nexp\ntarget\nlinkage\n)\n(\nend-with-linkage\nlinkage\n(\nmake-instruction-sequence\n'\n(\nenv\n) (\nlist\ntarget\n)\n`((\nassign\n,\ntarget\n(\nop\nlookup-variable-value\n)\n(\nconst\n,\nexp\n)\n(\nreg\nenv\n))))))\nこれら全ての代入命令はターゲットレジスタを変更します。また変数の検索を\n行う物は\nenv\nレジスタを必要とします。\n代入と定義はインタプリタの物と同様に扱われます。再帰的に変数に割り\n当てられる値を求めるコードを生成し、それに対して実際に変数の設定、また\nは定義を行う物と式全体の値\n(\nシンボル\nok\n)\nを割り当てる物の\n2\nつの命令列を\n接続します。再帰的なコンパイルはターゲット\nval\nとリンク記述子\nnext\nを持\nつのでコードはその結果を\nval\nに入れ、その後に接続されたコードを用いて続\nけられます。接続は\nenv\nを維持\n(preserving)\nしている間に行われます。環境が\n変数の設定、または定義のため必要なためです。また変数の値のためのコード\nは複雑な式のコンパイルと成り得るため任意の方法でレジスタを変更する可能\n性があります。\n(\ndefine\n(\ncompile-assignment\nexp\ntarget\nlinkage\n)\n(\nlet\n((\nvar\n(\nassignment-variable\nexp\n))\n(\nget-value-code\n(\ncompile\n(\nassignment-value\nexp\n)\n'val\n'next\n)))\n(\nend-with-linkage\nlinkage\n(\npreserving\n'\n(\nenv\n)\nget-value-code\n(\nmake-instruction-sequence\n'\n(\nenv\nval\n) (\nlist\ntarget\n)\n`((\nperform\n(\nop\nset-variable-value!\n)\n(\nconst\n,\nvar\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\n,\ntarget\n(\nconst\nok\n))))))))\n(\ndefine\n(\ncompile-definition\nexp\ntarget\nlinkage\n)\n(\nlet\n((\nvar\n(\ndefinition-variable\nexp\n))\n621","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":647},{"id":"./test/fixtures/pdf/sicp.pdf:648","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nget-value-code\n(\ncompile\n(\ndefinition-value\nexp\n)\n'val\n'next\n)))\n(\nend-with-linkage\nlinkage\n(\npreserving\n'\n(\nenv\n)\nget-value-code\n(\nmake-instruction-sequence\n'\n(\nenv\nval\n) (\nlist\ntarget\n)\n`((\nperform\n(\nop\ndefine-variable!\n)\n(\nconst\n,\nvar\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\n,\ntarget\n(\nconst\nok\n))))))))\n接続された\n2\nつの命令列は\nenv\nと\nval\nを必要とし、ターゲットを変更します。例\nえ\nenv\nをこの列のために維持したとしても、\nval\nは維持しません。\nget-value-\ncode\nが明示的にその結果をこの命令列のために\nval\nに配置するように設計さ\nれているためです。\n(\n実際には、もし\nval\nを維持した場合、バグを持つことにな\nります。これにより直前の\nval\nの中身が\nget-value-code\nの実行直後に復元さ\nれるためです。\n)\n条件式のコンパイル\n与えられたターゲットとリンク記述子と共にコンパイルされる\nif\n式のた\nめのコードは以下の形式を持ちます。\n⟨\n述語のコンパイル\n,\nターゲット\nval,\nリンク記述子\nnext\n⟩\n(\ntest\n(\nop\nfalse?\n) (\nreg\nval\n))\n(\nbranch\n(\nlabel\nfalse-branch\n))\ntrue-branch\n⟨\n結果部与えられたターゲット与えられたリンク記述子又は\nafter-if\n⟩\nfalse-branch\n⟨\n代替部与えられたターゲットリンク記述子\n⟩\nafter-if\nこのコードを生成するために、述語、結果部、代替部をコンパイルし、結果の\nコードを述語の結果をテストするコードと新しく生成された真と偽の分岐をマ\nークするラベルと条件文の最後と共に組み立てます。\n37\nこのコードの準備で\n37\n私達は単にラベル\ntrue-branch\n,\nfalse-branch\n,\nafter-if\nを上で示されたように使\nうことはできません。なぜならプログラム中に\nif\n文は複数存在する可能性があるためで\n622","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":648},{"id":"./test/fixtures/pdf/sicp.pdf:649","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"は、テストが偽である場合、真の分岐へと飛ぶ必要があります。唯一、微妙に\n複雑なのは真の分岐がリンク記述子をどのように扱うかについてです。もし条\n件文のリンク記述子が\nreturn\n、またはラベルの場合、真と偽の分岐は両方共こ\nれと同じリンク記述子を用います。もしリンク記述子が\nnext\nなら、真の分岐\nは偽の分岐を飛び越し条件文の最後へと飛ぶコードで終わります。\n(\ndefine\n(\ncompile-if\nexp\ntarget\nlinkage\n)\n(\nlet\n((\nt-branch\n(\nmake-label\n'true-branch\n))\n(\nf-branch\n(\nmake-label\n'false-branch\n))\n(\nafter-if\n(\nmake-label\n'after-if\n)))\n(\nlet\n((\nconsequent-linkage\n(\nif\n(\neq?\nlinkage\n'next\n)\nafter-if\nlinkage\n)))\n(\nlet\n((\np-code\n(\ncompile\n(\nif-predicate\nexp\n)\n'val\n'next\n))\n(\nc-code\n(\ncompile\n(\nif-consequent\nexp\n)\ntarget\nconsequent-linkage\n))\n(\na-code\n(\ncompile\n(\nif-alternative\nexp\n)\ntarget\nlinkage\n)))\n(\npreserving\n'\n(\nenv\ncontinue\n)\np-code\n(\nappend-instruction-sequences\n(\nmake-instruction-sequence\n'\n(\nval\n)\n'\n()\n`((\ntest\n(\nop\nfalse?\n) (\nreg\nval\n))\nす。\nmake-label\nはシンボルを引数として、与えられたシンボルで始まる取り新しいシン\nボルを返します。例えば、\n(make-label 'a)\nに対する連続した呼出は\na1\n,\na2\n,\n...\nを返し\nます。\nmake-label\nはクエリ言語における一意の変数名の生成と同様に、以下の様に実装\nすることができます。\n(\ndefine\nlabel-counter\n0)\n(\ndefine\n(\nnew-label-number\n)\n(\nset!\nlabel-counter\n(+ 1\nlabel-counter\n))\nlabel-counter\n)\n(\ndefine\n(\nmake-label\nname\n)\n(\nstring->symbol\n(\nstring-append\n(\nsymbol->string\nname\n)\n(\nnumber->string\n(\nnew-label-number\n)))))\n623","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":649},{"id":"./test/fixtures/pdf/sicp.pdf:650","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbranch\n(\nlabel\n,\nf-branch\n))))\n(\nparallel-instruction-sequences\n(\nappend-instruction-sequences\nt-branch\nc-code\n)\n(\nappend-instruction-sequences\nf-branch\na-code\n))\nafter-if\n))))))\nenv\nは述語コードの間維持されます。真と偽の分岐で必要になるかもしれな\nいためです。そして\ncontinue\nもそれら分岐内でリンクのためのコードにて使\n用されるかもしれないため維持されます。真と偽の分岐のためのコード\n(\n順\nには実行されません\n)\nは\nSection 5.5.4\nで説明される専用の結合器、\nparallel-\ninstruction-sequences\nを使用して接続されます。\ncond\nは派生式であることに注意してください。そのためコンパイラが取り\n扱いのために必要なこと全ては\n(\nSection 4.1.2\nの\n)\ncond->if\n変換器を適用して、\n結果の\nif\n式をコンパイルするだけです。\n列のコンパイル\n列のコンパイル\n(\n手続のボディ、または明示的な\nbegin\n式\n)\nはそれらの評価\nを並列化します。列の各式は次の条件でコンパイルされます。最後の式は列に\n対して指示されたリンク記述子を用いて。他の式はリンク記述子\nnext\nを用い\nて\n(\n列の残りを実行するために\n)\n。個別の式の命令列は接続され単一の命令列を\n形成します。\n(\n列の残りのために必要な\n)\nenv\nと\n(\n列の終わりのリンクコードで必\n要な可能性のある\n)\ncontinue\nは維持されます。\n(\ndefine\n(\ncompile-sequence\nseq\ntarget\nlinkage\n)\n(\nif\n(\nlast-exp?\nseq\n)\n(\ncompile\n(\nfirst-exp\nseq\n)\ntarget\nlinkage\n)\n(\npreserving\n'\n(\nenv\ncontinue\n)\n(\ncompile\n(\nfirst-exp\nseq\n)\ntarget\n'next\n)\n(\ncompile-sequence\n(\nrest-exps\nseq\n)\ntarget\nlinkage\n))))\nlambda\n式のコンパイル\nlambda\n式は手続を構築します。\nlambda\n式のためのオブジェクトコードは\n以下の形式に従わねばなりません。\n⟨\n手続オブジェクトの構築\n624","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":650},{"id":"./test/fixtures/pdf/sicp.pdf:651","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ターゲットレジスタにそれを割り当てる\n⟩\n⟨\nリンク\n⟩\nlambda\n式をコンパイルする時、手続のボディのためのコードも生成します。例\nえボディが手続構築時に実行されなくても、オブジェクトコードの中の\nlambda\n式のコードの直後に挿入しておくことは便利です。もし\nlambda\n式に対するリ\nンク記述子がラベルか\nreturn\nならば、このことに問題はありません。しかし、\nもしリンク記述子が\nnext\nならば、手続のボディの後ろに挿入されたラベルへ\n飛ぶリンク記述子を使用することによりボディに対するコードを回避する必要\nがあります。従ってオブジェクトコードは以下の形式になります。\n⟨\n手続オブジェクトの構築\nそれをターゲットレジスタに割当\n⟩\n⟨\n与えられたリンク記述子に対するコード\n⟩\nまたは\n(goto (label after-\nlambda))\n⟨\n手続ボディのコンパイル後コード\n⟩\nafter-lambda\ncompile-lambda\nは手続のボディのコードが続く手続オブジェクトを構築する\nためのコードを生成します。手続オブジェクトは実行時に現在の環境\n(\n定義時\n点での環境\n)\nをコンパイルされた手続ボディのエントリポイント\n(\n新しく生成\nされたラベル\n)\nと共に組み立てることで構築されます。\n38\n(\ndefine\n(\ncompile-lambda\nexp\ntarget\nlinkage\n)\n(\nlet\n((\nproc-entry\n(\nmake-label\n'entry\n))\n(\nafter-lambda\n(\nmake-label\n'after-lambda\n)))\n(\nlet\n((\nlambda-linkage\n(\nif\n(\neq?\nlinkage\n'next\n)\nafter-lambda\nlinkage\n)))\n(\nappend-instruction-sequences\n38\nSection 4.1.3\nで説明した複合手続のための構造と同様に、コンパイル後の手続を表\n現するためのデータ構造を実装するための機械語命令を必要とします。\n(\ndefine\n(\nmake-compiled-procedure\nentry\nenv\n)\n(\nlist\n'compiled-procedure\nentry\nenv\n))\n(\ndefine\n(\ncompiled-procedure?\nproc\n)\n(\ntagged-list?\nproc\n'compiled-procedure\n))\n(\ndefine\n(\ncompiled-procedure-entry\nc-proc\n) (\ncadr\nc-proc\n))\n(\ndefine\n(\ncompiled-procedure-env\nc-proc\n) (\ncaddr\nc-proc\n))\n625","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":651},{"id":"./test/fixtures/pdf/sicp.pdf:652","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ntack-on-instruction-sequence\n(\nend-with-linkage\nlambda-linkage\n(\nmake-instruction-sequence\n'\n(\nenv\n) (\nlist\ntarget\n)\n`((\nassign\n,\ntarget\n(\nop\nmake-compiled-procedure\n)\n(\nlabel\n,\nproc-entry\n)\n(\nreg\nenv\n)))))\n(\ncompile-lambda-body\nexp\nproc-entry\n))\nafter-lambda\n))))\ncompile-lambda\nは\nappend-instruction-sequences\n(\nSection 5.5.4\n)\nではなく、\n特別な結合器\ntack-on-instruction-sequence\nを手続のボディと\nlambda\n式の\nコードを接続するのに利用します。ボディは組み立てられた列が入力された時\nに実行される命令列の一部ではないためです。そうではなく、それはただ、そ\nこに置くことが便利だから、その列の中にあります。\ncompile-lambda-body\nは手続のボディのためのコードを構築します。この\nコードはエントリポイントに対するラベルで開始します。次に来るのは実行時\nの環境を手続のボディの評価を評価するために正しい環境へとスイッチする命\n令列です。即ち、手続の定義環境であり、これは手続が呼ばれる時に利用され\nる引数に対する形式パラメタの束縛を含むように拡張されています。これの後\nには、式の列のコードが来ます。これが手続のボディを作り上げます。この列\nはリンク記述子\nreturn\nとターゲット\nval\nと共にコンパイルさるため、手続の\n結果は\nval\nに入れらた状態で手続から戻ることで終わります。\n(\ndefine\n(\ncompile-lambda-body\nexp\nproc-entry\n)\n(\nlet\n((\nformals\n(\nlambda-parameters\nexp\n)))\n(\nappend-instruction-sequences\n(\nmake-instruction-sequence\n'\n(\nenv\nproc\nargl\n)\n'\n(\nenv\n)\n`(,\nproc-entry\n(\nassign\nenv\n(\nop\ncompiled-procedure-env\n)\n(\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nextend-environment\n)\n(\nconst\n,\nformals\n)\n(\nreg\nargl\n)\n(\nreg\nenv\n))))\n626","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":652},{"id":"./test/fixtures/pdf/sicp.pdf:653","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ncompile-sequence\n(\nlambda-body\nexp\n)\n'val\n'return\n))))\n5.5.3\n組み合わせのコンパイル\nコンパイル処理の本質は手続適用のコンパイルです。与えられたターゲッ\nトとリンク記述子と共にコンパイルされた組み合わせのコードは以下の形式を\n持ちます。\n⟨\n演算子のコンパイル\n,\nターゲット\nproc,\nリンク記述子\nnext\n⟩\n⟨\nオペランドを評価し、\nargl\n内に引数リストを構築\n⟩\n⟨\n手続呼出のコンパイル\n与えられたターゲットとリンク記述子と共に\n⟩\nレジスタ\nenv\n,\nproc\n,\nargl\nはオペレータ\n(\n演算子\n)\nとオペランドの評価の間に保\n存と復元を行う必要があるかもしれません。ここだけがこのコンパイラにおい\nて\nval\n以外のターゲットが指定される箇所であることに注意して下さい。\n必要なコードは\ncompile-application\nにより生成されます。これは再帰的\nにオペレータをコンパイルして\nproc\nに適用する手続を配置するコードを生成\nし、オペランドをコンパイルして個別の適用の個々のオペランドを評価するコ\nードを生成します。オペランドの命令列は\n(\nconstruct-arglist\nにより\n)\nargl\nに引数リストを構築するコードと共に組み合わされます。そして結果となる引\n数リストのコードは手続のコードと\n(\ncompile-procedure-call\nにより生成さ\nれた\n)\n手続呼出を実行するコードと共に組み合わされます。コードの列の接続\nにおいて、\nenv\nレジスタはオペレータの評価の周りにおいて維持\n(preserving)\nされなければなりません。\n(\nオペレータの評価がオペランドの評価で必要とな\nenv\nを変更する可能性があるため\n)\n。そして\nproc\nレジスタは引数リストの周り\nで維持されなければなりません。\n(\nオペランドの評価が実際の手続適用に必要\nな\nproc\nレジスタを変更するかもしれないため\n)\n。\nContinue\nもまたその間中、維\n持されなければなりません。手続呼出のリンクコードが必要とするためです。\n(\ndefine\n(\ncompile-application\nexp\ntarget\nlinkage\n)\n(\nlet\n((\nproc-code\n(\ncompile\n(\noperator\nexp\n)\n'proc\n'next\n))\n(\noperand-codes\n(\nmap\n(\nlambda\n(\noperand\n) (\ncompile\noperand\n'val\n'next\n))\n(\noperands\nexp\n))))\n(\npreserving\n'\n(\nenv\ncontinue\n)\n627","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":653},{"id":"./test/fixtures/pdf/sicp.pdf:654","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"proc-code\n(\npreserving\n'\n(\nproc\ncontinue\n)\n(\nconstruct-arglist\noperand-codes\n)\n(\ncompile-procedure-call\ntarget\nlinkage\n)))))\n引数リストを構築するためのコードは\nval\n内に評価して、次にその値を\nargl\nに蓄積される引数リスト上に\ncons\nします。\nargl\n上に順に引数を\ncons\nするた\nめ、最後の引数から開始し、最初のもので終わらなければなりません。そうす\nることで引数は結果リストの中に最初から最後の順で現れることになります。\nこの一連の評価のための設定を行うため、\nargl\nを空に初期化することで命令を\n無駄にするのではなく、\nargl\nの初期値を構築する最初のコード列を作成しま\nす。従って、引数リスト構築の一般的な形式は以下になります。\n⟨\n最後のオペランドのコンパイル\n,\nターゲットは\nval\n⟩\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n⟨\n次のオペランドのコンパイル\n,\nターゲットは\nval\n⟩\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n...\n⟨\n最初のオペランドのコンパイル\n,\nターゲットは\nval\n⟩\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\nargl\nは各オペランドの評価の間、最初の\n1\nつを除いて維持しなければなりませ\nん。\n(\nそうすることで、そこまで蓄積した引数を失わないように\n)\n。そして\nenv\nは\n(\n続きのオペランド評価での使用のため\n)\n各オペランドの評価の周りで、最\n後の\n1\nつを除いて維持されなければなりません。\nこの引数コードのコンパイルは少しだけ巧妙です。評価する最初のオペラ\nンドの特別な扱いと、\nargl\nと\nenv\nを異なる箇所にて維持する必要性のためで\nす。\nconstruct-arglist\n手続は引数として個々のオペランドを評価するコード\nを取ります。もしオペランドが全く無ければ、単純に以下の命令を発行します。\n(\nassign\nargl\n(\nconst\n()))\nそうでなければ、\nconstruct-arglist\nは\nargl\nを最後の引数で初期化するコー\nドを生成し、引数の残りを評価するコードを接続し、それらを相次いで\nargl\nの中に隣接させていきます。引数を最後から最初へ処理するために、オペラン\nドのコード列のリストを\ncompile-application\nにより提供された順から逆順\n(reverse)\nにする必要があります。\n(\ndefine\n(\nconstruct-arglist\noperand-codes\n)\n628","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":654},{"id":"./test/fixtures/pdf/sicp.pdf:655","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\noperand-codes\n(\nreverse\noperand-codes\n)))\n(\nif\n(\nnull?\noperand-codes\n)\n(\nmake-instruction-sequence\n'\n()\n'\n(\nargl\n)\n'\n((\nassign\nargl\n(\nconst\n()))))\n(\nlet\n((\ncode-to-get-last-arg\n(\nappend-instruction-sequences\n(\ncar\noperand-codes\n)\n(\nmake-instruction-sequence\n'\n(\nval\n)\n'\n(\nargl\n)\n'\n((\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n)))))))\n(\nif\n(\nnull?\n(\ncdr\noperand-codes\n))\ncode-to-get-last-arg\n(\npreserving\n'\n(\nenv\n)\ncode-to-get-last-arg\n(\ncode-to-get-rest-args\n(\ncdr\noperand-codes\n))))))))\n(\ndefine\n(\ncode-to-get-rest-args\noperand-codes\n)\n(\nlet\n((\ncode-for-next-arg\n(\npreserving\n'\n(\nargl\n)\n(\ncar\noperand-codes\n)\n(\nmake-instruction-sequence\n'\n(\nval\nargl\n)\n'\n(\nargl\n)\n'\n((\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n)))))))\n(\nif\n(\nnull?\n(\ncdr\noperand-codes\n))\ncode-for-next-arg\n(\npreserving\n'\n(\nenv\n)\ncode-for-next-arg\n(\ncode-to-get-rest-args\n(\ncdr\noperand-codes\n))))))\n手続の適用\n組み合わせの要素を評価した後に、コンパイルされたコードは\nproc\n内\nの手続を\nargl\n内の引数に適用しなければなりません。このコードは本質的\nに\nSection 4.1.1\nのメタ循環評価機の\napply\n手続、または\nSection 5.4.1\nの明示的\n制御評価機の\napply-dispatch\nエントリポイントと同じ割り振りを実行します。\n適用する手続がプリミティブな手続であるか複合手続であるかを確認します。\n629","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":655},{"id":"./test/fixtures/pdf/sicp.pdf:656","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"プリミティブな手続に対しては、\napply-primitive-procedure\nを使用します。\n簡潔にこれがどのようにコンパイルされた手続を取り扱うのかについて見てい\nきます。手続適用のコードは以下の形式を持ちます。\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch\n))\ncompiled-branch\n⟨\n与えられたターゲットと適切なリンク記述子と共に手続をコンパイルするコ\nード\n⟩\nprimitive-branch\n(\nassign\n⟨\ntarget\n⟩\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\n⟨\nリンクコード\n⟩\nafter-call\nコンパイルされた分岐は\nprimitive-branch\nをスキップしなければならないこと\nに注意して下さい。従って、もし元の手続呼出のリンク記述子が\nnext\nならば、\n複合分岐は\nprimitive-branch\nの後に挿入されたラベルへと飛ぶリンクコードを\n使用しなければなりません。\n(\nこれは\ncompile-if\nにおいて、真の分岐のために\n使用されたリンクコードと同様です。\n)\n(\ndefine\n(\ncompile-procedure-call\ntarget\nlinkage\n)\n(\nlet\n((\nprimitive-branch\n(\nmake-label\n'primitive-branch\n))\n(\ncompiled-branch\n(\nmake-label\n'compiled-branch\n))\n(\nafter-call\n(\nmake-label\n'after-call\n)))\n(\nlet\n((\ncompiled-linkage\n(\nif\n(\neq?\nlinkage\n'next\n)\nafter-call\nlinkage\n)))\n(\nappend-instruction-sequences\n(\nmake-instruction-sequence\n'\n(\nproc\n)\n'\n()\n`((\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\n,\nprimitive-branch\n))))\n(\nparallel-instruction-sequences\n(\nappend-instruction-sequences\ncompiled-branch\n(\ncompile-proc-appl\ntarget\ncompiled-linkage\n))\n630","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":656},{"id":"./test/fixtures/pdf/sicp.pdf:657","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nappend-instruction-sequences\nprimitive-branch\n(\nend-with-linkage\nlinkage\n(\nmake-instruction-sequence\n'\n(\nproc\nargl\n)\n(\nlist\ntarget\n)\n`((\nassign\n,\ntarget\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n)))))))\nafter-call\n))))\ncompile-if\nの真と偽の分岐のような、プリミティブかつ、複合な分岐は通常の\nappend-instruction-sequences\nではなく\nparallel-instruction-sequences\nを用いて接続されます。それらは順には実行されないためです。\nコンパイル済み手続の適用\n手続の適用を取り扱うコードはコンパイラの最も微妙な部分です。例えそ\nれが生成する命令列がとても短くても変わりません。\n(\ncompile-lambda\nにより\n構築されたような\n)\nコンパイルされた手続は手続が開始する場所を指定するラ\nベルであるエントリポイントを持ちます。このエントリポイントにてコードは\nval\nに結果を求め、命令\n(goto (reg continue))\nを実行することにより戻り\nます。従って与えられたターゲットとリンク記述子を伴なう\n(\ncompile-proc-\nappl\nにより生成される\n)\nコンパイルされた手続の適用はリンク記述子がラベル\nであれば以下のようになります。\n(\nassign\ncontinue\n(\nlabel\nproc-return\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nproc-return\n(\nassign\n⟨\ntarget\n⟩\n(\nreg\nval\n))\n;\nターゲットが\nval\nでなければ含まれ\nる\n(\ngoto\n(\nlabel\n⟨\nリンク記述子\n⟩\n))\n;\nリンクコード\nまたはリンク記述子が\nreturn\nの場合は次のとおりです。\n(\nsave\ncontinue\n)\n(\nassign\ncontinue\n(\nlabel\nproc-return\n))\n631","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":657},{"id":"./test/fixtures/pdf/sicp.pdf:658","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nproc-return\n(\nassign\n⟨\ntarget\n⟩\n(\nreg\nval\n))\n;\nターゲットが\nval\nでなければ含まれ\nる\n(\nrestore\ncontinue\n)\n(\ngoto\n(\nreg\ncontinue\n))\n;\nリンクコード\nこのコードは手続が\nproc-return\nに戻るように\ncontinue\nを設定し、手続のエ\nントリポイントへと飛びます。\nproc-return\nのコードは手続の結果を\nval\nから\nターゲットレジスタへと\n(\nもし必要なら\n)\n転送し、次にリンク記述子により指定\nされた位置へと飛びます。\n(\nリンク記述子は常に\nreturn\nかラベルです。なぜな\nら\ncompile-procedure-call\nが複合手続の分岐のためのリンク記述子\nnext\nを\nafter-call\nラベルに置き換えるためです。\n)\n実際には、もしターゲットが\nval\nでなければ、それはまさに私達のコンパ\nイラが生成するコードです。\n39\nしかし、通常はターゲットは\nval\nであり\n(\nコン\nパイラが異なるレジスタを指定する唯一の場合はオペレータの評価のターゲッ\nトを\nproc\nにする時です\n)\n、そのため手続の結果は直接ターゲットレジスタに入\nれられ、コピーを行う特別な位置へ戻る必要はありません。その代わりに、手\n続が直接呼び出し元のリンク記述子により指定される場所へ直接\n“\n戻る\n”\nよう\nに\ncontinue\nを設定します。\n⟨\ncontinue\nにリンク記述子を設定\n⟩\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nもしリンク記述子がラベルならば、手続がそのラベルに戻るように\ncontinue\nを設定します。\n(\nつまり、上記の\nproc-return\nにおいて手続の終端\n(goto (reg\ncontinue))\nが\n(goto (label <\nlinkage\n>))\nと等価になります。\n)\n(\nassign\ncontinue\n(\nlabel\n⟨\nリンク記述子\n⟩\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nもしリンク記述子が\nreturn\nなら、\ncontinue\nを設定する必要は全くありません。\nそれは既に望まれた位置を持っています。\n(\n言い換えれば、手続の終端\n(goto\n39\n実際に、ターゲットが\nval\nでなく、リンク記述子が\nreturn\nである場合にはエラーを\n発します。私達がリンク記述子\nreturn\nを要求する箇所は手続のコンパイル内のみです。\nそして私達の仕様は、手続はその値を\nval\nにて返す、です。\n632","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":658},{"id":"./test/fixtures/pdf/sicp.pdf:659","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(reg continue))\nは\nproc-return\nの\n(goto (reg continue))\nが飛ぶはずだっ\nた場所へ直接飛びます。\n)\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nこのリンク記述子\nreturn\nの実装を用いて、コンパイラは末尾再帰のコードを\n生成します。手続のボディの最後ステップとしての手続の呼出は直接移動を行\nいスタック上にどのような情報も保存しません。\nその代わりに手続呼出の場合をリンク記述子\nreturn\nとターゲット\nval\nを\n用いて、上記で示されたように\nval\n以外のターゲットに対しても取り扱ったと\n仮定します。これは末尾再帰を損うでしょう。それでも、私達のシステムは任\n意の式に対して同じ値を与えます。しかし、私達が手続を呼ぶ度に、\ncontinue\nを保存し、呼出の後に\n(\n必要の無い\n)\n保存の取消を呼び出すことになります。こ\nれらの余分な保存が入れ子の手続呼出の間に蓄積されます。\n40\ncodecompile-proc-appl\nは上記の手続適用のコードを生成します。これは呼\n出のためのターゲットが\nval\nであるか、そしてリンク記述子が\nreturn\nであ\nるかについてに依存する\n4\nつの場合について考慮します。命令列が全てのレ\nジスタを変更するために宣言されることについて注意して下さい。手続のボ\nディの実行が自由な形でレジスタを変更することができるためです。\n41\nまた\n40\nコンパイラに末尾再帰のコードを生成させることは簡単な考えのように見えるかも\nしれません。しかし一般的な言語のための多くのコンパイラは\nC\n言語と\nPascal\nを含め\nて、これを行いません。従ってこれらの言語は反復プロセスを手続呼出のみを用いて表\n現することができません。これらの言語における末尾再帰の困難さはそれらの実装がス\nタックを用いて手続の引数とローカル変数と同様にリターンアドレスをも格納してい\nるためです。この本で説明されている\nScheme\nの実装は引数と変数をガベージコレクシ\nョンされるようにメモリに保存します。変数と引数に対してスタックを使用する理由は\n他のやり方によりガベージコレクションの必要の無い言語内で、その必要性を回避する\nからです。そして一般的にはより効率的になると信じられています。実際には、最新の\nLisp\nコンパイラは末尾再帰を無効化せずにスタックを引数のために使用することができ\nます。\n(\nこのことの説明に関しては\nHanson 1990\nを参照して下さい\n)\n。またスタックの割当\nがそもそもガベージコレクションより効率的であるかどうかについての討論もいくつか\n存在します。しかし、詳細はコンピュータアーキテクチャの委細に依存しているように\n見えます。\n(\nこの問題の反対の立場からの視点については\nAppel 1987\nと\nMiller and Rozas\n1994\nを参照して下さい。\n)\n41\n変数\nall-regs\nは全てのレジスタの名前のリストに対して束縛されます。\n(\ndefine\nall-regs\n'\n(\nenv\nproc\nval\nargl\ncontinue\n))\n633","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":659},{"id":"./test/fixtures/pdf/sicp.pdf:660","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ターゲットが\nval\nであり、リンク記述子が\nreturn\nの場合に対するコードの\n列は\ncontinue\nを必要とすると宣言されていることに注意して下さい。例え\ncontinue\nが明示的に\n2\nつの命令列の中で使用されていなくとも、私達がコン\nパイルされた手続を入力した時に\ncontinue\nが正しい値を持つことを確実にし\nなければなりません。\n(\ndefine\n(\ncompile-proc-appl\ntarget\nlinkage\n)\n(\ncond\n((\nand\n(\neq?\ntarget\n'val\n) (\nnot\n(\neq?\nlinkage\n'return\n)))\n(\nmake-instruction-sequence\n'\n(\nproc\n)\nall-regs\n`((\nassign\ncontinue\n(\nlabel\n,\nlinkage\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n)\n(\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n)))))\n((\nand\n(\nnot\n(\neq?\ntarget\n'val\n))\n(\nnot\n(\neq?\nlinkage\n'return\n)))\n(\nlet\n((\nproc-return\n(\nmake-label\n'proc-return\n)))\n(\nmake-instruction-sequence\n'\n(\nproc\n)\nall-regs\n`((\nassign\ncontinue\n(\nlabel\n,\nproc-return\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n)\n(\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\n,\nproc-return\n(\nassign\n,\ntarget\n(\nreg\nval\n))\n(\ngoto\n(\nlabel\n,\nlinkage\n))))))\n((\nand\n(\neq?\ntarget\n'val\n) (\neq?\nlinkage\n'return\n))\n(\nmake-instruction-sequence\n'\n(\nproc\ncontinue\n)\nall-regs\n'\n((\nassign\nval\n(\nop\ncompiled-procedure-entry\n)\n(\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n)))))\n((\nand\n(\nnot\n(\neq?\ntarget\n'val\n))\n(\neq?\nlinkage\n'return\n))\n(\nerror\n\"\nreturn\nlinkage,\ntarget\nnot\nval\n:\nCOMPILE\n\"\ntarget\n))))\n634","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":660},{"id":"./test/fixtures/pdf/sicp.pdf:661","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"5.5.4\n命令列のコンパイル\nこの節では命令列がどのように表現され、組み合わされるのかについての\n詳細を説明します。\nSection 5.5.1\nから命令列が必要なレジスタのリスト、変更\nされるレジスタ、実際の命令のリストとして表現されたことを思い出して下さ\nい。またラベル\n(\nシンボル\n)\nを命令列の退化した場合だと考慮します。これはど\nのレジスタも必要とせず、また変更しません。故に、命令列により必要とされ\nる、または変更されるレジスタを決定するために以下のセレクタを用います。\n(\ndefine\n(\nregisters-needed\ns\n)\n(\nif\n(\nsymbol?\ns\n)\n'\n() (\ncar\ns\n)))\n(\ndefine\n(\nregisters-modified\ns\n)\n(\nif\n(\nsymbol?\ns\n)\n'\n() (\ncadr\ns\n)))\n(\ndefine\n(\nstatements\ns\n)\n(\nif\n(\nsymbol?\ns\n) (\nlist\ns\n) (\ncaddr\ns\n)))\nまた与えられた命令列が与えられたレジスタを必要とするか、変更するかを決\n定するために以下の述語を用います。\n(\ndefine\n(\nneeds-register?\nseq\nreg\n)\n(\nmemq\nreg\n(\nregisters-needed\nseq\n)))\n(\ndefine\n(\nmodifies-register?\nseq\nreg\n)\n(\nmemq\nreg\n(\nregisters-modified\nseq\n)))\nこれらの述語とセレクタを用いて、コンパイラを通して使用される様々な命令\n列の結合器\n(combiner)\nを実装することができます。\n基本的な結合器は\nappend-instruction-sequences\nです。これは引数とし\nて順に実行される任意の数の命令列を取り、命令文\n(statement)\nが全ての命令\n列の命令文を一緒に接続した命令文である命令列を返します。結果の命令列に\nより必要とされる、または変更されるレジスタの決定が繊細な点になります。\nこれは命令列のどれかにより変更されるレジスタが変更されます。またこれは\n最初の命令列が実行する前に初期化されなければならないレジスタ\n(\n最初の命\n令列で必要とされるレジスタ\n)\nに加えて、それに続く命令列により初期化され\nない\n(\n変更されない\n)\n他の命令列により必要とされるレジスタ全てです。\n命令列は\nappend-2-sequences\nにより一度に\n2\nつが接続されます。これは\n2\nつの命令列\nseq1\nと\nseq2\nを取り、命令文が\nseq1\nの命令文の後に\nseq2\nの命令\n文が置かれる命令列を返します。これの変更されたレジスタは\nseq1\nか\nseq2\nの\nどちらかにより変更されたレジスタです。そして必要とされるレジスタは\nseq1\nにより必要とされるレジスタと\nseq2\nで必要とされ\nseq1\nで変更されないレジ\n635","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":661},{"id":"./test/fixtures/pdf/sicp.pdf:662","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"スタを加えたものです。\n(\n集合の命令を用いて、必要なレジスタの新しい集合は\nseq1\nにより必要とされるレジスタの集合と、\nseq2\nにより必要とされるレジス\nタと\nseq1\nにより変更されたレジスタの差集合との、和集合です。\n)\n(\ndefine\n(\nappend-instruction-sequences\n.\nseqs\n)\n(\ndefine\n(\nappend-2-sequences\nseq1\nseq2\n)\n(\nmake-instruction-sequence\n(\nlist-union\n(\nregisters-needed\nseq1\n)\n(\nlist-difference\n(\nregisters-needed\nseq2\n)\n(\nregisters-modified\nseq1\n)))\n(\nlist-union\n(\nregisters-modified\nseq1\n)\n(\nregisters-modified\nseq2\n))\n(\nappend\n(\nstatements\nseq1\n) (\nstatements\nseq2\n))))\n(\ndefine\n(\nappend-seq-list\nseqs\n)\n(\nif\n(\nnull?\nseqs\n)\n(\nempty-instruction-sequence\n)\n(\nappend-2-sequences\n(\ncar\nseqs\n)\n(\nappend-seq-list\n(\ncdr\nseqs\n)))))\n(\nappend-seq-list\nseqs\n))\nこの手続はリストとして表現された集合を操作するためのいくつかの簡単な命\n令を使います。\nSection 2.3.3\nで説明された\n(\n順序無し\n)\n集合表現と同様です。\n(\ndefine\n(\nlist-union\ns1\ns2\n)\n(\ncond\n((\nnull?\ns1\n)\ns2\n)\n((\nmemq\n(\ncar\ns1\n)\ns2\n) (\nlist-union\n(\ncdr\ns1\n)\ns2\n))\n(\nelse\n(\ncons\n(\ncar\ns1\n) (\nlist-union\n(\ncdr\ns1\n)\ns2\n)))))\n(\ndefine\n(\nlist-difference\ns1\ns2\n)\n(\ncond\n((\nnull?\ns1\n)\n'\n())\n((\nmemq\n(\ncar\ns1\n)\ns2\n) (\nlist-difference\n(\ncdr\ns1\n)\ns2\n))\n(\nelse\n(\ncons\n(\ncar\ns1\n)\n(\nlist-difference\n(\ncdr\ns1\n)\ns2\n)))))\npreserving\nは\n2\nつ目の主な命令列結合器ですが、レジスタのリスト\nregs\nと\n順に実行する\n2\nつの命令列\nseq1\nと\nseq2\nを取ります。これは\nseq1\nの命令文\n(statements)\nのその後に\nseq2\nの命令文が続く命令文を持つ命令列を返します。\n636","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":662},{"id":"./test/fixtures/pdf/sicp.pdf:663","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"この命令文には\nseq1\nにより変更されるが\nseq2\nで必要とされる\nregs\n内のレジ\nスタを守るために\nseq1\nの周りに適切な\nsave\nと\nrestore\nが追加されます。こ\nれを達成するために、\npreserving\nは最初に必要とされる\nsave\nとそれに続く\nseq1\n、それに続く必要とされる\nrestore\nを持つ命令列を作ります。この命令列\nは\nseq1\nにより必要とされるレジスタに加えてレジスタの保存と復元を必要と\nします。そして\nseq1\nで変更されたレジスタを保存と回復が行われるものを除\nいて変更します。次に、この増補された命令列と\nseq2\nが通常の方法で接続さ\nれます。以下の手続はこの戦略を、維持されるべきレジスタのリストを横断し\nながら再帰的に実装します。\n42\n(\ndefine\n(\npreserving\nregs\nseq1\nseq2\n)\n(\nif\n(\nnull?\nregs\n)\n(\nappend-instruction-sequences\nseq1\nseq2\n)\n(\nlet\n((\nfirst-reg\n(\ncar\nregs\n)))\n(\nif\n(\nand\n(\nneeds-register?\nseq2\nfirst-reg\n)\n(\nmodifies-register?\nseq1\nfirst-reg\n))\n(\npreserving\n(\ncdr\nregs\n)\n(\nmake-instruction-sequence\n(\nlist-union\n(\nlist\nfirst-reg\n)\n(\nregisters-needed\nseq1\n))\n(\nlist-difference\n(\nregisters-modified\nseq1\n)\n(\nlist\nfirst-reg\n))\n(\nappend\n`((\nsave\n,\nfirst-reg\n))\n(\nstatements\nseq1\n)\n`((\nrestore\n,\nfirst-reg\n))))\nseq2\n)\n(\npreserving\n(\ncdr\nregs\n)\nseq1\nseq2\n)))))\n別の命令列結合器である\ntack-on-instruction-sequence\nは\ncompile-lambda\nにより手続のボディを他の命令列に接続するために使用されます。手続のボデ\nィは組み合わされた列の一部として実行されるための\n“\nインライン\n”\n形式では\nないため、それによるレジスタの使用はそれが組込まれる命令列のレジスタ使\n用に影響を与えません。従って手続ボディの必要な、また変更されるレジスタ\nの集合は別の命令列に接続する時に無視されます。\n42\npreserving\nが\nappend\nを\n3\nつの引数と共に呼び出すことに注意して下さい。この本\nに表われる\nappend\nの定義は\n2\nつの引数しか受け付けませんが、\nScheme\nの標準は任意の\n数の引数を取る\nappend\n手続を提供します。\n637","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":663},{"id":"./test/fixtures/pdf/sicp.pdf:664","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ndefine\n(\ntack-on-instruction-sequence\nseq\nbody-seq\n)\n(\nmake-instruction-sequence\n(\nregisters-needed\nseq\n)\n(\nregisters-modified\nseq\n)\n(\nappend\n(\nstatements\nseq\n)\n(\nstatements\nbody-seq\n))))\ncompile-if\nと\ncompile-procedure-call\nは\nparallel-instruction-sequences\nと呼ばれる特別な結合器を使用してテストに続く二者択一の分岐を接続しま\nす。\n2\nつの分岐は絶対に順には実行されません。どんなテストの評価に対して\nも、一方か、別の一方に入ります。このため、\n2\nつ目の分岐により必要とされ\nるレジスタは例えもしこれらが\n1\nつ目の分岐により変更されようとも依然とし\nて結合後の命令列でも必要とします。\n(\ndefine\n(\nparallel-instruction-sequences\nseq1\nseq2\n)\n(\nmake-instruction-sequence\n(\nlist-union\n(\nregisters-needed\nseq1\n)\n(\nregisters-needed\nseq2\n))\n(\nlist-union\n(\nregisters-modified\nseq1\n)\n(\nregisters-modified\nseq2\n))\n(\nappend\n(\nstatements\nseq1\n)\n(\nstatements\nseq2\n))))\n5.5.5\nコンパイルされたコードの例\nこれでコンパイラの全ての要素について学び終えました。ここまでのもの\nがどのように御互いに組合せられるのかを見るためにコンパイル済みのコード\nの例を試してみましょう。再帰\nfactorial\n手続の定義を\ncompile\nを呼ぶことで\nコンパイルしてみます。\n(\ncompile\n'\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1)\n1\n(* (\nfactorial\n(-\nn\n1))\nn\n)))\n'val\n'next\n)\n638","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":664},{"id":"./test/fixtures/pdf/sicp.pdf:665","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"define\n式の値はレジスタ\nval\nに配置されなければならないと指定しました。私\n達は\ndefine\nを実行した後にコンパイル済みコードが何を行うのか気にしませ\nん。そのためリンク記述子に対する\nnext\nの選択は気まぐれです。\ncompile\nは式が定義であるかを判断します。そのため\ncompile-definition\nを呼び出し\n(\nターゲット\nval\nに対し\n)\n割り当てられるべき値を求めるコードを\nコンパイルします。続いて定義を導入するコード、さらに\ndefine\nの値\n(\nシンボ\nル\nok\n)\nをターゲットレジスタに入れるコード、最後にリンクコードが続きます。\nenv\nは値の演算の周りで維持されます。定義の導入のために必要とされるため\nです。今回のリンク記述子は\nnext\nですから、リンクコードは存在しません。従\nってコンパイルされたコードの骨格は以下のようになります。\n⟨\n値を求めるコードで変更されるなら\nenv\nを保存\n⟩\n⟨\n定義値、ターゲット\nval\n、リンク記述子\nnext\nのコンパイル\n⟩\n⟨\n上で保存したなら\nenv\nの復元\n⟩\n(\nperform\n(\nop\ndefine-variable!\n)\n(\nconst\nfactorial\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\n変数\nfactorial\nに対する値を生成するためにコンパイルされる式は、値が階\n乗を計算する手続である\nlambda\n式です。\ncompile\nは\ncompile-lambda\nを呼ぶ\nことによりこれを扱います。\ncompile-lambda\nは手続のボディをコンパイルし、\nそれに新しいエントリポイントとしてラベル付けを行い、新しいエントリポイ\nントの手続ボディを実行時環境と組み合わせ、結果を\nval\nに割り当てるコード\nを生成します。次に命令列はこの時点で挿入された、このコンパイルされたコ\nードをスキップします。手続のコードそれ自体は手続定義環境を形式パラメタ\nn\nを手続の引数に束縛するフレームにより拡張することから始めます。その次\nに実際の手続のボディが来ます。変数の値のためのこのコードは\nenv\nレジスタ\nを変更しませんので、上で示された任意の\nsave\nと\nrestore\nは生成されません。\n(\nentry2\nにおける手続のコードはこの時点では実行されません。そのため、そ\nの\nenv\nの使用は無関係です\n)\n。従って、コンパイルされたコードの骨組は以下の\nようになります。\n(\nassign\nval\n(\nop\nmake-compiled-procedure\n)\n(\nlabel\nentry2\n)\n(\nreg\nenv\n))\n639","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":665},{"id":"./test/fixtures/pdf/sicp.pdf:666","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\ngoto\n(\nlabel\nafter-lambda1\n))\nentry2\n(\nassign\nenv\n(\nop\ncompiled-procedure-env\n) (\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nextend-environment\n)\n(\nconst\n(\nn\n))\n(\nreg\nargl\n)\n(\nreg\nenv\n))\n⟨\n手続ボディのコンパイル\n⟩\nafter-lambda1\n(\nperform\n(\nop\ndefine-variable!\n)\n(\nconst\nfactorial\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\n手続のボディは常に\n(\ncompile-lambda-body\nにより\n)\n、ターゲット\nval\nとリンク\n記述子\nreturn\nを用いる命令列としてコンパイルされます。今回の場合の命令\n列は単一の\nif\n式から成り立ちます。\n(\nif\n(=\nn\n1)\n1\n(* (\nfactorial\n(-\nn\n1))\nn\n))\ncompile-if\nは最初に述語を演算し\n(\nターゲットは\nval\n)\n、次にその結果を確認\nして述語が偽であれば真の分岐を回避します。\nenv\nと\ncontinue\nが述語のコー\nドの周りで維持されます。それらが\nif\n式の残りの部分で必要となる可能性が\nあるためです。\nif\n式が手続のボディを構成する命令列内の最後の式であるた\nめ\n(\nそしてただ\n1\nつの式であるため\n)\n、そのターゲットは\nval\nで、リンク記述子\nは\nreturn\nになります。そのため真と偽の両方の分岐がターゲット\nval\nとリン\nク記述子\nreturn\nと共にコンパイルされます。\n(\n言い換えれば、どちらかの分岐\nにより値が演算される条件文の値がその手続の値です。\n)\n⟨\n述語により変更され、分岐により必要とされるなら\ncontinue, env\nを保存す\nる\n⟩\n⟨\n述語\n,\nターゲット\nval,\nリンク記述子\nnext\nのコンパイル\n⟩\n⟨\n上で保存したなら\ncontinue, env\nを復元する\n⟩\n(\ntest\n(\nop\nfalse?\n) (\nreg\nval\n))\n640","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":666},{"id":"./test/fixtures/pdf/sicp.pdf:667","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbranch\n(\nlabel\nfalse-branch4\n))\ntrue-branch5\n⟨\n真の分岐\n,\nターゲット\nval,\nリンク記述子\nreturn\nのコンパイル\n⟩\nfalse-branch4\n⟨\n偽の分岐\n,\nターゲット\nval,\nリンク記述子\nreturn\nのコンパイル\n⟩\nafter-if3\n述語\n(= n 1)\nは手続の呼出です。これはオペレータ\n(\nシンボル\n=\n)\nを探し、その\n値を\nproc\n内に配置します。次に引数\n1\nと変数\nn\nを\nargl\nに集めます。そして\nproc\nがプリミティブ、または複合手続を含むかどうかをテストし、それに応じ\nてプリミティブの分岐か複合の分岐へ飛びます。両方の分岐がラベル\nafter-\ncall\nにて再開します。オペレータとオペランドの評価の周りでレジスタを維\n持する必要性はどのレジスタも保存することにはなりません。今回の場合はそ\nれらの評価は問題となるレジスタを変更しないためです。\n(\nassign\nproc\n(\nop\nlookup-variable-value\n) (\nconst\n=) (\nreg\nenv\n))\n(\nassign\nval\n(\nconst\n1))\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nassign\nval\n(\nop\nlookup-variable-value\n) (\nconst\nn\n) (\nreg\nenv\n))\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch17\n))\ncompiled-branch16\n(\nassign\ncontinue\n(\nlabel\nafter-call15\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch17\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call15\n真の分岐は定数\n1\nですが、\n(\nターゲット\nval\nとリンク記述子\nreturn\nと共に\n)\n以\n下のようにコンパイルされます。\n641","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":667},{"id":"./test/fixtures/pdf/sicp.pdf:668","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\nval\n(\nconst\n1))\n(\ngoto\n(\nreg\ncontinue\n))\n偽の分岐のコードは別の手続呼出です。手続はシンボル\n*\nで、その引数は\nn\nと\n別の手続呼出の結果\n(\nfactorial\nの呼出\n)\nです。これらの呼出の全てが\nproc\nと\nargl\n、それ自身のプリミティブと複合の分岐の準備を行います。\nFigure 5.17\nは\n手続\nfactorial\nの定義の完全なコンパイルを示します。述語の周りで可能性の\nある\ncontinue\nと\nenv\nの\nsave\nと\nrestore\nが実際に生成されていることに注意\nして下さい。これらのレジスタが述語内の手続呼出にて変更され、また分岐内\nの手続呼び出しと\nreturn\nのリンクコードにより必要とされるためです。\nExercise 5.33:\n上で与えられたものとは微妙に異なる以下の階乗手\n続の定義について考えよ。\n(\ndefine\n(\nfactorial-alt\nn\n)\n(\nif\n(=\nn\n1)\n1\n(*\nn\n(\nfactorial-alt\n(-\nn\n1)))))\nこの手続をコンパイルし結果のコードを\nfactorial\nに対して生成\nされたコードと比べよ。見つけた全ての違いについて説明せよ。ど\nちらのプログラムが他方よりもより効率的に実行するだろうか\n?\nExercise 5.34:\n反復階乗手続をコンパイルせよ\n(\ndefine\n(\nfactorial\nn\n)\n(\ndefine\n(\niter\nproduct\ncounter\n)\n(\nif\n(>\ncounter\nn\n)\nproduct\n(\niter\n(*\ncounter\nproduct\n)\n(+\ncounter\n1))))\n(\niter\n1 1))\n結果のコードに注釈を付け、一方のプロセスがスタック領域を増進\nさせ、他方が一定のスタック領域で実行される元となる、\nfactorial\nの反復版と再帰版のコードの間の本質的な違いを示せ。\nFigure 5.17:\n↓\nfactorial\n手続定義のコンパイル結果\n;;\n手続を構築し、手続のボディのコードを飛ばす\n(\nassign\nval\n642","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":668},{"id":"./test/fixtures/pdf/sicp.pdf:669","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nop\nmake-compiled-procedure\n)\n(\nlabel\nentry2\n)\n(\nreg\nenv\n))\n(\ngoto\n(\nlabel\nafter-lambda1\n))\nentry2\n;\nfactorial\nの呼出はここから入る\n(\nassign\nenv\n(\nop\ncompiled-procedure-env\n) (\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nextend-environment\n)\n(\nconst\n(\nn\n))\n(\nreg\nargl\n)\n(\nreg\nenv\n))\n;;\n実際の手続のボディを開始する\n(\nsave\ncontinue\n)\n(\nsave\nenv\n)\n;;\n(= n 1)\nを求める\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\n=)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\n1))\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nassign\nval\n(\nop\nlookup-variable-value\n)\n(\nconst\nn\n)\n(\nreg\nenv\n))\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch17\n))\ncompiled-branch16\n(\nassign\ncontinue\n(\nlabel\nafter-call15\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch17\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call15\n;\nここで\nval\nは\n(= n 1)\nの結果を持つ\n(\nrestore\nenv\n)\n(\nrestore\ncontinue\n)\n(\ntest\n(\nop\nfalse?\n) (\nreg\nval\n))\n(\nbranch\n(\nlabel\nfalse-branch4\n))\n643","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":669},{"id":"./test/fixtures/pdf/sicp.pdf:670","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"true-branch5\n; return 1\n(\nassign\nval\n(\nconst\n1))\n(\ngoto\n(\nreg\ncontinue\n))\nfalse-branch4\n;;\n(* (factorial (- n 1)) n)\nを求めて返す\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\n*)\n(\nreg\nenv\n))\n(\nsave\ncontinue\n)\n(\nsave\nproc\n)\n;\n*\n手続を保存する\n(\nassign\nval\n(\nop\nlookup-variable-value\n)\n(\nconst\nn\n)\n(\nreg\nenv\n))\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nsave\nargl\n)\n;\n*\nの引数リストの一部を保存\n;;\n(factorial (- n 1))\nを求める。これは\n*\nのもう一方の引数\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\nfactorial\n)\n(\nreg\nenv\n))\n(\nsave\nproc\n)\n;\nfactorial\n手続を保存\n;;\n(- n 1)\nを求める。これは\nfactorial\nに対する引数\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\n-)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\n1))\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nassign\nval\n(\nop\nlookup-variable-value\n)\n(\nconst\nn\n)\n(\nreg\nenv\n))\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch8\n))\ncompiled-branch7\n(\nassign\ncontinue\n(\nlabel\nafter-call6\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch8\n644","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":670},{"id":"./test/fixtures/pdf/sicp.pdf:671","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call6\n;\nここで\nval\nは\n(- n 1)\nの結果を持つ\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nrestore\nproc\n)\n;\nfactorial\nに戻す\n;;\nfactorial\nの適用\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch11\n))\ncompiled-branch10\n(\nassign\ncontinue\n(\nlabel\nafter-call9\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch11\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call9\n;\nここで\nval\nは\n(factorial (- n 1))\nの結果を持つ\n(\nrestore\nargl\n)\n;\n*\nの引数リストの一部を復元\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\nrestore\nproc\n)\n;\n*\nに戻す\n(\nrestore\ncontinue\n)\n;;\n*\nを適用しその値を返す\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch14\n))\ncompiled-branch13\n;;\nここの複合手続は末尾再帰で呼ばれることに注意すること\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch14\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\n(\ngoto\n(\nreg\ncontinue\n))\nafter-call12\nafter-if3\nafter-lambda1\n;;\n手続を変数\nfactorial\nに割り当てる\n(\nperform\n(\nop\ndefine-variable!\n)\n645","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":671},{"id":"./test/fixtures/pdf/sicp.pdf:672","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nconst\nfactorial\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\nExercise 5.35:\nどの式がコンパイルされると\nFigure 5.18\nに示され\nるコードを生成するか\n?\nFigure 5.18:\n↓\nコンパイラ出力の例。\nExercise 5.35\n参照\n(\nassign\nval\n(\nop\nmake-compiled-procedure\n)\n(\nlabel\nentry16\n)\n(\nreg\nenv\n))\n(\ngoto\n(\nlabel\nafter-lambda15\n))\nentry16\n(\nassign\nenv\n(\nop\ncompiled-procedure-env\n) (\nreg\nproc\n))\n(\nassign\nenv\n(\nop\nextend-environment\n)\n(\nconst\n(\nx\n))\n(\nreg\nargl\n)\n(\nreg\nenv\n))\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\n+)\n(\nreg\nenv\n))\n(\nsave\ncontinue\n)\n(\nsave\nproc\n)\n(\nsave\nenv\n)\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\ng\n)\n(\nreg\nenv\n))\n(\nsave\nproc\n)\n(\nassign\nproc\n(\nop\nlookup-variable-value\n)\n(\nconst\n+)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\n2))\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nassign\nval\n(\nop\nlookup-variable-value\n)\n646","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":672},{"id":"./test/fixtures/pdf/sicp.pdf:673","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nconst\nx\n)\n(\nreg\nenv\n))\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch19\n))\ncompiled-branch18\n(\nassign\ncontinue\n(\nlabel\nafter-call17\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch19\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call17\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nrestore\nproc\n)\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch22\n))\ncompiled-branch21\n(\nassign\ncontinue\n(\nlabel\nafter-call20\n))\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch22\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\nafter-call20\n(\nassign\nargl\n(\nop\nlist\n) (\nreg\nval\n))\n(\nrestore\nenv\n)\n(\nassign\nval\n(\nop\nlookup-variable-value\n)\n(\nconst\nx\n)\n(\nreg\nenv\n))\n(\nassign\nargl\n(\nop\ncons\n) (\nreg\nval\n) (\nreg\nargl\n))\n(\nrestore\nproc\n)\n(\nrestore\ncontinue\n)\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-branch25\n))\ncompiled-branch24\n(\nassign\nval\n647","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":673},{"id":"./test/fixtures/pdf/sicp.pdf:674","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nop\ncompiled-procedure-entry\n)\n(\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\nprimitive-branch25\n(\nassign\nval\n(\nop\napply-primitive-procedure\n)\n(\nreg\nproc\n)\n(\nreg\nargl\n))\n(\ngoto\n(\nreg\ncontinue\n))\nafter-call23\nafter-lambda15\n(\nperform\n(\nop\ndefine-variable!\n)\n(\nconst\nf\n)\n(\nreg\nval\n)\n(\nreg\nenv\n))\n(\nassign\nval\n(\nconst\nok\n))\nExercise 5.36:\n私達のコンパイラが生成する組み合わせのオペラン\nドに対する評価の順はどれか\n?\n左から右であるか、右から左である\nか、または何らかの他の順であるか\n?\nコンパイラの中のどこがこの\n順を決定するか\n?\nコンパイラを変更し、それが何らかの別の評価\n順を生成するようにせよ。\n(\nSection 5.4.1\nにおける明示的制御評価\n機の評価順の議論を参考にせよ\n)\n。オペランドの評価順を変更する\nことが引数リストを構築するコードの効率にどのような影響があ\nるか\n?\nExercise 5.37:\nスタック使用の最適化のためのコンパイラの\npreserving\nの仕組みを理解する\n1\nつの方法はこの考えを用い\nなかった場合にどんな余分な命令が生成されるかを見てみること\nだ。\npreserving\nを変更し、常に\nsave\nと\nrestore\nの命令を生成す\nるようにせよ。いくつかの簡単な式をコンパイルし、生成された\n不必要なスタック命令を確認せよ。\npreserving\nの仕組みが失われ\nていないものから生成されたコードと比較せよ。\nExercise 5.38:\n私達のコンパイラは不必要なスタック命令を防ぐ\nことに関して賢いものだ。しかし、機械により提供されるプリミ\nティブな命令を用いて言語のプリミティブな手続の呼出をコンパ\nイルすることに関しては全く賢くない。例えば、\n(+ a 1)\nを求め\nるためにどれだけのコードがコンパイルされるか考えてみる。こ\nのコードは引数リストを\nargl\nに準備し、\n(\n環境内でシンボル\n+\nを\n648","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":674},{"id":"./test/fixtures/pdf/sicp.pdf:675","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"探すことにより見つけた\n)\nプリミティブな加算手続を\nproc\nに入れ\nる。そしてこの手続がプリミティブであるか複合であるかをテス\nトする。コンパイラは常にこのテストを実行するコードと、同様\nにプリミティブと複合の分岐のためのコード\n(\n内、一方のみが実行\nされる\n)\nが生成される。私達はコントローラのプリミティブを実\n装する部品を示さなかった。しかし、これらの命令が機械のデー\nタパス内のプリミティブな数値演算命令を利用することは仮定し\nた。もしコンパイラがプリミティブを\nopen-code\nできたらどれだけ\n少ないコードが生成されたか考えよ。これはつまり、もしこれら\nのプリミティブな機械語命令を直接使用するコードを生成するこ\nとができれば、である。式\n(+ a 1)\nは以下と同じくらい単純なも\nのにコンパイルされるだろう。\n43\n(\nassign\nval\n(\nop\nlookup-variable-value\n) (\nconst\na\n) (\nreg\nenv\n))\n(\nassign\nval\n(\nop\n+) (\nreg\nval\n) (\nconst\n1))\nこの課題では私達のコンパイラを拡張し、選択されたプリミティ\nブの\nopen-code\nをサポートする。特別な目的のコードがこれらの\nプリミティブな手続の呼出に対し、一般的な手続適用のコードの\n代わりに生成される。これをサポートするためには、私達の機械\nに特別な引数レジスタ、\narg1\nと\narg2\nを追加する。機械のプリミ\nティブな数値演算子は入力を\narg1\nと\narg2\nから得る。その結果は\nval\n,\narg1\n,\narg2\nのどれかに入れて良い。\nコンパイラはソースプログラム内の\nopen-code\nなプリミティブの\n適用を認識できなければならない。\ncompile\n手続に割り振りを追加\nし、現在認識可能な予約語\n(\n特別形式\n)\nに加えてこれらのプリミテ\nィブの名前を認識できるようにする。\n44\n特別な形式のそれぞれに\n対してコンパイラはコード生成器を持つ。この課題では\nopen-code\nなプリミティブのためのコード生成器の仲間を構築する。\n43\n私達は同じシンボル\n+\nをソース言語の手続と機械語命令の両方を示すためにここで\n使用しました。一般的に、ソース言語のプリミティブと機械のプリミティブの間に\n1\n対\n1\nの対応はありません。\n44\nプリミティブを予約語に入れることは一般的には悪い考えです。そうするとユーザが\nこれらの名前を異なる手続に束縛し直すことができなくなるためです。さらに、もし使用\n中のコンパイラに予約語を追加すると、これらの名前で手続を定義した既存のプログラ\nムが動作しなくなります。この問題をどのように回避するかの見解については\nExercise\n5.44\nを参照して下さい。\n649","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":675},{"id":"./test/fixtures/pdf/sicp.pdf:676","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"a\nopen-code\nなプリミティブ全ては特別形式とは異なり、オペラ\nンドが評価されることを必要とする。全ての\nopen-code\nのコ\nード生成器から使用されるコード生成器\nspread-arguments\nを書け。\nspread-arguments\nはオペランドのリストを取り、与\nえられたオペランドを次に続く引数レジスタをターゲットに\nコンパイルしなければならない。オペランドが\nopen-code\nな\nプリミティブへの呼出を含んでも良いことに注意すること。\nそのため引数レジスタはオペランド評価の間は維持されなけ\nればならない。\nb\nプリミティブな手続\n=\n,\n*\n,\n-\n,\n+\nのそれぞれに対してそのオペ\nレータとターゲット、リンク記述子の組み合わせを取り引数\nをレジスタに入れ、与えられたターゲットをターゲットに取\nり、与えられたリンク記述子と共に命令を実行するコードを\n生成するコード生成器を書け。\n2\nつのオペランドを扱う式を\n扱うのみで良い。これらのコード生成器に対する割り振りを\n作成せよ。\nc\n貴方の新しいコンパイラを階乗の例を用いて試してみよ。結\n果のコードを\nopen-code\n無しで生成した結果と比較せよ。\nd\n+\nと\n*\nのコード生成器を拡張し任意の数のオペランドを持つ\n式を取り扱えるようにせよ。\n3\nつ以上のオペランドを持つ式\nは、それぞれが\n2\nつだけ入力を持つ命令の列にコンパイルし\nなければならない。\n5.5.6\nレキシカルアドレッシング\nコンパイラにより実行される最も一般的な最適化の\n1\nつは変数検索の最\n適化です。ここまで実装した私達のコンパイラは評価機の\nlookup-variable-\nvalue\n命令を用いるコードを生成します。これは実行時環境を通してフレーム\n毎に取り組みながら、変数を現在束縛されている全ての変数と比較することで\n変数の検索を行う。この検索はもしフレームが深く入れ子になったり、変数の\n数が多い場合には高コストに成り得ます。例えば以下の式を評価した結果の適\n用において、式\n(* x y z)\nの評価の間に\nx\nの値を探す問題について考えみまし\nょう。\n(\nlet\n((\nx\n3) (\ny\n4))\n(\nlambda\n(\na\nb\nc\nd\ne\n)\n650","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":676},{"id":"./test/fixtures/pdf/sicp.pdf:677","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nlet\n((\ny\n(*\na\nb\nx\n)) (\nz\n(+\nc\nd\nx\n)))\n(*\nx\ny\nz\n))))\nlet\n式は\nlambda\nの組み合わせのための単なる構文糖ですので、この式は以下\nと等価です。\n((\nlambda\n(\nx\ny\n)\n(\nlambda\n(\na\nb\nc\nd\ne\n)\n((\nlambda\n(\ny\nz\n) (*\nx\ny\nz\n))\n(*\na\nb\nx\n)\n(+\nc\nd\nx\n))))\n3\n4)\nlookup-variable-value\nが\nx\nを検索する度に、シンボル\nx\nは\ny\n、または\nz\nに\neq?\nでないことを\n(\n最初のフレームで\n)\n確認しなければなりません。また\n(2\nつ\n目のフレームにて\n)\na\n,\nb\n,\nc\n,\nd\n,\ne\nについても同様に必要です。差し当たり、私達\nのプログラムは\ndefine\nを使用しないと仮定します。つまり変数は\nlambda\nの使\n用にのみ束縛されます。私達の言語はレキシカルスコープであるため、任意の\n式のための実行時環境は式が現れるプログラムのレキシカルな\n(\n語彙的な\n)\n構\n造を並列化する構造を持ちます。\n45\n従って、コンパイラは上の式を分析した時\nに、手続が適用される度に\n(* x y z)\n内の変数\nx\nが現在のフレームから\n2\nつ外\nのフレームの最初の変数として見つかることを知ることができます。\n私達は新しい種類の変数検索命令、\nlexical-address-lookup\nを発明するこ\nとにより、この事実を利用することができます。この命令は引数として環境と\n2\nつの数値から成る\nlexical address\n(\nレキシカルアドレス\n)\nを取ります。\n2\nつの数\n値は、いくつのフレームを見送るかを指定する\nframe number\nとそのフレーム\n内でいくつの変数を見送るかを指定する\ndisplacement number\nです。\nlexical-\naddress-lookup\nは現在のフレームに対して相対的なレキシカルアドレスに格\n納された変数の値を生成します。もし私達の機械に\nlexical-address-lookup\n命令を追加したなら、コンパイラに対して\nlookup-variable-value\nではな\nく、この命令を使用して変数を参照するコードを生成させることができます。\n同様に、コンパイルされたコードは\nset-variable-value!\nの代わりに新しい\nlexical-address-set!\n命令を使用することができます。\nそのようなコードを生成するためには、コンパイラは参照をコンパイルし\nようとする変数のレキシカルアドレスを決定できなければなりません。プログ\n45\nこれはもし内部定義を許可するのであれば、それら全てを走査しない限りは正しく\nありません。\nExercise 5.43\nを参照して下さい。\n651","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":677},{"id":"./test/fixtures/pdf/sicp.pdf:678","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ラム中の変数のレキシカルアドレスはそれがコードのどこにあるのかに依存し\nます。例えば、以下のプログラムでは式\n⟨\ne1\n⟩\nのアドレスは\n(2, 0)\nです。つまり、\n2\nフレーム後ろでそのフレームの最初の変数です。同じ地点で\ny\nはアドレス\n(0,\n0)\nであり、\nc\nはアドレス\n(1, 2)\nに存在します。式\n⟨\ne2\n⟩\nにおいては、\nx\nは\n(1, 0)\nに、\ny\nは\n(1, 1)\nに、\nc\nは\n(0, 2)\nに存在します。\n((\nlambda\n(\nx\ny\n)\n(\nlambda\n(\na\nb\nc\nd\ne\n)\n((\nlambda\n(\ny\nz\n)\n⟨\ne1\n⟩\n)\n⟨\ne2\n⟩\n(+\nc\nd\nx\n))))\n3\n4)\nコンパイラにとってレキシカルアドレスを使用する\n1\nつの方法は\ncompile-time\nenvironment\n(\nコンパイル時環境\n)\nと呼ばれるデータ構造を管理することです。\nこれは実行時環境内にて特定の変数アクセス命令が実行された時に、どの変数\nがどのフレーム内のどの位置に存在することになるのかを追跡します。コン\nパイル時環境はフレームのリストであり、各フレームが変数の変数のリスト\nを保持します。\n(\nもちろん値が束縛されない変数も存在します。値はコンパイ\nル時には計算されないためです\n)\n。コンパイル時環境は\ncompile\nの追加の引数\nになり、各コード生成器に渡されます。\nlambda\nのボディがコンパイルされる\n時、\ncompile-lambda-body\nがコンパイル時環境を手続のパラメータを持つフレ\nームにより拡張し、ボディを構成する命令列がその拡張された環境を用いてコ\nンパイルされます。コンパイルの各時点にて、\ncompile-variable\nと\ncompile-\nassignment\nは適切なレキシカルアドレスを生成するためにコンパイル時環境\nを使用します。\nExercise 5.39\nから\nExercise 5.43\nはコンパイラにレキシカルな検索を組込む\nためにこのレキシカルアドレス付けの戦略の草案をどのようにして完了させる\nかについて説明します。\nExercise 5.44\nはコンパイル時環境の別の使用法を説明\nします。\nExercise 5.39:\n新しい検索命令を実装する\nlexical-address-lookup\n手続を書け。\n2\nつの引数、レキシカルアドレスと実行時環境を取\nること。そして指定したレキシカルアドレスに格納された変数の\n値を返すこと。\nlexical-address-lookup\nはもし変数の値がシンボ\n652","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":678},{"id":"./test/fixtures/pdf/sicp.pdf:679","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ル\n*unassigned*\nならばエラーを発する。\n46\nまた指定したレキシ\nカルアドレスの変数の値を変更する操作を実装する手続\nlexical-\naddress-set!\nを書け。\nExercise 5.40:\nコンパイラを変更し、上で説明されたコンパイル時\n環境を保存するようにせよ。つまり、\ncompile\nと多様なコード生成\n器の引数に\ncompile-time-environment\nを追加し、それを\ncompile-\nlambda-body\nの中で拡張せよ。\nExercise 5.41:\n引数として変数とコンパイル時環境を取り、その\n環境に関するその変数のレキシカルアドレスを返す手続\nfind-\nvariable\nを書け。例えば、上で示されたプログラムの断片におい\nて、式\n⟨\ne1\n⟩\nをコンパイルしている間のコンパイル時環境は\n((y z)\n(a b c d e) (x y))\nである。\nfind-variable\nは以下を生成しなけ\nればならない。\n(\nfind-variable\n'c\n'\n((\ny\nz\n) (\na\nb\nc\nd\ne\n) (\nx\ny\n)))\n(1 2)\n(\nfind-variable\n'x\n'\n((\ny\nz\n) (\na\nb\nc\nd\ne\n) (\nx\ny\n)))\n(2 0)\n(\nfind-variable\n'w\n'\n((\ny\nz\n) (\na\nb\nc\nd\ne\n) (\nx\ny\n)))\nnot-found\nExercise 5.42:\nExercise 5.41\nの\nfind-variable\nを使用して、\ncompile-\nvariable\nと\ncompile-assignment\nを書き直し、レキシカルアドレ\nス命令を出力するようにせよ。\nfind-variable\nが\nnot-found\nを返\nす場合においては\n(\nつまり、変数がコンパイル時環境内には存在\nしない場合には\n)\n、コード生成器に対して以前と同じ環境命令を\n使用させることで束縛を検索させなければならない。\n(\nコンパイル\n時に変数が見つからない唯一の場所はグローバル環境である。こ\nれは実行時環境の一部であり、コンパイル時環境の一部ではない。\n47\n従って、もしあなたが望むなら、それらに対し\nenv\n内の全ての\n46\nこれはもし内部定義を削除するためにこの検索手法を実装するのであれば必要とな\nる、変数検索に対する変更です\n(\nExercise 5.43\n)\n。レキシカルアドレスをうまく動かすた\nめにはこれらの定義を排除する必要があります。\n47\nレキシカルアドレスはグローバル環境内の変数をアクセスするためには利用できま\nせん。なぜなら、これらの名前は対話形式的に任意の時点で定義と再定義が可能なため\nです。\nExercise 5.43\nの内部定義走査を用いてコンパイラが知ることができる定義は、グ\n653","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":679},{"id":"./test/fixtures/pdf/sicp.pdf:680","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"実行時環境を探させる代わりに、環境の命令に、命令\n(op get-\nglobal-environment)\nにより獲得できるグローバル環境を直接探\nさせてもかまわない\n)\n。変更したコンパイラをこの節の最初の入れ\n子の\nlambda\nの組み合わせのような、いくつかの簡単な事例を用い\nてテストせよ。\nExercise 5.43:\nSection 4.1.6\nにおいてブロック構造に対する内部定\n義は\n“\n実際の\n”\ndefine\nだと考慮されるべきでないと主張した。そう\nではなく、手続のボディは通常の\nset!\nを用いて正しい値に初期化\nされた\nlambda\nの変数のように、内部変数定義が導入されたかのよ\nうに解釈されるべきである。\nSection 4.1.6\nと\nExercise 4.16\nはどのよ\nうにメタ循環インタプリタを変更して内部定義を走査することで、\nこれを達成するかを示した。コンパイラを変更し、手続のボディ\nをコンパイルする前にこれと同じ変形を実行するようにせよ。\nExercise 5.44:\nこの節ではレキシカルアドレスを生成するためのコ\nンパイル時環境の使用に焦点を合わせた。しかしコンパイル時環境\nの他の使用法も存在する。例として、\nExercise 5.38\nではコンパイル\nされたコードの効率を\nopen-code\nなプリミティブ手続により向上\nさせた。私達の実装は\nopen-code\nな手続を予約語として扱った。も\nしプログラムがそのような名前を再束縛するなら、\nExercise 5.38\nに\nて説明された仕組みは依然としてプリミティブとして\nopen-code\nし、新しい束縛を無視するだろう。例えば、以下の手続について考\nえてみる。\n(\nlambda\n(+ *\na\nb\nx\ny\n)\n(+ (*\na\nx\n) (*\nb\ny\n)))\nこれは\nx\nと\ny\nの一次結合を求める。これを引数\n+matrix\n,\n*matrix\n、\nそれに\n4\nつの行列\n(matrix)\nと共に呼ぶこともあるだろう。しかし、\nopen-code\nなコンパイラは依然として\n(+ (* a x) (* b y))\n内の\n+\nと\n*\nをプリミティブな\n+\nと\n*\nとして\nopen-code\nしてしまうだろ\nう。\nopen-code\nなコンパイラを変更し、プリミティブな手続の名前\nを含む式に対して正しいコードをコンパイルするために、コンパ\nイル時環境を参考にするようにせよ。\n(\nこのコードはプログラムが\nローバル環境に従うトップレベルのものだけです。定義のコンパイルは、定義された名\n前がコンパイル時環境に入れることにはなりません。\n654","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":680},{"id":"./test/fixtures/pdf/sicp.pdf:681","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"これらの名前に対して\ndefine\nや\nset!\nを行わない限り正しく動く\nようになる。\n)\n5.5.7\nコンパイル済みコードと評価機の連結\n私達はまだコンパイルされたコードを評価機にどのようにロードするか、ま\nたはどのように実行するかについて説明していません。ここでは明示的制御評\n価機が\nSection 5.4.4\nの時点にて定義された状態であると仮定します。\nFootnote\n38\nで指定された追加の命令も含みます。\nScheme\n式をコンパイルし、結果として\nのオブジェクトコードを評価機にロードし、評価機にグローバル環境の中で実\n行させ、結果を表示し、評価機のドライバループへと入る手続\ncompile-and-\ngo\nを実装します。また評価機を変更し、逐次翻訳された式がコンパイルされた\n手続を逐次翻訳されたものと同じように呼ぶことができるようにもします。す\nるとコンパイルされた手続を機械に入れてそれを呼び出すことができます。\n(\ncompile-and-go\n'\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1)\n1\n(* (\nfactorial\n(-\nn\n1))\nn\n))))\n;;; EC-Eval value:\nok\n;;; EC-Eval input:\n(\nfactorial\n5)\n;;; EC-Eval value:\n120\n評価機にコンパイルされた手続の取り扱いを可能にするには\n(\n例えば上記の\nfactorial\nの呼出を評価すること\n)\n、\napply-dispatch\n(\nSection 5.4.1\n)\nのコード\nを変更して、それがコンパイルされた手続を\n(\n複合、またはプリミティブな手\n続から区別可能なものとして\n)\n認識し、制御を直接コンパイルされたコードの\nエントリポイントへと移動させる必要があります。\n48\n48\nもちろん、逐次翻訳された手続と同様にコンパイルされた手続も複合\n(compound,\n非プリミティブ\n)\nです。明示的制御評価機で使用された用語との互換性のために、この節\nでは\n“\n複合\n”\nを逐次翻訳された\n(\nコンパイルされたの逆を\n)\n意味するものとして使用しま\nす。\n655","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":681},{"id":"./test/fixtures/pdf/sicp.pdf:682","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"apply-dispatch\n(\ntest\n(\nop\nprimitive-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\nprimitive-apply\n))\n(\ntest\n(\nop\ncompound-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\ncompound-apply\n))\n(\ntest\n(\nop\ncompiled-procedure?\n) (\nreg\nproc\n))\n(\nbranch\n(\nlabel\ncompiled-apply\n))\n(\ngoto\n(\nlabel\nunknown-procedure-type\n))\ncompiled-apply\n(\nrestore\ncontinue\n)\n(\nassign\nval\n(\nop\ncompiled-procedure-entry\n) (\nreg\nproc\n))\n(\ngoto\n(\nreg\nval\n))\ncompiled-apply\nでの\ncontinue\nの復元に注意して下さい。評価機は\napply-\ndispatch\nにて継続がスタックの一番上になるように準備されています。一方\nで、コンパイルされたコードのエントリポイントは継続が\ncontinue\nの中にあ\nることを期待しています。そのため、\ncontinue\nはコンパイルされたコードが実\n行される前に復元されなければなりません。\n評価機を開始した時にいくつかのコンパイルされたコードを実行すること\nを可能にするために、\nbranch\n命令を評価機の最初に追加します。これはもし\nflag\nレジスタが設定されていれば、機械を新しいエントリポイントへと飛ばし\nます。\n49\n(\nbranch\n(\nlabel\nexternal-entry\n))\n;\nflag\nが立っていれば飛ぶ\nread-eval-print-loop\n(\nperform\n(\nop\ninitialize-stack\n))\n...\n49\n今や評価機は\nbranch\nを用いて開始するので、私達は常に評価機を開始する前に\nflag\nレジスタを初期化しなければなりません。機械を通常の\nREPL\nにて開始するためには、\n以下を用いることができます。\n(\ndefine\n(\nstart-eceval\n)\n(\nset!\nthe-global-environment\n(\nsetup-environment\n))\n(\nset-register-contents!\neceval\n'flag\nfalse\n)\n(\nstart\neceval\n))\n656","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":682},{"id":"./test/fixtures/pdf/sicp.pdf:683","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"external-entry\nは機械が結果を\nval\nに入れ\n(goto (reg continue))\nで終わる\n命令列の位置を持つ\nval\nと共に開始すると仮定します。このエントリポイント\nで開始する場合、\nval\nで指定された位置へ飛びます。しかし、最初に\ncontinue\nに実行が\nprint-result\nに戻るように設定します。\nprint-result\nは\nval\n内の値\nを表示し、次に評価機の\nREPL\nの最初へと飛びます。\n50\nexternal-entry\n(\nperform\n(\nop\ninitialize-stack\n))\n(\nassign\nenv\n(\nop\nget-global-environment\n))\n(\nassign\ncontinue\n(\nlabel\nprint-result\n))\n(\ngoto\n(\nreg\nval\n))\nこれで以下手続を用いて手続定義をコンパイルし、コンパイルされたコードを\n実行し、手続を試行することができるよう\nREPL\nを実行することができます。\nコンパイルされたコードに\ncontinue\n内の位置に、\nval\n内の結果を持って戻っ\nて欲しいため、式をターゲット\nval\nとリンク記述子\nreturn\nを用いてコンパイ\nルします。コンパイラにより生成されたオブジェクトコードを評価機で実行可\n能な命令に変形するために、レジスタマシンシミュレータ\n(\nSection 5.2.2\n)\nの手\n続\nassemble\nを使用します。次に\nval\nレジスタを命令のリストを指すように初\n期化し、\nflag\nを評価機が\nexternal-entry\nへ飛ぶように設定し、評価機を開始\nします。\n(\ndefine\n(\ncompile-and-go\nexpression\n)\n(\nlet\n((\ninstructions\n(\nassemble\n50\nコンパイルされた手続はシステムが表示しようとするかもしれないオブジェクトで\nあるため、システムの表示命令\n(\nSection 4.1.4\nの\n)\nuser-print\nも変更し、コンパイルされ\nた手続の構成部品を表示しようとしないようにします。\n(\ndefine\n(\nuser-print\nobject\n)\n(\ncond\n((\ncompound-procedure?\nobject\n)\n(\ndisplay\n(\nlist\n'compound-procedure\n(\nprocedure-parameters\nobject\n)\n(\nprocedure-body\nobject\n)\n'<procedure-env>\n)))\n((\ncompiled-procedure?\nobject\n)\n(\ndisplay\n'<compiled-procedure>\n))\n(\nelse\n(\ndisplay\nobject\n))))\n657","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":683},{"id":"./test/fixtures/pdf/sicp.pdf:684","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nstatements\n(\ncompile\nexpression\n'val\n'return\n))\neceval\n)))\n(\nset!\nthe-global-environment\n(\nsetup-environment\n))\n(\nset-register-contents!\neceval\n'val\ninstructions\n)\n(\nset-register-contents!\neceval\n'flag\ntrue\n)\n(\nstart\neceval\n)))\nもし\nSection 5.4.4\nの終わりのようにスタック監視を設定したなら、コンパイル\nされたコードのスタック使用量を調査できます。\n(\ncompile-and-go\n'\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1)\n1\n(* (\nfactorial\n(-\nn\n1))\nn\n))))\n(total-pushes = 0 maximum-depth = 0)\n;;; EC-Eval value:\nok\n;;; EC-Eval input:\n(\nfactorial\n5)\n(total-pushes = 31 maximum-depth = 14)\n;;; EC-Eval value:\n120\nこの例を、\nSection 5.4.4\nの終わりで示された同じ手続の逐次翻訳された版を用\nいた\n(factorial 5)\nの評価と比べてみて下さい。逐次翻訳された版は\n144\n回の\npush\nと最大スタック深度\n28\nを必要としました。これは私達のコンパイル戦略\nに起因する最適化を説明しています。\n逐次翻訳とコンパイル\nこの節のプログラムを用いることで、今では逐次翻訳とコンパイルの代替\n的な実行戦略を実験することができます。\n51\nインタプリタは機械をユーザプロ\nグラムのレベルへと上げます。コンパイラはユーザプログラムを機械語のレベ\n51\nコンパイラを拡張してコンパイルされたコードに逐次翻訳された手続の呼び出しを\n許可することでさらにうまく行うことができます。\nExercise 5.47\nを参照して下さい。\n658","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":684},{"id":"./test/fixtures/pdf/sicp.pdf:685","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ルへと下げます。私達は\nScheme\n言語を\n(\nまたはどんなプログラミング言語も\n)\n機械語の上に構築された体系化の目的を同じとした仲間だと見做すことができ\nます。インタプリタは対話的なプログラム開発とデバッグに最適です。プログ\nラムのステップの実行がこれらの抽象化を用いて組織化され、そのため、プロ\nグラマにとってより理解しやすくなります。コンパイルされたコードはより速\nく実行することができます。プログラムのステップの実行が機械語を利用して\n体系化され、コンパイラは自由に高いレベルの抽象化を近道する最適化を作る\nことができます。\n52\n逐次翻訳とコンパイルの代替もまた、新しいコンピュータへ言語を移植す\nるための異なる戦略へと導きます。新しい機械に\nLisp\nを実装したいと願って\nいると仮定します。\n1\nつの戦略は\nSection 5.4\nの明示的制御評価機と共に始めて、\nその命令を新しい機械の命令へと翻訳することです。異なる戦略はコンパイラ\nと共に始めてコード生成器を変更し、新しい機械のコードを生成するようにし\nます。\n2\nつ目の戦略はどんな\nLisp\nプログラムも最初に元の\nLisp\nシステム上で\n動くコンパイラを用いてコンパイルし、実行時ライブラリのコンパイル済みの\n版とリンクすることにより、新しい機械の上で実行させることが可能になりま\nす。\n53\nもっと良いことには、コンパイラそれ自身をコンパイルすることができ\n52\n実行戦略とは独立して、もしユーザプログラムを実行した場合にエラーに遭遇した\n時にシステムを殺すことや間違った値を生成するおおを許可するのではなく、エラーが\n発見され、その旨が伝えられることを望むのならば、明らかなオーバヘッドを経験する\nことになります。例えば、配列の境界外参照は実行する前に参照の有効性をチェックす\nることで発見することができます。しかし、チェックのオーバヘッドは配列参照自体の\n何倍ものコストに成り得ます。そしてプログラマはそのようなチェックが望ましいかの\n決定において安全性よりもスピードに重きを置きます。良いコンパイラはそのようなチ\nェックを行うコードを生成することが可能であるべきです。また冗長なチェックは回避\nし、プログラマにコンパイルされたコード内でのエラーチェックの範囲と型を制御でき\nるようにするべきです。\nC\nや\nC++\nのような人気のある言語のコンパイラはほとんど何も実行コードの中にエ\nラーチェックの命令を挿入しません。可能な限り速く実行するためです。結果として、\nプログラマに対して明示的にエラーチェックを提供させることに陥ります。残念なこと\nに、人々は良くこのことを軽視します。例えスピードが制約ではない重要なアプリケー\nションにおいてもです。こうのような人々のプログラムは高速、かつ危険な生活へと導\nきます。例えば、\n1988\n年にインターネットを麻痺させた悪名高い\n“Worm”(\nワーム\n)\nは\nunix\n(tm) OS (\nオペレーティングシステム\n)\nの\nfinger\nデーモンにおける入力バッファがオ\nーバフローしたかどうかのチェックミスを利用しました。\n(\nSpafford 1989\n参照\n)\n53\nもちろん、逐次翻訳とコンパイルの戦略のどちらを用いても、新しい機械の記憶域割\nり当て、入出力\n(I/O)\n、そして評価機とコンパイラの議論において\n“\nプリミティブ\n”\nとし\nて扱った全ての多彩な命令もまた新しい機械のために実装しなければなりません。ここ\nで仕事量を最小化するための\n1\nつの方法としてはこれらの命令を可能な限り\nLisp\nで書\n659","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":685},{"id":"./test/fixtures/pdf/sicp.pdf:686","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ます。そしてこれを新しい機械の上で他の\nLisp\nプログラムをコンパイルするた\nめに実行するのです。\n54\nまたは、\nSection 4.1\nのインタプリタの内\n1\nつをコンパ\nイルして新しい機械上で実行できるインタプリタを生成することもできます。\nExercise 5.45:\nコンパイルされたコードにより使用されたスタック\n命令を同じ演算のための評価機により使用されたスタック命令と\n比較することで、コンパイラのスタック使用の最適化の範囲を速\nさ\n(\nスタック命令の総数の削減\n)\nと記憶域\n(\n最大スタック深度の削\n減\n)\nの両方において判断することができる。この最適化されたスタ\nックの使用を、同じ演算のための特別な目的の機械と比較するこ\nとでコンパイルの品質の何らかの指標を与えることができる。\na\nExercise 5.27\nは、評価機が上で与えられた再帰階乗手続を用い\nて\n푛!\nを求めるのに必要なプッシュの数と最大スタック深度\nを\n푛\nの関数として決定するよう求めた。\nExercise 5.14\nは\nFigure\n5.11\nで示された特別な目的の階乗マシンに対しする同じ測定\nを求めた。ここでは同じ分析をコンパイルした\nfactorial\n手\n続を用いて実行する。\nコンパイルされた版のプッシュの数と逐次翻訳された版のプ\nッシュの数との比率を取得せよ次に同じ事を最大スタック深\n度に対しても行なえ。\n푛!\nを求めるために使用される命令数と\nスタック深度は\n푛\nの線形であるために、これらの比率は\n푛\nが\n巨大になるにつれ定数へと収束するはずである。これらの定\n数は何か\n?\n同様に、特定目的マシンの使用量と逐次翻訳の版\nの使用量との比率も求めよ。\n特定目的と逐次翻訳されたコードとの間の比率と、コンパイ\nルされたコードと逐次翻訳されたコードとの間の比率を比較\nせよ。特定目的マシンがコンパイルされたコードよりもとて\nも良いことに気付くはずだ。手作りのコントローラのコード\nき、次に新しい機械のためにコンパイルすることが上げられます。究極的には、全てが\n新しい機械のために手で書かれた\n(\nガベージコレクションや実際の機械のプリミティブ\nを適用する仕組みの様な\n)\n小さなカーネルに縮小されます。\n54\nこの戦略は、コンパイルされたコンパイラを用いた、新しい機械上でのプログラムの\nコンパイルが元の\nLisp\nシステム上のプログラムのコンパイルと同一であるかどうかとい\nう、コンパイラの正確性の楽しいテストへと至ります。違いの原因の追跡は楽しいので\nすが、しばしばイライラもさせます。その結果はとても小さな詳細に非常に敏感なため\nです。\n660","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":686},{"id":"./test/fixtures/pdf/sicp.pdf:687","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"は基本的な汎用目的のコンパイラにより生成されたものより\nとても優れているはずだからである。\nb\nパフォーマンスにおいて手作り版により近いコードを生成す\nることを手助けする、コンパイラに対する改善を提案できる\nだろうか\n?\nExercise 5.46:\nExercise 5.45\nのような分析を木再帰フィボナッチ手\n続のコンパイルの効果を判断するために実行せよ。\n(\ndefine\n(\nfib\nn\n)\n(\nif\n(<\nn\n2)\nn\n(+ (\nfib\n(-\nn\n1))\n(\nfib\n(-\nn\n2)))))\nFigure 5.12\nの特定目的フィボナッチマシンを用いた場合の効果と\n比較せよ。\n(\n逐次翻訳のパフォーマンスの測定のために、\nExercise\n5.29\nを参照せよ\n)\n。フィボナッチ数では、使用された時間的リソー\nスは\n푛\nの線形にはならない。\nExercise 5.47:\nこの節では逐次翻訳されたコードがコンパイルされ\nたコードを呼び出すことができるようにするために、明示的制御評\n価機をどのように変更するかを説明した。コンパイルされた手続\nがプリミティブとコンパイルされた手続のみでなく、逐次翻訳され\nた手続も同様に呼び出すことができるようにするために、コンパ\nイラをどのように変更するのか示せ。これは\ncompile-procedure-\ncall\nを複合\n(\n逐次翻訳\n)\nの場合を取り扱うように変更する必要があ\nる。全ての同じ\ntarget\nと\nlinkage\nの組み合わせを\ncompile-proc-\nappl\nが行うように取り扱うよう気をつけよ。実際に手続適用を行\nうためには、コードは評価機の\ncompound-apply\nエントリポイン\nトへ飛ぶ必要がある。このラベルはオブジェクトコードの中では\n直接参照することができない。\n(\nアセンブラが全てのラベルに対し、\nそれがアセンブルしている、そこで定義されるコードにより参照\nされることを要求するためである\n)\n。従って、\ncompapp\nと呼ばれる\nレジスタを評価機に追加し、このエントリポイントを持たせて、こ\nれを初期化する命令を追加する。\n(\nassign\ncompapp\n(\nlabel\ncompound-apply\n))\n661","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":687},{"id":"./test/fixtures/pdf/sicp.pdf:688","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"(\nbranch\n(\nlabel\nexternal-entry\n))\n;\nflag\nが立っていれば\n飛ぶ\nread-eval-print-loop\n...\nあなたのコードをテストするために、手続\ng\nを呼ぶ手続\nf\nを定義\nすることから始めよ。\ncompile-and-go\nを用いて\nf\nの定義をコンパ\nイルし、評価機を開始せよ。ここから評価機に対し入力を行い\ng\nを\n定義し\nf\nの呼出を試せ。\nExercise 5.48:\nこの節で実装された\ncompile-and-go\nインターフェ\nイスは扱いにくい。コンパイラを\n(\n評価機が開始された時に\n)\n一度\nしか呼ぶことができないためだ。以下のように明示的制御評価機\nの中から呼び出すことができる\ncompile-and-run\nを追加すること\nでコンパイラ\n-\nインタプリタ間のインターフェイスを増補せよ。\n;;; EC-Eval input:\n(\ncompile-and-run\n'\n(\ndefine\n(\nfactorial\nn\n)\n(\nif\n(=\nn\n1) 1 (* (\nfactorial\n(-\nn\n1))\nn\n))))\n;;; EC-Eval value:\nok\n;;; EC-Eval input:\n(\nfactorial\n5)\n;;; EC-Eval value:\n120\nExercise 5.49:\n明示的制御評価機の\nREPL\nを用いる代わりとして、\nread-compile-execute-print loop\nを実行するレジスタマシンを設計\nせよ。言い換えれば、このマシンは式を読み込み、それをコンパ\nイルし、その結果のコードをアセンブルして実行し、その結果を\n表示するループを実行する。これは私達のシミュレートされた構\n成内で簡単に実行できる。なぜなら、手続\ncompile\nと\nassemble\nを\n“\nレジスタマシンの命令\n”\nとして呼ぶことを手配できるからだ。\nExercise 5.50:\nコンパイラを用いて\nSection 4.1\nのメタ循環評価機を\nコンパイルし、レジスタマシンシミュレータと用いてこのプログラ\nムを実行せよ。\n(\n一度に複数の定義をコンパイルするために、\nbegin\nの中に定義を詰めることができる\n)\n。結果としてのインタプリタの\n662","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":688},{"id":"./test/fixtures/pdf/sicp.pdf:689","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"実行は複数レベルの逐次翻訳のため、とても遅い。しかし、実行の\n詳細全てを理解することは教育的な課題である。\nExercise 5.51:\nC\n言語\n(\nまたはあなたが選んだ何らかの他の低レベ\nルな言語\n)\nによる\nScheme\nの基本的な実装を、\nSection 5.4\nの明示的\n制御評価機を\nC\n言語に翻訳することで開発せよ。このコードを実\n行するためには、適切なメモリ割当ルーチンと他の実行時サポー\nトも提供する必要がある。\nExercise 5.52:\nExercise 5.51\nに対する好対照として、コンパイラを\n変更して\nScheme\nの手続を\nC\n言語の命令列へとコンパイルするよ\nうにせよ。\nSection 4.1\nのメタ循環評価機をコンパイルして\nC\n言語\nで書かれた\nScheme\nインタプリタを生成せよ。\n663","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":689},{"id":"./test/fixtures/pdf/sicp.pdf:690","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"参考文献\nAbelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister,\nGuillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992. The Super-\ncomputer Toolkit: A general framework for special-purpose computing.\nInter-\nnational Journal of High-Speed Electronics\n3(3): 337-361.\n(Onl)\nAllen, John. 1978.\nAnatomy of Lisp\n. New York: McGraw-Hill.\nansi\nX3.226-1994.\nAmerican National Standard for Information Systems—\nProgramming Language—Common Lisp\n.\nAppel, Andrew W. 1987. Garbage collection can be faster than stack allo-\ncation.\nInformation Processing Letters\n25(4): 275-279.\n(Online)\nBackus, John. 1978. Can programming be liberated from the von Neumann\nstyle?\nCommunications of the\nacm\n21(8): 613-641.\n(Online)\nBaker, Henry G., Jr. 1978. List processing in real time on a serial computer.\nCommunications of the\nacm\n21(4): 280-293.\n(Online)\nBatali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel\nWeise. 1982. The Scheme-81 architecture—System and chip. In\nProceedings of\nthe\nmit\nConference on Advanced Research in\nvlsi\n, edited by Paul Penfield, Jr.\nDedham, MA: Artech House.\nBorning, Alan. 1977. ThingLab—An object-oriented system for building\nsimulations using constraints. In\nProceedings of the 5th International Joint\nConference on Artificial Intelligence\n.\n(Online)\nBorodin, Alan, and Ian Munro. 1975.\nThe Computational Complexity of\nAlgebraic and Numeric Problems\n. New York: American Elsevier.\nChaitin, Gregory J. 1975. Randomness and mathematical proof.\nScientific\nAmerican\n232(5): 47-52.\nChurch, Alonzo. 1941.\nThe Calculi of Lambda-Conversion\n. Princeton, N.J.:\n664","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":690},{"id":"./test/fixtures/pdf/sicp.pdf:691","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Princeton University Press.\nClark, Keith L. 1978. Negation as failure. In\nLogic and Data Bases\n. New\nYork: Plenum Press, pp. 293-322.\n(Online)\nClinger, William. 1982. Nondeterministic call by need is neither lazy nor\nby name. In\nProceedings of the\nacm\nSymposium on Lisp and Functional Pro-\ngramming\n, pp. 226-234.\nClinger, William, and Jonathan Rees. 1991. Macros that work. In\nProceed-\nings of the 1991\nacm\nConference on Principles of Programming Languages\n, pp.\n155-162.\n(Online)\nColmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973. Un système\nde communication homme-machine en français. Technical report, Groupe In-\ntelligence Artificielle, Université d’Aix Marseille, Luminy.\nCormen, Thomas, Charles Leiserson, and Ronald Rivest. 1990.\nIntroduction\nto Algorithms\n. Cambridge, MA:\nmit\nPress.\nDarlington, John, Peter Henderson, and David Turner. 1982.\nFunctional\nProgramming and Its Applications\n. New York: Cambridge University Press.\nDijkstra, Edsger W. 1968a. The structure of the “\nthe\n” multiprogramming\nsystem.\nCommunications of the\nacm\n11(5): 341-346.\n(Online)\nDijkstra, Edsger W. 1968b. Cooperating sequential processes. In\nProgram-\nming Languages\n, edited by F. Genuys. New York: Academic Press, pp. 43-112.\n(Online)\nDinesman, Howard P. 1968.\nSuperior Mathematical Puzzles\n. New York: Si-\nmon and Schuster.\ndeKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977.\namord\n: Explicit control of reasoning. In\nProceedings of the\nacm\nSymposium\non Artificial Intelligence and Programming Languages\n, pp. 116-125.\n(Online)\nDoyle, Jon. 1979. A truth maintenance system.\nArtificial Intelligence\n12:\n231-272.\n(Online)\nFeigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National\nFifth Generation Project: Introduction, survey, and evaluation. In\nFuture Gen-\neration Computer Systems\n, vol. 9, pp. 105-117.\nFeeley, Marc. 1986. Deux approches à l’implantation du language Scheme.\nMasters thesis, Université de Montréal.\nFeeley, Marc and Guy Lapalme. 1987. Using closures for code generation.\nJournal of Computer Languages\n12(1): 47-66.\n(Online)\n665","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":691},{"id":"./test/fixtures/pdf/sicp.pdf:692","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Feller, William. 1957.\nAn Introduction to Probability Theory and Its Appli-\ncations\n, volume 1. New York: John Wiley & Sons.\nFenichel, R., and J. Yochelson. 1969. A Lisp garbage collector for virtual\nmemory computer systems.\nCommunications of the\nacm\n12(11): 611-612.\nFloyd, Robert. 1967. Nondeterministic algorithms.\njacm\n, 14(4): 636-644.\nForbus, Kenneth D., and Johan deKleer. 1993.\nBuilding Problem Solvers\n.\nCambridge, MA:\nmit\nPress.\nFriedman, Daniel P., and David S. Wise. 1976.\ncons\nshould not evaluate\nits arguments. In\nAutomata, Languages, and Programming: Third International\nColloquium\n, edited by S. Michaelson and R. Milner, pp. 257-284.\n(Online)\nFriedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.\nEssentials of Programming Languages\n. Cambridge, MA:\nmit\nPress/ McGraw-\nHill.\nGabriel, Richard P. 1988. The Why of\nY\n.\nLisp Pointers\n2(2): 15-25.\n(Online)\nGoldberg, Adele, and David Robson. 1983.\nSmalltalk-80: The Language and\nIts Implementation\n. Reading, MA: Addison-Wesley.\nGordon, Michael, Robin Milner, and Christopher Wadsworth. 1979.\nEdin-\nburgh LCF\n. Lecture Notes in Computer Science, volume 78. New York: Springer-\nVerlag.\nGray, Jim, and Andreas Reuter. 1993.\nTransaction Processing: Concepts\nand Models\n. San Mateo, CA: Morgan-Kaufman.\nGreen, Cordell. 1969. Application of theorem proving to problem solving.\nIn\nProceedings of the International Joint Conference on Artificial Intelligence\n,\npp. 219-240.\n(Online)\nGreen, Cordell, and Bertram Raphael. 1968. The use of theorem-proving\ntechniques in question-answering systems. In\nProceedings of the\nacm\nNational\nConference\n, pp. 169-181.\nGriss, Martin L. 1981. Portable Standard Lisp, a brief overview. Utah Sym-\nbolic Computation Group Operating Note 58, University of Utah.\nGuttag, John V. 1977. Abstract data types and the development of data\nstructures.\nCommunications of the\nacm\n20(6): 396-404.\n(Online)\nHamming, Richard W. 1980.\nCoding and Information Theory\n. Englewood\nCliffs, N.J.: Prentice-Hall.\nHanson, Christopher P. 1990. Efficient stack allocation for tail-recursive\nlanguages. In\nProceedings of\nacm\nConference on Lisp and Functional Program-\nming\n, pp. 106-118.\n666","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":692},{"id":"./test/fixtures/pdf/sicp.pdf:693","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Hanson, Christopher P. 1991. A syntactic closures macro facility.\nLisp\nPointers\n, 4(3).\n(Online)\nHardy, Godfrey H. 1921. Srinivasa Ramanujan.\nProceedings of the London\nMathematical Society\nXIX(2).\nHardy, Godfrey H., and E. M. Wright. 1960.\nAn Introduction to the Theory\nof Numbers\n. 4th edition. New York: Oxford University Press.\nHavender, J. 1968. Avoiding deadlocks in multi-tasking systems.\nIBM Sys-\ntems Journal\n7(2): 74-84.\nHearn, Anthony C. 1969. Standard Lisp. Technical report\naim\n-90, Artificial\nIntelligence Project, Stanford University.\n(Online)\nHenderson, Peter. 1980.\nFunctional Programming: Application and Imple-\nmentation\n. Englewood Cliffs, N.J.: Prentice-Hall.\nHenderson. Peter. 1982. Functional Geometry. In\nConference Record of\nthe 1982\nacm\nSymposium on Lisp and Functional Programming\n, pp. 179-187.\n(Online)\n(2002 version)\nHewitt, Carl E. 1969.\nplanner\n: A language for proving theorems in robots.\nIn\nProceedings of the International Joint Conference on Artificial Intelligence\n,\npp. 295-301.\n(Online)\nHewitt, Carl E. 1977. Viewing control structures as patterns of passing\nmessages.\nJournal of Artificial Intelligence\n8(3): 323-364.\n(Online)\nHoare, C. A. R. 1972. Proof of correctness of data representations.\nActa\nInformatica\n1(1).\nHodges, Andrew. 1983.\nAlan Turing: The Enigma\n. New York: Simon and\nSchuster.\nHofstadter, Douglas R. 1979.\nGödel, Escher, Bach: An Eternal Golden\nBraid\n. New York: Basic Books.\nHughes, R. J. M. 1990. Why functional programming matters. In\nResearch\nTopics in Functional Programming\n, edited by David Turner. Reading, MA:\nAddison-Wesley, pp. 17-42.\n(Online)\nieee\nStd 1178-1990. 1990.\nieee\nStandard for the Scheme Programming Lan-\nguage\n.\nIngerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted\nby M. Lind, Herbert Kanner, and Robert Floyd. 1960.\nthunks\n: A way of\ncompiling procedure statements, with some comments on procedure declara-\ntions. Unpublished manuscript. (Also, private communication from Wallace\nFeurzeig.)\n667","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":693},{"id":"./test/fixtures/pdf/sicp.pdf:694","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Kaldewaij, Anne. 1990.\nProgramming: The Derivation of Algorithms\n. New\nYork: Prentice-Hall.\nKnuth, Donald E. 1973.\nFundamental Algorithms\n. Volume 1 of\nThe Art of\nComputer Programming\n. 2nd edition. Reading, MA: Addison-Wesley.\nKnuth, Donald E. 1981.\nSeminumerical Algorithms\n. Volume 2 of\nThe Art\nof Computer Programming\n. 2nd edition. Reading, MA: Addison-Wesley.\nKohlbecker, Eugene Edmund, Jr. 1986. Syntactic extensions in the pro-\ngramming language Lisp. Ph.D. thesis, Indiana University.\n(Online)\nKonopasek, Milos, and Sundaresan Jayaraman. 1984.\nThe TK!Solver Book:\nA Guide to Problem-Solving in Science, Engineering, Business, and Education\n.\nBerkeley, CA: Osborne/McGraw-Hill.\nKowalski, Robert. 1973. Predicate logic as a programming language. Tech-\nnical report 70, Department of Computational Logic, School of Artificial Intel-\nligence, University of Edinburgh.\n(Online)\nKowalski, Robert. 1979.\nLogic for Problem Solving\n. New York: North-Holland.\nLamport, Leslie. 1978. Time, clocks, and the ordering of events in a dis-\ntributed system.\nCommunications of the\nacm\n21(7): 558-565.\n(Online)\nLampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K.\nPopek. 1981. Report on the programming language Euclid. Technical report,\nComputer Systems Research Group, University of Toronto.\n(Online)\nLandin, Peter. 1965. A correspondence between Algol 60 and Church’s\nlambda notation: Part I.\nCommunications of the\nacm\n8(2): 89-101.\nLieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage collector\nbased on the lifetimes of objects.\nCommunications of the\nacm\n26(6): 419-429.\n(Online)\nLiskov, Barbara H., and Stephen N. Zilles. 1975. Specification techniques\nfor data abstractions.\nieee\nTransactions on Software Engineering\n1(1): 7-19.\n(Online)\nMcAllester, David Allen. 1978. A three-valued truth-maintenance system.\nMemo 473,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nMcAllester, David Allen. 1980. An outlook on truth maintenance. Memo\n551,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nMcCarthy, John. 1960. Recursive functions of symbolic expressions and\ntheir computation by machine.\nCommunications of the\nacm\n3(4): 184-195.\n(Online)\nMcCarthy, John. 1963. A basis for a mathematical theory of computation.\n668","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":694},{"id":"./test/fixtures/pdf/sicp.pdf:695","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"In\nComputer Programming and Formal Systems\n, edited by P. Braffort and D.\nHirschberg. North-Holland.\n(Online)\nMcCarthy, John. 1978. The history of Lisp. In\nProceedings of the\nacm sig-\nplan\nConference on the History of Programming Languages\n.\n(Online)\nMcCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.\nLevin. 1965.\nLisp 1.5 Programmer’s Manual\n. 2nd edition. Cambridge, MA:\nmit\nPress.\n(Online)\nMcDermott, Drew, and Gerald Jay Sussman. 1972. Conniver reference man-\nual. Memo 259,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nMiller, Gary L. 1976. Riemann’s Hypothesis and tests for primality.\nJournal\nof Computer and System Sciences\n13(3): 300-317.\n(Online)\nMiller, James S., and Guillermo J. Rozas. 1994. Garbage collection is fast,\nbut a stack is faster. Memo 1462,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nMoon, David. 1978. MacLisp reference manual, Version 0. Technical report,\nmit\nLaboratory for Computer Science.\n(Online)\nMoon, David, and Daniel Weinreb. 1981. Lisp machine manual. Technical\nreport,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nMorris, J. H., Eric Schmidt, and Philip Wadler. 1980. Experience with an\napplicative string processing language. In\nProceedings of the 7th Annual\nacm\nsigact\n/\nsigplan\nSymposium on the Principles of Programming Languages\n.\nPhillips, Hubert. 1934.\nThe Sphinx Problem Book\n. London: Faber and Faber.\nPitman, Kent. 1983. The revised MacLisp Manual (Saturday evening edi-\ntion). Technical report 295,\nmit\nLaboratory for Computer Science.\n(Online)\nRabin, Michael O. 1980. Probabilistic algorithm for testing primality.\nJour-\nnal of Number Theory\n12: 128-138.\nRaymond, Eric. 1993.\nThe New Hacker’s Dictionary\n. 2nd edition. Cam-\nbridge, MA:\nmit\nPress.\n(Online)\nRaynal, Michel. 1986.\nAlgorithms for Mutual Exclusion\n. Cambridge, MA:\nmit\nPress.\nRees, Jonathan A., and Norman I. Adams IV. 1982. T: A dialect of Lisp\nor, lambda: The ultimate software tool. In\nConference Record of the 1982\nacm\nSymposium on Lisp and Functional Programming\n, pp. 114-122.\n(Online)\nRees, Jonathan, and William Clinger (eds). 1991. The\n푟푒푣푖푠푒푑\n4\nreport on\nthe algorithmic language Scheme.\nLisp Pointers\n, 4(3).\n(Online)\nRivest, Ronald, Adi Shamir, and Leonard Adleman. 1977. A method for ob-\ntaining digital signatures and public-key cryptosystems. Technical memo LC-\n669","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":695},{"id":"./test/fixtures/pdf/sicp.pdf:696","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"S/TM82,\nmit\nLaboratory for Computer Science.\n(Online)\nRobinson, J. A. 1965. A machine-oriented logic based on the resolution\nprinciple.\nJournal of the\nacm\n12(1): 23.\nRobinson, J. A. 1983. Logic programming—Past, present, and future.\nNew\nGeneration Computing\n1: 107-124.\nSpafford, Eugene H. 1989. The Internet Worm: Crisis and aftermath.\nCom-\nmunications of the\nacm\n32(6): 678-688.\n(Online)\nSteele, Guy Lewis, Jr. 1977. Debunking the “expensive procedure call”\nmyth. In\nProceedings of the National Conference of the\nacm\n, pp. 153-62.\n(Online)\nSteele, Guy Lewis, Jr. 1982. An overview of Common Lisp. In\nProceedings\nof the\nacm\nSymposium on Lisp and Functional Programming\n, pp. 98-107.\nSteele, Guy Lewis, Jr. 1990.\nCommon Lisp: The Language\n. 2nd edition.\nDigital Press.\n(Online)\nSteele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975. Scheme: An inter-\npreter for the extended lambda calculus. Memo 349,\nmit\nArtificial Intelligence\nLaboratory.\n(Online)\nSteele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.\nCrispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983.\nThe Hacker’s\nDictionary\n. New York: Harper & Row.\n(Online)\nStoy, Joseph E. 1977.\nDenotational Semantics\n. Cambridge, MA:\nmit\nPress.\nSussman, Gerald Jay, and Richard M. Stallman. 1975. Heuristic techniques\nin computer-aided circuit analysis.\nieee\nTransactions on Circuits and Systems\nCAS-22(11): 857-865.\n(Online)\nSussman, Gerald Jay, and Guy Lewis Steele Jr. 1980. Constraints—A lan-\nguage for expressing almost-hierachical descriptions.\nAI Journal\n14: 1-39.\n(Online)\nSussman, Gerald Jay, and Jack Wisdom. 1992. Chaotic evolution of the\nsolar system.\nScience\n257: 256-262.\n(Online)\nSussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Mi-\ncroplanner reference manual. Memo 203A,\nmit\nArtificial Intelligence Labora-\ntory.\n(Online)\nSutherland, Ivan E. 1963.\nsketchpad\n: A man-machine graphical commu-\nnication system. Technical report 296,\nmit\nLincoln Laboratory.\n(Onl.)\nTeitelman, Warren. 1974. Interlisp reference manual. Technical report, Xe-\nrox Palo Alto Research Center.\nThatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data\n670","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":696},{"id":"./test/fixtures/pdf/sicp.pdf:697","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"type specification: Parameterization and the power of specification techniques.\nIn\nConference Record of the Tenth Annual\nacm\nSymposium on Theory of Com-\nputing\n, pp. 119-132.\nTurner, David. 1981. The future of applicative languages. In\nProceedings\nof the 3rd European Conference on Informatics\n, Lecture Notes in Computer\nScience, volume 123. New York: Springer-Verlag, pp. 334-348.\nWand, Mitchell. 1980. Continuation-based program transformation strate-\ngies.\nJournal of the\nacm\n27(1): 164-180.\n(Online)\nWaters, Richard C. 1979. A method for analyzing loop programs.\nieee\nTransactions on Software Engineering\n5(3): 237-247.\nWinograd, Terry. 1971. Procedures as a representation for data in a com-\nputer program for understanding natural language. Technical report AI TR-17,\nmit\nArtificial Intelligence Laboratory.\n(Online)\nWinston, Patrick. 1992.\nArtificial Intelligence\n. 3rd edition. Reading, MA:\nAddison-Wesley.\nZabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic\nLisp with dependency-directed backtracking.\naaai\n-87\n, pp. 59-64.\n(Online)\nZippel, Richard. 1979. Probabilistic algorithms for sparse polynomials. Ph.D.\ndissertation, Department of Electrical Engineering and Computer Science,\nmit\n.\nZippel, Richard. 1993.\nEffective Polynomial Computation\n. Boston, MA:\nKluwer Academic Publishers.\n671","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":697},{"id":"./test/fixtures/pdf/sicp.pdf:698","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"課題リスト\nChapter 1\n1.1\n1.2\n1.3\n1.4\n1.5\n1.6\n1.7\n1.8\n1.9\n1.10\n1.11\n1.12\n1.13\n1.14\n1.15\n1.16\n1.17\n1.18\n1.19\n1.20\n1.21\n1.22\n1.23\n1.24\n1.25\n1.26\n1.27\n1.28\n1.29\n1.30\n1.31\n1.32\n1.33\n1.34\n1.35\n1.36\n1.37\n1.38\n1.39\n1.40\n1.41\n1.42\n1.43\n1.44\n1.45\n1.46\nChapter 2\n2.1\n2.2\n2.3\n2.4\n2.5\n2.6\n2.7\n2.8\n2.9\n2.10\n2.11\n2.12\n2.13\n2.14\n2.15\n2.16\n2.17\n2.18\n2.19\n2.20\n2.21\n2.22\n2.23\n2.24\n2.25\n2.26\n2.27\n2.28\n2.29\n2.30\n2.31\n2.32\n2.33\n2.34\n2.35\n2.36\n2.37\n2.38\n2.39\n2.40\n2.41\n2.42\n2.43\n2.44\n2.45\n2.46\n2.47\n2.48\n2.49\n2.50\n2.51\n2.52\n2.53\n2.54\n2.55\n2.56\n2.57\n2.58\n2.59\n2.60\n2.61\n2.62\n2.63\n2.64\n2.65\n2.66\n2.67\n2.68\n2.69\n2.70\n2.71\n2.72\n2.73\n2.74\n2.75\n2.76\n2.77\n2.78\n2.79\n2.80\n2.81\n2.82\n2.83\n2.84\n2.85\n2.86\n2.87\n2.88\n2.89\n2.90\n2.91\n2.92\n2.93\n2.94\n2.95\n2.96\n2.97\n672","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":698},{"id":"./test/fixtures/pdf/sicp.pdf:699","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"Chapter 3\n3.1\n3.2\n3.3\n3.4\n3.5\n3.6\n3.7\n3.8\n3.9\n3.10\n3.11\n3.12\n3.13\n3.14\n3.15\n3.16\n3.17\n3.18\n3.19\n3.20\n3.21\n3.22\n3.23\n3.24\n3.25\n3.26\n3.27\n3.28\n3.29\n3.30\n3.31\n3.32\n3.33\n3.34\n3.35\n3.36\n3.37\n3.38\n3.39\n3.40\n3.41\n3.42\n3.43\n3.44\n3.45\n3.46\n3.47\n3.48\n3.49\n3.50\n3.51\n3.52\n3.53\n3.54\n3.55\n3.56\n3.57\n3.58\n3.59\n3.60\n3.61\n3.62\n3.63\n3.64\n3.65\n3.66\n3.67\n3.68\n3.69\n3.70\n3.71\n3.72\n3.73\n3.74\n3.75\n3.76\n3.77\n3.78\n3.79\n3.80\n3.81\n3.82\nChapter 4\n4.1\n4.2\n4.3\n4.4\n4.5\n4.6\n4.7\n4.8\n4.9\n4.10\n4.11\n4.12\n4.13\n4.14\n4.15\n4.16\n4.17\n4.18\n4.19\n4.20\n4.21\n4.22\n4.23\n4.24\n4.25\n4.26\n4.27\n4.28\n4.29\n4.30\n4.31\n4.32\n4.33\n4.34\n4.35\n4.36\n4.37\n4.38\n4.39\n4.40\n4.41\n4.42\n4.43\n4.44\n4.45\n4.46\n4.47\n4.48\n4.49\n4.50\n4.51\n4.52\n4.53\n4.54\n4.55\n4.56\n4.57\n4.58\n4.59\n4.60\n4.61\n4.62\n4.63\n4.64\n4.65\n4.66\n4.67\n4.68\n4.69\n4.70\n4.71\n4.72\n4.73\n4.74\n4.75\n4.76\n4.77\n4.78\n4.79\nChapter 5\n5.1\n5.2\n5.3\n5.4\n5.5\n5.6\n5.7\n5.8\n5.9\n5.10\n5.11\n5.12\n5.13\n5.14\n5.15\n5.16\n5.17\n5.18\n5.19\n5.20\n5.21\n5.22\n5.23\n5.24\n5.25\n5.26\n5.27\n5.28\n5.29\n5.30\n5.31\n5.32\n5.33\n5.34\n5.35\n5.36\n5.37\n5.38\n5.39\n5.40\n5.41\n5.42\n5.43\n5.44\n5.45\n5.46\n5.47\n5.48\n5.49\n5.50\n5.51\n5.52\n673","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":699},{"id":"./test/fixtures/pdf/sicp.pdf:700","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"図一覧\nChapter 1\n1.1\n1.2\n1.3\n1.4\n1.5\nChapter 2\n2.1\n2.2\n2.3\n2.4\n2.5\n2.6\n2.7\n2.8\n2.9\n2.10\n2.11\n2.12\n2.13\n2.14\n2.15\n2.16\n2.17\n2.18\n2.19\n2.20\n2.21\n2.22\n2.23\n2.24\n2.25\n2.26\nChapter 3\n3.1\n3.2\n3.3\n3.4\n3.5\n3.6\n3.7\n3.8\n3.9\n3.10\n3.11\n3.12\n3.13\n3.14\n3.15\n3.16\n3.17\n3.18\n3.19\n3.20\n3.21\n3.22\n3.23\n3.24\n3.25\n3.26\n3.27\n3.28\n3.29\n3.30\n3.31\n3.32\n3.33\n3.34\n3.35\n3.36\n3.37\n3.38\nChapter 4\n4.1\n4.2\n4.3\n4.4\n4.5\n4.6\nChapter 5\n5.1\n5.2\n5.3\n5.4\n5.5\n5.6\n5.7\n5.8\n5.9\n5.10\n5.11\n5.12\n5.13\n5.14\n5.15\n5.16\n5.17\n5.18\n674","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":700},{"id":"./test/fixtures/pdf/sicp.pdf:701","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"索引\nこの索引内のどんな間違いも、コンピュータの手助けによ\nり準備されたという事実により説明できるだろう。\n—Donald E. Knuth,\nFundamental Algorithms\n(Volume 1 of\nThe Art of Computer Programming\n)\nk\n-term finite continued fraction,\n73\nn\n-fold smoothed function,\n80\nn\n次畳み込み補間関数\n,\n80\nabstract models,\n94\nabstract syntax,\n391\nabstraction barriers,\n84\n,\n91\naccumulator,\n120\n,\n236\nacquired,\n332\naction,\n537\nadditive,\n189\nadditively,\n85\n,\n179\naddress,\n575\naddress arithmetic,\n575\nagenda,\n298\naliasing,\n246\nand-gate,\n291\nAND\nゲート\n,\n291\napplicative-order,\n427\narbiter,\n335\narguments,\n6\nassembler,\n554\nassertions,\n473\nassignment operator,\n231\natomically,\n334\nautomatic storage allocation,\n575\naverage damping,\n72\nB-trees,\n166\nbackbone,\n283\nbackquote,\n619\nbacktracks,\n445\nbalanced,\n117\nbarrier synchronization,\n337\nbase address,\n576\nBertrand’s hypothesis,\n353\nbignum,\n577\nbindings,\n249\nbinds,\n28\nbinomial coefficients,\n42\nblock structure,\n30\nbound variable,\n28\nbox-and-pointer notation,\n101\nbreakpoint,\n573\n675","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":701},{"id":"./test/fixtures/pdf/sicp.pdf:702","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"broken heart,\n584\nbugs,\n2\nB\n木\n,\n166\ncache-coherence,\n319\ncall-by-name,\n430\ncall-by-need,\n430\ncall-by-name,\n346\ncall-by-name thunks,\n347\ncall-by-need,\n347\ncall-by-need thunks,\n347\ncapturing,\n28\nCarmichael numbers,\n53\ncase analysis,\n17\ncell,\n333\nchronological backtracking,\n445\nChurch numerals,\n97\nChurch-Turing thesis,\n413\nclauses,\n17\nclosure,\n85\ncode generator,\n614\ncoerce,\n211\ncoercion,\n206\ncombinations,\n6\ncomments,\n130\ncompacting,\n583\ncompilation,\n611\ncompile-time environment,\n652\ncomposition,\n79\ncompound data,\n83\ncompound data object,\n83\ncompound procedure,\n12\ncomputability,\n413\ncomputational process,\n1\nconcurrently,\n317\ncongruent modulo,\n52\nconnectors,\n305\nconsequent expression,\n18\nconstraint networks,\n305\nconstructors,\n86\ncontinuation procedures,\n457\ncontinued fraction,\n73\ncontrol structure,\n496\ncontroller,\n530\nconventional interfaces,\n85\n,\n119\ncurrent time,\n301\ndata,\n1\n,\n94\ndata abstraction,\n83\n,\n86\ndata paths,\n530\ndata-directed,\n180\ndata-directed programming,\n85\n,\n190\ndeadlock,\n336\ndeadlock-recovery,\n336\ndebug,\n2\ndeep binding,\n407\ndeferred operations,\n34\ndelayed argument,\n373\ndelayed evaluation,\n230\n,\n339\ndelayed object,\n342\ndense,\n220\ndependency-directed   backtracking,\n445\ndepth-first search,\n445\ndeque,\n283\nderived expressions,\n400\ndigital signals,\n291\ndispatching on type,\n188\ndisplacement number,\n651\ndotted-tail notation,\n109\ndriver loop,\n410\nempty list,\n105\nenclosing environment,\n249\nentry points,\n533\nenumerator,\n120\nenvironment,\n9\nenvironment model,\n230\nenvironments,\n249\nEuclid’s Algorithm,\n49\nEuclidean ring,\n224\nevaluation,\n5\nevaluator,\n386\nevent-driven simulation,\n291\n676","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":702},{"id":"./test/fixtures/pdf/sicp.pdf:703","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"evlis tail recursion,\n596\nexecution procedure,\n422\nexplicit-control evaluator,\n589\nexpression,\n5\nfailure continuation,\n457\nFIFO,\n277\nfilter,\n63\n,\n120\nfirst-class,\n78\nfixed point,\n71\nfixed-length,\n170\nforcing,\n429\nforwarding address,\n584\nframe,\n487\nframe coordinate map,\n142\nframe number,\n651\nframed-stack,\n593\nframes,\n249\nfree,\n28\nfree list,\n579\nfront,\n277\nfull-adder,\n293\nfunction boxes,\n291\nfunctional programming,\n242\nfunctional programming languages,\n382\ngarbage,\n582\ngarbage collection,\n575\n,\n582\ngarbage collector,\n267\ngarbage-collected,\n433\ngeneric operations,\n85\ngeneric procedures,\n175\n,\n179\nglitches,\n2\nglobal,\n31\n,\n249\nglobal environment,\n9\ngolden ratio,\n38\ngrammar,\n451\nhalf-interval method,\n69\nhalf-adder,\n291\nHalting Theorem,\n415\nheaded list,\n283\nhiding principle,\n234\nhierarchical,\n102\nhierarchy of types,\n208\nhigher-order procedures,\n58\nHorner’s rule,\n125\nimperative programming,\n247\nindeterminates,\n214\nindex,\n576\ninstruction counting,\n573\ninstruction execution procedure,\n556\ninstruction sequence,\n616\ninstruction tracing,\n573\ninstructions,\n529\n,\n533\nintegerizing factor,\n226\nintegers,\n5\nintegrator,\n367\ninterning,\n578\ninterpreter,\n3\n,\n386\ninvariant quantity,\n46\ninverter,\n291\niterative improvement,\n80\niterative process,\n34\nkey,\n169\nk\n項有限連分数\n,\n73\nlabels,\n533\nlazy evaluation,\n427\nlexical address,\n651\nlexical addressing,\n407\nlexical scoping,\n30\nlinear iterative process,\n34\nlinear recursive process,\n34\nlinkage descriptor,\n615\nlist,\n103\nlist structure,\n103\nlist-structured,\n89\nlist-structured memory,\n574\nlocal evolution,\n31\nlocal state variables,\n231\n677","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":703},{"id":"./test/fixtures/pdf/sicp.pdf:704","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"location,\n575\nlogic-programming,\n388\nlogical and,\n291\nlogical deductions,\n483\nlogical or,\n291\nmachine language,\n611\nmacro,\n400\nmap,\n120\nmark-sweep,\n583\nmemoization,\n41\n,\n289\nmemoize,\n430\nmerge,\n383\nmessage passing,\n96\n,\n197\nmessage-passing,\n236\nmetacircular,\n389\nMetalinguistic abstraction,\n386\nMiller-Rabin test,\n57\nmodular,\n229\nmodulo,\n52\nmodus ponens,\n496\nmoments in time,\n317\nMonte Carlo integration,\n241\nMonte Carlo simulation,\n239\nmutable data objects,\n266\nmutators,\n266\nmutex,\n332\nmutual exclusion,\n332\nnative language,\n611\nneeded,\n617\nNewton’s method,\n76\nnil,\n105\nnon-computable,\n415\nnon-strict,\n428\nnondeterministic,\n322\nnondeterministic choice point,\n444\nnondeterministic computing,\n388\n,\n440\nnormal-order,\n427\nnormal-order evaluation,\n388\nobarray,\n577\nobject program,\n611\nobjects,\n230\nopen-code,\n649\noperand,\n6\noperator,\n6\n,\n420\nor-gate,\n291\norder of growth,\n42\nordinary,\n200\nOR\nゲート\n,\n291\noutput prompt,\n410\npackage,\n191\npainter,\n133\npair,\n88\nparse,\n450\nPascal’s triangle,\n42\npattern matcher,\n487\npattern matching,\n486\npattern variable,\n475\npipelining,\n317\npointer,\n101\npoly,\n215\npower series,\n355\npredicate,\n17\nprefix,\n171\nprefix code,\n171\nprefix notation,\n6\npretty-printing,\n7\nprimitive constraints,\n305\nprobabilistic algorithms,\n54\nprocedural epistemology,\nxxii\nprocedure definitions,\n12\nprocedures,\n4\nprogram,\n1\nprogramming languages,\n2\nprompt,\n410\npseudo-random,\n238\npseudodivision,\n226\npseudoremainder,\n226\nquasiquote,\n619\nqueries,\n472\n678","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":704},{"id":"./test/fixtures/pdf/sicp.pdf:705","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"query language,\n472\nqueue,\n277\nquote,\n150\nRamanujan numbers,\n366\nrational functions,\n224\nRC circuit,\n368\nRC\n回路\n,\n368\nread-eval-print loop,\n8\nreader macro characters,\n521\nreal numbers,\n5\nrear,\n277\nrecursion equations,\n2\nRecursion theory,\n413\nrecursive,\n9\n,\n26\nrecursive process,\n34\nred-black trees,\n166\nreferentially transparent,\n245\nregister machine,\n529\nregister table,\n556\nregisters,\n529\nreleased,\n332\nremainder,\n52\nresolution principle,\n470\nripple-carry adder,\n296\nrobust,\n149\nRSA\nアルゴリズム\n,\n54\nrules,\n480\nscope,\n28\nselectors,\n86\nsemaphore,\n333\nseparator code,\n171\nsequence,\n103\nsequence accelerator,\n359\nserializer,\n324\nserializers,\n325\nseries RLC circuit,\n375\nshadow,\n250\nshared,\n272\nside-effect bugs,\n246\nsieve of Eratosthenes,\n349\nsmoothing,\n80\nsource language,\n611\nsource program,\n611\nsparse,\n220\nstack,\n35\n,\n547\nstate variables,\n34\n,\n230\nstatements,\n617\nstop-and-copy,\n582\nstratified design,\n148\nstreams,\n230\n,\n338\n,\n339\nstrict,\n428\nsubroutine,\n542\nsubstitution model,\n15\nsubtype,\n208\nsuccess continuation,\n457\nsummation of a series,\n59\nsummer,\n367\nsupertype,\n208\nsymbolic expressions,\n85\nsyntactic sugar,\n11\nsyntax,\n390\nsystematically search,\n444\ntableau,\n360\ntabulation,\n41\n,\n289\ntagged architectures,\n577\ntail-recursive,\n35\n,\n600\ntarget,\n615\nthrashing,\nix\nthunk,\n429\nthunks,\n429\ntime,\n316\ntime segments,\n301\ntower,\n209\ntree accumulation,\n10\ntree recursion,\n37\ntruth maintenance,\n445\nTuring machine,\n413\ntype field,\n577\ntype tag,\n185\ntype tags,\n180\ntype-inferencing,\n378\n679","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":705},{"id":"./test/fixtures/pdf/sicp.pdf:706","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"typed pointers,\n576\nunbound,\n250\nunification,\n470\n,\n486\n,\n492\nunification algorithm,\n470\nunivariate polynomials,\n214\nuniversal machine,\n412\nupward-compatible extension,\n437\nvalue,\n8\nvalue of a variable,\n250\nvariable,\n8\nvariable-length,\n170\nvector,\n575\nwidth,\n98\nwires,\n291\nwishful thinking,\n87\nY\nコンビネータ\n,\n420\nzero crossings,\n369\nべき級数\n,\n355\nアクション\n,\n537\nアサーション\n,\n473\nアセンブラ\n,\n554\nアトミック\n,\n334\nアドレス\n,\n575\nアドレス演算\n,\n575\nアナログ加算器\n,\n367\nアービタ\n,\n335\nイベント駆動シミュレーション\n,\n291\nインタプリタ\n,\n3\n,\n386\nインデックス\n,\n576\nエイリアシング\n,\n246\nエニュメレータ\n,\n120\nエブリス末尾再帰\n,\n596\nエラトステネスの篩\n,\n349\nエントリポイント\n,\n533\nオブジェクト\n,\n230\nオブジェクトプログラム\n,\n611\nオブジェクト配列\n,\n577\nオペランド\n,\n6\nオペレータ\n,\n6\nカーマイケル数\n,\n53\nガベージコレクション\n,\n433\n,\n575\n,\n582\nガベージコレクタ\n,\n267\nキャッシュ一貫性\n,\n319\nキュー\n,\n277\nキー\n,\n169\nクエリ\n,\n472\nクエリ言語\n,\n472\nクロージャ\n,\n85\nクローズ\n,\n17\nグリッチ\n,\n2\nグローバル\n,\n249\nグローバル環境\n,\n9\nコネクタ\n,\n305\nコメント\n,\n130\nコントローラ\n,\n530\nコンパイル\n,\n611\nコンパイル時環境\n,\n652\nコード生成器\n,\n614\nコールバイニード\n,\n347\nコールバイニードサンク\n,\n347\nコールバイネーム\n,\n346\nコールバイネームサンク\n,\n347\nゴミ\n,\n582\nサブタイプ\n,\n208\nサブルーチン\n,\n542\nサンク\n,\n429\nシリアライザ\n,\n324\n,\n325\nジェネリック手続\n,\n175\n,\n179\nスコープ\n,\n28\nスタック\n,\n35\n,\n547\nスタックフレーム\n,\n593\nストリーム\n,\n230\n,\n338\n,\n339\nスラッシング\n,\nix\nスーパータイプ\n,\n208\nセマフォ\n,\n333\nセル\n,\n333\nゼロ交差\n,\n369\nソースプログラム\n,\n611\n680","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":706},{"id":"./test/fixtures/pdf/sicp.pdf:707","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"ソース言語\n,\n611\nタイプタグ\n,\n180\n,\n185\nタイプ別処理\n,\n188\nタイムセグメント\n,\n301\nタグアーキテクチャ\n,\n577\nタブロー\n,\n360\nタワー\n,\n209\nターゲット\n,\n615\nチャーチ・チューリングのテーゼ\n,\n413\nチャーチ数\n,\n97\nチューリングマシン\n,\n413\nデジタル信号\n,\n291\nデッドロック\n,\n336\nデッドロックリカバリ\n,\n336\nデバッグ\n,\n2\nデータ\n,\n1\n,\n94\nデータパス\n,\n530\nデータ抽象化\n,\n83\n,\n86\nデータ適従\n,\n180\nデータ適従プログラミング\n,\n85\n,\n190\nドット付き末尾記法\n,\n109\nドライバループ\n,\n410\nニュートン法\n,\n76\nネイティブ言語\n,\n611\nバグ\n,\n2\nバッククォート\n,\n619\nバックトラック\n,\n445\nバックボーン\n,\n283\nバランスが取れた状態\n,\n117\nバリア同期\n,\n337\nパイプライン\n,\n317\nパスカルの三角形\n,\n42\nパターンマッチャ\n,\n487\nパターンマッチング\n,\n486\nパターン変数\n,\n475\nパッケージ\n,\n191\nパース\n,\n450\nビッグナンバー\n,\n577\nフィルタ\n,\n63\n,\n120\nフレーム\n,\n249\n,\n487\nフレーム座標マップ\n,\n142\nブレイクポイント\n,\n573\nブロック構造\n,\n30\nプリティプリント\n,\n7\nプリミティブ制約\n,\n305\nプログラミング言語\n,\n2\nプログラム\n,\n1\nプロセス\n,\n35\nプロンプト\n,\n410\nベクタ\n,\n575\nベルトランの仮説\n,\n353\nベース\n(\n基底\n)\nアドレス\n,\n576\nペア\n,\n88\nペインタ\n,\n133\nホーナー法\n,\n125\nポインタ\n,\n101\nマクロ\n,\n400\nマークアンドスイープ\n,\n583\nマージ\n,\n383\nミュータブルデータオブジェクト\n,\n266\nミューテックス\n,\n332\nミューテータ\n,\n266\nメタ循環\n,\n389\nメタ言語抽象化\n,\n386\nメッセージパッシング\n,\n96\n,\n197\n,\n236\nメモ化\n,\n41\n,\n289\n,\n430\nモジュラ\n,\n229\nモンテカルロシミュレーション\n,\n239\nモンテカルロ積分\n,\n241\nユニフィケーション\n,\n470\n,\n486\n,\n492\nユニフィケーションアルゴリズム\n,\n470\nユークリッドの互除法\n,\n49\nユークリッド環\n,\n224\nラベル\n,\n533\nラマヌジャン数\n,\n366\nリスト\n,\n103\nリスト構造\n,\n103\nリスト構造メモリ\n,\n574\nリスト構造化\n,\n89\nリンク記述子\n,\n615\nリーダマクロキャラクタ\n,\n521\nルール\n,\n480\nレキシカルアドレス\n,\n651\nレキシカルアドレッシング\n,\n407\n681","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":707},{"id":"./test/fixtures/pdf/sicp.pdf:708","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"レキシカルスコープ\n,\n30\nレジスタ\n,\n529\nレジスタテーブル\n,\n556\nレジスタマシン\n,\n529\nレプル\n,\n8\nローカル状態変数\n,\n231\n一変数多項式\n,\n214\n万能機械\n,\n412\n上位互換性のある拡張\n,\n437\n不動点\n,\n71\n不変量\n,\n46\n不定元\n,\n214\n両頭キュー\n,\n283\n並行\n,\n317\n予定表\n,\n298\n事例分析\n,\n17\n二項係数\n,\n42\n付加的\n,\n85\n,\n179\n,\n189\n代入\n,\n15\n代入演算子\n,\n231\n位置\n,\n575\n体系的探索\n,\n444\n依存型バックトラック\n,\n445\n値\n,\n8\n停止性問題\n,\n415\n先入れ先出し\n,\n277\n先端\n,\n277\n全加算器\n,\n293\n共有\n,\n272\n再帰\n,\n9\n再帰プロセス\n,\n34\n再帰方程式\n,\n2\n再帰理論\n,\n413\n再帰的\n,\n26\n出力プロンプト\n,\n410\n分数関数\n,\n224\n分離符号\n,\n171\n列\n,\n103\n列アクセラレータ\n,\n359\n制御構造\n,\n496\n制約ネットワーク\n,\n305\n前置表記法\n,\n6\n副作用バグ\n,\n246\n半加算器\n,\n291\n半区間手法\n,\n69\n占領\n,\n28\n厳密\n,\n428\n参照透明\n,\n245\n反復プロセス\n,\n34\n反復改善法\n,\n80\n可変長\n,\n170\n合成\n,\n79\n名前呼出\n,\n430\n命令\n,\n529\n,\n533\n命令トレーサ\n,\n573\n命令列\n,\n616\n命令型プログラミング\n,\n247\n命令実行手続\n,\n556\n命令数カウンタ\n,\n573\n命令文\n,\n617\n回路\n,\n291\n固定長\n,\n170\n圧縮\n,\n583\n型の階層\n,\n208\n型フィールド\n,\n577\n型付きポインタ\n,\n576\n型推論\n,\n378\n堅牢\n,\n149\n増加のオーダー\n,\n42\n変数\n,\n8\n変数の値\n,\n250\n外部環境\n,\n249\n大域的\n,\n31\n失敗継続\n,\n457\n実数\n,\n5\n実行手続\n,\n422\n密\n,\n220\n導出原理\n,\n470\n局所展開\n,\n31\n希望的観測\n,\n87\n幅\n,\n98\n平均減衰\n,\n72\n682","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":708},{"id":"./test/fixtures/pdf/sicp.pdf:709","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"年代順バックトラック\n,\n445\n式\n,\n5\n引数\n,\n6\n引用\n,\n150\n強制\n,\n206\n,\n211\n,\n429\n必要時呼出\n,\n430\n慣習的インターフェイス\n,\n85\n,\n119\n成功継続\n,\n457\n手続\n,\n4\n,\n35\n手続の定義\n,\n12\n手続の抽象化\n,\n27\n手続的認識論\n,\nxxii\n抑留\n,\n578\n抽象モデル\n,\n94\n抽象化バリア\n,\n84\n,\n91\n抽象構文\n,\n391\n接頭符号\n,\n171\n接頭辞\n,\n171\n擬似クォート\n,\n619\n擬似乱数\n,\n238\n擬剰余\n,\n226\n擬除算\n,\n226\n整数\n,\n5\n整数化因数\n,\n226\n文法\n,\n451\n明示的制御評価機\n,\n589\n時間\n,\n316\n時間の瞬間\n,\n317\n木再帰\n,\n37\n末尾再帰\n,\n35\n,\n600\n束縛\n,\n28\n,\n249\n束縛されない\n,\n250\n束縛変数\n,\n28\n桁上げ伝播加算器\n,\n296\n構文\n,\n390\n構文糖\n,\n11\n構文解析\n,\n450\n機械語\n,\n611\n正規順序\n,\n427\n正規順序評価\n,\n16\n正規順評価\n,\n388\n法\n푛\nに関して合同\n,\n52\n派生式\n,\n400\n深い束縛\n,\n407\n深さ優先探索\n,\n445\n演算プロセス\n,\n1\n演算子\n,\n6\n特別形式\n,\n11\n状態変数\n,\n34\n,\n230\n獲得\n,\n332\n現在時刻\n,\n301\n環境\n,\n9\n,\n249\n環境モデル\n,\n230\n疎\n,\n220\n相互排除\n,\n332\n真理維持\n,\n445\n確率的アルゴリズム\n,\n54\n積分器\n,\n367\n空きリスト\n,\n579\n空リスト\n,\n105\n第一級\n,\n78\n箱と点表記法\n,\n101\n級数の和\n,\n59\n終端\n,\n277\n組み合わせ\n,\n6\n結果式\n,\n18\n継続手続\n,\n457\n総称命令\n,\n85\n線形再帰プロセス\n,\n34\n線形反復プロセス\n,\n34\n置換モデル\n,\n15\n肯定式\n,\n496\n自動記憶域割当\n,\n575\n自由\n,\n28\n表形式化\n,\n41\n,\n289\n補間\n,\n80\n複合データ\n,\n83\n複合データオブジェクト\n,\n83\n複合手続\n,\n12\n解放\n,\n332\n計算不可能\n,\n415\n683","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":709},{"id":"./test/fixtures/pdf/sicp.pdf:710","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"計算可能性\n,\n413\n記号表現\n,\n85\n評価\n,\n5\n評価機\n,\n386\n論理プログラミング\n,\n388\n論理和\n,\n291\n論理的推理\n,\n483\n論理積\n,\n291\n赤黒木\n,\n166\n転送先\n,\n584\n述語\n,\n17\n逆変換器\n,\n291\n連分数\n,\n73\n連続\nRLC\n回路\n,\n375\n遅延オブジェクト\n,\n342\n遅延引数\n,\n373\n遅延演算\n,\n34\n遅延評価\n,\n230\n,\n339\n,\n427\n適用順序\n,\n427\n適用順序評価\n,\n16\n閉包性\n,\n101\n関数型プログラミング\n,\n242\n関数型プログラミング言語\n,\n382\n関数箱\n,\n291\n階層\n,\n102\n階層化設計\n,\n148\n隠蔽する\n,\n250\n隠蔽原則\n,\n234\n集積木\n,\n10\n集積機\n,\n120\n非厳密\n,\n428\n非決定性演算\n,\n440\n非決定性選択点\n,\n444\n非決定的\n,\n322\n非決定的演算\n,\n388\n頭出しリスト\n,\n283\n高階手続\n,\n58\n黄金比\n,\n38\n684","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":710},{"id":"./test/fixtures/pdf/sicp.pdf:711","title":"Structure and Interpretation of Computer Programs, 2nd ed.","author":"Harold Abelson, Gerald Jay Sussman, Julie Sussman","body":"奥付\n表紙は\n1588\n年、\nAgostino Ramelli\nのブックホイールのメカニズムです。こ\nれは初期のハイパーテキストナビゲーション支援と見ることができるのではな\nいでしょうか。この版画のイメージは\nNew Gottland\n.\nの\nJ. E. Johnson\nにより\n提供されています。\nタイプフェイスは本文は\nLinux Libertine\nで、見出しは\nLinux Biolinum\nで\nす。両方とも\nPhilipp H. Poll\nの手によります。タイプライターフェイスは\nRaph\nLevien\nによる\nInconsolata\nであり、\nDimosthenis Kaponis\nと\nTakashi Tanigawa\nにより補完された\nInconsolata LGC\nの形式で利用しています。\n(\n日本語版では漢字に\nIPA\nフォントを使用させて頂いてます。\n)\nグラフィックデザインとタイポグラフィは\nAndres Raba\nにより行われまし\nた。\nTexinfo\nのソースは\nPerl\nスクリプトにより\nLaTeX\nに変換され、\nXeLaTeX\nにより\npdf\nにコンパイルされています。図は\nInkscape\nを用いて描かれました。\n685","filePath":"./test/fixtures/pdf/sicp.pdf","pageNumber":711}]